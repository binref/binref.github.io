<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.units.misc.run documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.misc.run</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/misc/run.py#L1-L199" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from __future__ import annotations

import shlex
import sys

from io import BytesIO
from subprocess import PIPE, STDOUT, Popen

from refinery.lib.meta import metavars
from refinery.lib.structures import MemoryFile
from refinery.lib.types import Param
from refinery.units import Arg, RefineryPartialResult, Unit


class run(Unit):
    &#34;&#34;&#34;
    Turns any command into a refinery unit. Data is processed by feeding it to the standard input
    of a process spawned from the given command line, and then reading the standard output of that
    process as the result of the operation. The main purpose of this unit is to allow using the
    syntax from `refinery.lib.frame` with other command line tools. By default, the unit streams
    the output from the executed command as individual outputs, but the `buffer` option can be set
    to buffer all output of a single execution. The format string expression `{}` or `{0}` can be
    used as one of the arguments passed to the external command to represent the incoming data. In
    this case, the data will not be sent to the standard input device of the new process.
    &#34;&#34;&#34;

    _JOIN_TIME = 2
    _WAIT_TIME = 0.01

    def __init__(
        self, *commandline: Param[str, Arg.String(nargs=&#39;...&#39;, metavar=&#39;(all remaining)&#39;, help=(
            &#39;All remaining command line tokens form an arbitrary command line to be executed. Use&#39;
            &#39; format string syntax to insert meta variables and incoming data chunks.&#39;))],
        stream: Param[bool, Arg.Switch(&#39;-s&#39;,
            help=&#39;Stream the command output rather than buffering it.&#39;)] = False,
        noinput: Param[bool, Arg.Switch(&#39;-x&#39;, help=&#39;Do not send any input to the new process.&#39;)] = False,
        errors: Param[bool, Arg.Switch(&#39;-m&#39;, help=(
            &#39;Merge stdout and stderr. By default, the standard error stream of the coupled command&#39;
            &#39; is forwarded to the logger, i.e. it is only visible if -v is also specified.&#39;
        ))] = False,
        timeout: Param[float, Arg.Double(&#39;-t&#39;, metavar=&#39;T&#39;, help=(
            &#39;Optionally set an execution timeout as a floating point number in seconds.&#39;
        ))] = 0.0
    ):
        if not commandline:
            raise ValueError(&#39;you need to provide a command line.&#39;)
        super().__init__(
            commandline=commandline, errors=errors, noinput=noinput, stream=stream, timeout=timeout)

    def process(self, data):
        def shlexjoin():
            import shlex
            return shlex.join(commandline)

        meta = metavars(data)
        meta.ghost = True
        used = set()
        commandline = [
            meta.format_str(cmd, self.codec, [data], None, used=used)
            for cmd in self.args.commandline
        ]

        if self.args.noinput:
            self.log_info(&#39;sending no input to process stdin&#39;)
            data = None

        if not self.log_debug(commandline):
            self.log_info(shlexjoin)

        stream: bool = self.args.stream
        merge: bool = self.args.errors
        timeout: int = self.args.timeout

        posix = &#39;posix&#39; in sys.builtin_module_names
        process = Popen(shlex.join(commandline) if posix else commandline, shell=True,
            stdin=PIPE, stdout=PIPE, stderr=STDOUT if merge else PIPE, close_fds=posix)

        if not stream and not timeout and not merge:
            out, err = process.communicate(data)
            for line in err.splitlines():
                self.log_info(line)
            yield out
            return

        from queue import Empty, Queue
        from threading import Event, Thread
        from time import monotonic, sleep

        start = 0
        result = None
        _jt = self._JOIN_TIME
        _wt = self._WAIT_TIME

        qerr: Queue[bytes] = Queue()
        qout: Queue[bytes] = Queue()
        done = Event()

        def adapter(stream: BytesIO, queue: Queue[bytes], event: Event):
            while not event.is_set():
                out = stream.read1()
                if out:
                    queue.put(out)
                else:
                    break
            stream.close()

        recvout = Thread(target=adapter, args=(process.stdout, qout, done), daemon=True)
        recvout.start()

        if not merge:
            recverr = Thread(target=adapter, args=(process.stderr, qerr, done), daemon=True)
            recverr.start()
        else:
            recverr = None

        if stdin := process.stdin:
            if data:
                stdin.write(data)
            stdin.close()
        start = monotonic()

        if not stream or timeout:
            result = MemoryFile()

        def queue_read(q: Queue[bytes]):
            try:
                return q.get_nowait()
            except Empty:
                return None

        errbuf = MemoryFile()
        errobj = None

        while True:
            out = queue_read(qout)
            err = None

            if not merge:
                err = queue_read(qerr)

            if err and self.log_info():
                errbuf.write(err)
                errbuf.seek(0)
                lines = errbuf.readlines()
                errbuf.seek(0)
                errbuf.truncate()
                if lines:
                    if not (done.is_set() or lines[~0].endswith(B&#39;\n&#39;)):
                        errbuf.write(lines.pop())
                    for line in lines:
                        if line := line.rstrip(B&#39;\n&#39;):
                            self.log_info(line)
            if out:
                if not stream or timeout:
                    if result is not None:
                        result.write(out)
                if stream:
                    yield out

            if done.is_set():
                if recverr is not None and recverr.is_alive():
                    self.log_warn(&#39;stderr receiver thread zombied&#39;)
                if recvout.is_alive():
                    self.log_warn(&#39;stdout receiver thread zombied&#39;)
                break
            elif not err and not out:
                if process.poll() is None:
                    sleep(_wt)
                else:
                    if recverr is not None:
                        recverr.join(_jt)
                    recvout.join(_jt)
                    done.set()
            elif timeout:
                assert result is not None
                if monotonic() - start &gt; timeout:
                    self.log_info(&#39;terminating process after timeout expired&#39;)
                    done.set()
                    process.terminate()
                    for wait in range(4):
                        if process.poll() is not None:
                            break
                        sleep(_wt)
                    else:
                        self.log_warn(&#39;process termination may have failed&#39;)
                    if recverr is not None:
                        recverr.join(_jt)
                    recvout.join(_jt)
                    if not len(result):
                        errobj = RuntimeError(&#39;timeout reached, process had no output&#39;)
                    else:
                        errobj = RefineryPartialResult(
                            &#39;timeout reached, returning all collected output&#39;,
                            partial=result.getvalue())

        if errobj is not None:
            raise errobj
        if result is not None:
            yield result.getvalue()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.misc.run.run"><code class="flex name class">
<span>class <span class="ident">run</span></span>
<span>(</span><span>*commandline, stream=False, noinput=False, errors=False, timeout=0.0)</span>
</code></dt>
<dd>
<section class="desc"><p>Turns any command into a refinery unit. Data is processed by feeding it to the standard input
of a process spawned from the given command line, and then reading the standard output of that
process as the result of the operation. The main purpose of this unit is to allow using the
syntax from <code><a title="refinery.lib.frame" href="../../lib/frame.html">refinery.lib.frame</a></code> with other command line tools. By default, the unit streams
the output from the executed command as individual outputs, but the <code>buffer</code> option can be set
to buffer all output of a single execution. The format string expression <code>{}</code> or <code>{0}</code> can be
used as one of the arguments passed to the external command to represent the incoming data. In
this case, the data will not be sent to the standard input device of the new process.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/misc/run.py#L15-L199" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class run(Unit):
    &#34;&#34;&#34;
    Turns any command into a refinery unit. Data is processed by feeding it to the standard input
    of a process spawned from the given command line, and then reading the standard output of that
    process as the result of the operation. The main purpose of this unit is to allow using the
    syntax from `refinery.lib.frame` with other command line tools. By default, the unit streams
    the output from the executed command as individual outputs, but the `buffer` option can be set
    to buffer all output of a single execution. The format string expression `{}` or `{0}` can be
    used as one of the arguments passed to the external command to represent the incoming data. In
    this case, the data will not be sent to the standard input device of the new process.
    &#34;&#34;&#34;

    _JOIN_TIME = 2
    _WAIT_TIME = 0.01

    def __init__(
        self, *commandline: Param[str, Arg.String(nargs=&#39;...&#39;, metavar=&#39;(all remaining)&#39;, help=(
            &#39;All remaining command line tokens form an arbitrary command line to be executed. Use&#39;
            &#39; format string syntax to insert meta variables and incoming data chunks.&#39;))],
        stream: Param[bool, Arg.Switch(&#39;-s&#39;,
            help=&#39;Stream the command output rather than buffering it.&#39;)] = False,
        noinput: Param[bool, Arg.Switch(&#39;-x&#39;, help=&#39;Do not send any input to the new process.&#39;)] = False,
        errors: Param[bool, Arg.Switch(&#39;-m&#39;, help=(
            &#39;Merge stdout and stderr. By default, the standard error stream of the coupled command&#39;
            &#39; is forwarded to the logger, i.e. it is only visible if -v is also specified.&#39;
        ))] = False,
        timeout: Param[float, Arg.Double(&#39;-t&#39;, metavar=&#39;T&#39;, help=(
            &#39;Optionally set an execution timeout as a floating point number in seconds.&#39;
        ))] = 0.0
    ):
        if not commandline:
            raise ValueError(&#39;you need to provide a command line.&#39;)
        super().__init__(
            commandline=commandline, errors=errors, noinput=noinput, stream=stream, timeout=timeout)

    def process(self, data):
        def shlexjoin():
            import shlex
            return shlex.join(commandline)

        meta = metavars(data)
        meta.ghost = True
        used = set()
        commandline = [
            meta.format_str(cmd, self.codec, [data], None, used=used)
            for cmd in self.args.commandline
        ]

        if self.args.noinput:
            self.log_info(&#39;sending no input to process stdin&#39;)
            data = None

        if not self.log_debug(commandline):
            self.log_info(shlexjoin)

        stream: bool = self.args.stream
        merge: bool = self.args.errors
        timeout: int = self.args.timeout

        posix = &#39;posix&#39; in sys.builtin_module_names
        process = Popen(shlex.join(commandline) if posix else commandline, shell=True,
            stdin=PIPE, stdout=PIPE, stderr=STDOUT if merge else PIPE, close_fds=posix)

        if not stream and not timeout and not merge:
            out, err = process.communicate(data)
            for line in err.splitlines():
                self.log_info(line)
            yield out
            return

        from queue import Empty, Queue
        from threading import Event, Thread
        from time import monotonic, sleep

        start = 0
        result = None
        _jt = self._JOIN_TIME
        _wt = self._WAIT_TIME

        qerr: Queue[bytes] = Queue()
        qout: Queue[bytes] = Queue()
        done = Event()

        def adapter(stream: BytesIO, queue: Queue[bytes], event: Event):
            while not event.is_set():
                out = stream.read1()
                if out:
                    queue.put(out)
                else:
                    break
            stream.close()

        recvout = Thread(target=adapter, args=(process.stdout, qout, done), daemon=True)
        recvout.start()

        if not merge:
            recverr = Thread(target=adapter, args=(process.stderr, qerr, done), daemon=True)
            recverr.start()
        else:
            recverr = None

        if stdin := process.stdin:
            if data:
                stdin.write(data)
            stdin.close()
        start = monotonic()

        if not stream or timeout:
            result = MemoryFile()

        def queue_read(q: Queue[bytes]):
            try:
                return q.get_nowait()
            except Empty:
                return None

        errbuf = MemoryFile()
        errobj = None

        while True:
            out = queue_read(qout)
            err = None

            if not merge:
                err = queue_read(qerr)

            if err and self.log_info():
                errbuf.write(err)
                errbuf.seek(0)
                lines = errbuf.readlines()
                errbuf.seek(0)
                errbuf.truncate()
                if lines:
                    if not (done.is_set() or lines[~0].endswith(B&#39;\n&#39;)):
                        errbuf.write(lines.pop())
                    for line in lines:
                        if line := line.rstrip(B&#39;\n&#39;):
                            self.log_info(line)
            if out:
                if not stream or timeout:
                    if result is not None:
                        result.write(out)
                if stream:
                    yield out

            if done.is_set():
                if recverr is not None and recverr.is_alive():
                    self.log_warn(&#39;stderr receiver thread zombied&#39;)
                if recvout.is_alive():
                    self.log_warn(&#39;stdout receiver thread zombied&#39;)
                break
            elif not err and not out:
                if process.poll() is None:
                    sleep(_wt)
                else:
                    if recverr is not None:
                        recverr.join(_jt)
                    recvout.join(_jt)
                    done.set()
            elif timeout:
                assert result is not None
                if monotonic() - start &gt; timeout:
                    self.log_info(&#39;terminating process after timeout expired&#39;)
                    done.set()
                    process.terminate()
                    for wait in range(4):
                        if process.poll() is not None:
                            break
                        sleep(_wt)
                    else:
                        self.log_warn(&#39;process termination may have failed&#39;)
                    if recverr is not None:
                        recverr.join(_jt)
                    recvout.join(_jt)
                    if not len(result):
                        errobj = RuntimeError(&#39;timeout reached, process had no output&#39;)
                    else:
                        errobj = RefineryPartialResult(
                            &#39;timeout reached, returning all collected output&#39;,
                            partial=result.getvalue())

        if errobj is not None:
            raise errobj
        if result is not None:
            yield result.getvalue()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></li>
<li><a title="refinery.units.Entry" href="../index.html#refinery.units.Entry">Entry</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.misc.run.run" href="#refinery.units.misc.run.run">run</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.misc.run.run.reverse"><code class="name">var <span class="ident">reverse</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.console" href="../index.html#refinery.units.Unit.console">console</a></code></li>
<li><code><a title="refinery.units.Unit.optional_dependencies" href="../index.html#refinery.units.Unit.optional_dependencies">optional_dependencies</a></code></li>
<li><code><a title="refinery.units.Unit.required_dependencies" href="../index.html#refinery.units.Unit.required_dependencies">required_dependencies</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.FilterEverything" href="../index.html#refinery.units.UnitBase.FilterEverything">FilterEverything</a></code></li>
<li><code><a title="refinery.units.Unit.Requires" href="../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.Unit.act" href="../index.html#refinery.units.Unit.act">act</a></code></li>
<li><code><a title="refinery.units.Unit.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.Unit.codec" href="../index.html#refinery.units.Unit.codec">codec</a></code></li>
<li><code><a title="refinery.units.Unit.finish" href="../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.Unit.handles" href="../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.Unit.is_quiet" href="../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.Unit.is_reversible" href="../index.html#refinery.units.Unit.is_reversible">is_reversible</a></code></li>
<li><code><a title="refinery.units.Unit.isatty" href="../index.html#refinery.units.Unit.isatty">isatty</a></code></li>
<li><code><a title="refinery.units.Unit.labelled" href="../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.Unit.leniency" href="../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.Unit.log_always" href="../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.Unit.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.Unit.log_detach" href="../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.Unit.log_fail" href="../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.Unit.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.Unit.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.Unit.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.Unit.logger" href="../index.html#refinery.units.Unit.logger">logger</a></code></li>
<li><code><a title="refinery.units.Unit.name" href="../index.html#refinery.units.Unit.name">name</a></code></li>
<li><code><a title="refinery.units.Unit.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.Unit.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.Unit.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.Unit.reset" href="../index.html#refinery.units.Unit.reset">reset</a></code></li>
<li><code><a title="refinery.units.Unit.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.Unit.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.Unit.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.process" href="../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.filter" href="../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.misc" href="index.html">refinery.units.misc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.misc.run.run" href="#refinery.units.misc.run.run">run</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
