<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.units.pattern.xtp documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.pattern.xtp</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/pattern/xtp.py#L1-L430" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from __future__ import annotations

import re

from enum import Enum
from fnmatch import fnmatch
from ipaddress import ip_address
from pathlib import Path
from string import ascii_letters
from typing import AnyStr
from urllib.parse import urlparse

from refinery.lib.patterns import indicators
from refinery.lib.types import Param
from refinery.units import RefineryCriticalException
from refinery.units.pattern import Arg, PatternExtractor, RefinedMatch


class LetterWeight:
    def __init__(self, weight):
        try:
            self._weights = weight._weights
        except AttributeError:
            pass
        else:
            return
        self._weights = {
            letter: weight for letters, weight in weight.items() for letter in letters
        }
        for letter in range(0x100):
            self._weights.setdefault(letter, 0)

    def __call__(self, data: AnyStr) -&gt; float:
        if isinstance(data, str):
            data = data.encode(&#39;latin1&#39;)
        return sum(self._weights[c] for c in data) / len(data) / max(self._weights.values())


class LetterWeights(LetterWeight, Enum):
    IOC = LetterWeight({
        B&#39;^`&#39;: 1,
        B&#39;!$%&amp;()*+-&lt;=&gt;?[]{}~\t&#39;: 2,
        B&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;: 4,
        B&#39;.,:;#/\\|@_ &#39;: 5,
        B&#39;0123456789abcdefghijklmnopqrstuvwxyz&#39;: 8,
    })
    Path = LetterWeight({
        B&#39;^`&#39;: 1,
        B&#39;$%&amp;()*+-&lt;=&gt;?[]{}~\t&#39;: 2,
        B&#39;.,:;#/\\|@_ &#39;: 4,
        B&#39;0123456789&#39;: 4,
        B&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;: 6,
        B&#39;abcdefghijklmnopqrstuvwxyz&#39;: 8,
    })


class xtp(PatternExtractor):
    &#34;&#34;&#34;
    Extract Patterns: Uses regular expressions to extract indicators from the input data and
    optionally filters these results heuristically. The unit is designed to extract indicators
    such as domain names and IP addresses, see below for a complete list. To extract data
    formats such as hex-encoded data, use `refinery.carve`.
    &#34;&#34;&#34;

    def __init__(
        self,
        *pattern: Param[str, Arg.String(&#39;pattern&#39;,
            default=(
                indicators.hostname.name,
                indicators.url.name,
                indicators.email.name,
            ), help=(
                &#39;Choose the pattern to extract. The unit uses {{default}} by default. Use an &#39;
                &#39;asterix character to select all available patterns. The available patterns &#39;
                &#39;are: {}&#39;.format(&#39;, &#39;.join(p.display for p in indicators))
            )
        )],
        filter: Param[int, Arg.Counts(&#39;-f&#39;, help=(
            &#39;If this setting is enabled, the xtp unit will attempt to reduce the number &#39;
            &#39;of false positives by certain crude heuristics. Specify multiple times to &#39;
            &#39;make the filtering more aggressive.&#39;)
        )] = 0,
        min=1, max=0, len=0, stripspace=False, duplicates=False, longest=False, take=0
    ):
        self.superinit(super(), **vars(), ascii=True, utf16=True)

        patterns = {
            p for name in pattern for p in indicators if fnmatch(p.display, name)
        }
        # if indicators.hostname in patterns:
        #     patterns.remove(indicators.hostname)
        #     patterns.add(indicators.ipv4)
        #     patterns.add(indicators.domain)
        patterns = [F&#39;(?P&lt;{p.name}&gt;{p.value})&#39; for p in patterns]
        if not patterns:
            raise RefineryCriticalException(&#39;The given mask does not match any known indicator pattern.&#39;)
        joined = &#39;|&#39;.join(patterns)
        self.args.pattern = re.compile(joined.encode(self.codec), flags=re.DOTALL)
        self.args.filter = filter

    _ALPHABETIC = ascii_letters.encode(&#39;ASCII&#39;)

    _LEGITIMATE_HOSTS = {
        &#39;acm.org&#39;                 : 1,
        &#39;adobe.com&#39;               : 1,
        &#39;aka.ms&#39;                  : 1,
        &#39;android.com&#39;             : 1,
        &#39;apache.org&#39;              : 1,
        &#39;apple.com&#39;               : 1,
        &#39;archive.org&#39;             : 2,
        &#39;azure.com&#39;               : 1,
        &#39;baidu.com&#39;               : 2,
        &#39;bootstrapcdn.com&#39;        : 2,
        &#39;cdnjs.cloudflare.com&#39;    : 4,
        &#39;comodo.net&#39;              : 1,
        &#39;comodoca.com&#39;            : 1,
        &#39;curl.haxx.se&#39;            : 1,
        &#39;curl.se&#39;                 : 1,
        &#39;digicert.com&#39;            : 1,
        &#39;dublincore.org&#39;          : 1,
        &#39;example.com&#39;             : 1,
        &#39;facebook.com&#39;            : 4,
        &#39;fontawesome.com&#39;         : 1,
        &#39;github.com&#39;              : 3,
        &#39;globalsign.com&#39;          : 1,
        &#39;globalsign.net&#39;          : 1,
        &#39;godaddy.com&#39;             : 1,
        &#39;golang.org&#39;              : 1,
        &#39;google.com&#39;              : 4,
        &#39;googleapis.com&#39;          : 5,
        &#39;googleusercontent.com&#39;   : 5,
        &#39;gov&#39;                     : 2,
        &#39;gstatic.com&#39;             : 2,
        &#39;iana.org&#39;                : 1,
        &#39;ietf.org&#39;                : 1,
        &#39;intel.com&#39;               : 1,
        &#39;jquery.com&#39;              : 1,
        &#39;jsdelivr.net&#39;            : 2,
        &#39;libssh.org&#39;              : 1,
        &#39;live.com&#39;                : 1,
        &#39;microsoft.com&#39;           : 1,
        &#39;mozilla.org&#39;             : 1,
        &#39;msdn.com&#39;                : 1,
        &#39;msn.com&#39;                 : 1,
        &#39;newtonsoft.com&#39;          : 3, # json.net
        &#39;nuget.org&#39;               : 3,
        &#39;office.com&#39;              : 1,
        &#39;office365.com&#39;           : 2,
        &#39;openssl.org&#39;             : 1,
        &#39;openssh.com&#39;             : 1,
        &#39;openxmlformats.org&#39;      : 1,
        &#39;oracle.com&#39;              : 1,
        &#39;purl.org&#39;                : 1,
        &#39;python.org&#39;              : 1,
        &#39;readthedocs.io&#39;          : 1,
        &#39;schema.org&#39;              : 2,
        &#39;sectigo.com&#39;             : 1,
        &#39;skype.com&#39;               : 1,
        &#39;sourceforge.net&#39;         : 4,
        &#39;stackoverflow.com&#39;       : 1,
        &#39;sun.com&#39;                 : 1,
        &#39;sway-cdn.com&#39;            : 1,
        &#39;sway-extensions.com&#39;     : 1,
        &#39;symantec.com&#39;            : 1,
        &#39;symauth.com&#39;             : 1,
        &#39;symcb.com&#39;               : 1,
        &#39;symcd.com&#39;               : 1,
        &#39;sysinternals.com&#39;        : 3,
        &#39;thawte.com&#39;              : 1,
        &#39;unicode.org&#39;             : 2,
        &#39;usertrust.com&#39;           : 1,
        &#39;verisign.com&#39;            : 1,
        &#39;w3.org&#39;                  : 1,
        &#39;wikipedia.org&#39;           : 1,
        &#39;wolfram.com&#39;             : 1,
        &#39;xml.org&#39;                 : 1,
        &#39;xmlsoap.org&#39;             : 1,
        &#39;yahoo.com&#39;               : 1,
    }

    for _ext in [
        &#39;build&#39;,
        &#39;data&#39;,
        &#39;do&#39;,
        &#39;help&#39;,
        &#39;java&#39;,
        &#39;md&#39;,
        &#39;mov&#39;,
        &#39;name&#39;,
        &#39;py&#39;,
        &#39;so&#39;,
        &#39;sys&#39;,
        &#39;zip&#39;,
    ]:
        _LEGITIMATE_HOSTS[_ext] = 4

    _DOMAIN_WHITELIST = {
        &#39;system.net&#39;,
        &#39;wscript.shell&#39;,
    }

    _BRACKETING = {
        B&#34;&#39;&#34;[0]: B&#34;&#39;&#34;,
        B&#39;&#34;&#39;[0]: B&#39;&#34;&#39;,
        B&#39;(&#39;[0]: B&#39;)&#39;,
        B&#39;{&#39;[0]: B&#39;}&#39;,
        B&#39;[&#39;[0]: B&#39;]&#39;,
        B&#39;&lt;&#39;[0]: B&#39;&gt;&#39;,
    }

    def _check_host(self, host: str, text: str):
        hl = host.lower()
        if hl in self._DOMAIN_WHITELIST:
            self.log_info(F&#39;excluding indicator because domain {hl} is forcefully ignored: {text}&#39;)
            return False
        for white, level in self._LEGITIMATE_HOSTS.items():
            if self.args.filter &gt;= level and (hl == white or hl.endswith(F&#39;.{white}&#39;)):
                self.log_info(F&#39;excluding indicator because domain {hl} is whitelisted: {text}&#39;, clip=True)
                self.log_debug(F&#39;reduce level below {level} to allow, current level is {self.args.filter}&#39;)
                return False
        return True

    def _check_match(self, data: memoryview | bytearray, pos: int, name: str, value: bytes):
        term = self._BRACKETING.get(data[pos - 1], None)
        text = value.decode(self.codec)
        if term:
            pos = value.find(term)
            if pos &gt; 0:
                value = value[:pos]
        if not self.args.filter:
            return value
        if name == indicators.hostname.name:
            if all(part.isdigit() for part in value.split(B&#39;.&#39;)):
                name = indicators.ipv4.name
            elif B&#39;.&#39; not in value:
                name = indicators.ipv6.name
            else:
                name = indicators.domain.name
        if name == indicators.ipv4.name:
            ocets = [int(x) for x in value.split(B&#39;.&#39;)]
            if ocets.count(0) &gt;= 3:
                self.log_info(F&#39;excluding ipv4 because it contains many zeros: {text}&#39;)
                return None
            if self.args.filter &gt; 2 and sum(ocets) &lt; 10:
                self.log_info(F&#39;excluding ipv4 because of low value ocets: {text}&#39;)
                return None
            if ocets[0] &lt;= 5 * self.args.filter:
                for area in (
                    bytes(data[pos - 20 : pos + 20]),
                    bytes(data[pos * 2 - 40 : pos * 2 + 40 : 2]),
                    bytes(data[pos * 2 - 41 : pos * 2 + 39 : 2]),
                ):
                    check = area.lower()
                    if B&#39;version&#39; in check or b&#39;build&#39; in check:
                        self.log_info(F&#39;excluding ipv4 because it might be a version: {text}&#39;)
                        return None
            small_ocet_count = sum(1 for ocet in ocets if ocet &lt; 10)
            if small_ocet_count &gt; max(0, 4 - self.args.filter):
                self.log_info(F&#39;excluding ipv4 because it has too many small ocets: {text}&#39;)
                return None
            ip = ip_address(text)
            if not ip.is_global:
                if self.args.filter &gt;= 3 or not ip.is_private:
                    self.log_info(F&#39;excluding ipv4 because it is not global: {text}&#39;)
                    return None
        elif name in {
            indicators.url.name,
            indicators.socket.name,
            indicators.hostname.name,
            indicators.domain.name,
            indicators.subdomain.name
        }:
            if self.args.filter &gt;= 2:
                if LetterWeights.IOC(value) &lt; 0.6:
                    self.log_info(F&#39;excluding indicator because with low score: {text}&#39;, clip=True)
                    return None
                if name != indicators.url.name and len(value) &gt; 0x100:
                    self.log_info(F&#39;excluding indicator because it is too long: {text}&#39;, clip=True)
                    return None
            ioc = text
            if &#39;://&#39; not in ioc:
                ioc = F&#39;tcp://{ioc}&#39;
            parts = urlparse(ioc)
            host, _, _ = parts.netloc.partition(&#39;:&#39;)
            if not self._check_host(host, text):
                return None
            if name == indicators.url.name:
                scheme = parts.scheme.lower()
                for p in (&#39;http&#39;, &#39;https&#39;, &#39;ftp&#39;, &#39;file&#39;, &#39;mailto&#39;):
                    if scheme.endswith(p):
                        pos = scheme.find(p)
                        value = value[pos:]
                        break
            if name in {
                indicators.hostname.name,
                indicators.domain.name,
                indicators.subdomain.name
            }:
                if data[pos - 1] in b&#39;/\\&#39; and self.args.filter &gt;= 2:
                    return None
                hostparts = host.split(&#39;.&#39;)
                if self.args.filter &gt;= 2:
                    if not all(p.isdigit() for p in hostparts) and all(len(p) &lt; 4 for p in hostparts):
                        self.log_info(F&#39;excluding host with too many short parts: {text}&#39;)
                        return None
                if self.args.filter &gt;= 3:
                    if len(hostparts) &lt;= sum(3 for p in hostparts if p != p.lower() and p != p.upper()):
                        self.log_info(F&#39;excluding host with too many mixed case parts: {text}&#39;)
                        return None
                # These heuristics attempt to filter out member access to variables in
                # scripts which can be mistaken for domains because of the TLD inflation
                # we&#39;ve had.
                uppercase = sum(1 for c in host if c.isalpha() and c.upper() == c)
                lowercase = sum(1 for c in host if c.isalpha() and c.lower() == c)
                if lowercase and uppercase:
                    caseratio = uppercase / lowercase
                    if 0.1 &lt; caseratio &lt; 0.9:
                        self.log_info(F&#39;excluding indicator with too much uppercase letters: {text}&#39;)
                        return None
                if all(x.isidentifier() for x in hostparts):
                    if len(hostparts) == 2 and hostparts[0] in (&#39;this&#39;, &#39;self&#39;):
                        self.log_info(F&#39;excluding host that looks like a code snippet: {text}&#39;)
                        return None
                    if len(hostparts[-2]) &lt; 3:
                        self.log_info(F&#39;excluding host with too short root domain name: {text}&#39;)
                        return None
                    if any(x.startswith(&#39;_&#39;) for x in hostparts):
                        self.log_info(F&#39;excluding host with underscores: {text}&#39;)
                        return None
                    if len(hostparts[-1]) &gt; 3:
                        prefix = &#39;.&#39;.join(hostparts[:-1])
                        seen_before = len(set(re.findall(
                            fR&#39;{prefix}(?:\.\w+)+&#39;.encode(&#39;ascii&#39;), data)))
                        if seen_before &gt; 2:
                            self.log_debug(F&#39;excluding indicator that was already seen: {text}&#39;)
                            return None
        elif name == indicators.email.name:
            _, _, host = value.partition(B&#39;@&#39;)
            host = host.decode(self.codec)
            if not self._check_host(host, text):
                return None
            at = value.find(B&#39;@&#39;)
            ix = 0
            while value[ix] not in self._ALPHABETIC:
                ix += 1
            return None if at - ix &lt; 3 else value[ix:]
        elif name in (
            indicators.path.name,
            indicators.winpath.name,
            indicators.nixpath.name,
        ):
            if len(value.split()) + min(self.args.filter, 4) &gt;= 6:
                self.log_info(F&#39;excluding path because it contains too many spaces: {text}&#39;)
                return None
            if len(value) &lt; 8:
                self.log_info(F&#39;excluding path because it is too short: {text}&#39;)
                return None
            if len(value) &gt; 16 and len(re.findall(RB&#39;\\x\d\d&#39;, value)) &gt; len(value) // 10:
                self.log_info(F&#39;excluding long path containign hex: {text}&#39;, clip=True)
                return None
            try:
                path_string = text
            except Exception:
                self.log_debug(F&#39;excluding path which did not decode: {value!r}&#39;, clip=True)
                return None
            try:
                path = Path(path_string)
            except Exception as E:
                self.log_debug(F&#39;error parsing path &#34;{path}&#34;: {E!s}&#39;)
                return None
            path_likeness = sum(v for v, x in [
                (1, path.suffix),
                (1, path_string.startswith(&#39;/&#39;)),
                (2, path_string.startswith(&#39;%&#39;)),
                (2, path_string.startswith(&#39;\\\\&#39;)),
                (2, path_string[1:3] == &#39;:\\&#39;),
            ] if x)
            if 2 + path_likeness &lt; min(self.args.filter, 2):
                self.log_info(F&#39;excluding long path because it has no characteristic parts: {text}&#39;)
                return None
            bad_parts = 0
            all_parts = len(path.parts)
            if self.args.filter &gt;= 1:
                date_likeness = sum(1
                    for t in [&#39;yyyy&#39;, &#39;yy&#39;, &#39;mm&#39;, &#39;dd&#39;, &#39;hh&#39;, &#39;ss&#39;]
                    if t in path.parts or t.upper() in path.parts)
                if len(value) &lt; 20 and date_likeness &gt;= all_parts - 1:
                    self.log_info(F&#39;excluding path that looks like a date format: {text}&#39;, clip=True)
                    return None
            if self.args.filter &gt;= 2:
                for k, part in enumerate(path.parts):
                    if not k:
                        drive, colon, slash = part.partition(&#39;:&#39;)
                        if colon and len(drive) == 1 and len(slash) &lt;= 1:
                            continue
                        if part[0] == part[~0] == &#39;%&#39;:
                            continue
                        if len(part) == 1:
                            continue
                    if (
                        LetterWeights.Path(part) &lt; 0.5 + (min(self.args.filter, 4) * 0.1)
                        or (self.args.filter &gt;= 2 and LetterWeights.Path(part[:1]) &lt; 0.5)
                    ):
                        bad_parts += 1
                        self.log_debug(F&#39;bad part {k + 1} in path: {part}&#39;)
            for filter_limit in (2, 3, 4):
                bad_ratio = 2 ** (filter_limit - 1)
                if self.args.filter &gt;= filter_limit and bad_parts * bad_ratio &gt;= all_parts:
                    self.log_info(F&#39;excluding path with bad parts: {text}&#39;, clip=True)
                    return None
        return value

    def process(self, data):
        whitelist = set()

        def check(match: RefinedMatch):
            for name, value in match.groupdict().items():
                if value is not None:
                    break
            else:
                raise RefineryCriticalException(&#39;Received empty match.&#39;)
            if value in whitelist:
                return None
            result = self._check_match(match.string, match.start(), name, value)
            if result is not None:
                return self.labelled(result, pattern=name)
            whitelist.add(value)

        transforms = [check]
        yield from self.matches_filtered(memoryview(data), self.args.pattern, *transforms)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.pattern.xtp.LetterWeight"><code class="flex name class">
<span>class <span class="ident">LetterWeight</span></span>
<span>(</span><span>weight)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/pattern/xtp.py#L19-L36" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LetterWeight:
    def __init__(self, weight):
        try:
            self._weights = weight._weights
        except AttributeError:
            pass
        else:
            return
        self._weights = {
            letter: weight for letters, weight in weight.items() for letter in letters
        }
        for letter in range(0x100):
            self._weights.setdefault(letter, 0)

    def __call__(self, data: AnyStr) -&gt; float:
        if isinstance(data, str):
            data = data.encode(&#39;latin1&#39;)
        return sum(self._weights[c] for c in data) / len(data) / max(self._weights.values())</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.pattern.xtp.LetterWeights" href="#refinery.units.pattern.xtp.LetterWeights">LetterWeights</a></li>
</ul>
</dd>
<dt id="refinery.units.pattern.xtp.LetterWeights"><code class="flex name class">
<span>class <span class="ident">LetterWeights</span></span>
<span>(</span><span>weight)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a collection of name/value pairs.</p>
<p>Example enumeration:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     BLUE = 2
...     GREEN = 3
</code></pre>
<p>Access them by:</p>
<ul>
<li>attribute access:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color.RED
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>value lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color(1)
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>name lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color['RED']
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<p>Enumerations can be iterated over, and know how many members they have:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; len(Color)
3
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</code></pre>
<p>Methods can be added to enumerations, and members can have their own
attributes &ndash; see the documentation for details.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/pattern/xtp.py#L39-L54" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LetterWeights(LetterWeight, Enum):
    IOC = LetterWeight({
        B&#39;^`&#39;: 1,
        B&#39;!$%&amp;()*+-&lt;=&gt;?[]{}~\t&#39;: 2,
        B&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;: 4,
        B&#39;.,:;#/\\|@_ &#39;: 5,
        B&#39;0123456789abcdefghijklmnopqrstuvwxyz&#39;: 8,
    })
    Path = LetterWeight({
        B&#39;^`&#39;: 1,
        B&#39;$%&amp;()*+-&lt;=&gt;?[]{}~\t&#39;: 2,
        B&#39;.,:;#/\\|@_ &#39;: 4,
        B&#39;0123456789&#39;: 4,
        B&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;: 6,
        B&#39;abcdefghijklmnopqrstuvwxyz&#39;: 8,
    })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.pattern.xtp.LetterWeight" href="#refinery.units.pattern.xtp.LetterWeight">LetterWeight</a></li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.pattern.xtp.LetterWeights.IOC"><code class="name">var <span class="ident">IOC</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.pattern.xtp.LetterWeights.Path"><code class="name">var <span class="ident">Path</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.pattern.xtp.xtp"><code class="flex name class">
<span>class <span class="ident">xtp</span></span>
<span>(</span><span>*pattern, filter=0, min=1, max=0, len=0, stripspace=False, duplicates=False, longest=False, take=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Extract Patterns: Uses regular expressions to extract indicators from the input data and
optionally filters these results heuristically. The unit is designed to extract indicators
such as domain names and IP addresses, see below for a complete list. To extract data
formats such as hex-encoded data, use <code><a title="refinery.carve" href="../../index.html#refinery.carve">carve</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/pattern/xtp.py#L57-L430" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class xtp(PatternExtractor):
    &#34;&#34;&#34;
    Extract Patterns: Uses regular expressions to extract indicators from the input data and
    optionally filters these results heuristically. The unit is designed to extract indicators
    such as domain names and IP addresses, see below for a complete list. To extract data
    formats such as hex-encoded data, use `refinery.carve`.
    &#34;&#34;&#34;

    def __init__(
        self,
        *pattern: Param[str, Arg.String(&#39;pattern&#39;,
            default=(
                indicators.hostname.name,
                indicators.url.name,
                indicators.email.name,
            ), help=(
                &#39;Choose the pattern to extract. The unit uses {{default}} by default. Use an &#39;
                &#39;asterix character to select all available patterns. The available patterns &#39;
                &#39;are: {}&#39;.format(&#39;, &#39;.join(p.display for p in indicators))
            )
        )],
        filter: Param[int, Arg.Counts(&#39;-f&#39;, help=(
            &#39;If this setting is enabled, the xtp unit will attempt to reduce the number &#39;
            &#39;of false positives by certain crude heuristics. Specify multiple times to &#39;
            &#39;make the filtering more aggressive.&#39;)
        )] = 0,
        min=1, max=0, len=0, stripspace=False, duplicates=False, longest=False, take=0
    ):
        self.superinit(super(), **vars(), ascii=True, utf16=True)

        patterns = {
            p for name in pattern for p in indicators if fnmatch(p.display, name)
        }
        # if indicators.hostname in patterns:
        #     patterns.remove(indicators.hostname)
        #     patterns.add(indicators.ipv4)
        #     patterns.add(indicators.domain)
        patterns = [F&#39;(?P&lt;{p.name}&gt;{p.value})&#39; for p in patterns]
        if not patterns:
            raise RefineryCriticalException(&#39;The given mask does not match any known indicator pattern.&#39;)
        joined = &#39;|&#39;.join(patterns)
        self.args.pattern = re.compile(joined.encode(self.codec), flags=re.DOTALL)
        self.args.filter = filter

    _ALPHABETIC = ascii_letters.encode(&#39;ASCII&#39;)

    _LEGITIMATE_HOSTS = {
        &#39;acm.org&#39;                 : 1,
        &#39;adobe.com&#39;               : 1,
        &#39;aka.ms&#39;                  : 1,
        &#39;android.com&#39;             : 1,
        &#39;apache.org&#39;              : 1,
        &#39;apple.com&#39;               : 1,
        &#39;archive.org&#39;             : 2,
        &#39;azure.com&#39;               : 1,
        &#39;baidu.com&#39;               : 2,
        &#39;bootstrapcdn.com&#39;        : 2,
        &#39;cdnjs.cloudflare.com&#39;    : 4,
        &#39;comodo.net&#39;              : 1,
        &#39;comodoca.com&#39;            : 1,
        &#39;curl.haxx.se&#39;            : 1,
        &#39;curl.se&#39;                 : 1,
        &#39;digicert.com&#39;            : 1,
        &#39;dublincore.org&#39;          : 1,
        &#39;example.com&#39;             : 1,
        &#39;facebook.com&#39;            : 4,
        &#39;fontawesome.com&#39;         : 1,
        &#39;github.com&#39;              : 3,
        &#39;globalsign.com&#39;          : 1,
        &#39;globalsign.net&#39;          : 1,
        &#39;godaddy.com&#39;             : 1,
        &#39;golang.org&#39;              : 1,
        &#39;google.com&#39;              : 4,
        &#39;googleapis.com&#39;          : 5,
        &#39;googleusercontent.com&#39;   : 5,
        &#39;gov&#39;                     : 2,
        &#39;gstatic.com&#39;             : 2,
        &#39;iana.org&#39;                : 1,
        &#39;ietf.org&#39;                : 1,
        &#39;intel.com&#39;               : 1,
        &#39;jquery.com&#39;              : 1,
        &#39;jsdelivr.net&#39;            : 2,
        &#39;libssh.org&#39;              : 1,
        &#39;live.com&#39;                : 1,
        &#39;microsoft.com&#39;           : 1,
        &#39;mozilla.org&#39;             : 1,
        &#39;msdn.com&#39;                : 1,
        &#39;msn.com&#39;                 : 1,
        &#39;newtonsoft.com&#39;          : 3, # json.net
        &#39;nuget.org&#39;               : 3,
        &#39;office.com&#39;              : 1,
        &#39;office365.com&#39;           : 2,
        &#39;openssl.org&#39;             : 1,
        &#39;openssh.com&#39;             : 1,
        &#39;openxmlformats.org&#39;      : 1,
        &#39;oracle.com&#39;              : 1,
        &#39;purl.org&#39;                : 1,
        &#39;python.org&#39;              : 1,
        &#39;readthedocs.io&#39;          : 1,
        &#39;schema.org&#39;              : 2,
        &#39;sectigo.com&#39;             : 1,
        &#39;skype.com&#39;               : 1,
        &#39;sourceforge.net&#39;         : 4,
        &#39;stackoverflow.com&#39;       : 1,
        &#39;sun.com&#39;                 : 1,
        &#39;sway-cdn.com&#39;            : 1,
        &#39;sway-extensions.com&#39;     : 1,
        &#39;symantec.com&#39;            : 1,
        &#39;symauth.com&#39;             : 1,
        &#39;symcb.com&#39;               : 1,
        &#39;symcd.com&#39;               : 1,
        &#39;sysinternals.com&#39;        : 3,
        &#39;thawte.com&#39;              : 1,
        &#39;unicode.org&#39;             : 2,
        &#39;usertrust.com&#39;           : 1,
        &#39;verisign.com&#39;            : 1,
        &#39;w3.org&#39;                  : 1,
        &#39;wikipedia.org&#39;           : 1,
        &#39;wolfram.com&#39;             : 1,
        &#39;xml.org&#39;                 : 1,
        &#39;xmlsoap.org&#39;             : 1,
        &#39;yahoo.com&#39;               : 1,
    }

    for _ext in [
        &#39;build&#39;,
        &#39;data&#39;,
        &#39;do&#39;,
        &#39;help&#39;,
        &#39;java&#39;,
        &#39;md&#39;,
        &#39;mov&#39;,
        &#39;name&#39;,
        &#39;py&#39;,
        &#39;so&#39;,
        &#39;sys&#39;,
        &#39;zip&#39;,
    ]:
        _LEGITIMATE_HOSTS[_ext] = 4

    _DOMAIN_WHITELIST = {
        &#39;system.net&#39;,
        &#39;wscript.shell&#39;,
    }

    _BRACKETING = {
        B&#34;&#39;&#34;[0]: B&#34;&#39;&#34;,
        B&#39;&#34;&#39;[0]: B&#39;&#34;&#39;,
        B&#39;(&#39;[0]: B&#39;)&#39;,
        B&#39;{&#39;[0]: B&#39;}&#39;,
        B&#39;[&#39;[0]: B&#39;]&#39;,
        B&#39;&lt;&#39;[0]: B&#39;&gt;&#39;,
    }

    def _check_host(self, host: str, text: str):
        hl = host.lower()
        if hl in self._DOMAIN_WHITELIST:
            self.log_info(F&#39;excluding indicator because domain {hl} is forcefully ignored: {text}&#39;)
            return False
        for white, level in self._LEGITIMATE_HOSTS.items():
            if self.args.filter &gt;= level and (hl == white or hl.endswith(F&#39;.{white}&#39;)):
                self.log_info(F&#39;excluding indicator because domain {hl} is whitelisted: {text}&#39;, clip=True)
                self.log_debug(F&#39;reduce level below {level} to allow, current level is {self.args.filter}&#39;)
                return False
        return True

    def _check_match(self, data: memoryview | bytearray, pos: int, name: str, value: bytes):
        term = self._BRACKETING.get(data[pos - 1], None)
        text = value.decode(self.codec)
        if term:
            pos = value.find(term)
            if pos &gt; 0:
                value = value[:pos]
        if not self.args.filter:
            return value
        if name == indicators.hostname.name:
            if all(part.isdigit() for part in value.split(B&#39;.&#39;)):
                name = indicators.ipv4.name
            elif B&#39;.&#39; not in value:
                name = indicators.ipv6.name
            else:
                name = indicators.domain.name
        if name == indicators.ipv4.name:
            ocets = [int(x) for x in value.split(B&#39;.&#39;)]
            if ocets.count(0) &gt;= 3:
                self.log_info(F&#39;excluding ipv4 because it contains many zeros: {text}&#39;)
                return None
            if self.args.filter &gt; 2 and sum(ocets) &lt; 10:
                self.log_info(F&#39;excluding ipv4 because of low value ocets: {text}&#39;)
                return None
            if ocets[0] &lt;= 5 * self.args.filter:
                for area in (
                    bytes(data[pos - 20 : pos + 20]),
                    bytes(data[pos * 2 - 40 : pos * 2 + 40 : 2]),
                    bytes(data[pos * 2 - 41 : pos * 2 + 39 : 2]),
                ):
                    check = area.lower()
                    if B&#39;version&#39; in check or b&#39;build&#39; in check:
                        self.log_info(F&#39;excluding ipv4 because it might be a version: {text}&#39;)
                        return None
            small_ocet_count = sum(1 for ocet in ocets if ocet &lt; 10)
            if small_ocet_count &gt; max(0, 4 - self.args.filter):
                self.log_info(F&#39;excluding ipv4 because it has too many small ocets: {text}&#39;)
                return None
            ip = ip_address(text)
            if not ip.is_global:
                if self.args.filter &gt;= 3 or not ip.is_private:
                    self.log_info(F&#39;excluding ipv4 because it is not global: {text}&#39;)
                    return None
        elif name in {
            indicators.url.name,
            indicators.socket.name,
            indicators.hostname.name,
            indicators.domain.name,
            indicators.subdomain.name
        }:
            if self.args.filter &gt;= 2:
                if LetterWeights.IOC(value) &lt; 0.6:
                    self.log_info(F&#39;excluding indicator because with low score: {text}&#39;, clip=True)
                    return None
                if name != indicators.url.name and len(value) &gt; 0x100:
                    self.log_info(F&#39;excluding indicator because it is too long: {text}&#39;, clip=True)
                    return None
            ioc = text
            if &#39;://&#39; not in ioc:
                ioc = F&#39;tcp://{ioc}&#39;
            parts = urlparse(ioc)
            host, _, _ = parts.netloc.partition(&#39;:&#39;)
            if not self._check_host(host, text):
                return None
            if name == indicators.url.name:
                scheme = parts.scheme.lower()
                for p in (&#39;http&#39;, &#39;https&#39;, &#39;ftp&#39;, &#39;file&#39;, &#39;mailto&#39;):
                    if scheme.endswith(p):
                        pos = scheme.find(p)
                        value = value[pos:]
                        break
            if name in {
                indicators.hostname.name,
                indicators.domain.name,
                indicators.subdomain.name
            }:
                if data[pos - 1] in b&#39;/\\&#39; and self.args.filter &gt;= 2:
                    return None
                hostparts = host.split(&#39;.&#39;)
                if self.args.filter &gt;= 2:
                    if not all(p.isdigit() for p in hostparts) and all(len(p) &lt; 4 for p in hostparts):
                        self.log_info(F&#39;excluding host with too many short parts: {text}&#39;)
                        return None
                if self.args.filter &gt;= 3:
                    if len(hostparts) &lt;= sum(3 for p in hostparts if p != p.lower() and p != p.upper()):
                        self.log_info(F&#39;excluding host with too many mixed case parts: {text}&#39;)
                        return None
                # These heuristics attempt to filter out member access to variables in
                # scripts which can be mistaken for domains because of the TLD inflation
                # we&#39;ve had.
                uppercase = sum(1 for c in host if c.isalpha() and c.upper() == c)
                lowercase = sum(1 for c in host if c.isalpha() and c.lower() == c)
                if lowercase and uppercase:
                    caseratio = uppercase / lowercase
                    if 0.1 &lt; caseratio &lt; 0.9:
                        self.log_info(F&#39;excluding indicator with too much uppercase letters: {text}&#39;)
                        return None
                if all(x.isidentifier() for x in hostparts):
                    if len(hostparts) == 2 and hostparts[0] in (&#39;this&#39;, &#39;self&#39;):
                        self.log_info(F&#39;excluding host that looks like a code snippet: {text}&#39;)
                        return None
                    if len(hostparts[-2]) &lt; 3:
                        self.log_info(F&#39;excluding host with too short root domain name: {text}&#39;)
                        return None
                    if any(x.startswith(&#39;_&#39;) for x in hostparts):
                        self.log_info(F&#39;excluding host with underscores: {text}&#39;)
                        return None
                    if len(hostparts[-1]) &gt; 3:
                        prefix = &#39;.&#39;.join(hostparts[:-1])
                        seen_before = len(set(re.findall(
                            fR&#39;{prefix}(?:\.\w+)+&#39;.encode(&#39;ascii&#39;), data)))
                        if seen_before &gt; 2:
                            self.log_debug(F&#39;excluding indicator that was already seen: {text}&#39;)
                            return None
        elif name == indicators.email.name:
            _, _, host = value.partition(B&#39;@&#39;)
            host = host.decode(self.codec)
            if not self._check_host(host, text):
                return None
            at = value.find(B&#39;@&#39;)
            ix = 0
            while value[ix] not in self._ALPHABETIC:
                ix += 1
            return None if at - ix &lt; 3 else value[ix:]
        elif name in (
            indicators.path.name,
            indicators.winpath.name,
            indicators.nixpath.name,
        ):
            if len(value.split()) + min(self.args.filter, 4) &gt;= 6:
                self.log_info(F&#39;excluding path because it contains too many spaces: {text}&#39;)
                return None
            if len(value) &lt; 8:
                self.log_info(F&#39;excluding path because it is too short: {text}&#39;)
                return None
            if len(value) &gt; 16 and len(re.findall(RB&#39;\\x\d\d&#39;, value)) &gt; len(value) // 10:
                self.log_info(F&#39;excluding long path containign hex: {text}&#39;, clip=True)
                return None
            try:
                path_string = text
            except Exception:
                self.log_debug(F&#39;excluding path which did not decode: {value!r}&#39;, clip=True)
                return None
            try:
                path = Path(path_string)
            except Exception as E:
                self.log_debug(F&#39;error parsing path &#34;{path}&#34;: {E!s}&#39;)
                return None
            path_likeness = sum(v for v, x in [
                (1, path.suffix),
                (1, path_string.startswith(&#39;/&#39;)),
                (2, path_string.startswith(&#39;%&#39;)),
                (2, path_string.startswith(&#39;\\\\&#39;)),
                (2, path_string[1:3] == &#39;:\\&#39;),
            ] if x)
            if 2 + path_likeness &lt; min(self.args.filter, 2):
                self.log_info(F&#39;excluding long path because it has no characteristic parts: {text}&#39;)
                return None
            bad_parts = 0
            all_parts = len(path.parts)
            if self.args.filter &gt;= 1:
                date_likeness = sum(1
                    for t in [&#39;yyyy&#39;, &#39;yy&#39;, &#39;mm&#39;, &#39;dd&#39;, &#39;hh&#39;, &#39;ss&#39;]
                    if t in path.parts or t.upper() in path.parts)
                if len(value) &lt; 20 and date_likeness &gt;= all_parts - 1:
                    self.log_info(F&#39;excluding path that looks like a date format: {text}&#39;, clip=True)
                    return None
            if self.args.filter &gt;= 2:
                for k, part in enumerate(path.parts):
                    if not k:
                        drive, colon, slash = part.partition(&#39;:&#39;)
                        if colon and len(drive) == 1 and len(slash) &lt;= 1:
                            continue
                        if part[0] == part[~0] == &#39;%&#39;:
                            continue
                        if len(part) == 1:
                            continue
                    if (
                        LetterWeights.Path(part) &lt; 0.5 + (min(self.args.filter, 4) * 0.1)
                        or (self.args.filter &gt;= 2 and LetterWeights.Path(part[:1]) &lt; 0.5)
                    ):
                        bad_parts += 1
                        self.log_debug(F&#39;bad part {k + 1} in path: {part}&#39;)
            for filter_limit in (2, 3, 4):
                bad_ratio = 2 ** (filter_limit - 1)
                if self.args.filter &gt;= filter_limit and bad_parts * bad_ratio &gt;= all_parts:
                    self.log_info(F&#39;excluding path with bad parts: {text}&#39;, clip=True)
                    return None
        return value

    def process(self, data):
        whitelist = set()

        def check(match: RefinedMatch):
            for name, value in match.groupdict().items():
                if value is not None:
                    break
            else:
                raise RefineryCriticalException(&#39;Received empty match.&#39;)
            if value in whitelist:
                return None
            result = self._check_match(match.string, match.start(), name, value)
            if result is not None:
                return self.labelled(result, pattern=name)
            whitelist.add(value)

        transforms = [check]
        yield from self.matches_filtered(memoryview(data), self.args.pattern, *transforms)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.pattern.PatternExtractor" href="index.html#refinery.units.pattern.PatternExtractor">PatternExtractor</a></li>
<li><a title="refinery.units.pattern.PatternExtractorBase" href="index.html#refinery.units.pattern.PatternExtractorBase">PatternExtractorBase</a></li>
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></li>
<li><a title="refinery.units.Entry" href="../index.html#refinery.units.Entry">Entry</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.pattern.xtp.xtp" href="#refinery.units.pattern.xtp.xtp">xtp</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.pattern.xtp.xtp.reverse"><code class="name">var <span class="ident">reverse</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.pattern.PatternExtractor" href="index.html#refinery.units.pattern.PatternExtractor">PatternExtractor</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.pattern.PatternExtractor.FilterEverything" href="../index.html#refinery.units.UnitBase.FilterEverything">FilterEverything</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.Requires" href="../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.act" href="../index.html#refinery.units.Unit.act">act</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.codec" href="../index.html#refinery.units.Unit.codec">codec</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.console" href="../index.html#refinery.units.Unit.console">console</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.filter" href="../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.finish" href="../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.handles" href="../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.is_quiet" href="../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.is_reversible" href="../index.html#refinery.units.Unit.is_reversible">is_reversible</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.isatty" href="../index.html#refinery.units.Unit.isatty">isatty</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.labelled" href="../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.leniency" href="../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.log_always" href="../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.log_detach" href="../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.log_fail" href="../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.logger" href="../index.html#refinery.units.Unit.logger">logger</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.matches" href="index.html#refinery.units.pattern.PatternExtractorBase.matches">matches</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.matches_filtered" href="index.html#refinery.units.pattern.PatternExtractorBase.matches_filtered">matches_filtered</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.name" href="../index.html#refinery.units.Unit.name">name</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.optional_dependencies" href="../index.html#refinery.units.Unit.optional_dependencies">optional_dependencies</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.process" href="../index.html#refinery.units.UnitBase.process">process</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.required_dependencies" href="../index.html#refinery.units.Unit.required_dependencies">required_dependencies</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.reset" href="../index.html#refinery.units.Unit.reset">reset</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.pattern.PatternExtractor.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.pattern" href="index.html">refinery.units.pattern</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.pattern.xtp.LetterWeight" href="#refinery.units.pattern.xtp.LetterWeight">LetterWeight</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.pattern.xtp.LetterWeights" href="#refinery.units.pattern.xtp.LetterWeights">LetterWeights</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.pattern.xtp.xtp" href="#refinery.units.pattern.xtp.xtp">xtp</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
