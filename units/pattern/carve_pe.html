<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.units.pattern.carve_pe documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.pattern.carve_pe</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/pattern/carve_pe.py#L1-L89" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from __future__ import annotations

from struct import unpack

from refinery.lib import lief
from refinery.lib.mime import FileMagicInfo as magic
from refinery.lib.types import Param
from refinery.units.formats import Arg, PathExtractorUnit, UnpackResult
from refinery.units.formats.pe import get_pe_size
from refinery.units.formats.pe.pemeta import pemeta


class carve_pe(PathExtractorUnit):
    &#34;&#34;&#34;
    Extracts anything from the input data that looks like a Portable
    Executable (PE) file.
    &#34;&#34;&#34;
    def __init__(
        self, *paths, list=False, join_path=False, drop_path=False, path=b&#39;name&#39;,
        recursive: Param[bool, Arg.Switch(&#39;-r&#39;, help=&#39;Extract PE files that are contained in already extracted PEs.&#39;)] = False,
        keep_root: Param[bool, Arg.Switch(&#39;-k&#39;, help=&#39;If the input chunk is itself a PE, include it as an output chunk.&#39;)] = False,
        memdump: Param[bool, Arg.Switch(&#39;-m&#39;, help=&#39;Use the virtual memory layout of a PE file to calculate its size.&#39;)] = False,
        fileinfo: Param[bool, Arg.Switch(&#39;-f&#39;, help=&#39;Use the PE meta information to deduce a file name meta variable.&#39;)] = False
    ):
        super().__init__(
            *paths,
            list=list,
            join_path=join_path,
            drop_path=drop_path,
            path=path,
            recursive=recursive,
            keep_root=keep_root,
            memdump=memdump,
            fileinfo=fileinfo,
        )

    def unpack(self, data):
        cursor = 0
        mv = memoryview(data)

        while True:
            offset = data.find(B&#39;MZ&#39;, cursor)
            if offset &lt; cursor: break
            cursor = offset + 2
            ntoffset = mv[offset + 0x3C:offset + 0x3E]
            if len(ntoffset) &lt; 2:
                return
            ntoffset, = unpack(&#39;H&#39;, ntoffset)
            if mv[offset + ntoffset:offset + ntoffset + 2] != B&#39;PE&#39;:
                self.log_debug(F&#39;invalid NT header signature for candidate at 0x{offset:08X}&#39;)
                continue
            try:
                pe = lief.load_pe_fast(mv[offset:])
            except Exception as err:
                self.log_debug(F&#39;parsing of PE header at 0x{offset:08X} failed:&#39;, err)
                continue

            pesize = get_pe_size(pe, memdump=self.args.memdump)
            pedata = mv[offset:offset + pesize]
            info = {}
            if self.args.fileinfo:
                pe_meta_parser = pemeta()
                try:
                    info = pe_meta_parser.parse_version(pe) or {}
                except Exception as error:
                    self.log_warn(F&#39;Unable to obtain file information: {error!s}&#39;)
                try:
                    info.update(pe_meta_parser.parse_header(pe) or {})
                except Exception:
                    pass
            try:
                path = info[&#39;OriginalFilename&#39;]
            except KeyError:
                try:
                    path = info[&#39;ExportName&#39;]
                except KeyError:
                    path = F&#39;carve-0x{offset:08X}.{magic(pedata).extension}&#39;

            if offset &gt; 0 or self.args.keep_root:
                yield UnpackResult(path, pedata, offset=offset)
                self.log_info(F&#39;extracted PE file of size 0x{pesize:08X} from 0x{offset:08X}&#39;)
            else:
                self.log_info(F&#39;ignored root file of size 0x{pesize:08X} from 0x{offset:08X}&#39;)
                continue

            if not offset or self.args.recursive:
                cursor += pe.optional_header.sizeof_headers
            else:
                cursor += pesize - 2</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.pattern.carve_pe.carve_pe"><code class="flex name class">
<span>class <span class="ident">carve_pe</span></span>
<span>(</span><span>*paths, list=False, join_path=False, drop_path=False, path=b'name', recursive=False, keep_root=False, memdump=False, fileinfo=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts anything from the input data that looks like a Portable
Executable (PE) file.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/pattern/carve_pe.py#L13-L89" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class carve_pe(PathExtractorUnit):
    &#34;&#34;&#34;
    Extracts anything from the input data that looks like a Portable
    Executable (PE) file.
    &#34;&#34;&#34;
    def __init__(
        self, *paths, list=False, join_path=False, drop_path=False, path=b&#39;name&#39;,
        recursive: Param[bool, Arg.Switch(&#39;-r&#39;, help=&#39;Extract PE files that are contained in already extracted PEs.&#39;)] = False,
        keep_root: Param[bool, Arg.Switch(&#39;-k&#39;, help=&#39;If the input chunk is itself a PE, include it as an output chunk.&#39;)] = False,
        memdump: Param[bool, Arg.Switch(&#39;-m&#39;, help=&#39;Use the virtual memory layout of a PE file to calculate its size.&#39;)] = False,
        fileinfo: Param[bool, Arg.Switch(&#39;-f&#39;, help=&#39;Use the PE meta information to deduce a file name meta variable.&#39;)] = False
    ):
        super().__init__(
            *paths,
            list=list,
            join_path=join_path,
            drop_path=drop_path,
            path=path,
            recursive=recursive,
            keep_root=keep_root,
            memdump=memdump,
            fileinfo=fileinfo,
        )

    def unpack(self, data):
        cursor = 0
        mv = memoryview(data)

        while True:
            offset = data.find(B&#39;MZ&#39;, cursor)
            if offset &lt; cursor: break
            cursor = offset + 2
            ntoffset = mv[offset + 0x3C:offset + 0x3E]
            if len(ntoffset) &lt; 2:
                return
            ntoffset, = unpack(&#39;H&#39;, ntoffset)
            if mv[offset + ntoffset:offset + ntoffset + 2] != B&#39;PE&#39;:
                self.log_debug(F&#39;invalid NT header signature for candidate at 0x{offset:08X}&#39;)
                continue
            try:
                pe = lief.load_pe_fast(mv[offset:])
            except Exception as err:
                self.log_debug(F&#39;parsing of PE header at 0x{offset:08X} failed:&#39;, err)
                continue

            pesize = get_pe_size(pe, memdump=self.args.memdump)
            pedata = mv[offset:offset + pesize]
            info = {}
            if self.args.fileinfo:
                pe_meta_parser = pemeta()
                try:
                    info = pe_meta_parser.parse_version(pe) or {}
                except Exception as error:
                    self.log_warn(F&#39;Unable to obtain file information: {error!s}&#39;)
                try:
                    info.update(pe_meta_parser.parse_header(pe) or {})
                except Exception:
                    pass
            try:
                path = info[&#39;OriginalFilename&#39;]
            except KeyError:
                try:
                    path = info[&#39;ExportName&#39;]
                except KeyError:
                    path = F&#39;carve-0x{offset:08X}.{magic(pedata).extension}&#39;

            if offset &gt; 0 or self.args.keep_root:
                yield UnpackResult(path, pedata, offset=offset)
                self.log_info(F&#39;extracted PE file of size 0x{pesize:08X} from 0x{offset:08X}&#39;)
            else:
                self.log_info(F&#39;ignored root file of size 0x{pesize:08X} from 0x{offset:08X}&#39;)
                continue

            if not offset or self.args.recursive:
                cursor += pe.optional_header.sizeof_headers
            else:
                cursor += pesize - 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.PathExtractorUnit" href="../formats/index.html#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></li>
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></li>
<li><a title="refinery.units.Entry" href="../index.html#refinery.units.Entry">Entry</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.pattern.carve_pe.carve_pe" href="#refinery.units.pattern.carve_pe.carve_pe">carve_pe</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.pattern.carve_pe.carve_pe.required_dependencies"><code class="name">var <span class="ident">required_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.pattern.carve_pe.carve_pe.optional_dependencies"><code class="name">var <span class="ident">optional_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.pattern.carve_pe.carve_pe.console"><code class="name">var <span class="ident">console</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.pattern.carve_pe.carve_pe.reverse"><code class="name">var <span class="ident">reverse</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.pattern.carve_pe.carve_pe.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/pattern/carve_pe.py#L37-L89" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpack(self, data):
    cursor = 0
    mv = memoryview(data)

    while True:
        offset = data.find(B&#39;MZ&#39;, cursor)
        if offset &lt; cursor: break
        cursor = offset + 2
        ntoffset = mv[offset + 0x3C:offset + 0x3E]
        if len(ntoffset) &lt; 2:
            return
        ntoffset, = unpack(&#39;H&#39;, ntoffset)
        if mv[offset + ntoffset:offset + ntoffset + 2] != B&#39;PE&#39;:
            self.log_debug(F&#39;invalid NT header signature for candidate at 0x{offset:08X}&#39;)
            continue
        try:
            pe = lief.load_pe_fast(mv[offset:])
        except Exception as err:
            self.log_debug(F&#39;parsing of PE header at 0x{offset:08X} failed:&#39;, err)
            continue

        pesize = get_pe_size(pe, memdump=self.args.memdump)
        pedata = mv[offset:offset + pesize]
        info = {}
        if self.args.fileinfo:
            pe_meta_parser = pemeta()
            try:
                info = pe_meta_parser.parse_version(pe) or {}
            except Exception as error:
                self.log_warn(F&#39;Unable to obtain file information: {error!s}&#39;)
            try:
                info.update(pe_meta_parser.parse_header(pe) or {})
            except Exception:
                pass
        try:
            path = info[&#39;OriginalFilename&#39;]
        except KeyError:
            try:
                path = info[&#39;ExportName&#39;]
            except KeyError:
                path = F&#39;carve-0x{offset:08X}.{magic(pedata).extension}&#39;

        if offset &gt; 0 or self.args.keep_root:
            yield UnpackResult(path, pedata, offset=offset)
            self.log_info(F&#39;extracted PE file of size 0x{pesize:08X} from 0x{offset:08X}&#39;)
        else:
            self.log_info(F&#39;ignored root file of size 0x{pesize:08X} from 0x{offset:08X}&#39;)
            continue

        if not offset or self.args.recursive:
            cursor += pe.optional_header.sizeof_headers
        else:
            cursor += pesize - 2</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.formats.PathExtractorUnit" href="../formats/index.html#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.formats.PathExtractorUnit.CustomPathSeparator" href="../formats/index.html#refinery.units.formats.PathExtractorUnit.CustomPathSeparator">CustomPathSeparator</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.Requires" href="../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.filter" href="../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.finish" href="../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.handles" href="../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.is_quiet" href="../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.labelled" href="../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.leniency" href="../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_always" href="../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_detach" href="../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_fail" href="../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.process" href="../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.pattern" href="index.html">refinery.units.pattern</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.pattern.carve_pe.carve_pe" href="#refinery.units.pattern.carve_pe.carve_pe">carve_pe</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.pattern.carve_pe.carve_pe.unpack" href="#refinery.units.pattern.carve_pe.carve_pe.unpack">unpack</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
