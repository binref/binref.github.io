<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.units.formats.exe.vstack documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.formats.exe.vstack</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L1-L596" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from __future__ import annotations

from refinery.lib.types import Param

if True:
    import colorama
    colorama.init()
    FG = colorama.Fore
    RS = colorama.Style.RESET_ALL

import functools
import re

from collections import defaultdict
from dataclasses import dataclass, field
from typing import Callable, Type, TypeVar, cast

from refinery.lib.emulator import (
    EmulationError,
    Emulator,
    Hook,
    MemAccess,
    Register,
)
from refinery.lib.executable import Arch, Range
from refinery.lib.intervals import MemoryIntervalUnion
from refinery.lib.meta import metavars
from refinery.lib.structures import StructReader
from refinery.lib.tools import exception_to_string
from refinery.lib.types import INF, bounds, isbuffer
from refinery.units import Arg, Chunk
from refinery.units.formats.exe import EmulatingUnit, Engine


@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool


@dataclass
class EmuState:
    cfg: EmuConfig
    expected_address: int
    address_width: int
    wait: int
    waiting: int = 0
    callstack: list[int] = field(default_factory=list)
    retaddr: int | None = None
    stop: int | None = None
    previous_address: int = 0
    callstack_ceiling: int = 0
    invalid_instructions: int = 0
    synthesized: dict[bytes, str] = field(default_factory=dict)
    ticks: int | INF = field(default_factory=lambda: INF())
    visits: dict[int, int] = field(default_factory=lambda: defaultdict(int))
    memory: MemoryIntervalUnion = field(default_factory=MemoryIntervalUnion)
    init_registers: list[Register] = field(default_factory=list)
    last_read: int | None = None
    last_api: int | None = None

    def log(self, msg: str) -&gt; str:
        _width = len(str(w)) if (w := self.cfg.wait.start) else 8
        _depth = len(self.callstack)
        return F&#39;[wait={self.waiting:0{_width}d}] [depth={_depth}] {self.fmt(self.previous_address)}: {msg}&#39;

    def contains(self, address: int):
        return self.memory.overlaps(address)

    def write(self, address: int, data: bytes):
        self.memory.addi(address, data)

    def fmt(self, address: int) -&gt; str:
        return F&#39;0x{address:0{self.address_width}X}&#39;


FN = TypeVar(&#39;FN&#39;, bound=Callable)
ET = TypeVar(&#39;ET&#39;, bound=Type[Emulator])


def EmuFactory(base: ET) -&gt; ET:

    def inject_state_argument(pfn: FN) -&gt; FN:
        @functools.wraps(pfn)
        def wrapped(self: VStackEmulator, *args, **kwargs):
            if &#39;state&#39; in kwargs:
                kwargs.update(state=self.state)
            else:
                *head, state = args
                if state is None:
                    args = *head, self.state
            try:
                return pfn(self, *args, **kwargs)
            except KeyboardInterrupt:
                self.halt()
                return False
        return cast(FN, wrapped)

    class VStackEmulator(base):

        state: EmuState

        def stackrange(self):
            return Range(self.stack_base, self.stack_base + self.stack_size)

        def disassemble(self, address: int):
            try:
                return self.disassemble_instruction(address)
            except Exception:
                return None

        def hook_api_call(self, emu, name: str, cb=None, args: tuple[int, ...] = ()):
            def _repr(x):
                if not isinstance(x, int):
                    return repr(x)
                try:
                    data = self.mem_read(x, 0x200)
                except Exception:
                    data = None
                else:
                    read = StructReader(data)
                    try:
                        utf16 = read.read_w_string(&#39;utf-16le&#39;)
                    except UnicodeDecodeError:
                        utf16 = &#39;&#39;
                    try:
                        read.seek(0)
                        ascii = read.read_c_string(&#39;latin1&#39;)
                    except UnicodeDecodeError:
                        ascii = &#39;&#39;
                    string = utf16
                    if not symbol.endswith(&#39;W&#39;) and len(ascii) &gt; 1 and ascii.isprintable():
                        string = ascii
                    if len(string) in range(5, 80):
                        return repr(string)
                return F&#39;0x{x:X}&#39;

            self.state.last_api = self.ip
            module, _, symbol = name.rpartition(&#39;.&#39;)
            symbol = symbol.lstrip(&#39;_&#39;)
            if module:
                module, _, _ = module.lower().partition(&#39;.&#39;)
                name = F&#39;{module}::{symbol}&#39;
            logged_args = [_repr(a) for a in args]
            if symbol == &#39;connect&#39; and args:
                sockaddr = StructReader(self.mem_read(args[1], 8))
                if sockaddr.u16() in (0x02, 0x0200):
                    sockaddr.bigendian = True
                    port = sockaddr.u16()
                    host = &#39;.&#39;.join(map(str, sockaddr.read(4)))
                    self.state.synthesized[F&#39;{host}:{port}&#39;.encode(vstack.codec)] = name
                    logged_args[1] = F&#39;sockaddr_in{{AF_INET, {host!r}, {port}}}&#39;
            if self.state.cfg.show_apis:
                for k, arg in enumerate(logged_args):
                    if arg.startswith(&#39;&#34;&#39;) or arg.startswith(&#34;&#39;&#34;):
                        logged_args[k] = F&#39;{FG.LIGHTRED_EX}{arg}{RS}&#39;
                vstack.log_always(
                    F&#39;{FG.LIGHTCYAN_EX}{name}{RS}({&#34;, &#34;.join(logged_args)}){RS}&#39;)
            if cb is None:
                retval = True
            else:
                try:
                    retval = cb(args)
                except Exception as e:
                    if self.state.cfg.skip_calls &gt; 1:
                        retval = self.malloc(self.alloc_size)
                        what = F&#39;empty buffer at 0x{retval:X}&#39;
                    else:
                        retval = 0
                        what = &#39;0&#39;
                    vstack.log_debug(F&#39;exception of type {e.__class__.__name__} while emulating api routine, returning {what}&#39;)
                    self.ip = self.pop()
            return retval

        @inject_state_argument
        def hook_mem_read(self, emu, access: MemAccess, address: int, size: int, value: int, state: EmuState):
            mask = (1 &lt;&lt; (size * 8)) - 1
            state.last_read = value &amp; mask

        @inject_state_argument
        def hook_mem_write(self, emu, access: MemAccess, address: int, size: int, value: int, state: EmuState):
            mask = (1 &lt;&lt; (size * 8)) - 1
            unsigned_value = value &amp; mask

            if unsigned_value == state.expected_address:
                callstack = state.callstack
                state.retaddr = unsigned_value
                if not state.cfg.skip_calls:
                    if not callstack:
                        state.callstack_ceiling = self.sp
                    callstack.append(unsigned_value)
                return
            else:
                state.retaddr = None

            skipped = False

            if (
                not state.cfg.log_stack_cookies
                and self.sp ^ unsigned_value == state.last_read
            ):
                skipped = &#39;no -E and stack cookie written&#39;
            elif size not in bounds[state.cfg.write_range]:
                skipped = &#39;size excluded&#39;
            elif (
                state.callstack_ceiling &gt; 0
                and not state.cfg.log_writes_in_calls
                and address in range(state.callstack_ceiling - 0x200, state.callstack_ceiling)
            ):
                skipped = &#39;no -W and inside call&#39;
            elif not state.cfg.log_stack_addresses and unsigned_value in self.stackrange():
                skipped = &#39;no -X and stack address written&#39;
            elif not state.cfg.log_other_addresses and not self.exe.blob:
                for s in self.exe.sections():
                    if address in s.virtual:
                        skipped = F&#39;no -Y and write to section {s.name}&#39;
                        break

            if (
                not skipped
                and unsigned_value == 0
                and state.cfg.log_zero_overwrites is False
                and state.memory.overlaps(address, size)
            ):
                skipped = &#39;no -Z and zero overwrite detected&#39;

            if not skipped:
                state.write(address, unsigned_value.to_bytes(size, &#39;little&#39;))
                wait_config = state.cfg.wait
                if (wait := state.wait) &gt; (stop := wait_config.stop):
                    state.wait = max(stop, wait - wait_config.step)
                    vstack.log_debug(F&#39;adjusting wait to {state.wait}&#39;)
                state.waiting = 0

            if state.cfg.show_memory:
                data = unsigned_value.to_bytes(size, self.exe.byte_order().value)
                ph = self.exe.pointer_size // 4
                pt = self.exe.pointer_size // 8
                h = data.hex().upper()
                t = re.sub(&#39;[^!-~]&#39;, &#39;.&#39;, data.decode(&#39;latin1&#39;))
                msg = state.log(F&#39;{state.fmt(address)} &lt;- {h:_&lt;{ph}} {t:_&lt;{pt}}&#39;)
                if skipped:
                    msg = F&#39;{msg} (ignored: {skipped})&#39;
                    vstack.log_debug(msg)
                else:
                    vstack.log_always(msg)

        @inject_state_argument
        def hook_mem_error(self, _, access: MemAccess, address: int, size: int, value: int, state: EmuState) -&gt; bool:
            state = self.state
            if state is None:
                return True
            if address == state.last_api:
                state.last_api = None
                return True
            if access.Execute and access.Unmapped:
                vstack.log_info(state.log(&#39;attempt to execute unmapped memory&#39;))
                self.halt()
                return False
            if address &gt;= (1 &lt;&lt; self.exe.pointer_size) - 1:
                vstack.log_info(state.log(&#39;attempt to execute beyond address space&#39;))
                self.halt()
                return False
            msg = F&#39;{state.fmt(address)}:{size:02X} memory error&#39;
            if self.is_mapped(address, size):
                vstack.log_info(state.log(F&#39;{msg}; fatal, this area was already mapped&#39;))
            else:
                try:
                    self.map(self.align(address, down=True), self.alloc_size)
                except Exception as error:
                    vstack.log_info(state.log(F&#39;{msg}; fatal, {exception_to_string(error)}&#39;))
                else:
                    vstack.log_debug(state.log(F&#39;{msg}; recovery, space mapped for access {access!r}&#39;))
            return True

        def hook_code_error(self, emu, state: EmuState):
            vstack.log_debug(&#39;aborting emulation; instruction error&#39;)
            self.halt()
            return False

        @inject_state_argument
        def hook_code_execute(self, emu, address: int, size: int, state: EmuState):

            if _init := state.init_registers:
                tos = self.sp
                for reg in _init:
                    self.set_register(reg, tos)
                _init.clear()

            if (max_visits := state.cfg.max_visits) &gt; 0:
                state.visits[address] += 1
                if state.visits[address] &gt; max_visits:
                    vstack.log_info(
                        F&#39;aborting emulation: 0x{address:0{self.exe.pointer_size // 8}X}&#39;
                        F&#39; was visited more than {state.cfg.max_visits} times.&#39;)
                    self.halt()
                    return False

            if address == state.stop or (ticks := state.ticks - 1) &lt;= 0:
                self.halt()
                return False
            else:
                state.ticks = ticks

            waiting = state.waiting
            callstack = state.callstack
            depth = len(callstack)
            state.previous_address = address
            retaddr = state.retaddr
            state.retaddr = None

            if address != state.expected_address:
                if retaddr is not None and state.cfg.skip_calls:
                    if state.cfg.skip_calls &gt; 1:
                        self.rv = self.malloc(state.cfg.block_size)
                    self.ip = _ip = self.pop()
                    if _ip != retaddr:
                        raise RuntimeError(
                            &#39;Trying to return from call: top of stack was not the execpted return address.&#39;)
                    return
                if depth and address == callstack[-1]:
                    depth -= 1
                    state.callstack.pop()
                    if depth == 0:
                        state.callstack_ceiling = 0
                state.expected_address = address
            elif retaddr is not None and not state.cfg.skip_calls:
                # The present address was moved to the stack but we did not branch.
                # This is not quite accurate, of course: We could be calling the
                # next instruction. However, that sort of code is usually not really
                # a function call anyway, but rather a way to get the IP.
                callstack.pop()

            if waiting &gt; state.wait &gt; 0:
                self.halt()
                return False
            if not depth or not state.cfg.wait_calls:
                state.waiting = waiting + 1
            state.expected_address += size

            instruction = self.disassemble(address)
            if instruction:
                state.invalid_instructions = 0
                if state.cfg.show_code:
                    vstack.log_always(state.log(F&#39;{instruction.mnemonic} {instruction.op_str}&#39;))
            else:
                iv = state.invalid_instructions + 1
                state.invalid_instructions += iv
                vstack.log_debug(state.log(&#39;unrecognized instruction&#39;))
                if iv &gt; 2:
                    self.halt()

    return cast(ET, VStackEmulator)


class vstack(EmulatingUnit):
    &#34;&#34;&#34;
    The unit emulates instructions at a given address in the input executable (PE/ELF/MachO) and
    extracts data patches that are written to memory during emulation. The unit can also be used
    to emulate shellcode blobs, in which case it defaults to emulating 32bit x86 instructions.

    Emulation is halted as soon as a certain number of instructions have not performed any memory
    writes, or when an error occurs. By default, most registers are set to the current location in
    the emulated stack. If you want to initialize some of them differently, the `-r` switch maes
    the unit initialize register values from meta variables:

        emit shellcode [| put eax 0x2000 | vstack -r ]

    In this pipeline, the eax register is set to `0x2000` before emulation begins.
    &#34;&#34;&#34;
    def __init__(
        self,
        *address: Param[str, Arg.String(metavar=&#39;a[:end|::size]&#39;,
            help=&#39;Specify a symbol name or the (virtual) addresses of what to emulate; optionally specify a stop address or a length.&#39;)],
        base=None, arch=Arch.X32, engine=Engine.unicorn, se=False, ic=False, uc=False,
        registers: Param[bool, Arg.Switch(&#39;-r&#39;, help=(
            &#39;Consume register initialization values from the chunk\&#39;s metadata. If the value is a byte string, &#39;
            &#39;the data will be mapped.&#39;))] = False,
        timeout: Param[int, Arg.Number(&#39;-t&#39;, help=&#39;Optionally stop emulating after a given number of instructions.&#39;)] = 0,
        patch_range: Param[slice, Arg.Bounds(&#39;-p&#39;, metavar=&#39;MIN:MAX&#39;,
            help=&#39;Extract only patches that are in the given range, default is {default}.&#39;)] = slice(5, None),
        write_range: Param[slice, Arg.Bounds(&#39;-n&#39;, metavar=&#39;MIN:MAX&#39;,
            help=&#39;Log only writes whose size is in the given range, default is {default}.&#39;)] = slice(1, None),
        wait: Param[slice, Arg.Bounds(&#39;-w&#39;, metavar=&#39;A[:B[:D]]&#39;, intok=True, help=(
            &#39;Emulation halts when X instructions ran without tracking a memory write. &#39;
            &#39;X starts at A and is decreased by D after each write until it reaches B and then remains at B. &#39;
            &#39;Specifying A is equivalent to A:A:1, and A:B is equivalent to A:B:1. B may not be greater than A. &#39;
            &#39;The default is {default}.&#39;))] = slice(80, 20, 5),
        wait_calls: Param[bool, Arg.Switch(&#39;-c&#39;, group=&#39;CALL&#39;,
            help=&#39;Wait indefinitely when inside a function call.&#39;)] = False,
        skip_calls: Param[int, Arg.Counts(&#39;-C&#39;, group=&#39;CALL&#39;,
            help=&#39;Skip function calls entirely. Use twice to treat each call as allocating memory.&#39;)] = 0,
        stack_size: Param[int, Arg.Number(&#39;-S&#39;, help=&#39;Optionally specify the stack size. The default is 0x{default:X}.&#39;)] = 0x10000,
        stack_push: Param[tuple[str] | None, Arg(&#39;-u&#39;, action=&#39;append&#39;, metavar=&#39;REG&#39;,
            help=&#39;Push the value of a register to the stack before beginning emulation; implies -r.&#39;)] = None,
        show_apis: Param[bool, Arg.Switch(&#39;-A&#39;, help=&#39;Show API calls in the debug log.&#39;)] = False,
        show_code: Param[bool, Arg.Switch(&#39;-I&#39;, help=&#39;Show all executed instructions in the debug log.&#39;)] = False,
        show_memory: Param[bool, Arg.Switch(&#39;-M&#39;, help=&#39;Show all memory writes in the debug log.&#39;)] = False,
        block_size: Param[int, Arg.Number(&#39;-B&#39;, help=&#39;Standard memory block size for the emulator, 0x{default:X} by default.&#39;)] = 0x1000,
        max_visits: Param[int, Arg.Number(&#39;-V&#39;, help=&#39;Maximum number of times a code address is visited. Default is {default}.&#39;)] = 0x10000,
        log_writes_in_calls: Param[bool, Arg.Switch(&#39;-W&#39;, help=&#39;Log writes of values that occur in functions calls.&#39;)] = False,
        log_stack_addresses: Param[bool, Arg.Switch(&#39;-X&#39;, help=&#39;Log writes of values that are stack addresses.&#39;)] = False,
        log_other_addresses: Param[bool, Arg.Switch(&#39;-Y&#39;, help=&#39;Log writes of values that are addresses to mapped segments.&#39;)] = False,
        log_zero_overwrites: Param[bool, Arg.Switch(&#39;-Z&#39;, help=&#39;Log writes of zeros to memory that contained nonzero values.&#39;)] = False,
        log_stack_cookies: Param[bool, Arg.Switch(&#39;-E&#39;, help=&#39;Log writes that look like stack cookies.&#39;)] = False,
    ):
        super().__init__(
            base=base,
            arch=arch,
            engine=engine,
            se=se,
            ic=ic,
            uc=uc,
            address=address,
            registers=registers,
            timeout=timeout,
            patch_range=patch_range,
            write_range=write_range,
            wait=wait,
            stack_size=stack_size,
            stack_push=stack_push,
            wait_calls=wait_calls,
            skip_calls=skip_calls,
            block_size=block_size,
            max_visits=max_visits,
            show_apis=show_apis,
            show_code=show_code,
            show_memory=show_memory,
            log_writes_in_calls=log_writes_in_calls,
            log_stack_addresses=log_stack_addresses,
            log_other_addresses=log_other_addresses,
            log_zero_overwrites=log_zero_overwrites,
            log_stack_cookies=log_stack_cookies
        )

    def process(self, data: Chunk):
        meta = metavars(data)
        args = self.args

        engine = self._engine()
        flags = Hook.Default | Hook.ApiCall
        self.log_debug(F&#39;attempting to use {engine.name}&#39;)

        Emu = EmuFactory(engine.cls)

        emu = Emu(
            data,
            args.base,
            args.arch,
            flags,
            args.block_size,
            args.stack_size,
        )

        wait: int | slice[int, int, int] = args.wait
        if isinstance(wait, int):
            wait = slice(wait, wait, 1)
        elif wait.start &lt; wait.stop:
            raise ValueError(&#39;invalid wait format&#39;)

        self.log_info(F&#39;setting wait to: {wait.start}:{wait.stop}:{wait.step}&#39;)

        cfg = EmuConfig(
            args.wait_calls,
            args.skip_calls,
            args.write_range,
            wait,
            args.block_size,
            args.stack_size,
            args.max_visits,
            args.log_stack_cookies,
            args.log_writes_in_calls,
            args.log_stack_addresses,
            args.log_other_addresses,
            args.log_zero_overwrites,
            args.show_apis,
            args.show_code,
            args.show_memory,
        )

        register_values: dict[Register, int | str | bytes] = {}
        emu.reset(None)

        if args.registers or args.stack_push:
            for var, value in list(meta.items()):
                try:
                    register = emu.lookup_register(var)
                except LookupError:
                    continue
                meta.discard(var)
                register_values[register] = value

        if not (addresses := [
            self._parse_address(data, emu.exe, a) for a in args.address
        ]):
            for symbol in emu.exe.symbols():
                if symbol.name is None:
                    addresses.append(slice(symbol.address, None))
                    break

        for cursor in addresses:
            state = EmuState(
                cfg,
                cursor.start,
                emu.exe.pointer_size // 4,
                wait=wait.start,
                stop=cursor.stop,
            )

            emu.reset(state)

            for reg in emu.general_purpose_registers():
                emu.set_register(reg, 0)

            for reg in register_values:
                # check if we are tainting a general purpose register
                emu.set_register(reg, 1)

            for reg in emu.general_purpose_registers():
                if emu.get_register(reg) == 0:
                    state.init_registers.append(reg)

            for reg, value in register_values.items():
                if isinstance(value, int):
                    self.log_info(F&#39;setting {reg.name} to integer value 0x{value:X}&#39;)
                    emu.set_register(reg, value)
                    continue
                if isinstance(value, str):
                    value = value.encode()
                if isbuffer(value):
                    start = emu.malloc(len(value))
                    emu.mem_write(start, bytes(value))
                    emu.set_register(reg, start)
                    self.log_info(F&#39;setting {reg.name} to mapped buffer of size 0x{len(value):X}&#39;)
                    continue
                _tn = value.__class__.__name__
                self.log_warn(F&#39;canot interpret value of type {_tn} for register {reg.name}&#39;)

            if push := args.stack_push:
                for reg in push:
                    emu.push_register(reg)

            timeout = args.timeout
            if timeout:
                self.log_info(F&#39;setting timeout of {timeout} steps&#39;)
                state.ticks = timeout

            try:
                emu.emulate(
                    emu.base_exe_to_emu(cursor.start),
                    emu.base_exe_to_emu(cursor.stop),
                )
            except EmulationError as e:
                self.log_info(F&#39;emulation halted with error: {e!s}&#39;)

            for patch, api in state.synthesized.items():
                chunk = self.labelled(patch, src=api)
                yield chunk

            valid = bounds[args.patch_range]
            for base, patch in state.memory:
                if len(patch) not in valid or not any(patch):
                    continue
                self.log_info(F&#39;memory patch at {state.fmt(base)} of size {len(patch)}&#39;)
                chunk = self.labelled(patch, src=base)
                yield chunk</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.units.formats.exe.vstack.EmuFactory"><code class="name flex">
<span>def <span class="ident">EmuFactory</span></span>(<span>base)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L111-L383" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def EmuFactory(base: ET) -&gt; ET:

    def inject_state_argument(pfn: FN) -&gt; FN:
        @functools.wraps(pfn)
        def wrapped(self: VStackEmulator, *args, **kwargs):
            if &#39;state&#39; in kwargs:
                kwargs.update(state=self.state)
            else:
                *head, state = args
                if state is None:
                    args = *head, self.state
            try:
                return pfn(self, *args, **kwargs)
            except KeyboardInterrupt:
                self.halt()
                return False
        return cast(FN, wrapped)

    class VStackEmulator(base):

        state: EmuState

        def stackrange(self):
            return Range(self.stack_base, self.stack_base + self.stack_size)

        def disassemble(self, address: int):
            try:
                return self.disassemble_instruction(address)
            except Exception:
                return None

        def hook_api_call(self, emu, name: str, cb=None, args: tuple[int, ...] = ()):
            def _repr(x):
                if not isinstance(x, int):
                    return repr(x)
                try:
                    data = self.mem_read(x, 0x200)
                except Exception:
                    data = None
                else:
                    read = StructReader(data)
                    try:
                        utf16 = read.read_w_string(&#39;utf-16le&#39;)
                    except UnicodeDecodeError:
                        utf16 = &#39;&#39;
                    try:
                        read.seek(0)
                        ascii = read.read_c_string(&#39;latin1&#39;)
                    except UnicodeDecodeError:
                        ascii = &#39;&#39;
                    string = utf16
                    if not symbol.endswith(&#39;W&#39;) and len(ascii) &gt; 1 and ascii.isprintable():
                        string = ascii
                    if len(string) in range(5, 80):
                        return repr(string)
                return F&#39;0x{x:X}&#39;

            self.state.last_api = self.ip
            module, _, symbol = name.rpartition(&#39;.&#39;)
            symbol = symbol.lstrip(&#39;_&#39;)
            if module:
                module, _, _ = module.lower().partition(&#39;.&#39;)
                name = F&#39;{module}::{symbol}&#39;
            logged_args = [_repr(a) for a in args]
            if symbol == &#39;connect&#39; and args:
                sockaddr = StructReader(self.mem_read(args[1], 8))
                if sockaddr.u16() in (0x02, 0x0200):
                    sockaddr.bigendian = True
                    port = sockaddr.u16()
                    host = &#39;.&#39;.join(map(str, sockaddr.read(4)))
                    self.state.synthesized[F&#39;{host}:{port}&#39;.encode(vstack.codec)] = name
                    logged_args[1] = F&#39;sockaddr_in{{AF_INET, {host!r}, {port}}}&#39;
            if self.state.cfg.show_apis:
                for k, arg in enumerate(logged_args):
                    if arg.startswith(&#39;&#34;&#39;) or arg.startswith(&#34;&#39;&#34;):
                        logged_args[k] = F&#39;{FG.LIGHTRED_EX}{arg}{RS}&#39;
                vstack.log_always(
                    F&#39;{FG.LIGHTCYAN_EX}{name}{RS}({&#34;, &#34;.join(logged_args)}){RS}&#39;)
            if cb is None:
                retval = True
            else:
                try:
                    retval = cb(args)
                except Exception as e:
                    if self.state.cfg.skip_calls &gt; 1:
                        retval = self.malloc(self.alloc_size)
                        what = F&#39;empty buffer at 0x{retval:X}&#39;
                    else:
                        retval = 0
                        what = &#39;0&#39;
                    vstack.log_debug(F&#39;exception of type {e.__class__.__name__} while emulating api routine, returning {what}&#39;)
                    self.ip = self.pop()
            return retval

        @inject_state_argument
        def hook_mem_read(self, emu, access: MemAccess, address: int, size: int, value: int, state: EmuState):
            mask = (1 &lt;&lt; (size * 8)) - 1
            state.last_read = value &amp; mask

        @inject_state_argument
        def hook_mem_write(self, emu, access: MemAccess, address: int, size: int, value: int, state: EmuState):
            mask = (1 &lt;&lt; (size * 8)) - 1
            unsigned_value = value &amp; mask

            if unsigned_value == state.expected_address:
                callstack = state.callstack
                state.retaddr = unsigned_value
                if not state.cfg.skip_calls:
                    if not callstack:
                        state.callstack_ceiling = self.sp
                    callstack.append(unsigned_value)
                return
            else:
                state.retaddr = None

            skipped = False

            if (
                not state.cfg.log_stack_cookies
                and self.sp ^ unsigned_value == state.last_read
            ):
                skipped = &#39;no -E and stack cookie written&#39;
            elif size not in bounds[state.cfg.write_range]:
                skipped = &#39;size excluded&#39;
            elif (
                state.callstack_ceiling &gt; 0
                and not state.cfg.log_writes_in_calls
                and address in range(state.callstack_ceiling - 0x200, state.callstack_ceiling)
            ):
                skipped = &#39;no -W and inside call&#39;
            elif not state.cfg.log_stack_addresses and unsigned_value in self.stackrange():
                skipped = &#39;no -X and stack address written&#39;
            elif not state.cfg.log_other_addresses and not self.exe.blob:
                for s in self.exe.sections():
                    if address in s.virtual:
                        skipped = F&#39;no -Y and write to section {s.name}&#39;
                        break

            if (
                not skipped
                and unsigned_value == 0
                and state.cfg.log_zero_overwrites is False
                and state.memory.overlaps(address, size)
            ):
                skipped = &#39;no -Z and zero overwrite detected&#39;

            if not skipped:
                state.write(address, unsigned_value.to_bytes(size, &#39;little&#39;))
                wait_config = state.cfg.wait
                if (wait := state.wait) &gt; (stop := wait_config.stop):
                    state.wait = max(stop, wait - wait_config.step)
                    vstack.log_debug(F&#39;adjusting wait to {state.wait}&#39;)
                state.waiting = 0

            if state.cfg.show_memory:
                data = unsigned_value.to_bytes(size, self.exe.byte_order().value)
                ph = self.exe.pointer_size // 4
                pt = self.exe.pointer_size // 8
                h = data.hex().upper()
                t = re.sub(&#39;[^!-~]&#39;, &#39;.&#39;, data.decode(&#39;latin1&#39;))
                msg = state.log(F&#39;{state.fmt(address)} &lt;- {h:_&lt;{ph}} {t:_&lt;{pt}}&#39;)
                if skipped:
                    msg = F&#39;{msg} (ignored: {skipped})&#39;
                    vstack.log_debug(msg)
                else:
                    vstack.log_always(msg)

        @inject_state_argument
        def hook_mem_error(self, _, access: MemAccess, address: int, size: int, value: int, state: EmuState) -&gt; bool:
            state = self.state
            if state is None:
                return True
            if address == state.last_api:
                state.last_api = None
                return True
            if access.Execute and access.Unmapped:
                vstack.log_info(state.log(&#39;attempt to execute unmapped memory&#39;))
                self.halt()
                return False
            if address &gt;= (1 &lt;&lt; self.exe.pointer_size) - 1:
                vstack.log_info(state.log(&#39;attempt to execute beyond address space&#39;))
                self.halt()
                return False
            msg = F&#39;{state.fmt(address)}:{size:02X} memory error&#39;
            if self.is_mapped(address, size):
                vstack.log_info(state.log(F&#39;{msg}; fatal, this area was already mapped&#39;))
            else:
                try:
                    self.map(self.align(address, down=True), self.alloc_size)
                except Exception as error:
                    vstack.log_info(state.log(F&#39;{msg}; fatal, {exception_to_string(error)}&#39;))
                else:
                    vstack.log_debug(state.log(F&#39;{msg}; recovery, space mapped for access {access!r}&#39;))
            return True

        def hook_code_error(self, emu, state: EmuState):
            vstack.log_debug(&#39;aborting emulation; instruction error&#39;)
            self.halt()
            return False

        @inject_state_argument
        def hook_code_execute(self, emu, address: int, size: int, state: EmuState):

            if _init := state.init_registers:
                tos = self.sp
                for reg in _init:
                    self.set_register(reg, tos)
                _init.clear()

            if (max_visits := state.cfg.max_visits) &gt; 0:
                state.visits[address] += 1
                if state.visits[address] &gt; max_visits:
                    vstack.log_info(
                        F&#39;aborting emulation: 0x{address:0{self.exe.pointer_size // 8}X}&#39;
                        F&#39; was visited more than {state.cfg.max_visits} times.&#39;)
                    self.halt()
                    return False

            if address == state.stop or (ticks := state.ticks - 1) &lt;= 0:
                self.halt()
                return False
            else:
                state.ticks = ticks

            waiting = state.waiting
            callstack = state.callstack
            depth = len(callstack)
            state.previous_address = address
            retaddr = state.retaddr
            state.retaddr = None

            if address != state.expected_address:
                if retaddr is not None and state.cfg.skip_calls:
                    if state.cfg.skip_calls &gt; 1:
                        self.rv = self.malloc(state.cfg.block_size)
                    self.ip = _ip = self.pop()
                    if _ip != retaddr:
                        raise RuntimeError(
                            &#39;Trying to return from call: top of stack was not the execpted return address.&#39;)
                    return
                if depth and address == callstack[-1]:
                    depth -= 1
                    state.callstack.pop()
                    if depth == 0:
                        state.callstack_ceiling = 0
                state.expected_address = address
            elif retaddr is not None and not state.cfg.skip_calls:
                # The present address was moved to the stack but we did not branch.
                # This is not quite accurate, of course: We could be calling the
                # next instruction. However, that sort of code is usually not really
                # a function call anyway, but rather a way to get the IP.
                callstack.pop()

            if waiting &gt; state.wait &gt; 0:
                self.halt()
                return False
            if not depth or not state.cfg.wait_calls:
                state.waiting = waiting + 1
            state.expected_address += size

            instruction = self.disassemble(address)
            if instruction:
                state.invalid_instructions = 0
                if state.cfg.show_code:
                    vstack.log_always(state.log(F&#39;{instruction.mnemonic} {instruction.op_str}&#39;))
            else:
                iv = state.invalid_instructions + 1
                state.invalid_instructions += iv
                vstack.log_debug(state.log(&#39;unrecognized instruction&#39;))
                if iv &gt; 2:
                    self.halt()

    return cast(ET, VStackEmulator)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.formats.exe.vstack.EmuConfig"><code class="flex name class">
<span>class <span class="ident">EmuConfig</span></span>
<span>(</span><span>wait_calls, skip_calls, write_range, wait, block_size, stack_size, max_visits, log_stack_cookies, log_writes_in_calls, log_stack_addresses, log_other_addresses, log_zero_overwrites, show_apis, show_code, show_memory)</span>
</code></dt>
<dd>
<section class="desc"><p>EmuConfig(wait_calls: 'bool', skip_calls: 'bool', write_range: 'slice', wait: 'slice[int, int, int]', block_size: 'int', stack_size: 'int', max_visits: 'int', log_stack_cookies: 'bool', log_writes_in_calls: 'bool', log_stack_addresses: 'bool', log_other_addresses: 'bool', log_zero_overwrites: 'bool', show_apis: 'bool', show_code: 'bool', show_memory: 'bool')</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.block_size"><code class="name">var <span class="ident">block_size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.log_other_addresses"><code class="name">var <span class="ident">log_other_addresses</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.log_stack_addresses"><code class="name">var <span class="ident">log_stack_addresses</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.log_stack_cookies"><code class="name">var <span class="ident">log_stack_cookies</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.log_writes_in_calls"><code class="name">var <span class="ident">log_writes_in_calls</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.log_zero_overwrites"><code class="name">var <span class="ident">log_zero_overwrites</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.max_visits"><code class="name">var <span class="ident">max_visits</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.show_apis"><code class="name">var <span class="ident">show_apis</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.show_code"><code class="name">var <span class="ident">show_code</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.show_memory"><code class="name">var <span class="ident">show_memory</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.skip_calls"><code class="name">var <span class="ident">skip_calls</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.stack_size"><code class="name">var <span class="ident">stack_size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.wait"><code class="name">var <span class="ident">wait</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.wait_calls"><code class="name">var <span class="ident">wait_calls</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuConfig.write_range"><code class="name">var <span class="ident">write_range</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L35-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuConfig:
    __slots__ = (
        &#39;wait_calls&#39;,
        &#39;skip_calls&#39;,
        &#39;write_range&#39;,
        &#39;wait&#39;,
        &#39;block_size&#39;,
        &#39;stack_size&#39;,
        &#39;max_visits&#39;,
        &#39;log_stack_cookies&#39;,
        &#39;log_writes_in_calls&#39;,
        &#39;log_stack_addresses&#39;,
        &#39;log_other_addresses&#39;,
        &#39;log_zero_overwrites&#39;,
        &#39;show_apis&#39;,
        &#39;show_code&#39;,
        &#39;show_memory&#39;,
    )
    wait_calls: bool
    skip_calls: bool
    write_range: slice
    wait: slice[int, int, int]
    block_size: int
    stack_size: int
    max_visits: int
    log_stack_cookies: bool
    log_writes_in_calls: bool
    log_stack_addresses: bool
    log_other_addresses: bool
    log_zero_overwrites: bool
    show_apis: bool
    show_code: bool
    show_memory: bool</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState"><code class="flex name class">
<span>class <span class="ident">EmuState</span></span>
<span>(</span><span>cfg, expected_address, address_width, wait, waiting=0, callstack=&lt;factory&gt;, retaddr=None, stop=None, previous_address=0, callstack_ceiling=0, invalid_instructions=0, synthesized=&lt;factory&gt;, ticks=&lt;factory&gt;, visits=&lt;factory&gt;, memory=&lt;factory&gt;, init_registers=&lt;factory&gt;, last_read=None, last_api=None)</span>
</code></dt>
<dd>
<section class="desc"><p>EmuState(cfg: 'EmuConfig', expected_address: 'int', address_width: 'int', wait: 'int', waiting: 'int' = 0, callstack: 'list[int]' = <factory>, retaddr: 'int | None' = None, stop: 'int | None' = None, previous_address: 'int' = 0, callstack_ceiling: 'int' = 0, invalid_instructions: 'int' = 0, synthesized: 'dict[bytes, str]' = <factory>, ticks: 'int | INF' = <factory>, visits: 'dict[int, int]' = <factory>, memory: 'MemoryIntervalUnion' = <factory>, init_registers: 'list[Register]' = <factory>, last_read: 'int | None' = None, last_api: 'int | None' = None)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L71-L104" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class EmuState:
    cfg: EmuConfig
    expected_address: int
    address_width: int
    wait: int
    waiting: int = 0
    callstack: list[int] = field(default_factory=list)
    retaddr: int | None = None
    stop: int | None = None
    previous_address: int = 0
    callstack_ceiling: int = 0
    invalid_instructions: int = 0
    synthesized: dict[bytes, str] = field(default_factory=dict)
    ticks: int | INF = field(default_factory=lambda: INF())
    visits: dict[int, int] = field(default_factory=lambda: defaultdict(int))
    memory: MemoryIntervalUnion = field(default_factory=MemoryIntervalUnion)
    init_registers: list[Register] = field(default_factory=list)
    last_read: int | None = None
    last_api: int | None = None

    def log(self, msg: str) -&gt; str:
        _width = len(str(w)) if (w := self.cfg.wait.start) else 8
        _depth = len(self.callstack)
        return F&#39;[wait={self.waiting:0{_width}d}] [depth={_depth}] {self.fmt(self.previous_address)}: {msg}&#39;

    def contains(self, address: int):
        return self.memory.overlaps(address)

    def write(self, address: int, data: bytes):
        self.memory.addi(address, data)

    def fmt(self, address: int) -&gt; str:
        return F&#39;0x{address:0{self.address_width}X}&#39;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.exe.vstack.EmuState.cfg"><code class="name">var <span class="ident">cfg</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.expected_address"><code class="name">var <span class="ident">expected_address</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.address_width"><code class="name">var <span class="ident">address_width</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.wait"><code class="name">var <span class="ident">wait</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.callstack"><code class="name">var <span class="ident">callstack</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.synthesized"><code class="name">var <span class="ident">synthesized</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.ticks"><code class="name">var <span class="ident">ticks</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.visits"><code class="name">var <span class="ident">visits</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.memory"><code class="name">var <span class="ident">memory</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.init_registers"><code class="name">var <span class="ident">init_registers</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.waiting"><code class="name">var <span class="ident">waiting</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.retaddr"><code class="name">var <span class="ident">retaddr</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.stop"><code class="name">var <span class="ident">stop</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.previous_address"><code class="name">var <span class="ident">previous_address</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.callstack_ceiling"><code class="name">var <span class="ident">callstack_ceiling</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.invalid_instructions"><code class="name">var <span class="ident">invalid_instructions</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.last_read"><code class="name">var <span class="ident">last_read</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.last_api"><code class="name">var <span class="ident">last_api</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.exe.vstack.EmuState.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L92-L95" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log(self, msg: str) -&gt; str:
    _width = len(str(w)) if (w := self.cfg.wait.start) else 8
    _depth = len(self.callstack)
    return F&#39;[wait={self.waiting:0{_width}d}] [depth={_depth}] {self.fmt(self.previous_address)}: {msg}&#39;</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L97-L98" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def contains(self, address: int):
    return self.memory.overlaps(address)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, address, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L100-L101" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def write(self, address: int, data: bytes):
    self.memory.addi(address, data)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.exe.vstack.EmuState.fmt"><code class="name flex">
<span>def <span class="ident">fmt</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L103-L104" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fmt(self, address: int) -&gt; str:
    return F&#39;0x{address:0{self.address_width}X}&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.exe.vstack.vstack"><code class="flex name class">
<span>class <span class="ident">vstack</span></span>
<span>(</span><span>*address, base=None, arch=Arch.X32, engine=Engine.unicorn, se=False, ic=False, uc=False, registers=False, timeout=0, patch_range=slice(5, None, None), write_range=slice(1, None, None), wait=slice(80, 20, 5), wait_calls=False, skip_calls=0, stack_size=65536, stack_push=None, show_apis=False, show_code=False, show_memory=False, block_size=4096, max_visits=65536, log_writes_in_calls=False, log_stack_addresses=False, log_other_addresses=False, log_zero_overwrites=False, log_stack_cookies=False)</span>
</code></dt>
<dd>
<section class="desc"><p>The unit emulates instructions at a given address in the input executable (PE/ELF/MachO) and
extracts data patches that are written to memory during emulation. The unit can also be used
to emulate shellcode blobs, in which case it defaults to emulating 32bit x86 instructions.</p>
<p>Emulation is halted as soon as a certain number of instructions have not performed any memory
writes, or when an error occurs. By default, most registers are set to the current location in
the emulated stack. If you want to initialize some of them differently, the <code>-r</code> switch maes
the unit initialize register values from meta variables:</p>
<pre><code>emit shellcode [| put eax 0x2000 | vstack -r ]
</code></pre>
<p>In this pipeline, the eax register is set to <code>0x2000</code> before emulation begins.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/exe/vstack.py#L386-L596" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class vstack(EmulatingUnit):
    &#34;&#34;&#34;
    The unit emulates instructions at a given address in the input executable (PE/ELF/MachO) and
    extracts data patches that are written to memory during emulation. The unit can also be used
    to emulate shellcode blobs, in which case it defaults to emulating 32bit x86 instructions.

    Emulation is halted as soon as a certain number of instructions have not performed any memory
    writes, or when an error occurs. By default, most registers are set to the current location in
    the emulated stack. If you want to initialize some of them differently, the `-r` switch maes
    the unit initialize register values from meta variables:

        emit shellcode [| put eax 0x2000 | vstack -r ]

    In this pipeline, the eax register is set to `0x2000` before emulation begins.
    &#34;&#34;&#34;
    def __init__(
        self,
        *address: Param[str, Arg.String(metavar=&#39;a[:end|::size]&#39;,
            help=&#39;Specify a symbol name or the (virtual) addresses of what to emulate; optionally specify a stop address or a length.&#39;)],
        base=None, arch=Arch.X32, engine=Engine.unicorn, se=False, ic=False, uc=False,
        registers: Param[bool, Arg.Switch(&#39;-r&#39;, help=(
            &#39;Consume register initialization values from the chunk\&#39;s metadata. If the value is a byte string, &#39;
            &#39;the data will be mapped.&#39;))] = False,
        timeout: Param[int, Arg.Number(&#39;-t&#39;, help=&#39;Optionally stop emulating after a given number of instructions.&#39;)] = 0,
        patch_range: Param[slice, Arg.Bounds(&#39;-p&#39;, metavar=&#39;MIN:MAX&#39;,
            help=&#39;Extract only patches that are in the given range, default is {default}.&#39;)] = slice(5, None),
        write_range: Param[slice, Arg.Bounds(&#39;-n&#39;, metavar=&#39;MIN:MAX&#39;,
            help=&#39;Log only writes whose size is in the given range, default is {default}.&#39;)] = slice(1, None),
        wait: Param[slice, Arg.Bounds(&#39;-w&#39;, metavar=&#39;A[:B[:D]]&#39;, intok=True, help=(
            &#39;Emulation halts when X instructions ran without tracking a memory write. &#39;
            &#39;X starts at A and is decreased by D after each write until it reaches B and then remains at B. &#39;
            &#39;Specifying A is equivalent to A:A:1, and A:B is equivalent to A:B:1. B may not be greater than A. &#39;
            &#39;The default is {default}.&#39;))] = slice(80, 20, 5),
        wait_calls: Param[bool, Arg.Switch(&#39;-c&#39;, group=&#39;CALL&#39;,
            help=&#39;Wait indefinitely when inside a function call.&#39;)] = False,
        skip_calls: Param[int, Arg.Counts(&#39;-C&#39;, group=&#39;CALL&#39;,
            help=&#39;Skip function calls entirely. Use twice to treat each call as allocating memory.&#39;)] = 0,
        stack_size: Param[int, Arg.Number(&#39;-S&#39;, help=&#39;Optionally specify the stack size. The default is 0x{default:X}.&#39;)] = 0x10000,
        stack_push: Param[tuple[str] | None, Arg(&#39;-u&#39;, action=&#39;append&#39;, metavar=&#39;REG&#39;,
            help=&#39;Push the value of a register to the stack before beginning emulation; implies -r.&#39;)] = None,
        show_apis: Param[bool, Arg.Switch(&#39;-A&#39;, help=&#39;Show API calls in the debug log.&#39;)] = False,
        show_code: Param[bool, Arg.Switch(&#39;-I&#39;, help=&#39;Show all executed instructions in the debug log.&#39;)] = False,
        show_memory: Param[bool, Arg.Switch(&#39;-M&#39;, help=&#39;Show all memory writes in the debug log.&#39;)] = False,
        block_size: Param[int, Arg.Number(&#39;-B&#39;, help=&#39;Standard memory block size for the emulator, 0x{default:X} by default.&#39;)] = 0x1000,
        max_visits: Param[int, Arg.Number(&#39;-V&#39;, help=&#39;Maximum number of times a code address is visited. Default is {default}.&#39;)] = 0x10000,
        log_writes_in_calls: Param[bool, Arg.Switch(&#39;-W&#39;, help=&#39;Log writes of values that occur in functions calls.&#39;)] = False,
        log_stack_addresses: Param[bool, Arg.Switch(&#39;-X&#39;, help=&#39;Log writes of values that are stack addresses.&#39;)] = False,
        log_other_addresses: Param[bool, Arg.Switch(&#39;-Y&#39;, help=&#39;Log writes of values that are addresses to mapped segments.&#39;)] = False,
        log_zero_overwrites: Param[bool, Arg.Switch(&#39;-Z&#39;, help=&#39;Log writes of zeros to memory that contained nonzero values.&#39;)] = False,
        log_stack_cookies: Param[bool, Arg.Switch(&#39;-E&#39;, help=&#39;Log writes that look like stack cookies.&#39;)] = False,
    ):
        super().__init__(
            base=base,
            arch=arch,
            engine=engine,
            se=se,
            ic=ic,
            uc=uc,
            address=address,
            registers=registers,
            timeout=timeout,
            patch_range=patch_range,
            write_range=write_range,
            wait=wait,
            stack_size=stack_size,
            stack_push=stack_push,
            wait_calls=wait_calls,
            skip_calls=skip_calls,
            block_size=block_size,
            max_visits=max_visits,
            show_apis=show_apis,
            show_code=show_code,
            show_memory=show_memory,
            log_writes_in_calls=log_writes_in_calls,
            log_stack_addresses=log_stack_addresses,
            log_other_addresses=log_other_addresses,
            log_zero_overwrites=log_zero_overwrites,
            log_stack_cookies=log_stack_cookies
        )

    def process(self, data: Chunk):
        meta = metavars(data)
        args = self.args

        engine = self._engine()
        flags = Hook.Default | Hook.ApiCall
        self.log_debug(F&#39;attempting to use {engine.name}&#39;)

        Emu = EmuFactory(engine.cls)

        emu = Emu(
            data,
            args.base,
            args.arch,
            flags,
            args.block_size,
            args.stack_size,
        )

        wait: int | slice[int, int, int] = args.wait
        if isinstance(wait, int):
            wait = slice(wait, wait, 1)
        elif wait.start &lt; wait.stop:
            raise ValueError(&#39;invalid wait format&#39;)

        self.log_info(F&#39;setting wait to: {wait.start}:{wait.stop}:{wait.step}&#39;)

        cfg = EmuConfig(
            args.wait_calls,
            args.skip_calls,
            args.write_range,
            wait,
            args.block_size,
            args.stack_size,
            args.max_visits,
            args.log_stack_cookies,
            args.log_writes_in_calls,
            args.log_stack_addresses,
            args.log_other_addresses,
            args.log_zero_overwrites,
            args.show_apis,
            args.show_code,
            args.show_memory,
        )

        register_values: dict[Register, int | str | bytes] = {}
        emu.reset(None)

        if args.registers or args.stack_push:
            for var, value in list(meta.items()):
                try:
                    register = emu.lookup_register(var)
                except LookupError:
                    continue
                meta.discard(var)
                register_values[register] = value

        if not (addresses := [
            self._parse_address(data, emu.exe, a) for a in args.address
        ]):
            for symbol in emu.exe.symbols():
                if symbol.name is None:
                    addresses.append(slice(symbol.address, None))
                    break

        for cursor in addresses:
            state = EmuState(
                cfg,
                cursor.start,
                emu.exe.pointer_size // 4,
                wait=wait.start,
                stop=cursor.stop,
            )

            emu.reset(state)

            for reg in emu.general_purpose_registers():
                emu.set_register(reg, 0)

            for reg in register_values:
                # check if we are tainting a general purpose register
                emu.set_register(reg, 1)

            for reg in emu.general_purpose_registers():
                if emu.get_register(reg) == 0:
                    state.init_registers.append(reg)

            for reg, value in register_values.items():
                if isinstance(value, int):
                    self.log_info(F&#39;setting {reg.name} to integer value 0x{value:X}&#39;)
                    emu.set_register(reg, value)
                    continue
                if isinstance(value, str):
                    value = value.encode()
                if isbuffer(value):
                    start = emu.malloc(len(value))
                    emu.mem_write(start, bytes(value))
                    emu.set_register(reg, start)
                    self.log_info(F&#39;setting {reg.name} to mapped buffer of size 0x{len(value):X}&#39;)
                    continue
                _tn = value.__class__.__name__
                self.log_warn(F&#39;canot interpret value of type {_tn} for register {reg.name}&#39;)

            if push := args.stack_push:
                for reg in push:
                    emu.push_register(reg)

            timeout = args.timeout
            if timeout:
                self.log_info(F&#39;setting timeout of {timeout} steps&#39;)
                state.ticks = timeout

            try:
                emu.emulate(
                    emu.base_exe_to_emu(cursor.start),
                    emu.base_exe_to_emu(cursor.stop),
                )
            except EmulationError as e:
                self.log_info(F&#39;emulation halted with error: {e!s}&#39;)

            for patch, api in state.synthesized.items():
                chunk = self.labelled(patch, src=api)
                yield chunk

            valid = bounds[args.patch_range]
            for base, patch in state.memory:
                if len(patch) not in valid or not any(patch):
                    continue
                self.log_info(F&#39;memory patch at {state.fmt(base)} of size {len(patch)}&#39;)
                chunk = self.labelled(patch, src=base)
                yield chunk</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.exe.EmulatingUnit" href="index.html#refinery.units.formats.exe.EmulatingUnit">EmulatingUnit</a></li>
<li><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></li>
<li><a title="refinery.units.Entry" href="../../index.html#refinery.units.Entry">Entry</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.exe.vstack.vstack" href="#refinery.units.formats.exe.vstack.vstack">vstack</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.exe.vstack.vstack.reverse"><code class="name">var <span class="ident">reverse</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.formats.exe.EmulatingUnit" href="index.html#refinery.units.formats.exe.EmulatingUnit">EmulatingUnit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.FilterEverything" href="../../index.html#refinery.units.UnitBase.FilterEverything">FilterEverything</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.Requires" href="../../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.act" href="../../index.html#refinery.units.Unit.act">act</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.assemble" href="../../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.codec" href="../../index.html#refinery.units.Unit.codec">codec</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.console" href="../../index.html#refinery.units.Unit.console">console</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.filter" href="../../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.finish" href="../../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.handles" href="../../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.is_quiet" href="../../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.is_reversible" href="../../index.html#refinery.units.Unit.is_reversible">is_reversible</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.isatty" href="../../index.html#refinery.units.Unit.isatty">isatty</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.labelled" href="../../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.leniency" href="../../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.log_always" href="../../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.log_debug" href="../../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.log_detach" href="../../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.log_fail" href="../../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.log_info" href="../../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.log_level" href="../../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.log_warn" href="../../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.logger" href="../../index.html#refinery.units.Unit.logger">logger</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.name" href="../../index.html#refinery.units.Unit.name">name</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.nozzle" href="../../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.optional_dependencies" href="../../index.html#refinery.units.Unit.optional_dependencies">optional_dependencies</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.process" href="../../index.html#refinery.units.UnitBase.process">process</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.read" href="../../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.read1" href="../../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.required_dependencies" href="../../index.html#refinery.units.Unit.required_dependencies">required_dependencies</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.reset" href="../../index.html#refinery.units.Unit.reset">reset</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.run" href="../../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.source" href="../../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.formats.exe.EmulatingUnit.superinit" href="../../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.formats.exe" href="index.html">refinery.units.formats.exe</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.units.formats.exe.vstack.EmuFactory" href="#refinery.units.formats.exe.vstack.EmuFactory">EmuFactory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.formats.exe.vstack.EmuConfig" href="#refinery.units.formats.exe.vstack.EmuConfig">EmuConfig</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.exe.vstack.EmuState" href="#refinery.units.formats.exe.vstack.EmuState">EmuState</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.exe.vstack.EmuState.log" href="#refinery.units.formats.exe.vstack.EmuState.log">log</a></code></li>
<li><code><a title="refinery.units.formats.exe.vstack.EmuState.contains" href="#refinery.units.formats.exe.vstack.EmuState.contains">contains</a></code></li>
<li><code><a title="refinery.units.formats.exe.vstack.EmuState.write" href="#refinery.units.formats.exe.vstack.EmuState.write">write</a></code></li>
<li><code><a title="refinery.units.formats.exe.vstack.EmuState.fmt" href="#refinery.units.formats.exe.vstack.EmuState.fmt">fmt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.exe.vstack.vstack" href="#refinery.units.formats.exe.vstack.vstack">vstack</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
