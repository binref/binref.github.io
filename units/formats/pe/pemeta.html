<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.units.formats.pe.pemeta documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.formats.pe.pemeta</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L1-L748" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from __future__ import annotations

import itertools
import json

from contextlib import suppress
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from enum import Enum

from refinery.lib import lief
from refinery.lib.dotnet.header import DotNetHeader
from refinery.lib.id import is_likely_pe
from refinery.lib.lcid import LCID
from refinery.lib.resources import datapath
from refinery.lib.tools import NoLoggingProxy, date_from_timestamp, unwrap
from refinery.lib.types import Param
from refinery.units import Arg, Unit
from refinery.units.formats.pe import get_pe_size
from refinery.units.sinks.ppjson import ppjson


def _FILETIME(value: int) -&gt; datetime:
    s, ns100 = divmod(value - 116444736000000000, 10000000)
    return datetime.fromtimestamp(s, timezone.utc).replace(microsecond=(ns100 // 10))


def _STRING(value: str | bytes, dll: bool = False) -&gt; str:
    if not isinstance(value, str):
        value, _, _ = value.partition(B&#39;\0&#39;)
        value = value.decode(&#39;utf8&#39;)
    if dll and value.lower().endswith(&#39;.dll&#39;):
        value = value[~3:]
    return value


class VIT(str, Enum):
    ERR = &#39;unknown&#39;
    OBJ = &#39;object file from C&#39;
    CPP = &#39;object file from C++&#39;
    ASM = &#39;object file from assembler&#39;
    RES = &#39;object from CVTRES&#39;
    LNK = &#39;linker version&#39;
    IMP = &#39;dll import in library file&#39;
    EXP = &#39;dll export in library file&#39;

    @property
    def tag(self) -&gt; str:
        if self in (VIT.OBJ, VIT.CPP, VIT.ASM, VIT.RES):
            return &#39;object&#39;
        if self is VIT.IMP:
            return &#39;import&#39;
        if self is VIT.EXP:
            return &#39;export&#39;
        if self is VIT.LNK:
            return &#39;linker&#39;
        else:
            return &#39;unknown&#39;


@dataclass
class VersionInfo:
    pid: str
    ver: str
    err: bool

    def __str__(self):
        return F&#39;{self.ver} [{self.pid.upper()}]&#39;

    def __bool__(self):
        return not self.err


with datapath(&#39;rich.json&#39;).open(&#39;r&#39;) as stream:
    RICH = json.load(stream)


class ShortPID(str, Enum):
    UTC = &#39;STDLIB&#39; # STDLIBC
    RES = &#39;CVTRES&#39; # Cvt/RES
    OMF = &#39;CVTOMF&#39; # Cvt/OMF
    PGD = &#39;CVTPGD&#39; # Cvt/PGD
    LNK = &#39;LINKER&#39; # Linker
    EXP = &#39;EXPORT&#39; # Exports
    IMP = &#39;IMPORT&#39; # Imports
    OBJ = &#39;OBJECT&#39; # Object
    PHX = &#39;PHOENX&#39; # Phoenix
    ASM = &#39;MASM&#39;   # MASM
    MIL = &#39;MSIL&#39;   # MSIL
    VB6 = &#39;VB6OBJ&#39; # VB6

    def __str__(self):
        width = max(len(item.value) for item in self.__class__)
        return F&#39;{self.value:&gt;{width}}&#39;


def get_rich_short_pid(pid: str) -&gt; ShortPID:
    pid = pid.upper()
    if pid.startswith(&#39;UTC&#39;):
        return ShortPID.UTC
    if pid.startswith(&#39;CVTRES&#39;):
        return ShortPID.RES
    if pid.startswith(&#39;CVTOMF&#39;):
        return ShortPID.OMF
    if pid.startswith(&#39;CVTPGD&#39;):
        return ShortPID.PGD
    if pid.startswith(&#39;LINKER&#39;):
        return ShortPID.LNK
    if pid.startswith(&#39;EXPORT&#39;):
        return ShortPID.EXP
    if pid.startswith(&#39;IMPORT&#39;):
        return ShortPID.IMP
    if pid.startswith(&#39;IMPLIB&#39;):
        return ShortPID.IMP
    if pid.startswith(&#39;ALIASOBJ&#39;):
        return ShortPID.OBJ
    if pid.startswith(&#39;RESOURCE&#39;):
        return ShortPID.RES
    if pid.startswith(&#39;PHX&#39;):
        return ShortPID.PHX
    if pid.startswith(&#39;PHOENIX&#39;):
        return ShortPID.PHX
    if pid.startswith(&#39;MASM&#39;):
        return ShortPID.ASM
    if pid.startswith(&#39;ILASM&#39;):
        return ShortPID.MIL
    if pid.startswith(&#39;VISUALBASIC&#39;):
        return ShortPID.VB6
    raise LookupError(pid)


def get_rich_info(vid: int) -&gt; VersionInfo:
    pid = vid &gt;&gt; 0x10
    ver = vid &amp; 0xFFFF
    ver = RICH[&#39;ver&#39;].get(F&#39;{ver:04X}&#39;)
    pid = RICH[&#39;pid&#39;].get(F&#39;{pid:04X}&#39;)
    err = ver is None and pid is None
    if ver is not None:
        suffix = ver.get(&#39;ver&#39;)
        ver = ver[&#39;ide&#39;]
        if suffix:
            ver = F&#39;{ver} {suffix}&#39;
    else:
        ver = &#39;Unknown Version&#39;
    pid = pid or &#39;Unknown Type&#39;
    return VersionInfo(pid, ver, err)


class pemeta(Unit):
    &#34;&#34;&#34;
    Extract metadata from PE files. By default, all information except for imports and exports are
    extracted.
    &#34;&#34;&#34;
    def __init__(
        self,
        custom: Param[bool, Arg(&#39;-c&#39;, &#39;--custom&#39;,
            help=&#39;Unless enabled, all default categories will be extracted.&#39;)] = False,
        debug: Param[bool, Arg.Switch(&#39;-D&#39;,
            help=&#39;Parse the PDB path from the debug directory.&#39;)] = False,
        dotnet: Param[bool, Arg.Switch(&#39;-N&#39;,
            help=&#39;Parse the .NET header.&#39;)] = False,
        signatures: Param[bool, Arg.Switch(&#39;-S&#39;,
            help=&#39;Parse digital signatures.&#39;)] = False,
        timestamps: Param[int, Arg.Counts(&#39;-T&#39;,
            help=&#39;Extract time stamps. Specify twice for more detail.&#39;)] = 0,
        version: Param[bool, Arg.Switch(&#39;-V&#39;,
            help=&#39;Parse the VERSION resource.&#39;)] = False,
        header: Param[bool, Arg.Switch(&#39;-H&#39;,
            help=&#39;Parse base data from the PE header.&#39;)] = False,
        exports: Param[int, Arg.Counts(&#39;-E&#39;,
            help=&#39;List all exported functions. Specify twice to include addresses.&#39;)] = 0,
        imports: Param[int, Arg.Counts(&#39;-I&#39;,
            help=&#39;List all imported functions. Specify twice to include addresses.&#39;)] = 0,
        tabular: Param[bool, Arg.Switch(&#39;-t&#39;,
            help=&#39;Print information in a table rather than as JSON&#39;)] = False,
        timeraw: Param[bool, Arg.Switch(&#39;-r&#39;,
            help=&#39;Extract time stamps as numbers instead of human-readable format.&#39;)] = False,
    ):
        if not custom and not any((debug, dotnet, signatures, timestamps, version, header)):
            debug = dotnet = signatures = timestamps = version = header = True
        super().__init__(
            debug=debug,
            dotnet=dotnet,
            signatures=signatures,
            timestamps=timestamps,
            version=version,
            header=header,
            imports=imports,
            exports=exports,
            timeraw=timeraw,
            tabular=tabular,
        )

    @classmethod
    def handles(cls, data):
        return is_likely_pe(data)

    @classmethod
    def _ensure_string(cls, x):
        if not isinstance(x, str):
            x = repr(x) if not isinstance(x, bytes) else x.decode(cls.codec, &#39;backslashreplace&#39;)
        return x

    @classmethod
    def _parse_pedict(cls, bin: dict):
        return {
            cls._ensure_string(key).replace(&#34; &#34;, &#34;&#34;): cls._ensure_string(val)
            for key, val in bin.items() if val}

    @classmethod
    def parse_signature(cls, data: bytearray) -&gt; dict:
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human-readable dictionary with information about
        time stamp and code signing certificates that are attached to the input PE file.
        &#34;&#34;&#34;
        from refinery.units.formats.pkcs7 import pkcs7

        try:
            signature = data | pkcs7 | json.loads
        except Exception as E:
            raise ValueError(F&#39;PKCS7 parser failed with error: {E!s}&#39;)

        info = {}

        def _value(doc: dict, require_type=None):
            if require_type is not None:
                if doc.get(&#39;type&#39;, None) != require_type:
                    raise LookupError
            value = doc.get(&#39;value&#39;, None)
            value = [value] if value else doc.get(&#39;values&#39;, [])
            if not value:
                raise LookupError
            return value[0]

        def find_timestamps(entry) -&gt; dict:
            if isinstance(entry, dict):
                try:
                    return {&#39;Timestamp&#39;: _value(entry, &#39;signing_time&#39;)}
                except LookupError:
                    pass
                for value in entry.values():
                    result = find_timestamps(value)
                    if result is None:
                        continue
                    with suppress(KeyError):
                        result.setdefault(&#39;TimestampIssuer&#39;, entry[&#39;sid&#39;][&#39;issuer&#39;][&#39;common_name&#39;])
                    return result
            elif isinstance(entry, list):
                for value in entry:
                    result = find_timestamps(value)
                    if result is None:
                        continue
                    return result

        timestamp_info = find_timestamps(signature)
        if timestamp_info is not None:
            info.update(timestamp_info)

        try:
            certificates = signature[&#39;content&#39;][&#39;certificates&#39;]
            signer_infos = signature[&#39;content&#39;][&#39;signer_infos&#39;]
        except KeyError:
            return info

        try:
            signer_serials = {info[&#39;sid&#39;][&#39;serial_number&#39;]: info for info in signer_infos}
        except KeyError:
            return info

        signer_certificates = []

        for certificate in certificates:
            with suppress(Exception):
                crt = certificate[&#39;tbs_certificate&#39;]
                serial = crt[&#39;serial_number&#39;]
                signer = signer_serials[serial]
                if isinstance(serial, int):
                    serial = F&#39;{serial:x}&#39;
                if len(serial) % 2 != 0:
                    serial = F&#39;0{serial}&#39;
                assert bytes.fromhex(serial) in data
                subject = crt[&#39;subject&#39;]
                location = [subject.get(t, &#39;&#39;) for t in (
                    &#39;locality_name&#39;, &#39;state_or_province_name&#39;, &#39;country_name&#39;)]
                cert_info = {}
                cert_info.update(Subject=subject[&#39;common_name&#39;])
                if any(location):
                    cert_info.update(SubjectLocation=&#39;, &#39;.join(filter(None, location)))
                for attr in signer[&#39;signed_attrs&#39;]:
                    if attr[&#39;type&#39;] == &#39;authenticode_info&#39;:
                        auth = _value(attr)
                        cert_info.update(ProgramName=auth[&#39;programName&#39;])
                        cert_info.update(MoreInfo=auth[&#39;moreInfo&#39;])
                try:
                    valid_since = crt[&#39;validity&#39;][&#39;not_before&#39;]
                    valid_until = crt[&#39;validity&#39;][&#39;not_after&#39;]
                except KeyError:
                    pass
                else:
                    cert_info.update(ValidSince=valid_since, ValidUntil=valid_until)
                cert_info.update(
                    Issuer=crt[&#39;issuer&#39;][&#39;common_name&#39;], Fingerprint=certificate[&#39;fingerprint&#39;], Serial=serial)
                signer_certificates.append(cert_info)

        if len(signer_certificates) == 1:
            info.update(signer_certificates[0])
        if len(signer_certificates) &gt;= 2:
            info[&#39;Signer&#39;] = signer_certificates
        return info

    def _pe_characteristics(self, pe: lief.PE.Binary):
        characteristics = {F&#39;IMAGE_FILE_{flag.name}&#39; for flag in lief.PE.Header.CHARACTERISTICS
            if pe.header.characteristics &amp; flag.value}
        if pe.header.characteristics &amp; 0x40:
            # TODO: Missing from LIEF
            characteristics.add(&#39;IMAGE_FILE_16BIT_MACHINE&#39;)
        return characteristics

    def _pe_address_width(self, pe: lief.PE.Binary, default=16) -&gt; int:
        # TODO: missing from LIEF
        IMAGE_FILE_16BIT_MACHINE = 0x40
        if pe.header.characteristics &amp; IMAGE_FILE_16BIT_MACHINE:
            return 4
        elif pe.header.machine == lief.PE.Header.MACHINE_TYPES.I386:
            return 8
        elif pe.header.machine in (
            lief.PE.Header.MACHINE_TYPES.AMD64,
            lief.PE.Header.MACHINE_TYPES.IA64,
        ):
            return 16
        else:
            return default

    def _vint(self, pe: lief.PE.Binary, value: int):
        if not self.args.tabular:
            return value
        aw = self._pe_address_width(pe)
        return F&#39;0x{value:0{aw}X}&#39;

    def parse_version(self, pe: lief.PE.Binary, data=None) -&gt; dict | None:
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human-readable dictionary with information about
        the version resource of an input PE file, if available.
        &#34;&#34;&#34;
        version_info = {}
        rsrc = unwrap(pe.resources_manager)
        if isinstance(rsrc, lief.lib.lief_errors) or not rsrc.has_version:
            return None
        version = rsrc.version[0]

        if info := version.string_file_info:
            for child in info.children:
                entries = {e.key: e.value for e in child.entries}
                version_info.update({
                    k.replace(&#39; &#39;, &#39;&#39;): _STRING(v) for k, v in entries.items()
                })

        if rsrc.has_icons:
            icon = next(iter(rsrc.icons))
            version_info.update(
                LangID=self._vint(pe, icon.lang &lt;&lt; 0x10 | icon.sublang),
                Language=LCID.get(icon.lang, &#39;Language Neutral&#39;),
                Charset=self._CHARSET.get(icon.sublang, &#39;Unknown Charset&#39;),
            )

        def _code_pages(d: lief.PE.ResourceDirectory | lief.PE.ResourceData):
            if isinstance(d, lief.PE.ResourceData):
                yield d.code_page
                return
            for child in d.childs:
                yield from _code_pages(child)

        code_pages: set[int] = set()

        for t in rsrc.types:
            code_pages.update(_code_pages(rsrc.get_node_type(t)))

        if len(code_pages) == 1:
            cp = next(iter(code_pages))
            version_info.update(CodePage=cp)

        def _to_version_string(hi: int, lo: int):
            a = hi &gt;&gt; 0x10
            b = hi &amp; 0xFFFF
            c = lo &gt;&gt; 0x10
            d = lo &amp; 0xFFFF
            return F&#39;{a}.{b}.{c}.{d}&#39;

        # TODO: Missing: Version.CompanyName
        # TODO: Missing: Version.FileDescription
        # TODO: Missing: Version.LegalCopyright
        # TODO: Missing: Version.ProductName

        if info := version.file_info:
            for name, val, T in (
                (&#39;FileType&#39;, info.file_type, info.FILE_TYPE),
                (&#39;OSName&#39;, info.file_os, info.VERSION_OS),
                (&#39;FileSubType&#39;, info.file_subtype, info.FILE_TYPE_DETAILS),
            ):
                if not val:
                    continue
                try:
                    version_info[name] = T(val).name
                except Exception:
                    continue
            if t := info.file_date_ms &lt;&lt; 32 | info.file_date_ls:
                version_info.update(Timestamp=_FILETIME(t))
            version_info.update(
                ProductVersion=_to_version_string(info.product_version_ms, info.product_version_ls),
                FileVersion=_to_version_string(info.file_version_ms, info.file_version_ls),
            )

        if info := version.var_file_info:
            ...

        return version_info or None

    def parse_exports(self, pe: lief.PE.Binary, data=None, include_addresses=False) -&gt; list:
        base = pe.optional_header.imagebase
        info = []
        if not pe.has_exports:
            return None
        for k, exp in enumerate(pe.get_export().entries):
            name = exp.demangled_name
            if not name:
                name = exp.name
            if not name:
                name = F&#39;@{k}&#39;
            if not isinstance(name, str):
                name = name.decode(&#39;latin1&#39;)
            item = {
                &#39;Name&#39;: name, &#39;Address&#39;: self._vint(pe, exp.address + base)
            } if include_addresses else name
            info.append(item)
        return info

    def parse_imports(self, pe: lief.PE.Binary, data=None, include_addresses=False) -&gt; list:
        info = {}
        for idd in itertools.chain(pe.imports, pe.delay_imports):
            dll = _STRING(idd.name)
            if dll.lower().endswith(&#39;.dll&#39;):
                dll = dll[:~3]
            imports: list[str] = info.setdefault(dll, [])
            for imp in idd.entries:
                name = _STRING(imp.name) or F&#39;@{imp.ordinal}&#39;
                imports.append(dict(
                    Name=name, Address=self._vint(pe, imp.value)
                ) if include_addresses else name)
        return info

    def parse_header(self, pe: lief.PE.Binary, data=None) -&gt; dict:
        major = pe.optional_header.major_operating_system_version
        minor = pe.optional_header.minor_operating_system_version
        version = self._WINVER.get(major, {0: &#39;Unknown&#39;})

        try:
            MinimumOS = version[minor]
        except LookupError:
            MinimumOS = version[0]
        header_information = {
            &#39;Machine&#39;: pe.header.machine.name,
            &#39;Subsystem&#39;: pe.optional_header.subsystem.name,
            &#39;MinimumOS&#39;: MinimumOS,
        }
        if pe.has_exports:
            export_name = _STRING(pe.get_export().name)
            if export_name.isprintable():
                header_information[&#39;ExportName&#39;] = export_name

        if pe.has_rich_header:
            rich = []
            if self.args.tabular:
                cw = max(len(F&#39;{entry.count:d}&#39;) for entry in pe.rich_header.entries)
            for entry in pe.rich_header.entries:
                idv = entry.build_id | (entry.id &lt;&lt; 0x10)
                count = entry.count
                info = get_rich_info(idv)
                if not info:
                    continue
                pid = info.pid.upper()
                if self.args.tabular:
                    short_pid = get_rich_short_pid(pid)
                    rich.append(F&#39;[{idv:08x}] {count:&gt;0{cw}d} {short_pid!s} {info.ver}&#39;)
                else:
                    rich.append({
                        &#39;Counter&#39;: count,
                        &#39;Encoded&#39;: F&#39;{idv:08x}&#39;,
                        &#39;Library&#39;: pid,
                        &#39;Product&#39;: info.ver,
                    })
            header_information[&#39;RICH&#39;] = rich

        characteristics = self._pe_characteristics(pe)
        for typespec, flag in {
            &#39;EXE&#39;: &#39;IMAGE_FILE_EXECUTABLE_IMAGE&#39;,
            &#39;DLL&#39;: &#39;IMAGE_FILE_DLL&#39;,
            &#39;SYS&#39;: &#39;IMAGE_FILE_SYSTEM&#39;
        }.items():
            if flag in characteristics:
                header_information[&#39;Type&#39;] = typespec

        base = pe.optional_header.imagebase
        header_information[&#39;ImageBase&#39;] = self._vint(pe, base)
        header_information[&#39;ImageSize&#39;] = self._vint(pe, pe.optional_header.sizeof_image)
        header_information[&#39;ComputedSize&#39;] = get_pe_size(pe)
        header_information[&#39;Bits&#39;] = 4 * self._pe_address_width(pe, 16)
        header_information[&#39;EntryPoint&#39;] = self._vint(pe, pe.optional_header.addressof_entrypoint + base)
        return header_information

    def parse_time_stamps(self, pe: lief.PE.Binary, raw_time_stamps: bool, more_detail: bool) -&gt; dict:
        &#34;&#34;&#34;
        Extracts time stamps from the PE header (link time), as well as from the imports,
        exports, debug, and resource directory. The resource time stamp is also parsed as
        a DOS time stamp and returned as the &#34;Delphi&#34; time stamp.
        &#34;&#34;&#34;
        def _id(x): return x
        dt = _id if raw_time_stamps else date_from_timestamp
        info = {}

        with suppress(AttributeError):
            info.update(Linker=dt(pe.header.time_date_stamps))

        import_timestamps = {}
        for entry in pe.imports:
            ts = entry.timedatestamp
            if ts == 0 or ts == 0xFFFFFFFF:
                continue
            import_timestamps[_STRING(entry.name, True)] = dt(ts)

        symbol_timestamps = {}
        for entry in pe.delay_imports:
            ts = entry.timestamp
            if ts == 0 or ts == 0xFFFFFFFF:
                continue
            symbol_timestamps[_STRING(entry.name, True)] = dt(ts)

        for key, impts in [
            (&#39;Import&#39;, import_timestamps),
            (&#39;Symbol&#39;, symbol_timestamps),
        ]:
            if not impts:
                continue
            if not more_detail:
                dmin = min(impts.values())
                dmax = max(impts.values())
                small_delta = 2 * 60 * 60
                if not raw_time_stamps:
                    small_delta = timedelta(seconds=small_delta)
                if dmax - dmin &lt; small_delta:
                    impts = dmin
            info[key] = impts

        if pe.has_exports and (ts := pe.get_export().timestamp):
            info.update(Export=dt(ts))

        if pe.has_resources and pe.resources.is_directory:
            rsrc: lief.PE.ResourceDirectory = pe.resources
            if res_timestamp := rsrc.time_date_stamp:
                with suppress(ValueError):
                    from refinery.units.misc.datefix import datefix
                    dos = datefix.dostime(res_timestamp)
                    info.update(Delphi=dos)
                    info.update(RsrcTS=dt(res_timestamp))

        def norm(value):
            if isinstance(value, list):
                return [norm(v) for v in value]
            if isinstance(value, dict):
                return {k: norm(v) for k, v in value.items()}
            if isinstance(value, int):
                return value
            return str(value)

        return {key: norm(value) for key, value in info.items()}

    def parse_dotnet(self, pe: lief.PE.Binary, data):
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human-readable dictionary with information about
        the .NET metadata of an input PE file.
        &#34;&#34;&#34;
        header = DotNetHeader(data, pe)
        tables = header.meta.Streams.Tables
        info = dict(
            RuntimeVersion=F&#39;{header.head.MajorRuntimeVersion}.{header.head.MinorRuntimeVersion}&#39;,
            Version=F&#39;{header.meta.MajorVersion}.{header.meta.MinorVersion}&#39;,
            VersionString=header.meta.VersionString
        )

        info[&#39;Flags&#39;] = [name for name, check in header.head.KnownFlags.items() if check]

        if len(tables.Assembly) == 1:
            assembly = tables.Assembly[0]
            info.update(
                AssemblyName=assembly.Name,
                Release=&#39;{}.{}.{}.{}&#39;.format(
                    assembly.MajorVersion,
                    assembly.MinorVersion,
                    assembly.BuildNumber,
                    assembly.RevisionNumber
                )
            )

        try:
            entry = self._vint(pe, header.head.EntryPointToken + pe.optional_header.imagebase)
            info.update(EntryPoint=entry)
        except AttributeError:
            pass

        if len(tables.Module) == 1:
            module = tables.Module[0]
            info.update(ModuleName=module.Name)

        return info

    def parse_debug(self, pe: lief.PE.Binary, data=None):
        result = []
        if not pe.has_debug:
            return None
        for entry in pe.debug:
            if entry.type != lief.PE.Debug.TYPES.CODEVIEW:
                continue
            try:
                entry: lief.PE.CodeViewPDB
                result.append(dict(
                    PdbPath=_STRING(entry.filename),
                    PdbGUID=entry.guid,
                    PdbAge=entry.age,
                ))
            except AttributeError:
                continue
        if len(result) == 1:
            result = result[0]
        return result

    def process(self, data):
        result = {}

        pe = lief.load_pe(
            data,
            parse_exports=True,
            parse_imports=self.args.imports,
            parse_rsrc=self.args.version,
            parse_reloc=False,
            parse_signature=self.args.timestamps or self.args.signatures,
        )

        if pe is None:
            raise ValueError(&#39;Input not recognized as a PE file.&#39;)

        pe = NoLoggingProxy(pe)

        for switch, resolver, name in [
            (self.args.debug,   self.parse_debug,    &#39;Debug&#39;),    # noqa
            (self.args.dotnet,  self.parse_dotnet,   &#39;DotNet&#39;),   # noqa
            (self.args.header,  self.parse_header,   &#39;Header&#39;),   # noqa
            (self.args.version, self.parse_version,  &#39;Version&#39;),  # noqa
            (self.args.imports, self.parse_imports,  &#39;Imports&#39;),  # noqa
            (self.args.exports, self.parse_exports,  &#39;Exports&#39;),  # noqa
        ]:
            if not switch:
                continue
            self.log_debug(F&#39;parsing: {name}&#39;)
            args = pe, data
            if switch &gt; 1:
                args = *args, True
            try:
                info = resolver(*args)
            except Exception as E:
                self.log_info(F&#39;failed to obtain {name}: {E!s}&#39;)
                continue
            if info:
                result[name] = info

        signature = {}

        if self.args.timestamps or self.args.signatures:
            with suppress(Exception):
                from refinery.units.formats.pe.pesig import pesig
                signature = self.parse_signature(next(data | pesig))

        if signature:
            try:
                verification = pe.verify_signature()
            except Exception:
                pass
            else:
                from lief.PE import Signature
                if verification == Signature.VERIFICATION_FLAGS.OK:
                    signature[&#39;IsValid&#39;] = True
                else:
                    signature[&#39;Flags&#39;] = [
                        vf.name for vf in Signature.VERIFICATION_FLAGS if vf &amp; verification]
                    signature[&#39;IsValid&#39;] = False

        if self.args.timestamps:
            ts = self.parse_time_stamps(pe, self.args.timeraw, self.args.timestamps &gt; 1)
            with suppress(KeyError):
                ts.update(Signed=signature[&#39;Timestamp&#39;])
            result.update(TimeStamp=ts)

        if signature and self.args.signatures:
            result[&#39;Signature&#39;] = signature

        if result:
            yield from ppjson(tabular=self.args.tabular)._pretty_output(result, indent=4, ensure_ascii=False)

    _CHARSET = {
        0x0000: &#39;7-bit ASCII&#39;,
        0x03A4: &#39;Japan (Shift ? JIS X-0208)&#39;,
        0x03B5: &#39;Korea (Shift ? KSC 5601)&#39;,
        0x03B6: &#39;Taiwan (Big5)&#39;,
        0x04B0: &#39;Unicode&#39;,
        0x04E2: &#39;Latin-2 (Eastern European)&#39;,
        0x04E3: &#39;Cyrillic&#39;,
        0x04E4: &#39;Multilingual&#39;,
        0x04E5: &#39;Greek&#39;,
        0x04E6: &#39;Turkish&#39;,
        0x04E7: &#39;Hebrew&#39;,
        0x04E8: &#39;Arabic&#39;,
    }

    _WINVER = {
        3: {
            0x00: &#39;Windows NT 3&#39;,
            0x0A: &#39;Windows NT 3.1&#39;,
            0x32: &#39;Windows NT 3.5&#39;,
            0x33: &#39;Windows NT 3.51&#39;,
        },
        4: {
            0x00: &#39;Windows 95&#39;,
            0x0A: &#39;Windows 98&#39;,
        },
        5: {
            0x00: &#39;Windows 2000&#39;,
            0x5A: &#39;Windows Me&#39;,
            0x01: &#39;Windows XP&#39;,
            0x02: &#39;Windows Server 2003&#39;,
        },
        6: {
            0x00: &#39;Windows Vista&#39;,
            0x01: &#39;Windows 7&#39;,
            0x02: &#39;Windows 8&#39;,
            0x03: &#39;Windows 8.1&#39;,
        },
        10: {
            0x00: &#39;Windows 10&#39;,
        }
    }</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.units.formats.pe.pemeta.get_rich_short_pid"><code class="name flex">
<span>def <span class="ident">get_rich_short_pid</span></span>(<span>pid)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L97-L129" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_rich_short_pid(pid: str) -&gt; ShortPID:
    pid = pid.upper()
    if pid.startswith(&#39;UTC&#39;):
        return ShortPID.UTC
    if pid.startswith(&#39;CVTRES&#39;):
        return ShortPID.RES
    if pid.startswith(&#39;CVTOMF&#39;):
        return ShortPID.OMF
    if pid.startswith(&#39;CVTPGD&#39;):
        return ShortPID.PGD
    if pid.startswith(&#39;LINKER&#39;):
        return ShortPID.LNK
    if pid.startswith(&#39;EXPORT&#39;):
        return ShortPID.EXP
    if pid.startswith(&#39;IMPORT&#39;):
        return ShortPID.IMP
    if pid.startswith(&#39;IMPLIB&#39;):
        return ShortPID.IMP
    if pid.startswith(&#39;ALIASOBJ&#39;):
        return ShortPID.OBJ
    if pid.startswith(&#39;RESOURCE&#39;):
        return ShortPID.RES
    if pid.startswith(&#39;PHX&#39;):
        return ShortPID.PHX
    if pid.startswith(&#39;PHOENIX&#39;):
        return ShortPID.PHX
    if pid.startswith(&#39;MASM&#39;):
        return ShortPID.ASM
    if pid.startswith(&#39;ILASM&#39;):
        return ShortPID.MIL
    if pid.startswith(&#39;VISUALBASIC&#39;):
        return ShortPID.VB6
    raise LookupError(pid)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.get_rich_info"><code class="name flex">
<span>def <span class="ident">get_rich_info</span></span>(<span>vid)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L132-L146" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_rich_info(vid: int) -&gt; VersionInfo:
    pid = vid &gt;&gt; 0x10
    ver = vid &amp; 0xFFFF
    ver = RICH[&#39;ver&#39;].get(F&#39;{ver:04X}&#39;)
    pid = RICH[&#39;pid&#39;].get(F&#39;{pid:04X}&#39;)
    err = ver is None and pid is None
    if ver is not None:
        suffix = ver.get(&#39;ver&#39;)
        ver = ver[&#39;ide&#39;]
        if suffix:
            ver = F&#39;{ver} {suffix}&#39;
    else:
        ver = &#39;Unknown Version&#39;
    pid = pid or &#39;Unknown Type&#39;
    return VersionInfo(pid, ver, err)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.formats.pe.pemeta.VIT"><code class="flex name class">
<span>class <span class="ident">VIT</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L37-L58" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class VIT(str, Enum):
    ERR = &#39;unknown&#39;
    OBJ = &#39;object file from C&#39;
    CPP = &#39;object file from C++&#39;
    ASM = &#39;object file from assembler&#39;
    RES = &#39;object from CVTRES&#39;
    LNK = &#39;linker version&#39;
    IMP = &#39;dll import in library file&#39;
    EXP = &#39;dll export in library file&#39;

    @property
    def tag(self) -&gt; str:
        if self in (VIT.OBJ, VIT.CPP, VIT.ASM, VIT.RES):
            return &#39;object&#39;
        if self is VIT.IMP:
            return &#39;import&#39;
        if self is VIT.EXP:
            return &#39;export&#39;
        if self is VIT.LNK:
            return &#39;linker&#39;
        else:
            return &#39;unknown&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.VIT.ERR"><code class="name">var <span class="ident">ERR</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VIT.OBJ"><code class="name">var <span class="ident">OBJ</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VIT.CPP"><code class="name">var <span class="ident">CPP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VIT.ASM"><code class="name">var <span class="ident">ASM</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VIT.RES"><code class="name">var <span class="ident">RES</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VIT.LNK"><code class="name">var <span class="ident">LNK</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VIT.IMP"><code class="name">var <span class="ident">IMP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VIT.EXP"><code class="name">var <span class="ident">EXP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.VIT.tag"><code class="name">var <span class="ident">tag</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L47-L58" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def tag(self) -&gt; str:
    if self in (VIT.OBJ, VIT.CPP, VIT.ASM, VIT.RES):
        return &#39;object&#39;
    if self is VIT.IMP:
        return &#39;import&#39;
    if self is VIT.EXP:
        return &#39;export&#39;
    if self is VIT.LNK:
        return &#39;linker&#39;
    else:
        return &#39;unknown&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VersionInfo"><code class="flex name class">
<span>class <span class="ident">VersionInfo</span></span>
<span>(</span><span>pid, ver, err)</span>
</code></dt>
<dd>
<section class="desc"><p>VersionInfo(pid: 'str', ver: 'str', err: 'bool')</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L61-L71" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class VersionInfo:
    pid: str
    ver: str
    err: bool

    def __str__(self):
        return F&#39;{self.ver} [{self.pid.upper()}]&#39;

    def __bool__(self):
        return not self.err</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.VersionInfo.pid"><code class="name">var <span class="ident">pid</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VersionInfo.ver"><code class="name">var <span class="ident">ver</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.VersionInfo.err"><code class="name">var <span class="ident">err</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID"><code class="flex name class">
<span>class <span class="ident">ShortPID</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L78-L94" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ShortPID(str, Enum):
    UTC = &#39;STDLIB&#39; # STDLIBC
    RES = &#39;CVTRES&#39; # Cvt/RES
    OMF = &#39;CVTOMF&#39; # Cvt/OMF
    PGD = &#39;CVTPGD&#39; # Cvt/PGD
    LNK = &#39;LINKER&#39; # Linker
    EXP = &#39;EXPORT&#39; # Exports
    IMP = &#39;IMPORT&#39; # Imports
    OBJ = &#39;OBJECT&#39; # Object
    PHX = &#39;PHOENX&#39; # Phoenix
    ASM = &#39;MASM&#39;   # MASM
    MIL = &#39;MSIL&#39;   # MSIL
    VB6 = &#39;VB6OBJ&#39; # VB6

    def __str__(self):
        width = max(len(item.value) for item in self.__class__)
        return F&#39;{self.value:&gt;{width}}&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.UTC"><code class="name">var <span class="ident">UTC</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.RES"><code class="name">var <span class="ident">RES</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.OMF"><code class="name">var <span class="ident">OMF</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.PGD"><code class="name">var <span class="ident">PGD</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.LNK"><code class="name">var <span class="ident">LNK</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.EXP"><code class="name">var <span class="ident">EXP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.IMP"><code class="name">var <span class="ident">IMP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.OBJ"><code class="name">var <span class="ident">OBJ</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.PHX"><code class="name">var <span class="ident">PHX</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.ASM"><code class="name">var <span class="ident">ASM</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.MIL"><code class="name">var <span class="ident">MIL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.ShortPID.VB6"><code class="name">var <span class="ident">VB6</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta"><code class="flex name class">
<span>class <span class="ident">pemeta</span></span>
<span>(</span><span>custom=False, debug=False, dotnet=False, signatures=False, timestamps=0, version=False, header=False, exports=0, imports=0, tabular=False, timeraw=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Extract metadata from PE files. By default, all information except for imports and exports are
extracted.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L149-L748" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class pemeta(Unit):
    &#34;&#34;&#34;
    Extract metadata from PE files. By default, all information except for imports and exports are
    extracted.
    &#34;&#34;&#34;
    def __init__(
        self,
        custom: Param[bool, Arg(&#39;-c&#39;, &#39;--custom&#39;,
            help=&#39;Unless enabled, all default categories will be extracted.&#39;)] = False,
        debug: Param[bool, Arg.Switch(&#39;-D&#39;,
            help=&#39;Parse the PDB path from the debug directory.&#39;)] = False,
        dotnet: Param[bool, Arg.Switch(&#39;-N&#39;,
            help=&#39;Parse the .NET header.&#39;)] = False,
        signatures: Param[bool, Arg.Switch(&#39;-S&#39;,
            help=&#39;Parse digital signatures.&#39;)] = False,
        timestamps: Param[int, Arg.Counts(&#39;-T&#39;,
            help=&#39;Extract time stamps. Specify twice for more detail.&#39;)] = 0,
        version: Param[bool, Arg.Switch(&#39;-V&#39;,
            help=&#39;Parse the VERSION resource.&#39;)] = False,
        header: Param[bool, Arg.Switch(&#39;-H&#39;,
            help=&#39;Parse base data from the PE header.&#39;)] = False,
        exports: Param[int, Arg.Counts(&#39;-E&#39;,
            help=&#39;List all exported functions. Specify twice to include addresses.&#39;)] = 0,
        imports: Param[int, Arg.Counts(&#39;-I&#39;,
            help=&#39;List all imported functions. Specify twice to include addresses.&#39;)] = 0,
        tabular: Param[bool, Arg.Switch(&#39;-t&#39;,
            help=&#39;Print information in a table rather than as JSON&#39;)] = False,
        timeraw: Param[bool, Arg.Switch(&#39;-r&#39;,
            help=&#39;Extract time stamps as numbers instead of human-readable format.&#39;)] = False,
    ):
        if not custom and not any((debug, dotnet, signatures, timestamps, version, header)):
            debug = dotnet = signatures = timestamps = version = header = True
        super().__init__(
            debug=debug,
            dotnet=dotnet,
            signatures=signatures,
            timestamps=timestamps,
            version=version,
            header=header,
            imports=imports,
            exports=exports,
            timeraw=timeraw,
            tabular=tabular,
        )

    @classmethod
    def handles(cls, data):
        return is_likely_pe(data)

    @classmethod
    def _ensure_string(cls, x):
        if not isinstance(x, str):
            x = repr(x) if not isinstance(x, bytes) else x.decode(cls.codec, &#39;backslashreplace&#39;)
        return x

    @classmethod
    def _parse_pedict(cls, bin: dict):
        return {
            cls._ensure_string(key).replace(&#34; &#34;, &#34;&#34;): cls._ensure_string(val)
            for key, val in bin.items() if val}

    @classmethod
    def parse_signature(cls, data: bytearray) -&gt; dict:
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human-readable dictionary with information about
        time stamp and code signing certificates that are attached to the input PE file.
        &#34;&#34;&#34;
        from refinery.units.formats.pkcs7 import pkcs7

        try:
            signature = data | pkcs7 | json.loads
        except Exception as E:
            raise ValueError(F&#39;PKCS7 parser failed with error: {E!s}&#39;)

        info = {}

        def _value(doc: dict, require_type=None):
            if require_type is not None:
                if doc.get(&#39;type&#39;, None) != require_type:
                    raise LookupError
            value = doc.get(&#39;value&#39;, None)
            value = [value] if value else doc.get(&#39;values&#39;, [])
            if not value:
                raise LookupError
            return value[0]

        def find_timestamps(entry) -&gt; dict:
            if isinstance(entry, dict):
                try:
                    return {&#39;Timestamp&#39;: _value(entry, &#39;signing_time&#39;)}
                except LookupError:
                    pass
                for value in entry.values():
                    result = find_timestamps(value)
                    if result is None:
                        continue
                    with suppress(KeyError):
                        result.setdefault(&#39;TimestampIssuer&#39;, entry[&#39;sid&#39;][&#39;issuer&#39;][&#39;common_name&#39;])
                    return result
            elif isinstance(entry, list):
                for value in entry:
                    result = find_timestamps(value)
                    if result is None:
                        continue
                    return result

        timestamp_info = find_timestamps(signature)
        if timestamp_info is not None:
            info.update(timestamp_info)

        try:
            certificates = signature[&#39;content&#39;][&#39;certificates&#39;]
            signer_infos = signature[&#39;content&#39;][&#39;signer_infos&#39;]
        except KeyError:
            return info

        try:
            signer_serials = {info[&#39;sid&#39;][&#39;serial_number&#39;]: info for info in signer_infos}
        except KeyError:
            return info

        signer_certificates = []

        for certificate in certificates:
            with suppress(Exception):
                crt = certificate[&#39;tbs_certificate&#39;]
                serial = crt[&#39;serial_number&#39;]
                signer = signer_serials[serial]
                if isinstance(serial, int):
                    serial = F&#39;{serial:x}&#39;
                if len(serial) % 2 != 0:
                    serial = F&#39;0{serial}&#39;
                assert bytes.fromhex(serial) in data
                subject = crt[&#39;subject&#39;]
                location = [subject.get(t, &#39;&#39;) for t in (
                    &#39;locality_name&#39;, &#39;state_or_province_name&#39;, &#39;country_name&#39;)]
                cert_info = {}
                cert_info.update(Subject=subject[&#39;common_name&#39;])
                if any(location):
                    cert_info.update(SubjectLocation=&#39;, &#39;.join(filter(None, location)))
                for attr in signer[&#39;signed_attrs&#39;]:
                    if attr[&#39;type&#39;] == &#39;authenticode_info&#39;:
                        auth = _value(attr)
                        cert_info.update(ProgramName=auth[&#39;programName&#39;])
                        cert_info.update(MoreInfo=auth[&#39;moreInfo&#39;])
                try:
                    valid_since = crt[&#39;validity&#39;][&#39;not_before&#39;]
                    valid_until = crt[&#39;validity&#39;][&#39;not_after&#39;]
                except KeyError:
                    pass
                else:
                    cert_info.update(ValidSince=valid_since, ValidUntil=valid_until)
                cert_info.update(
                    Issuer=crt[&#39;issuer&#39;][&#39;common_name&#39;], Fingerprint=certificate[&#39;fingerprint&#39;], Serial=serial)
                signer_certificates.append(cert_info)

        if len(signer_certificates) == 1:
            info.update(signer_certificates[0])
        if len(signer_certificates) &gt;= 2:
            info[&#39;Signer&#39;] = signer_certificates
        return info

    def _pe_characteristics(self, pe: lief.PE.Binary):
        characteristics = {F&#39;IMAGE_FILE_{flag.name}&#39; for flag in lief.PE.Header.CHARACTERISTICS
            if pe.header.characteristics &amp; flag.value}
        if pe.header.characteristics &amp; 0x40:
            # TODO: Missing from LIEF
            characteristics.add(&#39;IMAGE_FILE_16BIT_MACHINE&#39;)
        return characteristics

    def _pe_address_width(self, pe: lief.PE.Binary, default=16) -&gt; int:
        # TODO: missing from LIEF
        IMAGE_FILE_16BIT_MACHINE = 0x40
        if pe.header.characteristics &amp; IMAGE_FILE_16BIT_MACHINE:
            return 4
        elif pe.header.machine == lief.PE.Header.MACHINE_TYPES.I386:
            return 8
        elif pe.header.machine in (
            lief.PE.Header.MACHINE_TYPES.AMD64,
            lief.PE.Header.MACHINE_TYPES.IA64,
        ):
            return 16
        else:
            return default

    def _vint(self, pe: lief.PE.Binary, value: int):
        if not self.args.tabular:
            return value
        aw = self._pe_address_width(pe)
        return F&#39;0x{value:0{aw}X}&#39;

    def parse_version(self, pe: lief.PE.Binary, data=None) -&gt; dict | None:
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human-readable dictionary with information about
        the version resource of an input PE file, if available.
        &#34;&#34;&#34;
        version_info = {}
        rsrc = unwrap(pe.resources_manager)
        if isinstance(rsrc, lief.lib.lief_errors) or not rsrc.has_version:
            return None
        version = rsrc.version[0]

        if info := version.string_file_info:
            for child in info.children:
                entries = {e.key: e.value for e in child.entries}
                version_info.update({
                    k.replace(&#39; &#39;, &#39;&#39;): _STRING(v) for k, v in entries.items()
                })

        if rsrc.has_icons:
            icon = next(iter(rsrc.icons))
            version_info.update(
                LangID=self._vint(pe, icon.lang &lt;&lt; 0x10 | icon.sublang),
                Language=LCID.get(icon.lang, &#39;Language Neutral&#39;),
                Charset=self._CHARSET.get(icon.sublang, &#39;Unknown Charset&#39;),
            )

        def _code_pages(d: lief.PE.ResourceDirectory | lief.PE.ResourceData):
            if isinstance(d, lief.PE.ResourceData):
                yield d.code_page
                return
            for child in d.childs:
                yield from _code_pages(child)

        code_pages: set[int] = set()

        for t in rsrc.types:
            code_pages.update(_code_pages(rsrc.get_node_type(t)))

        if len(code_pages) == 1:
            cp = next(iter(code_pages))
            version_info.update(CodePage=cp)

        def _to_version_string(hi: int, lo: int):
            a = hi &gt;&gt; 0x10
            b = hi &amp; 0xFFFF
            c = lo &gt;&gt; 0x10
            d = lo &amp; 0xFFFF
            return F&#39;{a}.{b}.{c}.{d}&#39;

        # TODO: Missing: Version.CompanyName
        # TODO: Missing: Version.FileDescription
        # TODO: Missing: Version.LegalCopyright
        # TODO: Missing: Version.ProductName

        if info := version.file_info:
            for name, val, T in (
                (&#39;FileType&#39;, info.file_type, info.FILE_TYPE),
                (&#39;OSName&#39;, info.file_os, info.VERSION_OS),
                (&#39;FileSubType&#39;, info.file_subtype, info.FILE_TYPE_DETAILS),
            ):
                if not val:
                    continue
                try:
                    version_info[name] = T(val).name
                except Exception:
                    continue
            if t := info.file_date_ms &lt;&lt; 32 | info.file_date_ls:
                version_info.update(Timestamp=_FILETIME(t))
            version_info.update(
                ProductVersion=_to_version_string(info.product_version_ms, info.product_version_ls),
                FileVersion=_to_version_string(info.file_version_ms, info.file_version_ls),
            )

        if info := version.var_file_info:
            ...

        return version_info or None

    def parse_exports(self, pe: lief.PE.Binary, data=None, include_addresses=False) -&gt; list:
        base = pe.optional_header.imagebase
        info = []
        if not pe.has_exports:
            return None
        for k, exp in enumerate(pe.get_export().entries):
            name = exp.demangled_name
            if not name:
                name = exp.name
            if not name:
                name = F&#39;@{k}&#39;
            if not isinstance(name, str):
                name = name.decode(&#39;latin1&#39;)
            item = {
                &#39;Name&#39;: name, &#39;Address&#39;: self._vint(pe, exp.address + base)
            } if include_addresses else name
            info.append(item)
        return info

    def parse_imports(self, pe: lief.PE.Binary, data=None, include_addresses=False) -&gt; list:
        info = {}
        for idd in itertools.chain(pe.imports, pe.delay_imports):
            dll = _STRING(idd.name)
            if dll.lower().endswith(&#39;.dll&#39;):
                dll = dll[:~3]
            imports: list[str] = info.setdefault(dll, [])
            for imp in idd.entries:
                name = _STRING(imp.name) or F&#39;@{imp.ordinal}&#39;
                imports.append(dict(
                    Name=name, Address=self._vint(pe, imp.value)
                ) if include_addresses else name)
        return info

    def parse_header(self, pe: lief.PE.Binary, data=None) -&gt; dict:
        major = pe.optional_header.major_operating_system_version
        minor = pe.optional_header.minor_operating_system_version
        version = self._WINVER.get(major, {0: &#39;Unknown&#39;})

        try:
            MinimumOS = version[minor]
        except LookupError:
            MinimumOS = version[0]
        header_information = {
            &#39;Machine&#39;: pe.header.machine.name,
            &#39;Subsystem&#39;: pe.optional_header.subsystem.name,
            &#39;MinimumOS&#39;: MinimumOS,
        }
        if pe.has_exports:
            export_name = _STRING(pe.get_export().name)
            if export_name.isprintable():
                header_information[&#39;ExportName&#39;] = export_name

        if pe.has_rich_header:
            rich = []
            if self.args.tabular:
                cw = max(len(F&#39;{entry.count:d}&#39;) for entry in pe.rich_header.entries)
            for entry in pe.rich_header.entries:
                idv = entry.build_id | (entry.id &lt;&lt; 0x10)
                count = entry.count
                info = get_rich_info(idv)
                if not info:
                    continue
                pid = info.pid.upper()
                if self.args.tabular:
                    short_pid = get_rich_short_pid(pid)
                    rich.append(F&#39;[{idv:08x}] {count:&gt;0{cw}d} {short_pid!s} {info.ver}&#39;)
                else:
                    rich.append({
                        &#39;Counter&#39;: count,
                        &#39;Encoded&#39;: F&#39;{idv:08x}&#39;,
                        &#39;Library&#39;: pid,
                        &#39;Product&#39;: info.ver,
                    })
            header_information[&#39;RICH&#39;] = rich

        characteristics = self._pe_characteristics(pe)
        for typespec, flag in {
            &#39;EXE&#39;: &#39;IMAGE_FILE_EXECUTABLE_IMAGE&#39;,
            &#39;DLL&#39;: &#39;IMAGE_FILE_DLL&#39;,
            &#39;SYS&#39;: &#39;IMAGE_FILE_SYSTEM&#39;
        }.items():
            if flag in characteristics:
                header_information[&#39;Type&#39;] = typespec

        base = pe.optional_header.imagebase
        header_information[&#39;ImageBase&#39;] = self._vint(pe, base)
        header_information[&#39;ImageSize&#39;] = self._vint(pe, pe.optional_header.sizeof_image)
        header_information[&#39;ComputedSize&#39;] = get_pe_size(pe)
        header_information[&#39;Bits&#39;] = 4 * self._pe_address_width(pe, 16)
        header_information[&#39;EntryPoint&#39;] = self._vint(pe, pe.optional_header.addressof_entrypoint + base)
        return header_information

    def parse_time_stamps(self, pe: lief.PE.Binary, raw_time_stamps: bool, more_detail: bool) -&gt; dict:
        &#34;&#34;&#34;
        Extracts time stamps from the PE header (link time), as well as from the imports,
        exports, debug, and resource directory. The resource time stamp is also parsed as
        a DOS time stamp and returned as the &#34;Delphi&#34; time stamp.
        &#34;&#34;&#34;
        def _id(x): return x
        dt = _id if raw_time_stamps else date_from_timestamp
        info = {}

        with suppress(AttributeError):
            info.update(Linker=dt(pe.header.time_date_stamps))

        import_timestamps = {}
        for entry in pe.imports:
            ts = entry.timedatestamp
            if ts == 0 or ts == 0xFFFFFFFF:
                continue
            import_timestamps[_STRING(entry.name, True)] = dt(ts)

        symbol_timestamps = {}
        for entry in pe.delay_imports:
            ts = entry.timestamp
            if ts == 0 or ts == 0xFFFFFFFF:
                continue
            symbol_timestamps[_STRING(entry.name, True)] = dt(ts)

        for key, impts in [
            (&#39;Import&#39;, import_timestamps),
            (&#39;Symbol&#39;, symbol_timestamps),
        ]:
            if not impts:
                continue
            if not more_detail:
                dmin = min(impts.values())
                dmax = max(impts.values())
                small_delta = 2 * 60 * 60
                if not raw_time_stamps:
                    small_delta = timedelta(seconds=small_delta)
                if dmax - dmin &lt; small_delta:
                    impts = dmin
            info[key] = impts

        if pe.has_exports and (ts := pe.get_export().timestamp):
            info.update(Export=dt(ts))

        if pe.has_resources and pe.resources.is_directory:
            rsrc: lief.PE.ResourceDirectory = pe.resources
            if res_timestamp := rsrc.time_date_stamp:
                with suppress(ValueError):
                    from refinery.units.misc.datefix import datefix
                    dos = datefix.dostime(res_timestamp)
                    info.update(Delphi=dos)
                    info.update(RsrcTS=dt(res_timestamp))

        def norm(value):
            if isinstance(value, list):
                return [norm(v) for v in value]
            if isinstance(value, dict):
                return {k: norm(v) for k, v in value.items()}
            if isinstance(value, int):
                return value
            return str(value)

        return {key: norm(value) for key, value in info.items()}

    def parse_dotnet(self, pe: lief.PE.Binary, data):
        &#34;&#34;&#34;
        Extracts a JSON-serializable and human-readable dictionary with information about
        the .NET metadata of an input PE file.
        &#34;&#34;&#34;
        header = DotNetHeader(data, pe)
        tables = header.meta.Streams.Tables
        info = dict(
            RuntimeVersion=F&#39;{header.head.MajorRuntimeVersion}.{header.head.MinorRuntimeVersion}&#39;,
            Version=F&#39;{header.meta.MajorVersion}.{header.meta.MinorVersion}&#39;,
            VersionString=header.meta.VersionString
        )

        info[&#39;Flags&#39;] = [name for name, check in header.head.KnownFlags.items() if check]

        if len(tables.Assembly) == 1:
            assembly = tables.Assembly[0]
            info.update(
                AssemblyName=assembly.Name,
                Release=&#39;{}.{}.{}.{}&#39;.format(
                    assembly.MajorVersion,
                    assembly.MinorVersion,
                    assembly.BuildNumber,
                    assembly.RevisionNumber
                )
            )

        try:
            entry = self._vint(pe, header.head.EntryPointToken + pe.optional_header.imagebase)
            info.update(EntryPoint=entry)
        except AttributeError:
            pass

        if len(tables.Module) == 1:
            module = tables.Module[0]
            info.update(ModuleName=module.Name)

        return info

    def parse_debug(self, pe: lief.PE.Binary, data=None):
        result = []
        if not pe.has_debug:
            return None
        for entry in pe.debug:
            if entry.type != lief.PE.Debug.TYPES.CODEVIEW:
                continue
            try:
                entry: lief.PE.CodeViewPDB
                result.append(dict(
                    PdbPath=_STRING(entry.filename),
                    PdbGUID=entry.guid,
                    PdbAge=entry.age,
                ))
            except AttributeError:
                continue
        if len(result) == 1:
            result = result[0]
        return result

    def process(self, data):
        result = {}

        pe = lief.load_pe(
            data,
            parse_exports=True,
            parse_imports=self.args.imports,
            parse_rsrc=self.args.version,
            parse_reloc=False,
            parse_signature=self.args.timestamps or self.args.signatures,
        )

        if pe is None:
            raise ValueError(&#39;Input not recognized as a PE file.&#39;)

        pe = NoLoggingProxy(pe)

        for switch, resolver, name in [
            (self.args.debug,   self.parse_debug,    &#39;Debug&#39;),    # noqa
            (self.args.dotnet,  self.parse_dotnet,   &#39;DotNet&#39;),   # noqa
            (self.args.header,  self.parse_header,   &#39;Header&#39;),   # noqa
            (self.args.version, self.parse_version,  &#39;Version&#39;),  # noqa
            (self.args.imports, self.parse_imports,  &#39;Imports&#39;),  # noqa
            (self.args.exports, self.parse_exports,  &#39;Exports&#39;),  # noqa
        ]:
            if not switch:
                continue
            self.log_debug(F&#39;parsing: {name}&#39;)
            args = pe, data
            if switch &gt; 1:
                args = *args, True
            try:
                info = resolver(*args)
            except Exception as E:
                self.log_info(F&#39;failed to obtain {name}: {E!s}&#39;)
                continue
            if info:
                result[name] = info

        signature = {}

        if self.args.timestamps or self.args.signatures:
            with suppress(Exception):
                from refinery.units.formats.pe.pesig import pesig
                signature = self.parse_signature(next(data | pesig))

        if signature:
            try:
                verification = pe.verify_signature()
            except Exception:
                pass
            else:
                from lief.PE import Signature
                if verification == Signature.VERIFICATION_FLAGS.OK:
                    signature[&#39;IsValid&#39;] = True
                else:
                    signature[&#39;Flags&#39;] = [
                        vf.name for vf in Signature.VERIFICATION_FLAGS if vf &amp; verification]
                    signature[&#39;IsValid&#39;] = False

        if self.args.timestamps:
            ts = self.parse_time_stamps(pe, self.args.timeraw, self.args.timestamps &gt; 1)
            with suppress(KeyError):
                ts.update(Signed=signature[&#39;Timestamp&#39;])
            result.update(TimeStamp=ts)

        if signature and self.args.signatures:
            result[&#39;Signature&#39;] = signature

        if result:
            yield from ppjson(tabular=self.args.tabular)._pretty_output(result, indent=4, ensure_ascii=False)

    _CHARSET = {
        0x0000: &#39;7-bit ASCII&#39;,
        0x03A4: &#39;Japan (Shift ? JIS X-0208)&#39;,
        0x03B5: &#39;Korea (Shift ? KSC 5601)&#39;,
        0x03B6: &#39;Taiwan (Big5)&#39;,
        0x04B0: &#39;Unicode&#39;,
        0x04E2: &#39;Latin-2 (Eastern European)&#39;,
        0x04E3: &#39;Cyrillic&#39;,
        0x04E4: &#39;Multilingual&#39;,
        0x04E5: &#39;Greek&#39;,
        0x04E6: &#39;Turkish&#39;,
        0x04E7: &#39;Hebrew&#39;,
        0x04E8: &#39;Arabic&#39;,
    }

    _WINVER = {
        3: {
            0x00: &#39;Windows NT 3&#39;,
            0x0A: &#39;Windows NT 3.1&#39;,
            0x32: &#39;Windows NT 3.5&#39;,
            0x33: &#39;Windows NT 3.51&#39;,
        },
        4: {
            0x00: &#39;Windows 95&#39;,
            0x0A: &#39;Windows 98&#39;,
        },
        5: {
            0x00: &#39;Windows 2000&#39;,
            0x5A: &#39;Windows Me&#39;,
            0x01: &#39;Windows XP&#39;,
            0x02: &#39;Windows Server 2003&#39;,
        },
        6: {
            0x00: &#39;Windows Vista&#39;,
            0x01: &#39;Windows 7&#39;,
            0x02: &#39;Windows 8&#39;,
            0x03: &#39;Windows 8.1&#39;,
        },
        10: {
            0x00: &#39;Windows 10&#39;,
        }
    }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></li>
<li><a title="refinery.units.Entry" href="../../index.html#refinery.units.Entry">Entry</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.pe.pemeta.pemeta" href="#refinery.units.formats.pe.pemeta.pemeta">pemeta</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.pemeta.required_dependencies"><code class="name">var <span class="ident">required_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.optional_dependencies"><code class="name">var <span class="ident">optional_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.console"><code class="name">var <span class="ident">console</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.reverse"><code class="name">var <span class="ident">reverse</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_signature"><code class="name flex">
<span>def <span class="ident">parse_signature</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts a JSON-serializable and human-readable dictionary with information about
time stamp and code signing certificates that are attached to the input PE file.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_version"><code class="name flex">
<span>def <span class="ident">parse_version</span></span>(<span>self, pe, data=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts a JSON-serializable and human-readable dictionary with information about
the version resource of an input PE file, if available.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L340-L416" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_version(self, pe: lief.PE.Binary, data=None) -&gt; dict | None:
    &#34;&#34;&#34;
    Extracts a JSON-serializable and human-readable dictionary with information about
    the version resource of an input PE file, if available.
    &#34;&#34;&#34;
    version_info = {}
    rsrc = unwrap(pe.resources_manager)
    if isinstance(rsrc, lief.lib.lief_errors) or not rsrc.has_version:
        return None
    version = rsrc.version[0]

    if info := version.string_file_info:
        for child in info.children:
            entries = {e.key: e.value for e in child.entries}
            version_info.update({
                k.replace(&#39; &#39;, &#39;&#39;): _STRING(v) for k, v in entries.items()
            })

    if rsrc.has_icons:
        icon = next(iter(rsrc.icons))
        version_info.update(
            LangID=self._vint(pe, icon.lang &lt;&lt; 0x10 | icon.sublang),
            Language=LCID.get(icon.lang, &#39;Language Neutral&#39;),
            Charset=self._CHARSET.get(icon.sublang, &#39;Unknown Charset&#39;),
        )

    def _code_pages(d: lief.PE.ResourceDirectory | lief.PE.ResourceData):
        if isinstance(d, lief.PE.ResourceData):
            yield d.code_page
            return
        for child in d.childs:
            yield from _code_pages(child)

    code_pages: set[int] = set()

    for t in rsrc.types:
        code_pages.update(_code_pages(rsrc.get_node_type(t)))

    if len(code_pages) == 1:
        cp = next(iter(code_pages))
        version_info.update(CodePage=cp)

    def _to_version_string(hi: int, lo: int):
        a = hi &gt;&gt; 0x10
        b = hi &amp; 0xFFFF
        c = lo &gt;&gt; 0x10
        d = lo &amp; 0xFFFF
        return F&#39;{a}.{b}.{c}.{d}&#39;

    # TODO: Missing: Version.CompanyName
    # TODO: Missing: Version.FileDescription
    # TODO: Missing: Version.LegalCopyright
    # TODO: Missing: Version.ProductName

    if info := version.file_info:
        for name, val, T in (
            (&#39;FileType&#39;, info.file_type, info.FILE_TYPE),
            (&#39;OSName&#39;, info.file_os, info.VERSION_OS),
            (&#39;FileSubType&#39;, info.file_subtype, info.FILE_TYPE_DETAILS),
        ):
            if not val:
                continue
            try:
                version_info[name] = T(val).name
            except Exception:
                continue
        if t := info.file_date_ms &lt;&lt; 32 | info.file_date_ls:
            version_info.update(Timestamp=_FILETIME(t))
        version_info.update(
            ProductVersion=_to_version_string(info.product_version_ms, info.product_version_ls),
            FileVersion=_to_version_string(info.file_version_ms, info.file_version_ls),
        )

    if info := version.var_file_info:
        ...

    return version_info or None</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_exports"><code class="name flex">
<span>def <span class="ident">parse_exports</span></span>(<span>self, pe, data=None, include_addresses=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L418-L435" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_exports(self, pe: lief.PE.Binary, data=None, include_addresses=False) -&gt; list:
    base = pe.optional_header.imagebase
    info = []
    if not pe.has_exports:
        return None
    for k, exp in enumerate(pe.get_export().entries):
        name = exp.demangled_name
        if not name:
            name = exp.name
        if not name:
            name = F&#39;@{k}&#39;
        if not isinstance(name, str):
            name = name.decode(&#39;latin1&#39;)
        item = {
            &#39;Name&#39;: name, &#39;Address&#39;: self._vint(pe, exp.address + base)
        } if include_addresses else name
        info.append(item)
    return info</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_imports"><code class="name flex">
<span>def <span class="ident">parse_imports</span></span>(<span>self, pe, data=None, include_addresses=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L437-L449" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_imports(self, pe: lief.PE.Binary, data=None, include_addresses=False) -&gt; list:
    info = {}
    for idd in itertools.chain(pe.imports, pe.delay_imports):
        dll = _STRING(idd.name)
        if dll.lower().endswith(&#39;.dll&#39;):
            dll = dll[:~3]
        imports: list[str] = info.setdefault(dll, [])
        for imp in idd.entries:
            name = _STRING(imp.name) or F&#39;@{imp.ordinal}&#39;
            imports.append(dict(
                Name=name, Address=self._vint(pe, imp.value)
            ) if include_addresses else name)
    return info</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_header"><code class="name flex">
<span>def <span class="ident">parse_header</span></span>(<span>self, pe, data=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L451-L508" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_header(self, pe: lief.PE.Binary, data=None) -&gt; dict:
    major = pe.optional_header.major_operating_system_version
    minor = pe.optional_header.minor_operating_system_version
    version = self._WINVER.get(major, {0: &#39;Unknown&#39;})

    try:
        MinimumOS = version[minor]
    except LookupError:
        MinimumOS = version[0]
    header_information = {
        &#39;Machine&#39;: pe.header.machine.name,
        &#39;Subsystem&#39;: pe.optional_header.subsystem.name,
        &#39;MinimumOS&#39;: MinimumOS,
    }
    if pe.has_exports:
        export_name = _STRING(pe.get_export().name)
        if export_name.isprintable():
            header_information[&#39;ExportName&#39;] = export_name

    if pe.has_rich_header:
        rich = []
        if self.args.tabular:
            cw = max(len(F&#39;{entry.count:d}&#39;) for entry in pe.rich_header.entries)
        for entry in pe.rich_header.entries:
            idv = entry.build_id | (entry.id &lt;&lt; 0x10)
            count = entry.count
            info = get_rich_info(idv)
            if not info:
                continue
            pid = info.pid.upper()
            if self.args.tabular:
                short_pid = get_rich_short_pid(pid)
                rich.append(F&#39;[{idv:08x}] {count:&gt;0{cw}d} {short_pid!s} {info.ver}&#39;)
            else:
                rich.append({
                    &#39;Counter&#39;: count,
                    &#39;Encoded&#39;: F&#39;{idv:08x}&#39;,
                    &#39;Library&#39;: pid,
                    &#39;Product&#39;: info.ver,
                })
        header_information[&#39;RICH&#39;] = rich

    characteristics = self._pe_characteristics(pe)
    for typespec, flag in {
        &#39;EXE&#39;: &#39;IMAGE_FILE_EXECUTABLE_IMAGE&#39;,
        &#39;DLL&#39;: &#39;IMAGE_FILE_DLL&#39;,
        &#39;SYS&#39;: &#39;IMAGE_FILE_SYSTEM&#39;
    }.items():
        if flag in characteristics:
            header_information[&#39;Type&#39;] = typespec

    base = pe.optional_header.imagebase
    header_information[&#39;ImageBase&#39;] = self._vint(pe, base)
    header_information[&#39;ImageSize&#39;] = self._vint(pe, pe.optional_header.sizeof_image)
    header_information[&#39;ComputedSize&#39;] = get_pe_size(pe)
    header_information[&#39;Bits&#39;] = 4 * self._pe_address_width(pe, 16)
    header_information[&#39;EntryPoint&#39;] = self._vint(pe, pe.optional_header.addressof_entrypoint + base)
    return header_information</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_time_stamps"><code class="name flex">
<span>def <span class="ident">parse_time_stamps</span></span>(<span>self, pe, raw_time_stamps, more_detail)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts time stamps from the PE header (link time), as well as from the imports,
exports, debug, and resource directory. The resource time stamp is also parsed as
a DOS time stamp and returned as the "Delphi" time stamp.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L510-L574" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_time_stamps(self, pe: lief.PE.Binary, raw_time_stamps: bool, more_detail: bool) -&gt; dict:
    &#34;&#34;&#34;
    Extracts time stamps from the PE header (link time), as well as from the imports,
    exports, debug, and resource directory. The resource time stamp is also parsed as
    a DOS time stamp and returned as the &#34;Delphi&#34; time stamp.
    &#34;&#34;&#34;
    def _id(x): return x
    dt = _id if raw_time_stamps else date_from_timestamp
    info = {}

    with suppress(AttributeError):
        info.update(Linker=dt(pe.header.time_date_stamps))

    import_timestamps = {}
    for entry in pe.imports:
        ts = entry.timedatestamp
        if ts == 0 or ts == 0xFFFFFFFF:
            continue
        import_timestamps[_STRING(entry.name, True)] = dt(ts)

    symbol_timestamps = {}
    for entry in pe.delay_imports:
        ts = entry.timestamp
        if ts == 0 or ts == 0xFFFFFFFF:
            continue
        symbol_timestamps[_STRING(entry.name, True)] = dt(ts)

    for key, impts in [
        (&#39;Import&#39;, import_timestamps),
        (&#39;Symbol&#39;, symbol_timestamps),
    ]:
        if not impts:
            continue
        if not more_detail:
            dmin = min(impts.values())
            dmax = max(impts.values())
            small_delta = 2 * 60 * 60
            if not raw_time_stamps:
                small_delta = timedelta(seconds=small_delta)
            if dmax - dmin &lt; small_delta:
                impts = dmin
        info[key] = impts

    if pe.has_exports and (ts := pe.get_export().timestamp):
        info.update(Export=dt(ts))

    if pe.has_resources and pe.resources.is_directory:
        rsrc: lief.PE.ResourceDirectory = pe.resources
        if res_timestamp := rsrc.time_date_stamp:
            with suppress(ValueError):
                from refinery.units.misc.datefix import datefix
                dos = datefix.dostime(res_timestamp)
                info.update(Delphi=dos)
                info.update(RsrcTS=dt(res_timestamp))

    def norm(value):
        if isinstance(value, list):
            return [norm(v) for v in value]
        if isinstance(value, dict):
            return {k: norm(v) for k, v in value.items()}
        if isinstance(value, int):
            return value
        return str(value)

    return {key: norm(value) for key, value in info.items()}</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_dotnet"><code class="name flex">
<span>def <span class="ident">parse_dotnet</span></span>(<span>self, pe, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts a JSON-serializable and human-readable dictionary with information about
the .NET metadata of an input PE file.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L576-L613" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_dotnet(self, pe: lief.PE.Binary, data):
    &#34;&#34;&#34;
    Extracts a JSON-serializable and human-readable dictionary with information about
    the .NET metadata of an input PE file.
    &#34;&#34;&#34;
    header = DotNetHeader(data, pe)
    tables = header.meta.Streams.Tables
    info = dict(
        RuntimeVersion=F&#39;{header.head.MajorRuntimeVersion}.{header.head.MinorRuntimeVersion}&#39;,
        Version=F&#39;{header.meta.MajorVersion}.{header.meta.MinorVersion}&#39;,
        VersionString=header.meta.VersionString
    )

    info[&#39;Flags&#39;] = [name for name, check in header.head.KnownFlags.items() if check]

    if len(tables.Assembly) == 1:
        assembly = tables.Assembly[0]
        info.update(
            AssemblyName=assembly.Name,
            Release=&#39;{}.{}.{}.{}&#39;.format(
                assembly.MajorVersion,
                assembly.MinorVersion,
                assembly.BuildNumber,
                assembly.RevisionNumber
            )
        )

    try:
        entry = self._vint(pe, header.head.EntryPointToken + pe.optional_header.imagebase)
        info.update(EntryPoint=entry)
    except AttributeError:
        pass

    if len(tables.Module) == 1:
        module = tables.Module[0]
        info.update(ModuleName=module.Name)

    return info</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.pe.pemeta.pemeta.parse_debug"><code class="name flex">
<span>def <span class="ident">parse_debug</span></span>(<span>self, pe, data=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/pe/pemeta.py#L615-L633" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_debug(self, pe: lief.PE.Binary, data=None):
    result = []
    if not pe.has_debug:
        return None
    for entry in pe.debug:
        if entry.type != lief.PE.Debug.TYPES.CODEVIEW:
            continue
        try:
            entry: lief.PE.CodeViewPDB
            result.append(dict(
                PdbPath=_STRING(entry.filename),
                PdbGUID=entry.guid,
                PdbAge=entry.age,
            ))
        except AttributeError:
            continue
    if len(result) == 1:
        result = result[0]
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.handles" href="../../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.Requires" href="../../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.Unit.assemble" href="../../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.Unit.finish" href="../../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.Unit.is_quiet" href="../../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.Unit.labelled" href="../../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.Unit.leniency" href="../../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.Unit.log_always" href="../../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.Unit.log_debug" href="../../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.Unit.log_detach" href="../../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.Unit.log_fail" href="../../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.Unit.log_info" href="../../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.Unit.log_level" href="../../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.Unit.log_warn" href="../../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.Unit.nozzle" href="../../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.Unit.read" href="../../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.Unit.read1" href="../../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.Unit.run" href="../../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.Unit.source" href="../../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.Unit.superinit" href="../../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.process" href="../../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.filter" href="../../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.formats.pe" href="index.html">refinery.units.formats.pe</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.units.formats.pe.pemeta.get_rich_short_pid" href="#refinery.units.formats.pe.pemeta.get_rich_short_pid">get_rich_short_pid</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.get_rich_info" href="#refinery.units.formats.pe.pemeta.get_rich_info">get_rich_info</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.formats.pe.pemeta.VIT" href="#refinery.units.formats.pe.pemeta.VIT">VIT</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.pe.pemeta.VersionInfo" href="#refinery.units.formats.pe.pemeta.VersionInfo">VersionInfo</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.pe.pemeta.ShortPID" href="#refinery.units.formats.pe.pemeta.ShortPID">ShortPID</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.pe.pemeta.pemeta" href="#refinery.units.formats.pe.pemeta.pemeta">pemeta</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_signature" href="#refinery.units.formats.pe.pemeta.pemeta.parse_signature">parse_signature</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_version" href="#refinery.units.formats.pe.pemeta.pemeta.parse_version">parse_version</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_exports" href="#refinery.units.formats.pe.pemeta.pemeta.parse_exports">parse_exports</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_imports" href="#refinery.units.formats.pe.pemeta.pemeta.parse_imports">parse_imports</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_header" href="#refinery.units.formats.pe.pemeta.pemeta.parse_header">parse_header</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_time_stamps" href="#refinery.units.formats.pe.pemeta.pemeta.parse_time_stamps">parse_time_stamps</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_dotnet" href="#refinery.units.formats.pe.pemeta.pemeta.parse_dotnet">parse_dotnet</a></code></li>
<li><code><a title="refinery.units.formats.pe.pemeta.pemeta.parse_debug" href="#refinery.units.formats.pe.pemeta.pemeta.parse_debug">parse_debug</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
