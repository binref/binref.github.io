<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.units.formats.java.jvdasm documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.formats.java.jvdasm</code></h1>
</header>
<section id="section-intro">
<p>Java disassembler. The main logic is implemented int <code><a title="refinery.lib.java.JvOpCode" href="../../../lib/java.html#refinery.lib.java.JvOpCode">JvOpCode</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/java/jvdasm.py#L1-L215" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Java disassembler. The main logic is implemented int `refinery.lib.java.JvOpCode`.
&#34;&#34;&#34;
from __future__ import annotations

import collections
import io
import re

from refinery.lib.java import (
    JvBaseType,
    JvClassFile,
    JvClassMember,
    JvClassProperty,
    JvCode,
    JvString,
    JvTypePath,
    opc,
)
from refinery.lib.types import Param
from refinery.units.formats import Arg, PathExtractorUnit, UnpackResult


def _parse_descriptor(
    descriptor: str,
    color_reset: str,
    color_space: str,
    color_types: str,
    color_array: str,
):
    def parse_type_list(args: str):
        while args:
            suffix = &#39;&#39;
            while args.startswith(&#39;[&#39;):
                args = args[1:]
                suffix += &#39;[]&#39;
            code, args = args[0], args[1:]
            if code == &#39;L&#39;:
                spec, _, args = args.partition(&#39;;&#39;)
                *ns, t = spec.split(&#39;/&#39;)
                ns = &#39;.&#39;.join([F&#39;{color_space}{part}{color_reset}&#39; for part in ns])
                spec = F&#39;{ns}.{color_types}{t}{color_reset}&#39;
            else:
                spec = {
                    &#39;Z&#39;: &#39;boolean&#39;,
                    &#39;B&#39;: &#39;byte&#39;,
                    &#39;S&#39;: &#39;short&#39;,
                    &#39;I&#39;: &#39;int&#39;,
                    &#39;J&#39;: &#39;long&#39;,
                    &#39;F&#39;: &#39;float&#39;,
                    &#39;D&#39;: &#39;double&#39;,
                    &#39;C&#39;: &#39;char&#39;,
                    &#39;V&#39;: &#39;void&#39;,
                }[code]
                spec = F&#39;{color_types}{spec}{color_reset}&#39;
            yield F&#39;{spec}{color_array}{suffix}{color_reset}&#39;

    args, retval = re.match(R&#39;^\((.*?)\)(.*?)$&#39;, descriptor).groups()
    retval, = parse_type_list(retval)
    return retval, tuple(parse_type_list(args))


class jvdasm(PathExtractorUnit):
    &#34;&#34;&#34;
    Disassembles the JVM bytecode instructions of methods of classes defined in Java class
    files. The unit is implemented as a path extractor and each path name corresponds to the
    name of one method defined in the class file.
    &#34;&#34;&#34;
    _OPC_STRLEN = max(len(op.name) for op in opc)

    def _hex(self, bytestring, sep=&#39;&#39;):
        return sep.join(F&#39;{x:02x}&#39; for x in bytestring)

    def __init__(
        self, *paths,
        gray: Param[bool, Arg.Switch(&#39;-g&#39;, help=&#39;Disable colored output.&#39;)] = False,
        **keywords
    ):
        super().__init__(*paths, gray=gray, **keywords)

    def unpack(self, data):
        def _name(method: JvClassMember):
            name = method.name
            if name == &#39;&lt;init&gt;&#39;:
                _, _, name = str(jc.this).rpartition(&#39;/&#39;)
            elif m := re.fullmatch(&#39;&lt;(.*?)&gt;&#39;, name):
                name = F&#39;.{m[0]}&#39;
            return name

        def _path(method: JvClassMember):
            return F&#39;{jc.this!s}/{_name(method)}&#39;
        try:
            if self.args.gray or not self.isatty():
                raise ImportError
            import colorama
        except ImportError:
            class _FG():
                def __getattr__(self, _):
                    return &#39;&#39;
            FG = _FG()
            RS = &#39;&#39;
        else:
            FG = colorama.Fore
            RS = colorama.Style.RESET_ALL
        finally:
            c_none = RS
            c_space = FG.LIGHTCYAN_EX
            c_types = FG.LIGHTCYAN_EX
            c_member = FG.LIGHTYELLOW_EX
            c_kwd = FG.LIGHTYELLOW_EX
            c_const = FG.LIGHTRED_EX
            c_string = FG.LIGHTRED_EX
            c_address = FG.LIGHTBLACK_EX
            c_label = RS

        def _color(arg, offset):
            if isinstance(arg, (str, JvString)):
                color = c_string
            elif isinstance(arg, (JvClassProperty, JvTypePath)):
                ns, dd, prop = str(arg).partition(&#39;::&#39;)
                if not dd:
                    return repr(arg)
                ns = ns.split(&#39;.&#39;)
                ns = &#39;.&#39;.join(F&#39;{c_space}{p}{c_none}&#39; for p in ns)
                return F&#39;{ns}{dd}{c_member}{prop}{c_none}&#39;
            elif isinstance(arg, int) and arg + offset in labels:
                return F&#39;{c_label}0x{arg + offset:08X}{c_none}&#39;
            elif isinstance(arg, (bool, int, float)):
                color = c_const
            elif isinstance(arg, JvBaseType):
                color = c_kwd
            else:
                return repr(arg)
            return F&#39;{color}{arg!r}{c_none}&#39;

        jc = JvClassFile(data)
        tab = &#39; &#39;
        namespace = &#39;.&#39;.join(str(jc.this).split(&#39;/&#39;))
        opcw = self._OPC_STRLEN
        path_counter = collections.defaultdict(int)
        path_index = collections.defaultdict(int)

        for method in jc.methods:
            path_counter[_path(method)] += 1
        for method in jc.methods:
            for attribute in method.attributes:
                if attribute.name == &#39;Code&#39;:
                    break
            else:
                self.log_warn(F&#39;no code found for method: {method.name}&#39;)
                continue
            code: JvCode = attribute.parse(JvCode)
            with io.StringIO() as display:
                rv, args = _parse_descriptor(method.descriptor, c_none, c_space, c_types, c_kwd)
                args = &#39;, &#39;.join(args)
                print(
                    F&#39;{c_types}{rv}{c_none} {c_space}{namespace}{c_none}&#39;
                    F&#39;::{c_member}{_name(method)}{c_none}({args})&#39;, file=display)
                offset = 0
                labels = set()
                addresses = set()

                for op in code.disassembly:
                    addresses.add(offset)
                    if op.table:
                        labels.update(offset + jmp for jmp in op.table.values())
                    elif op.code in (opc.goto, opc.goto_w):
                        labels.update(offset + arg for arg in op.arguments if isinstance(arg, int))
                    offset += len(op.raw)

                offset = 0
                labels = labels &amp; addresses

                for op in code.disassembly:
                    if offset in labels:
                        label = F&#39;{c_label}{offset:08X}{c_none}:&#39;
                    else:
                        label = F&#39;{c_address}{offset:08X}{c_none}:&#39;
                    addr = offset
                    olen = len(op.raw)
                    offset += olen
                    if op.table is None:
                        args = &#39;, &#39;.join(_color(a, addr) for a in op.arguments)
                    else:
                        ow = 4 if op.code is opc.tableswitch else 8
                        olen = olen - (len(op.table) - 1) * ow
                        args = F&#39;___default =&gt; {c_label}{op.table[None] + addr:#010x}{c_none}&#39;
                        jmps = []
                        for k, (key, jmp) in enumerate(op.table.items()):
                            if key is None:
                                continue
                            raw = self._hex(op.raw[olen + k * ow: olen + k * ow + ow], &#39; &#39;)
                            jmps.append(
                                F&#39;{label}{tab}&#39;
                                F&#39;{raw!s:&lt;{opcw + 15}} &#39;
                                F&#39;{c_const}{key:#010x}{c_none} =&gt; &#39;
                                F&#39;{c_label}{jmp + addr:#010x}{c_none}&#39;)
                        args = &#39;\n&#39;.join((args, *jmps))
                    opch = self._hex(op.raw[:olen], &#39; &#39;)
                    if len(opch) &gt; 14:
                        opch += F&#39;\n{label}{tab}{tab:&lt;15}&#39;
                    print(
                        F&#39;{label}{tab}&#39;
                        F&#39;{opch:&lt;15}&#39;
                        F&#39;{c_kwd}{op.code!r:&lt;{opcw}}{c_none} {args}&#39;, file=display)
                path = _path(method)
                if path_counter[path] &gt; 1:
                    k = path_index[path]
                    path_index[path] = k + 1
                    path = F&#39;{path}[{k}]&#39;
                yield UnpackResult(path, display.getvalue().encode(self.codec))

    @classmethod
    def handles(cls, data):
        return data.startswith(B&#39;\xCA\xFE\xBA\xBE&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.formats.java.jvdasm.jvdasm"><code class="flex name class">
<span>class <span class="ident">jvdasm</span></span>
<span>(</span><span>*paths, gray=False, path=b'path', regex=False, exact=False, fuzzy=0, drop_path=False, join_path=False, list=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Disassembles the JVM bytecode instructions of methods of classes defined in Java class
files. The unit is implemented as a path extractor and each path name corresponds to the
name of one method defined in the class file.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/java/jvdasm.py#L63-L215" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class jvdasm(PathExtractorUnit):
    &#34;&#34;&#34;
    Disassembles the JVM bytecode instructions of methods of classes defined in Java class
    files. The unit is implemented as a path extractor and each path name corresponds to the
    name of one method defined in the class file.
    &#34;&#34;&#34;
    _OPC_STRLEN = max(len(op.name) for op in opc)

    def _hex(self, bytestring, sep=&#39;&#39;):
        return sep.join(F&#39;{x:02x}&#39; for x in bytestring)

    def __init__(
        self, *paths,
        gray: Param[bool, Arg.Switch(&#39;-g&#39;, help=&#39;Disable colored output.&#39;)] = False,
        **keywords
    ):
        super().__init__(*paths, gray=gray, **keywords)

    def unpack(self, data):
        def _name(method: JvClassMember):
            name = method.name
            if name == &#39;&lt;init&gt;&#39;:
                _, _, name = str(jc.this).rpartition(&#39;/&#39;)
            elif m := re.fullmatch(&#39;&lt;(.*?)&gt;&#39;, name):
                name = F&#39;.{m[0]}&#39;
            return name

        def _path(method: JvClassMember):
            return F&#39;{jc.this!s}/{_name(method)}&#39;
        try:
            if self.args.gray or not self.isatty():
                raise ImportError
            import colorama
        except ImportError:
            class _FG():
                def __getattr__(self, _):
                    return &#39;&#39;
            FG = _FG()
            RS = &#39;&#39;
        else:
            FG = colorama.Fore
            RS = colorama.Style.RESET_ALL
        finally:
            c_none = RS
            c_space = FG.LIGHTCYAN_EX
            c_types = FG.LIGHTCYAN_EX
            c_member = FG.LIGHTYELLOW_EX
            c_kwd = FG.LIGHTYELLOW_EX
            c_const = FG.LIGHTRED_EX
            c_string = FG.LIGHTRED_EX
            c_address = FG.LIGHTBLACK_EX
            c_label = RS

        def _color(arg, offset):
            if isinstance(arg, (str, JvString)):
                color = c_string
            elif isinstance(arg, (JvClassProperty, JvTypePath)):
                ns, dd, prop = str(arg).partition(&#39;::&#39;)
                if not dd:
                    return repr(arg)
                ns = ns.split(&#39;.&#39;)
                ns = &#39;.&#39;.join(F&#39;{c_space}{p}{c_none}&#39; for p in ns)
                return F&#39;{ns}{dd}{c_member}{prop}{c_none}&#39;
            elif isinstance(arg, int) and arg + offset in labels:
                return F&#39;{c_label}0x{arg + offset:08X}{c_none}&#39;
            elif isinstance(arg, (bool, int, float)):
                color = c_const
            elif isinstance(arg, JvBaseType):
                color = c_kwd
            else:
                return repr(arg)
            return F&#39;{color}{arg!r}{c_none}&#39;

        jc = JvClassFile(data)
        tab = &#39; &#39;
        namespace = &#39;.&#39;.join(str(jc.this).split(&#39;/&#39;))
        opcw = self._OPC_STRLEN
        path_counter = collections.defaultdict(int)
        path_index = collections.defaultdict(int)

        for method in jc.methods:
            path_counter[_path(method)] += 1
        for method in jc.methods:
            for attribute in method.attributes:
                if attribute.name == &#39;Code&#39;:
                    break
            else:
                self.log_warn(F&#39;no code found for method: {method.name}&#39;)
                continue
            code: JvCode = attribute.parse(JvCode)
            with io.StringIO() as display:
                rv, args = _parse_descriptor(method.descriptor, c_none, c_space, c_types, c_kwd)
                args = &#39;, &#39;.join(args)
                print(
                    F&#39;{c_types}{rv}{c_none} {c_space}{namespace}{c_none}&#39;
                    F&#39;::{c_member}{_name(method)}{c_none}({args})&#39;, file=display)
                offset = 0
                labels = set()
                addresses = set()

                for op in code.disassembly:
                    addresses.add(offset)
                    if op.table:
                        labels.update(offset + jmp for jmp in op.table.values())
                    elif op.code in (opc.goto, opc.goto_w):
                        labels.update(offset + arg for arg in op.arguments if isinstance(arg, int))
                    offset += len(op.raw)

                offset = 0
                labels = labels &amp; addresses

                for op in code.disassembly:
                    if offset in labels:
                        label = F&#39;{c_label}{offset:08X}{c_none}:&#39;
                    else:
                        label = F&#39;{c_address}{offset:08X}{c_none}:&#39;
                    addr = offset
                    olen = len(op.raw)
                    offset += olen
                    if op.table is None:
                        args = &#39;, &#39;.join(_color(a, addr) for a in op.arguments)
                    else:
                        ow = 4 if op.code is opc.tableswitch else 8
                        olen = olen - (len(op.table) - 1) * ow
                        args = F&#39;___default =&gt; {c_label}{op.table[None] + addr:#010x}{c_none}&#39;
                        jmps = []
                        for k, (key, jmp) in enumerate(op.table.items()):
                            if key is None:
                                continue
                            raw = self._hex(op.raw[olen + k * ow: olen + k * ow + ow], &#39; &#39;)
                            jmps.append(
                                F&#39;{label}{tab}&#39;
                                F&#39;{raw!s:&lt;{opcw + 15}} &#39;
                                F&#39;{c_const}{key:#010x}{c_none} =&gt; &#39;
                                F&#39;{c_label}{jmp + addr:#010x}{c_none}&#39;)
                        args = &#39;\n&#39;.join((args, *jmps))
                    opch = self._hex(op.raw[:olen], &#39; &#39;)
                    if len(opch) &gt; 14:
                        opch += F&#39;\n{label}{tab}{tab:&lt;15}&#39;
                    print(
                        F&#39;{label}{tab}&#39;
                        F&#39;{opch:&lt;15}&#39;
                        F&#39;{c_kwd}{op.code!r:&lt;{opcw}}{c_none} {args}&#39;, file=display)
                path = _path(method)
                if path_counter[path] &gt; 1:
                    k = path_index[path]
                    path_index[path] = k + 1
                    path = F&#39;{path}[{k}]&#39;
                yield UnpackResult(path, display.getvalue().encode(self.codec))

    @classmethod
    def handles(cls, data):
        return data.startswith(B&#39;\xCA\xFE\xBA\xBE&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.PathExtractorUnit" href="../index.html#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></li>
<li><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></li>
<li><a title="refinery.units.Entry" href="../../index.html#refinery.units.Entry">Entry</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.java.jvdasm.jvdasm" href="#refinery.units.formats.java.jvdasm.jvdasm">jvdasm</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.java.jvdasm.jvdasm.required_dependencies"><code class="name">var <span class="ident">required_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.java.jvdasm.jvdasm.optional_dependencies"><code class="name">var <span class="ident">optional_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.java.jvdasm.jvdasm.console"><code class="name">var <span class="ident">console</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.java.jvdasm.jvdasm.reverse"><code class="name">var <span class="ident">reverse</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.java.jvdasm.jvdasm.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/java/jvdasm.py#L81-L211" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpack(self, data):
    def _name(method: JvClassMember):
        name = method.name
        if name == &#39;&lt;init&gt;&#39;:
            _, _, name = str(jc.this).rpartition(&#39;/&#39;)
        elif m := re.fullmatch(&#39;&lt;(.*?)&gt;&#39;, name):
            name = F&#39;.{m[0]}&#39;
        return name

    def _path(method: JvClassMember):
        return F&#39;{jc.this!s}/{_name(method)}&#39;
    try:
        if self.args.gray or not self.isatty():
            raise ImportError
        import colorama
    except ImportError:
        class _FG():
            def __getattr__(self, _):
                return &#39;&#39;
        FG = _FG()
        RS = &#39;&#39;
    else:
        FG = colorama.Fore
        RS = colorama.Style.RESET_ALL
    finally:
        c_none = RS
        c_space = FG.LIGHTCYAN_EX
        c_types = FG.LIGHTCYAN_EX
        c_member = FG.LIGHTYELLOW_EX
        c_kwd = FG.LIGHTYELLOW_EX
        c_const = FG.LIGHTRED_EX
        c_string = FG.LIGHTRED_EX
        c_address = FG.LIGHTBLACK_EX
        c_label = RS

    def _color(arg, offset):
        if isinstance(arg, (str, JvString)):
            color = c_string
        elif isinstance(arg, (JvClassProperty, JvTypePath)):
            ns, dd, prop = str(arg).partition(&#39;::&#39;)
            if not dd:
                return repr(arg)
            ns = ns.split(&#39;.&#39;)
            ns = &#39;.&#39;.join(F&#39;{c_space}{p}{c_none}&#39; for p in ns)
            return F&#39;{ns}{dd}{c_member}{prop}{c_none}&#39;
        elif isinstance(arg, int) and arg + offset in labels:
            return F&#39;{c_label}0x{arg + offset:08X}{c_none}&#39;
        elif isinstance(arg, (bool, int, float)):
            color = c_const
        elif isinstance(arg, JvBaseType):
            color = c_kwd
        else:
            return repr(arg)
        return F&#39;{color}{arg!r}{c_none}&#39;

    jc = JvClassFile(data)
    tab = &#39; &#39;
    namespace = &#39;.&#39;.join(str(jc.this).split(&#39;/&#39;))
    opcw = self._OPC_STRLEN
    path_counter = collections.defaultdict(int)
    path_index = collections.defaultdict(int)

    for method in jc.methods:
        path_counter[_path(method)] += 1
    for method in jc.methods:
        for attribute in method.attributes:
            if attribute.name == &#39;Code&#39;:
                break
        else:
            self.log_warn(F&#39;no code found for method: {method.name}&#39;)
            continue
        code: JvCode = attribute.parse(JvCode)
        with io.StringIO() as display:
            rv, args = _parse_descriptor(method.descriptor, c_none, c_space, c_types, c_kwd)
            args = &#39;, &#39;.join(args)
            print(
                F&#39;{c_types}{rv}{c_none} {c_space}{namespace}{c_none}&#39;
                F&#39;::{c_member}{_name(method)}{c_none}({args})&#39;, file=display)
            offset = 0
            labels = set()
            addresses = set()

            for op in code.disassembly:
                addresses.add(offset)
                if op.table:
                    labels.update(offset + jmp for jmp in op.table.values())
                elif op.code in (opc.goto, opc.goto_w):
                    labels.update(offset + arg for arg in op.arguments if isinstance(arg, int))
                offset += len(op.raw)

            offset = 0
            labels = labels &amp; addresses

            for op in code.disassembly:
                if offset in labels:
                    label = F&#39;{c_label}{offset:08X}{c_none}:&#39;
                else:
                    label = F&#39;{c_address}{offset:08X}{c_none}:&#39;
                addr = offset
                olen = len(op.raw)
                offset += olen
                if op.table is None:
                    args = &#39;, &#39;.join(_color(a, addr) for a in op.arguments)
                else:
                    ow = 4 if op.code is opc.tableswitch else 8
                    olen = olen - (len(op.table) - 1) * ow
                    args = F&#39;___default =&gt; {c_label}{op.table[None] + addr:#010x}{c_none}&#39;
                    jmps = []
                    for k, (key, jmp) in enumerate(op.table.items()):
                        if key is None:
                            continue
                        raw = self._hex(op.raw[olen + k * ow: olen + k * ow + ow], &#39; &#39;)
                        jmps.append(
                            F&#39;{label}{tab}&#39;
                            F&#39;{raw!s:&lt;{opcw + 15}} &#39;
                            F&#39;{c_const}{key:#010x}{c_none} =&gt; &#39;
                            F&#39;{c_label}{jmp + addr:#010x}{c_none}&#39;)
                    args = &#39;\n&#39;.join((args, *jmps))
                opch = self._hex(op.raw[:olen], &#39; &#39;)
                if len(opch) &gt; 14:
                    opch += F&#39;\n{label}{tab}{tab:&lt;15}&#39;
                print(
                    F&#39;{label}{tab}&#39;
                    F&#39;{opch:&lt;15}&#39;
                    F&#39;{c_kwd}{op.code!r:&lt;{opcw}}{c_none} {args}&#39;, file=display)
            path = _path(method)
            if path_counter[path] &gt; 1:
                k = path_index[path]
                path_index[path] = k + 1
                path = F&#39;{path}[{k}]&#39;
            yield UnpackResult(path, display.getvalue().encode(self.codec))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.formats.PathExtractorUnit" href="../index.html#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.formats.PathExtractorUnit.CustomPathSeparator" href="../index.html#refinery.units.formats.PathExtractorUnit.CustomPathSeparator">CustomPathSeparator</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.Requires" href="../../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.assemble" href="../../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.filter" href="../../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.finish" href="../../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.handles" href="../../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.is_quiet" href="../../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.labelled" href="../../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.leniency" href="../../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_always" href="../../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_debug" href="../../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_detach" href="../../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_fail" href="../../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_info" href="../../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_level" href="../../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_warn" href="../../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.nozzle" href="../../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.read" href="../../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.read1" href="../../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.run" href="../../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.source" href="../../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.superinit" href="../../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.process" href="../../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.formats.java" href="index.html">refinery.units.formats.java</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.formats.java.jvdasm.jvdasm" href="#refinery.units.formats.java.jvdasm.jvdasm">jvdasm</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.java.jvdasm.jvdasm.unpack" href="#refinery.units.formats.java.jvdasm.jvdasm.unpack">unpack</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
