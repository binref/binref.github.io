<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.units.formats.archive.xtzpaq documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.formats.archive.xtzpaq</code></h1>
</header>
<section id="section-intro">
<p>This code was ported directly from unzpaq.cpp; it is not very Pythonic and has inherited a
somewhat convoluted structure from the source. Cleaning it up seems to be largely pointless
given the archaic nature of the file format.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1-L1493" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This code was ported directly from unzpaq.cpp; it is not very Pythonic and has inherited a
somewhat convoluted structure from the source. Cleaning it up seems to be largely pointless
given the archaic nature of the file format.
&#34;&#34;&#34;
from __future__ import annotations

from types import CodeType
from typing import TYPE_CHECKING

from refinery.lib.types import Param

if TYPE_CHECKING:
    from hashlib import _Hash

import hashlib
import io
import itertools
import re

from array import array
from dataclasses import dataclass, field
from datetime import datetime
from enum import IntEnum
from math import exp, log

from refinery.lib.structures import MemoryFile, StructReader
from refinery.units.formats.archive import ArchiveUnit, Arg

_TCU32 = &#39;I&#39;
_TCI32 = &#39;i&#39;
_TCU16 = &#39;H&#39;
_TCI16 = &#39;h&#39;


class _HaltExecution(Exception):
    pass


def _i32(x: int):
    return -(~(x - 1) &amp; 0xFFFFFFFF) if x &amp; 0x80000000 else x


def _resize(a: array[int] | bytearray, c: int, b: int = 0):
    c *= (1 &lt;&lt; b)
    del a[c:]
    a.extend(itertools.repeat(0, c - len(a)))


def _memzap(a: array[int] | bytearray, offset: int, n: int):
    a[offset:offset + n] = itertools.repeat(0, n)


class CompType(IntEnum):
    NONE  = 0 # noqa
    CONS  = 1 # noqa
    CM    = 2 # noqa
    ICM   = 3 # noqa
    MATCH = 4 # noqa
    AVG   = 5 # noqa
    MIX2  = 6 # noqa
    MIX   = 7 # noqa
    ISSE  = 8 # noqa
    SSE   = 9 # noqa


CompSize = [0, 2, 3, 2, 3, 4, 6, 6, 3, 5]
CompSize.extend(itertools.repeat(0, 256 - len(CompSize)))


class ZPAQL:

    output: MemoryFile | None
    header: bytearray # hsize[2] hh hm ph pm n COMP (guard) HCOMP (guard)
    cend: int
    hbegin: int
    hend: int

    m: bytearray
    h: array
    r: array

    a: int
    b: int
    c: int
    d: int
    f: int
    pc: int

    sha1: _Hash | None

    _cpu_defs: dict[int, str]
    _cpu_spec: dict[int, CodeType]

    def __init__(self):
        self.h = array(_TCU32)
        self.r = array(_TCU32)
        self.m = bytearray()
        self.sha1 = None
        self.output = None
        self.header = bytearray()
        self.clear()

        self._cpu_spec = {}
        self._cpu_defs = {
            0x01: &#39;a = a + 1 &amp; 0xFFFFFFFF&#39;,
            0x02: &#39;a = a - 1 &amp; 0xFFFFFFFF&#39;,
            0x03: &#39;a = ~a &amp; 0xFFFFFFFF&#39;,
            0x04: &#39;a = 0&#39;,
            0x07: &#39;a = r[{} % len(r)]&#39;,
            0x08: &#39;b, a = a, b&#39;,
            0x09: &#39;b = b + 1 &amp; 0xFFFFFFFF&#39;,
            0x0A: &#39;b = b - 1 &amp; 0xFFFFFFFF&#39;,
            0x0B: &#39;b = ~b &amp; 0xFFFFFFFF&#39;,
            0x0C: &#39;b = 0&#39;,
            0x0F: &#39;b = r[{} % len(r)]&#39;,
            0x10: &#39;c, a = a, c&#39;,
            0x11: &#39;c = c + 1 &amp; 0xFFFFFFFF&#39;,
            0x12: &#39;c = c - 1 &amp; 0xFFFFFFFF&#39;,
            0x13: &#39;c = ~c &amp; 0xFFFFFFFF&#39;,
            0x14: &#39;c = 0&#39;,
            0x17: &#39;c = r[{} % len(r)]&#39;,
            0x18: &#39;d, a = a, d&#39;,
            0x19: &#39;d = d + 1 &amp; 0xFFFFFFFF&#39;,
            0x1A: &#39;d = d - 1 &amp; 0xFFFFFFFF&#39;,
            0x1B: &#39;d = ~d &amp; 0xFFFFFFFF&#39;,
            0x1C: &#39;d = 0&#39;,
            0x1F: &#39;d = r[{} % len(r)]&#39;,
            0x20: &#39;m[b % len(m)], a = a, m[b % len(m)]&#39;,
            0x21: &#39;m[b % len(m)] += 1&#39;,
            0x22: &#39;m[b % len(m)] -= 1&#39;,
            0x23: &#39;m[b % len(m)] = ~m[b % len(m)] &amp; 0xFF&#39;,
            0x24: &#39;m[b % len(m)] = 0&#39;,
            0x27: &#39;pc += ((header[pc] + 128) &amp; 255) - 127 if f else 1&#39;,
            0x28: &#39;m[c % len(m)], a = a, m[c % len(m)]&#39;,
            0x29: &#39;m[c % len(m)] += 1&#39;,
            0x2A: &#39;m[c % len(m)] -= 1&#39;,
            0x2B: &#39;m[c % len(m)] = ~m[c % len(m)] &amp; 0xFF&#39;,
            0x2C: &#39;m[c % len(m)] = 0 &amp; 0xFF&#39;,
            0x2F: &#39;pc += 1 if f else ((header[pc] + 128) &amp; 255) - 127&#39;,
            0x30: &#39;h[d % len(h)], a = a, h[d % len(h)]&#39;,
            0x31: &#39;h[d % len(h)] += 1&#39;,
            0x32: &#39;h[d % len(h)] -= 1&#39;,
            0x33: &#39;h[d % len(h)] = ~h[d % len(h)]&#39;,
            0x34: &#39;h[d % len(h)] = 0&#39;,
            0x37: &#39;r[{} % len(r)] = a&#39;,
            0x38: &#39;raise halt(pc)&#39;,
            0x39: &#39;out(a &amp; 255)&#39;,
            0x3B: &#39;a = ((a + m[b % len(m)] + 512) * 773) &amp; 0xFFFFFFFF&#39;,
            0x3C: &#39;h[d % len(h)] = (h[d % len(h)] + a + 512) * 773 &amp; 0xFFFFFFFF&#39;,
            0x3F: &#39;pc += ((header[pc] + 128) &amp; 255) - 127&#39;,
            0x40: &#39;&#39;,
            0x41: &#39;a = b&#39;,
            0x42: &#39;a = c&#39;,
            0x43: &#39;a = d&#39;,
            0x44: &#39;a = m[b % len(m)]&#39;,
            0x45: &#39;a = m[c % len(m)]&#39;,
            0x46: &#39;a = h[d % len(h)]&#39;,
            0x47: &#39;a = {}&#39;,
            0x48: &#39;b = a&#39;,
            0x49: &#39;&#39;,
            0x4A: &#39;b = c&#39;,
            0x4B: &#39;b = d&#39;,
            0x4C: &#39;b = m[b % len(m)]&#39;,
            0x4D: &#39;b = m[c % len(m)]&#39;,
            0x4E: &#39;b = h[d % len(h)]&#39;,
            0x4F: &#39;b = {}&#39;,
            0x50: &#39;c = a&#39;,
            0x51: &#39;c = b&#39;,
            0x52: &#39;&#39;,
            0x53: &#39;c = d&#39;,
            0x54: &#39;c = m[b % len(m)]&#39;,
            0x55: &#39;c = m[c % len(m)]&#39;,
            0x56: &#39;c = h[d % len(h)]&#39;,
            0x57: &#39;c = {}&#39;,
            0x58: &#39;d = a&#39;,
            0x59: &#39;d = b&#39;,
            0x5A: &#39;d = c&#39;,
            0x5B: &#39;&#39;,
            0x5C: &#39;d = m[b % len(m)]&#39;,
            0x5D: &#39;d = m[c % len(m)]&#39;,
            0x5E: &#39;d = h[d % len(h)]&#39;,
            0x5F: &#39;d = {}&#39;,
            0x60: &#39;m[b % len(m)] = a &amp; 0xFF&#39;,
            0x61: &#39;m[b % len(m)] = b &amp; 0xFF&#39;,
            0x62: &#39;m[b % len(m)] = c &amp; 0xFF&#39;,
            0x63: &#39;m[b % len(m)] = d &amp; 0xFF&#39;,
            0x64: &#39;&#39;,
            0x65: &#39;m[b % len(m)] = m[c % len(m)]&#39;,
            0x66: &#39;m[b % len(m)] = h[d % len(h)] &amp; 0xFF&#39;,
            0x67: &#39;m[b % len(m)] = {}&#39;,
            0x68: &#39;m[c % len(m)] = a &amp; 0xFF&#39;,
            0x69: &#39;m[c % len(m)] = b &amp; 0xFF&#39;,
            0x6A: &#39;m[c % len(m)] = c &amp; 0xFF&#39;,
            0x6B: &#39;m[c % len(m)] = d &amp; 0xFF&#39;,
            0x6C: &#39;m[c % len(m)] = m[b % len(m)]&#39;,
            0x6D: &#39;&#39;,
            0x6E: &#39;m[c % len(m)] = h[d % len(h)] &amp; 0xFF&#39;,
            0x6F: &#39;m[c % len(m)] = {}&#39;,
            0x70: &#39;h[d % len(h)] = a&#39;,
            0x71: &#39;h[d % len(h)] = b&#39;,
            0x72: &#39;h[d % len(h)] = c&#39;,
            0x73: &#39;h[d % len(h)] = d&#39;,
            0x74: &#39;h[d % len(h)] = m[b % len(m)]&#39;,
            0x75: &#39;h[d % len(h)] = m[c % len(m)]&#39;,
            0x76: &#39;&#39;,
            0x77: &#39;h[d % len(h)] = {}&#39;,
            0x80: &#39;a = a + a &amp; 0xFFFFFFFF&#39;,
            0x81: &#39;a = a + b &amp; 0xFFFFFFFF&#39;,
            0x82: &#39;a = a + c &amp; 0xFFFFFFFF&#39;,
            0x83: &#39;a = a + d &amp; 0xFFFFFFFF&#39;,
            0x84: &#39;a = a + m[b % len(m)] &amp; 0xFFFFFFFF&#39;,
            0x85: &#39;a = a + m[c % len(m)] &amp; 0xFFFFFFFF&#39;,
            0x86: &#39;a = a + h[d % len(h)] &amp; 0xFFFFFFFF&#39;,
            0x87: &#39;a = a + {} &amp; 0xFFFFFFFF&#39;,
            0x88: &#39;a = 0&#39;,
            0x89: &#39;a = a - b &amp; 0xFFFFFFFF&#39;,
            0x8A: &#39;a = a - c &amp; 0xFFFFFFFF&#39;,
            0x8B: &#39;a = a - d &amp; 0xFFFFFFFF&#39;,
            0x8C: &#39;a = a - m[b % len(m)] &amp; 0xFFFFFFFF&#39;,
            0x8D: &#39;a = a - m[c % len(m)] &amp; 0xFFFFFFFF&#39;,
            0x8E: &#39;a = a - h[d % len(h)] &amp; 0xFFFFFFFF&#39;,
            0x8F: &#39;a = a - {} &amp; 0xFFFFFFFF&#39;,
            0x90: &#39;a = a * a &amp; 0xFFFFFFFF&#39;,
            0x91: &#39;a = a * b &amp; 0xFFFFFFFF&#39;,
            0x92: &#39;a = a * c &amp; 0xFFFFFFFF&#39;,
            0x93: &#39;a = a * d &amp; 0xFFFFFFFF&#39;,
            0x94: &#39;a = a * m[b % len(m)] &amp; 0xFFFFFFFF&#39;,
            0x95: &#39;a = a * m[c % len(m)] &amp; 0xFFFFFFFF&#39;,
            0x96: &#39;a = a * h[d % len(h)] &amp; 0xFFFFFFFF&#39;,
            0x97: &#39;a = a * {} &amp; 0xFFFFFFFF&#39;,
            0x98: &#39;a = a//a if a else 0&#39;,
            0x99: &#39;a = a//b if b else 0&#39;,
            0x9A: &#39;a = a//c if c else 0&#39;,
            0x9B: &#39;a = a//d if d else 0&#39;,
            0x9C: &#39;t = m[b % len(m)]\na = a//t if t else 0&#39;,
            0x9D: &#39;t = m[c % len(m)]\na = a//t if t else 0&#39;,
            0x9E: &#39;t = h[d % len(h)]\na = a//t if t else 0&#39;,
            0x9F: &#39;t = {}           \na = a//t if t else 0&#39;,
            0xA0: &#39;a = a % a if a else 0&#39;,
            0xA1: &#39;a = a % b if b else 0&#39;,
            0xA2: &#39;a = a % c if c else 0&#39;,
            0xA3: &#39;a = a % d if d else 0&#39;,
            0xA4: &#39;t = m[b % len(m)]\na = a % t if t else 0&#39;,
            0xA5: &#39;t = m[c % len(m)]\na = a % t if t else 0&#39;,
            0xA6: &#39;t = h[d % len(h)]\na = a % t if t else 0&#39;,
            0xA7: &#39;t = {}           \na = a % t if t else 0&#39;,
            0xA8: &#39;a &amp;= a&#39;,
            0xA9: &#39;a &amp;= b&#39;,
            0xAA: &#39;a &amp;= c&#39;,
            0xAB: &#39;a &amp;= d&#39;,
            0xAC: &#39;a &amp;= m[b % len(m)]&#39;,
            0xAD: &#39;a &amp;= m[c % len(m)]&#39;,
            0xAE: &#39;a &amp;= h[d % len(h)]&#39;,
            0xAF: &#39;a &amp;= {}&#39;,
            0xB0: &#39;a &amp;= ~a&#39;,
            0xB1: &#39;a &amp;= ~b&#39;,
            0xB2: &#39;a &amp;= ~c&#39;,
            0xB3: &#39;a &amp;= ~d&#39;,
            0xB4: &#39;a &amp;= ~m[b % len(m)]&#39;,
            0xB5: &#39;a &amp;= ~m[c % len(m)]&#39;,
            0xB6: &#39;a &amp;= ~h[d % len(h)]&#39;,
            0xB7: &#39;a &amp;= ~{}&#39;,
            0xB8: &#39;a |= a&#39;,
            0xB9: &#39;a |= b&#39;,
            0xBA: &#39;a |= c&#39;,
            0xBB: &#39;a |= d&#39;,
            0xBC: &#39;a |= m[b % len(m)]&#39;,
            0xBD: &#39;a |= m[c % len(m)]&#39;,
            0xBE: &#39;a |= h[d % len(h)]&#39;,
            0xBF: &#39;a |= {}&#39;,
            0xC0: &#39;a ^= a&#39;,
            0xC1: &#39;a ^= b&#39;,
            0xC2: &#39;a ^= c&#39;,
            0xC3: &#39;a ^= d&#39;,
            0xC4: &#39;a ^= m[b % len(m)]&#39;,
            0xC5: &#39;a ^= m[c % len(m)]&#39;,
            0xC6: &#39;a ^= h[d % len(h)]&#39;,
            0xC7: &#39;a ^= {}&#39;,
            0xC8: &#39;a = (a &lt;&lt; (a &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xC9: &#39;a = (a &lt;&lt; (b &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xCA: &#39;a = (a &lt;&lt; (c &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xCB: &#39;a = (a &lt;&lt; (d &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xCC: &#39;a = (a &lt;&lt; (m[b % len(m)] &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xCD: &#39;a = (a &lt;&lt; (m[c % len(m)] &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xCE: &#39;a = (a &lt;&lt; (h[d % len(h)] &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xCF: &#39;a = (a &lt;&lt; ({} &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xD0: &#39;a &gt;&gt;= (a &amp; 31)&#39;,
            0xD1: &#39;a &gt;&gt;= (b &amp; 31)&#39;,
            0xD2: &#39;a &gt;&gt;= (c &amp; 31)&#39;,
            0xD3: &#39;a &gt;&gt;= (d &amp; 31)&#39;,
            0xD4: &#39;a &gt;&gt;= (m[b % len(m)] &amp; 31)&#39;,
            0xD5: &#39;a &gt;&gt;= (m[c % len(m)] &amp; 31)&#39;,
            0xD6: &#39;a &gt;&gt;= (h[d % len(h)] &amp; 31)&#39;,
            0xD7: &#39;a &gt;&gt;= ({} &amp; 31)&#39;,
            0xD8: &#39;f = (a == a)&#39;,
            0xD9: &#39;f = (a == b)&#39;,
            0xDA: &#39;f = (a == c)&#39;,
            0xDB: &#39;f = (a == d)&#39;,
            0xDC: &#39;f = (a == m[b % len(m)])&#39;,
            0xDD: &#39;f = (a == m[c % len(m)])&#39;,
            0xDE: &#39;f = (a == h[d % len(h)])&#39;,
            0xDF: &#39;f = (a == {})&#39;,
            0xE0: &#39;f = (a &lt; a)&#39;,
            0xE1: &#39;f = (a &lt; b)&#39;,
            0xE2: &#39;f = (a &lt; c)&#39;,
            0xE3: &#39;f = (a &lt; d)&#39;,
            0xE4: &#39;f = (a &lt; m[b % len(m)])&#39;,
            0xE5: &#39;f = (a &lt; m[c % len(m)])&#39;,
            0xE6: &#39;f = (a &lt; h[d % len(h)])&#39;,
            0xE7: &#39;f = (a &lt; {})&#39;,
            0xE8: &#39;f = (a &gt; a)&#39;,
            0xE9: &#39;f = (a &gt; b)&#39;,
            0xEA: &#39;f = (a &gt; c)&#39;,
            0xEB: &#39;f = (a &gt; d)&#39;,
            0xEC: &#39;f = (a &gt; m[b % len(m)])&#39;,
            0xED: &#39;f = (a &gt; m[c % len(m)])&#39;,
            0xEE: &#39;f = (a &gt; h[d % len(h)])&#39;,
            0xEF: &#39;f = (a &gt; {})&#39;,
            0xFF: (
                &#39;pc = hbegin + header[pc] + 256 * header[pc + 1]\n&#39;
                &#39;if pc &gt;= hend: raise RuntimeError&#39;
            )
        }

    def inith(self):
        self.init(self.header[2], self.header[3])

    def initp(self):
        self.init(self.header[4], self.header[5])

    def run(self, input: int):
        assert self.cend &gt; 6
        assert self.hbegin &gt;= self.cend + 128
        assert self.hend &gt;= self.hbegin
        assert self.hend &lt; len(self.header) - 130
        assert len(self.m) &gt; 0
        assert len(self.h) &gt; 0
        assert self.header[0] + 256 * self.header[1] == self.cend + self.hend - self.hbegin - 2
        self.pc = self.hbegin
        self.a = input
        self.execute_loop()

    def read(self, in2: StructReader) -&gt; int:
        hsize = in2.u16()
        self.header = bytearray(hsize + 300)
        cend = hbegin = hend = 0
        self.header[cend] = hsize &amp; 255
        cend += 1
        self.header[cend] = hsize &gt;&gt; 8
        cend += 1
        while cend &lt; 7:
            self.header[cend] = in2.u8()
            cend += 1
        n = self.header[cend - 1]
        for _ in range(n):
            type = in2.u8()
            self.header[cend] = type
            cend += 1
            size = CompSize[type]
            for _ in range(1, size):
                self.header[cend] = in2.u8()
                cend += 1
        end_byte = in2.u8()
        self.header[cend] = end_byte
        cend += 1
        if end_byte != 0:
            raise ValueError(&#39;missing COMP END&#39;)
        hbegin = hend = cend + 128
        if hend &gt; hsize + 129:
            raise ValueError(&#39;missing HCOMP&#39;)
        while hend &lt; hsize + 129:
            assert hend &lt; len(self.header) - 8
            op = in2.u8()
            self.header[hend] = op
            hend += 1
        end_byte = in2.u8()
        self.header[hend] = end_byte
        hend += 1
        self.cend = cend
        self.hend = hend
        self.hbegin = hbegin
        if end_byte != 0:
            raise ValueError(&#39;missing HCOMP END&#39;)
        assert cend &gt;= 7 and cend &lt; len(self.header)
        assert hbegin == cend + 128 and hbegin &lt; len(self.header)
        assert hend &gt; hbegin and hend &lt; len(self.header)
        assert hsize == self.header[0] + 256 * self.header[1]
        assert hsize == cend - 2 + hend - hbegin
        return cend + hend - hbegin

    def clear(self):
        self.cend = 0
        self.hbegin = 0
        self.hend = 0
        self.a = 0
        self.b = 0
        self.c = 0
        self.d = 0
        self.f = 0
        self.pc = 0
        self.header.clear()
        self.m.clear()
        del self.h[:]
        del self.r[:]

    def outc(self, c: int):
        c &amp;= 0xFF
        if self.output is not None:
            self.output.write_byte(c)
        if self.sha1 is not None:
            self.sha1.update(bytes((c,)))

    def init(self, hbits: int, mbits: int):
        assert len(self.header) &gt; 0
        assert self.cend &gt;= 7
        assert self.hbegin &gt;= self.cend + 128
        assert self.hend &gt;= self.hbegin
        assert self.hend &lt; len(self.header) - 130
        assert self.header[0] + 256 * self.header[1] == self.cend - 2 + self.hend - self.hbegin
        mlen = 1 &lt;&lt; mbits
        hlen = 1 &lt;&lt; hbits
        rlen = 0x100
        del self.m[mlen:]
        self.m.extend(itertools.repeat(0, mlen - len(self.m)))
        del self.h[hlen:]
        self.h.extend(itertools.repeat(0, hlen - len(self.h)))
        del self.r[rlen:]
        self.r.extend(itertools.repeat(0, rlen - len(self.r)))
        _resize(self.r, 256)
        self.a = 0
        self.b = 0
        self.c = 0
        self.d = 0
        self.f = 0
        self.pc = 0

    def execute_loop(self):

        def out(c: int):
            c &amp;= 0xFF
            if self.output is not None:
                self.output.write_byte(c)
            if self.sha1 is not None:
                self.sha1.update(bytes((c,)))

        cpu = dict(self.__dict__)
        cpu.update(out=out, halt=_HaltExecution)

        while True:
            pc = cpu[&#39;pc&#39;]
            try:
                code = self._cpu_spec[pc]
            except KeyError:
                with io.StringIO() as writer:
                    start = pc
                    done = False
                    xtzpaq.log_info(F&#39;precompiling block B{start:08X}&#39;)
                    while not done:
                        opcode = self.header[pc]
                        try:
                            line = self._cpu_defs[opcode]
                        except KeyError:
                            raise RuntimeError(F&#39;invalid opcode: 0x{opcode:02X}&#39;)
                        pc += 1
                        if &#39;{}&#39; in line:
                            line = line.format(self.header[pc])
                            pc += 1
                        if &#39;pc&#39; in line:
                            done = True
                            writer.write(F&#39;pc = {pc}\n&#39;)
                        writer.write(F&#39;{line}\n&#39;)
                    code = writer.getvalue()
                self._cpu_spec[start] = code = compile(
                    code, F&#39;&lt;BB:{start:08X}&gt;&#39;, &#39;exec&#39;, optimize=2)
            try:
                exec(code, {}, cpu)
            except _HaltExecution:
                break
            except Exception as E:
                raise E

        self.__dict__.update((k, cpu[k]) for k in self.__dict__.keys() &amp; cpu.keys())


class Component:
    def __init__(self):
        self.init()

    def init(self):
        self.limit = 0
        self.cxt = 0
        self.a = 0
        self.b = 0
        self.c = 0
        self.ht = bytearray()
        self.cm = array(_TCU32)
        self.a16 = array(_TCU32)


class StateTable:
    _N = 64
    ns: bytearray

    def next(self, state: int, y: int):
        assert 0 &lt;= state &lt;= 256
        assert 0 &lt;= y &lt;= 3
        return self.ns[state * 4 + y]

    def cminit(self, state: int):
        assert 0 &lt;= state &lt;= 256
        ns = self.ns
        a = (ns[state * 4 + 3] * 2 + 1) &lt;&lt; 22
        b = ns[state * 4 + 2] + ns[state * 4 + 3] + 1
        return a // b

    def num_states(self, n0: int, n1: int):
        bound = (20, 48, 15, 8, 6, 5)
        if n0 &lt; n1:
            return self.num_states(n1, n0)
        if n0 &lt; 0 or n1 &lt; 0 or n1 &gt;= len(bound) or n0 &gt; bound[n1]:
            return 0
        return 1 + int(n1 &gt; 0 and n0 + n1 &lt;= 17)

    def discount(self, n0: int):
        return (n0 &gt;= 1) + (n0 &gt;= 2) + (n0 &gt;= 3) + (n0 &gt;= 4) + (n0 &gt;= 5) + (n0 &gt;= 7) + (n0 &gt;= 8)

    def next_state(self, n0: int, n1: int, y: int):
        if n0 &lt; n1:
            n1, n0 = self.next_state(n1, n0, 1 - y)
            return n0, n1
        if y:
            n1 += 1
            n0 = self.discount(n0)
        else:
            n0 += 1
            n1 = self.discount(n1)
        while not self.num_states(n0, n1):
            if n1 &lt; 2:
                n0 = n0 - 1
            else:
                n0 = (n0 * (n1 - 1) + (n1 // 2)) // n1
                n1 = n1 - 1
        return n0, n1

    def __init__(self):
        N = 50
        t = [[bytearray(N) for _ in range(N)] for _ in range(2)]
        state = 0
        for i in range(N):
            for n1 in range(i + 1):
                n0 = i - n1
                n = self.num_states(n0, n1)
                assert 0 &lt;= n &lt;= 2
                if not n:
                    continue
                t[0][n0][n1] = state
                t[1][n0][n1] = state + n - 1
                state += n
        self.ns = bytearray(1024)
        for n0 in range(N):
            for n1 in range(N):
                for y in range(self.num_states(n0, n1)):
                    assert 0 &lt;= y &lt;= 1
                    s = t[y][n0][n1]
                    assert 0 &lt;= s &lt;= 256
                    s0, s1 = self.next_state(n0, n1, 0)
                    assert 0 &lt;= s0 &lt;= N and 0 &lt;= s1 &lt;= N
                    self.ns[s * 4 + 0] = t[0][s0][s1]
                    s0, s1 = self.next_state(n0, n1, 1)
                    assert 0 &lt;= s0 &lt;= N and 0 &lt;= s1 &lt;= N
                    self.ns[s * 4 + 1] = t[1][s0][s1]
                    self.ns[s * 4 + 2] = n0
                    self.ns[s * 4 + 3] = n1


class Predictor:

    c8: int
    hmap4: int
    p: array
    h: array
    z: ZPAQL

    comp: list[Component]

    dt2k: array
    dt: array
    squasht: array
    stretcht: array
    st: StateTable

    def __init__(self, z: ZPAQL):
        self.c8 = 1
        self.hmap4 = 1
        self.z = z
        self.st = StateTable()
        self.dt2k = array(_TCI32)
        self.dt = array(_TCI32)
        self.squasht = array(_TCU16)
        self.stretcht = array(_TCI16)
        self.p = array(_TCI32)
        self.h = array(_TCU32)
        self.comp = []
        for _ in range(0x100):
            self.p.append(0)
            self.h.append(0)
            self.comp.append(Component())
        self.p = array(_TCI32)
        self.h = array(_TCU32)
        _resize(self.p, 256)
        _resize(self.h, 256)
        self.dt2k.append(0)
        for i in range(1, 0x100):
            self.dt2k.append(2048 // i)
        for i in range(1024):
            self.dt.append(((1 &lt;&lt; 17) // (i * 2 + 3)) * 2)
        for i in range(32768):
            _k = 100000
            _l = log((i + 0.5) / (32767.5 - i)) * 64 + 0.5
            self.stretcht.append(int(_l + _k) - _k)
        for i in range(4096):
            _e = exp((i - 2048) * (-1.0 / 64)) + 1
            self.squasht.append(int(32768.0 / _e))
        sqsum = 0
        stsum = 0
        for v in reversed(self.stretcht):
            stsum = stsum * 3 + v &amp; 0xFFFFFFFF
        for v in reversed(self.squasht):
            sqsum = sqsum * 3 + v &amp; 0xFFFFFFFF
        if stsum != 3887533746:
            raise RuntimeError(F&#39;checksum failure for stretch {stsum}&#39;)
        if sqsum != 2278286169:
            raise RuntimeError(F&#39;checksum failure for squash {sqsum}&#39;)

    def init(self):
        self.z.inith()
        for i in range(0x100):
            self.h[i] = 0
            self.p[i] = 0
            self.comp[i].init()
        n = self.z.header[6]
        cp = memoryview(self.z.header)[7:self.z.cend]
        for i in range(n):
            assert cp
            cr = self.comp[i]
            ct = CompType(cp[0])
            if ct is CompType.CONS:
                self.p[i] = (cp[1] - 128) * 4
            elif ct is CompType.CM:
                if cp[1] &gt; 32:
                    raise ValueError(&#39;max size for CM is 32&#39;)
                _resize(cr.cm, 1, cp[1])
                cr.limit = cp[2] * 4
                for j in range(len(cr.cm)):
                    cr.cm[j] = 0x80000000
            elif ct is CompType.ICM:
                if cp[1] &gt; 26:
                    raise ValueError(&#39;max size for ICM is 26&#39;)
                cr.limit = 1023
                _resize(cr.cm, 256)
                _resize(cr.ht, 64, cp[1])
                for j in range(256):
                    cr.cm[j] = self.st.cminit(j)
            elif ct is CompType.MATCH:
                if cp[1] &gt; 32 or cp[2] &gt; 32:
                    raise ValueError(&#39;max size for MATCH is 32/32&#39;)
                _resize(cr.cm, 1, cp[1])
                _resize(cr.ht, 1, cp[2])
                cr.ht[0] = 1
            elif ct is CompType.AVG:
                if cp[1] &gt;= i:
                    raise ValueError(&#39;AVG j &gt;= i&#39;)
                if cp[2] &gt;= i:
                    raise ValueError(&#39;AVG k &gt;= i&#39;)
            elif ct is CompType.MIX2:
                if cp[1] &gt; 32:
                    raise ValueError(&#39;max size for MIX2 is 32&#39;)
                if cp[3] &gt;= i:
                    raise ValueError(&#39;MIX2 k &gt;= i&#39;)
                if cp[2] &gt;= i:
                    raise ValueError(&#39;MIX2 j &gt;= i&#39;)
                cr.c = 1 &lt;&lt; cp[1]  # size (number of contexts)
                _resize(cr.a16, 1, cp[1])
                for j in range(len(cr.a16)):
                    cr.a16[j] = 32768
            elif ct is CompType.MIX:
                if cp[1] &gt; 32:
                    raise ValueError(&#39;max size for MIX is 32&#39;)
                if cp[2] &gt;= i:
                    raise ValueError(&#39;MIX j &gt;= i&#39;)
                if cp[3] &lt; 1 or cp[3] &gt; i - cp[2]:
                    raise ValueError(&#39;MIX m not in 1..i-j&#39;)
                m = cp[3] # number of inputs
                assert m &gt;= 1
                cr.c = 1 &lt;&lt; cp[1]  # size (number of contexts)
                _resize(cr.cm, m, cp[1])
                for j in range(len(cr.cm)):
                    cr.cm[j] = 65536 // m
            elif ct is CompType.ISSE:
                if cp[1] &gt; 32:
                    raise ValueError(&#39;max size for ISSE is 32&#39;)
                if cp[2] &gt;= i:
                    raise ValueError(&#39;ISSE j &gt;= i&#39;)
                _resize(cr.ht, 64, cp[1])
                _resize(cr.cm, 512)
                for j in range(256):
                    clamped = self.clamp512k(self.stretch(self.st.cminit(j) &gt;&gt; 8) * 1024)
                    cr.cm[j * 2 + 0] = 1 &lt;&lt; 15
                    cr.cm[j * 2 + 1] = clamped
            elif ct is CompType.SSE:
                if cp[1] &gt; 32:
                    raise ValueError(&#39;max size for SSE is 32&#39;)
                if cp[2] &gt;= i:
                    raise ValueError(&#39;SSE j &gt;= i&#39;)
                if cp[3] &gt; cp[4] * 4:
                    raise ValueError(&#39;SSE start &gt; limit*4&#39;)
                _resize(cr.cm, 32, cp[1])
                cr.limit = cp[4] * 4
                for j in range(len(cr.cm)):
                    cr.cm[j] = self.squash((j &amp; 31) * 64 - 992) &lt;&lt; 17 | cp[3]
            else:
                raise ValueError(&#39;unknown component type&#39;)
            cs = CompSize[cp[0]]
            cp = cp[cs:]

    def predict(self):
        assert 0 &lt; self.c8 &lt; 256
        n = self.z.header[6]
        assert 0 &lt; n &lt; 256
        cp = memoryview(self.z.header)[7:]
        assert self.z.header[6] == n
        p = self.p
        h = self.h
        for i in range(n):
            cr = self.comp[i]
            ct = CompType(cp[0])
            if ct is CompType.CONS:
                pass
            elif ct is CompType.CM:
                cr.cxt = self.h[i] ^ self.hmap4
                p[i] = self.stretch(cr.cm[cr.cxt] &gt;&gt; 17)
            elif ct is CompType.ICM:
                assert self.hmap4 &amp; 15 &gt; 0
                if self.c8 == 1 or (self.c8 &amp; 0xF0) == 16:
                    cr.c = self.find(cr.ht, cp[1] + 2, h[i] + 16 * self.c8)
                cr.cxt = cr.ht[cr.c + (self.hmap4 &amp; 15)]
                p[i] = self.stretch(cr.cm[cr.cxt] &gt;&gt; 8)
            elif ct is CompType.MATCH:
                assert len(cr.cm) == 1 &lt;&lt; cp[1]
                assert len(cr.ht) == 1 &lt;&lt; cp[2]
                assert cr.a &lt;= 255
                assert cr.c in {0, 1}
                assert cr.cxt &lt; 8
                assert cr.limit &lt; len(cr.ht)
                if cr.a == 0:
                    p[i] = 0
                else:
                    cr.c = (cr.ht[cr.limit - cr.b] &gt;&gt; (7 - cr.cxt)) &amp; 1
                    p[i] = self.stretch(self.dt2k[cr.a] * (cr.c * -2 + 1) &amp; 32767)
            elif ct is CompType.AVG:
                p[i] = (p[cp[1]] * cp[3] + p[cp[2]] * (256 - cp[3])) &gt;&gt; 8
            elif ct is CompType.MIX2:
                cr.cxt = (h[i] + (self.c8 &amp; cp[5])) &amp; (cr.c - 1)
                assert cr.cxt &lt; len(cr.a16)
                w = cr.a16[cr.cxt]
                assert 0 &lt;= w &lt; 65536
                p[i] = (w * p[cp[2]] + (65536 - w) * p[cp[3]]) &gt;&gt; 16
                assert -2048 &lt;= p[i] &lt; 2048
            elif ct is CompType.MIX:
                m = cp[3]
                assert 1 &lt;= m &lt;= i
                cr.cxt = h[i] + (self.c8 &amp; cp[5])
                cr.cxt = (cr.cxt &amp; (cr.c - 1)) * m
                assert cr.cxt &lt;= len(cr.cm) - m
                w = cr.cxt
                p[i] = 0
                for j in range(m):
                    p[i] += (_i32(cr.cm[w + j]) &gt;&gt; 8) * p[cp[2] + j]
                p[i] = self.clamp2k(p[i] &gt;&gt; 8)
            elif ct is CompType.ISSE:
                if self.c8 == 1 or (self.c8 &amp; 0xF0) == 16:
                    cr.c = self.find(cr.ht, cp[1] + 2, h[i] + 16 * self.c8)
                cr.cxt = cr.ht[cr.c + (self.hmap4 &amp; 15)]
                wt0 = _i32(cr.cm[cr.cxt * 2 + 0])
                wt1 = _i32(cr.cm[cr.cxt * 2 + 1])
                p[i] = self.clamp2k((wt0 * p[cp[2]] + wt1 * 64) &gt;&gt; 16)
            elif ct is CompType.SSE:
                cr.cxt = (h[i] + self.c8) * 32
                pq = min(max(0, p[cp[2]] + 992), 1983)
                wt = pq &amp; 63
                pq &gt;&gt;= 6
                assert 0 &lt;= pq &lt;= 30
                cr.cxt += pq
                p[i] = self.stretch((
                    (cr.cm[cr.cxt + 0] &gt;&gt; 10) * (64 - wt) + (cr.cm[cr.cxt + 1] &gt;&gt; 10) * wt) &gt;&gt; 13)
                cr.cxt += wt &gt;&gt; 5
            else:
                raise ValueError(&#39;component predict not implemented&#39;)
            cs = CompSize[cp[0]]
            cp = cp[cs:]
        assert CompType(cp[0]) is CompType.NONE
        return self.squash(p[n - 1])

    def update(self, y: int):
        assert y in (0, 1)
        assert 0 &lt; self.c8 &lt; 256
        assert 0 &lt; self.hmap4 &lt; 512
        cp = memoryview(self.z.header)[7:]
        n = self.z.header[6]
        h = self.h
        p = self.p
        assert 0 &lt; n &lt; 256
        for i in range(n):
            cr = self.comp[i]
            ct = CompType(cp[0])
            if ct is CompType.CONS:
                pass
            elif ct is CompType.CM:
                self.train(cr, y)
            elif ct is CompType.ICM:
                k = cr.c + (self.hmap4 &amp; 15)
                cr.ht[k] = self.st.next(cr.ht[k], y)
                pn = cr.cm[cr.cxt]
                pn += (y * 32767 - (pn &gt;&gt; 8)) &gt;&gt; 2
                cr.cm[cr.cxt] = pn
            elif ct is CompType.MATCH:
                assert cr.a &lt;= 255
                assert cr.c in (0, 1)
                assert cr.cxt &lt; 8
                assert len(cr.cm) == 1 &lt;&lt; cp[1]
                assert len(cr.ht) == 1 &lt;&lt; cp[2]
                assert cr.limit &lt; len(cr.ht)
                if cr.c != y:
                    cr.a = 0  # mismatch?
                cr.ht[cr.limit] = (cr.ht[cr.limit] &lt;&lt; 1) + y &amp; 0xFF
                cr.cxt += 1
                if cr.cxt == 8:
                    cr.cxt = 0
                    cr.limit += 1
                    cr.limit &amp;= (1 &lt;&lt; cp[2]) - 1
                    hi = h[i] % len(cr.cm)
                    if cr.a != 0:
                        cr.a += int(cr.a &lt; 255)
                    else:  # look for a match
                        cr.b = cr.limit - cr.cm[hi]
                        if cr.b &amp; (len(cr.ht) - 1):
                            while cr.a &lt; 255 and cr.ht[cr.limit - cr.a - 1] == cr.ht[cr.limit - cr.a - cr.b - 1]:
                                cr.a += 1
                    cr.cm[hi] = cr.limit
            elif ct is CompType.AVG:
                pass
            elif ct is CompType.MIX2:
                assert len(cr.a16) == cr.c
                assert cr.cxt &lt; cr.c
                err = (y * 32767 - self.squash(p[i])) * cp[4] &gt;&gt; 5
                w = cr.a16[cr.cxt]
                w += (err * (p[cp[2]] - p[cp[3]]) + (1 &lt;&lt; 12)) &gt;&gt; 13
                cr.a16[cr.cxt] = min(max(w, 0), 65535)
            elif ct is CompType.MIX:
                m = cp[3]
                assert m &gt; 0 and m &lt;= i
                assert len(cr.cm) == m * cr.c
                assert cr.cxt + m &lt;= len(cr.cm)
                err = (y * 32767 - self.squash(p[i])) * cp[4] &gt;&gt; 4
                w = cr.cxt
                for j in range(m):
                    cr.cm[w + j] = self.clamp512k(_i32(cr.cm[w + j]) + ((err * p[cp[2] + j] + (1 &lt;&lt; 12)) &gt;&gt; 13))
            elif ct is CompType.ISSE:
                assert cr.cxt == cr.ht[cr.c + (self.hmap4 &amp; 15)]
                err = y * 32767 - self.squash(p[i])
                w = cr.cxt * 2
                cr.cm[w + 0] = self.clamp512k(_i32(cr.cm[w + 0]) + ((err * p[cp[2]] + (1 &lt;&lt; 12)) &gt;&gt; 13))
                cr.cm[w + 1] = self.clamp512k(_i32(cr.cm[w + 1]) + ((err + 16) &gt;&gt; 5))
                cr.ht[cr.c + (self.hmap4 &amp; 15)] = self.st.next(cr.cxt, y)
            elif ct is CompType.SSE:
                self.train(cr, y)
            else:
                raise RuntimeError
            cs = CompSize[cp[0]]
            cp = cp[cs:]

        assert CompType(cp[0]) is CompType.NONE

        self.c8 *= 2
        self.c8 += y
        if self.c8 &gt;= 256:
            self.z.run(self.c8 - 256)
            self.hmap4 = 1
            self.c8 = 1
            self.h[:n] = self.z.h[:n]
        elif 16 &lt;= self.c8 &lt; 32:
            self.hmap4 = ((self.hmap4 &amp; 15) &lt;&lt; 5) | (y &lt;&lt; 4) | 1
        else:
            self.hmap4 = (self.hmap4 &amp; 0x1f0) | (((self.hmap4 &amp; 15) * 2 + y) &amp; 15)

    def is_modeled(self):
        return self.z.header[6] != 0

    def train(self, cr: Component, y: int):
        assert 0 &lt;= y &lt;= 1
        cxt = cr.cxt % len(cr.cm)
        pn = cr.cm[cxt]
        count = pn &amp; 0x3FF
        error = y * 32767 - (pn &gt;&gt; 17)
        pn += (error * self.dt[count] &amp; -1024) + (count &lt; cr.limit)
        pn &amp;= 0xFFFFFFFF
        cr.cm[cxt] = pn

    def squash(self, x: int):
        assert -2048 &lt;= x &lt;= 2047
        return self.squasht[x + 2048]

    def stretch(self, x: int):
        assert 0 &lt;= x &lt;= 32767
        return self.stretcht[x]

    def clamp2k(self, x: int):
        return min(max(x, -2048), 2047)

    def clamp512k(self, x: int):
        return min(max(x, -(1 &lt;&lt; 19)), (1 &lt;&lt; 19) - 1) &amp; 0xFFFFFFFF

    def find(self, ht: array[int] | bytearray, sizebits: int, cxt: int):
        assert len(ht) == 16 &lt;&lt; sizebits
        chk = cxt &gt;&gt; sizebits &amp; 255
        h0 = (cxt * 16) &amp; (len(ht) - 16)
        if ht[h0] == chk:
            return h0
        h1 = h0 ^ 16
        if ht[h1] == chk:
            return h1
        h2 = h0 ^ 32
        if ht[h2] == chk:
            return h2
        if ht[h0 + 1] &lt;= ht[h1 + 1] and ht[h0 + 1] &lt;= ht[h2 + 1]:
            _memzap(ht, h0, 16)
            ht[h0] = chk
            return h0
        elif ht[h1 + 1] &lt; ht[h2 + 1]:
            _memzap(ht, h1, 16)
            ht[h1] = chk
            return h1
        else:
            _memzap(ht, h2, 16)
            ht[h2] = chk
            return h2


class Decoder:
    src: StructReader
    low: int
    high: int
    curr: int
    pr: Predictor

    def __init__(self, z: ZPAQL, src: StructReader[bytearray]):
        self.src = src
        self.pr = Predictor(z)
        self._set_values(1, 0xFFFFFFFF, 0)

    def _set_values(self, low, high, curr):
        self.low = low
        self.high = high
        self.curr = curr

    def init(self):
        self.pr.init()
        if self.pr.is_modeled():
            self._set_values(1, 0xFFFFFFFF, 0)
        else:
            self._set_values(0, 0x00000000, 0)

    def decode(self, p: int) -&gt; int:
        assert 0 &lt;= p &lt; 65536
        assert 0 &lt; self.low &lt; self.high
        if self.curr &lt; self.low or self.high &lt; self.curr:
            raise RuntimeError(&#39;archive corrupted&#39;)
        mid = self.low + (((self.high - self.low) * p) &gt;&gt; 16) &amp; 0xFFFFFFFF
        assert self.low &lt;= mid &lt;= self.high
        rv = self.curr &lt;= mid
        if rv:
            self.high = mid
        else:
            self.low = mid + 1 &amp; 0xFFFFFFFF
        while (self.high ^ self.low) &lt; 0x1000000:
            self.high &lt;&lt;= 8
            self.high |= 0xFF
            self.high &amp;= 0xFFFFFFFF
            self.low = (self.low &lt;&lt; 8) &amp; 0xFFFFFFFF
            if self.low == 0:
                self.low = 1
            self.curr &lt;&lt;= 8
            self.curr |= self.src.u8fast()
            self.curr &amp;= 0xFFFFFFFF
        return int(rv)

    def decompress(self) -&gt; int | None:
        pr = self.pr
        if pr.is_modeled():
            if self.curr == 0:
                with self.src.be:
                    self.curr = self.src.u32()
            if self.decode(0):
                if self.curr:
                    raise ValueError(&#39;decoding end of input&#39;)
                return None
            else:
                c = 1
                while c &lt; 256:
                    p = pr.predict() * 2 + 1
                    c *= 2
                    c += self.decode(p)
                    pr.update(c &amp; 1)
                return c - 256
        else:
            if self.curr == 0:
                with self.src.be:
                    self.curr = self.src.u32()
            if self.curr == 0:
                return None
            assert self.curr &gt; 0
            self.curr -= 1
            if self.src.eof:
                return None
            return self.src.u8fast()


class PostProcessor:
    state: int
    hsize: int
    ph: int
    pm: int
    z: ZPAQL

    def __init__(self):
        self.z = ZPAQL()
        self.init(0, 0)

    def init(self, h: int, m: int):
        self.state = 0
        self.hsize = 0
        self.ph = h
        self.pm = m
        self.z.clear()

    def set_output(self, writer: MemoryFile):
        self.z.output = writer

    def set_hasher(self, hasher: _Hash):
        self.z.sha1 = hasher

    def write(self, c: int | None):
        assert c is None or c in range(256)
        z = self.z
        s = self.state
        if c is None:
            if s == 5:
                c = -1
            elif s != 1:
                raise ValueError(&#39;Unexpected EOS&#39;)
        elif s == 0:
            if c is None:
                raise ValueError(&#39;Unexpected EOS&#39;)
            self.state = s = c + 1
            if s &gt; 2:
                raise RuntimeError(&#39;unknown post processing type&#39;)
            if s == 1:
                z.clear()
        elif s == 1:
            z.outc(c)
        elif s == 2:
            self.hsize = c
            self.state = 3
        elif s == 3:
            self.hsize += c * 256
            if self.hsize &lt; 1:
                raise RuntimeError(&#39;Empty PCOMP&#39;)
            _resize(z.header, self.hsize + 300)
            z.cend = 8
            z.hbegin = z.hend = z.cend + 128
            z.header[4] = self.ph
            z.header[5] = self.pm
            self.state = 4
        elif s == 4:
            assert z.hend &lt; len(z.header)
            z.header[z.hend] = c
            z.hend += 1
            if z.hend - z.hbegin == self.hsize:
                self.hsize = z.cend - 2 + z.hend - z.hbegin
                z.header[0] = self.hsize &amp; 255
                z.header[1] = self.hsize &gt;&gt; 8
                z.initp()
                self.state = 5
        elif s == 5:
            z.run(c)
        return self.state


class Decompressor:
    z: ZPAQL
    dec: Decoder
    pp: PostProcessor

    class State(IntEnum):
        BLOCK = 0
        FILENAME = 1
        COMMENT = 2
        DATA = 3
        SEGEND = 4

    state: State
    first_seg: bool

    def __init__(self, data: bytearray):
        self.z = z = ZPAQL()
        self.dec = Decoder(z, StructReader(data))
        self.pp = PostProcessor()
        self.state = Decompressor.State.BLOCK
        self.first_seg = True

    def set_output(self, op: MemoryFile):
        self.pp.set_output(op)

    def set_hasher(self, sha1: _Hash):
        self.pp.set_hasher(sha1)

    def read_block(self) -&gt; bool:
        if self.state is not Decompressor.State.BLOCK:
            raise RuntimeError(&#39;invalid state&#39;)
        h1 = 0x3D49B113
        h2 = 0x29EB7F93
        h3 = 0x2614BE13
        h4 = 0x3828EB13
        ip = self.dec.src
        while not ip.eof:
            c = ip.u8fast()
            h1 = h1 * 12 + c &amp; 0xFFFFFFFF
            h2 = h2 * 20 + c &amp; 0xFFFFFFFF
            h3 = h3 * 28 + c &amp; 0xFFFFFFFF
            h4 = h4 * 44 + c &amp; 0xFFFFFFFF
            if h1 == 0xB16B88F1 and h2 == 0xFF5376F1 and h3 == 0x72AC5BF1 and h4 == 0x2F909AF1:
                break
        if ip.eof:
            return False
        c = ip.u8fast()
        z = self.z
        if c not in (1, 2):
            raise RuntimeError(&#39;unsupported ZPAQ level&#39;)
        if ip.u8fast() != 1:
            raise RuntimeError(&#39;unsupported ZPAQ type&#39;)
        z.read(ip)
        if c == 1 and len(z.header) &gt; 6 and z.header[6] == 0:
            raise RuntimeError(&#39;ZPAQ level 1 requires at least 1 component&#39;)
        self.state = Decompressor.State.FILENAME
        self.first_seg = True
        return True

    def read_filename(self) -&gt; str | None:
        if self.state is not Decompressor.State.FILENAME:
            raise RuntimeError(&#39;invalid state&#39;)
        ip = self.dec.src
        c = ip.u8fast()
        if c == 1:
            self.state = Decompressor.State.COMMENT
            return ip.read_c_string(&#39;utf8&#39;)
        elif c == 0xFF:
            self.state = Decompressor.State.BLOCK
            return None
        else:
            raise RuntimeError(&#39;missing segment or end of block&#39;)

    def read_comment(self) -&gt; str | None:
        if self.state is Decompressor.State.BLOCK:
            return None
        if self.state is not Decompressor.State.COMMENT:
            raise RuntimeError(&#39;invalid state&#39;)
        ip = self.dec.src
        comment = ip.read_c_string(&#39;utf8&#39;)
        if ip.u8fast() != 0:
            raise RuntimeError(&#39;missing reserved byte&#39;)
        self.state = Decompressor.State.DATA
        return comment

    def decompress_data(self):
        if self.state is not Decompressor.State.DATA:
            raise RuntimeError(&#39;invalid state&#39;)
        z = self.z
        dec = self.dec
        pp = self.pp
        if self.first_seg:
            dec.init()
            assert len(z.header) &gt; 5
            pp.init(z.header[4], z.header[5])
            self.first_seg = False
        while pp.state &amp; 3 != 1:
            pp.write(dec.decompress())
        while True:
            c = dec.decompress()
            pp.write(c)
            if c is None:
                self.state = Decompressor.State.SEGEND
                return

    def read_segment_end(self) -&gt; bytes | None:
        if self.state is not Decompressor.State.SEGEND:
            raise RuntimeError(&#39;invalid state&#39;)
        dec = self.dec
        src = dec.src
        c = src.u8fast()
        if c == 254:
            checksum = None
        elif c == 253:
            checksum = src.read(20)
        else:
            raise RuntimeError(&#39;missing end of segment marker&#39;)
        self.state = Decompressor.State.FILENAME
        return checksum


class xtzpaq(ArchiveUnit, docs=&#39;{0}{s}{PathExtractorUnit}&#39;):
    &#34;&#34;&#34;
    Extract files from a ZPAQ archive.
    &#34;&#34;&#34;

    _MAGIC = B&#39;7kSt\xA01\x83\xD3\x8C\xB2\x28\xB0\xD3zPQ&#39;

    def __init__(
        self, *paths,
        index: Param[bool, Arg.Switch(&#39;-i&#39;, help=&#39;Archive is an index (no d-blocks).&#39;)] = False,
        **more
    ):
        for _code, _size in {
            _TCU32: 4,
            _TCI32: 4,
            _TCU16: 2,
            _TCI16: 2,
        }.items():
            _item_size = array(_code).itemsize
            if _item_size == _size:
                continue
            raise RuntimeError(
                F&#39;Expected array type &#34;{_code}&#34; to have entries of size {_size}, but the API &#39;
                F&#39;reports a size of {_item_size}.&#39;)

        super().__init__(*paths, index=index, **more)

    @classmethod
    def handles(cls, data) -&gt; bool | None:
        return data[:len(cls._MAGIC)] == cls._MAGIC

    def unpack(self, data: bytearray):
        def mkdate(date) -&gt; datetime:
            date = int(date)
            year = date // 1000000 // 10000
            month = date // 100000000 % 100
            day = date // 1000000 % 100
            hour = date // 10000 % 100
            minute = date // 100 % 100
            second = date % 100
            return datetime(year, month, day, hour, minute, second, 0)

        @dataclass
        class DT:
            date: int = 0
            attr: int = 0
            name: str = &#34;&#34;
            frag: list[int] = field(default_factory=list)

            @property
            def dt(self) -&gt; datetime | None:
                if self.date &gt; 0:
                    return mkdate(self.date)

        # TODO: implement password-protected archives
        # key = self.args.pwd
        index = self.args.index
        bsize: dict[int, int] = {}  # frag ID -&gt; d block compressed size
        dt: dict[str, DT] = {}      # filename -&gt; date, attr, frags
        frag: list[bytes] = []      # ID -&gt; hash[20] size[4] data
        csize = 0                   # expected offset of next non d block
        streaming = False
        journaling = False

        done = False
        dc = Decompressor(data)
        src = dc.dec.src
        offset = 0

        while not done and dc.read_block():
            while not done:
                filename = dc.read_filename()
                if filename is None:
                    break
                self.log_info(&#39;reading file&#39;, filename)
                comment = dc.read_comment()
                jsize = 0
                if comment and len(comment) &gt;= 4 and comment[-4:] == &#34;jDC\x01&#34;:
                    num = re.search(&#39;^\\d+&#39;, comment)
                    if not num:
                        raise RuntimeError(&#39;missing size in comment&#39;)
                    jsize = int(num[0])
                    if streaming:
                        raise RuntimeError(&#39;journaling block after streaming one&#39;)
                    journaling = True
                    self.log_info(&#39;archive type is journaling&#39;)
                else:
                    if journaling:
                        raise RuntimeError(&#39;streaming block after journaling one&#39;)
                    if index:
                        raise RuntimeError(&#39;streaming block in index&#39;)
                    streaming = True
                    self.log_info(&#39;archive type is streaming&#39;)

                # Test journaling filename. The format must be
                # jDC[YYYYMMDDHHMMSS][t][NNNNNNNNNN]
                # where YYYYMMDDHHMMSS is the date, t is the type {c,d,h,i}, and
                # NNNNNNNNNN is the 10 digit first fragment ID for types c,d,h.
                # They must be in ascending lexicographical order.

                frag_id = 0
                block_type = None

                if journaling:
                    if len(filename) != 28:
                        raise RuntimeError(&#39;filename size not 28&#39;)
                    if filename[:3] != &#39;jDC&#39;:
                        raise RuntimeError(&#39;filename not jDC&#39;)
                    block_type = filename[17]
                    if block_type not in &#39;cdhi&#39;:
                        raise RuntimeError(&#39;type not c,d,h,i&#39;)
                    try:
                        mkdate(filename[3:17])
                    except Exception as E:
                        raise RuntimeError(&#39;invalid date&#39;) from E
                    frag_id = int(filename[18:28])
                    if not 1 &lt;= frag_id &lt;= 4294967295:
                        raise RuntimeError(&#39;fragment ID out of range&#39;)

                seg = MemoryFile(size_limit=jsize)
                dc.set_output(seg)
                sha1 = hashlib.sha1()
                dc.set_hasher(sha1)
                dc.decompress_data()

                if journaling and len(seg) != jsize:
                    raise RuntimeError(&#39;incomplete output&#39;)

                checksum = dc.read_segment_end()
                if checksum is None:
                    self.log_debug(&#39;no checksum&#39;)
                elif checksum != sha1.digest():
                    raise RuntimeError(&#39;SHA1 mismatch&#39;)

                # check csize at first non-d block
                if csize and block_type and block_type in &#39;chi&#39;:
                    if csize != offset:
                        raise RuntimeError(F&#39;csize={csize} does not point to offset={offset}&#39;)
                    csize = 0

                # get csize from c block
                seglen = len(seg)
                seg = StructReader(seg.getvalue())
                if block_type == &#39;c&#39;:
                    if seglen &lt; 8:
                        raise RuntimeError(&#34;c block too small&#34;)
                    csize = seg.u64()
                    offset = src.tell() + 1
                    self.log_debug(F&#39;csize={csize} at offset={offset}&#39;)
                    if csize &gt;&gt; 63:
                        self.log_warn(&#39;incomplete transaction at end of archive&#39;)
                        done = True
                    elif index and csize != 0:
                        raise RuntimeError(&#39;nonzero csize in index&#39;)
                    # Set csize to expected offset of first non d block
                    # assuming 1 more byte for unread end of block marker.
                    csize += offset

                if block_type == &#39;d&#39;:
                    if index:
                        raise RuntimeError(&#39;d block in index&#39;)
                    bsize[frag_id] = src.tell() + 1 - offset  # compressed size
                    self.log_debug(F&#39; {bsize[frag_id]} -&gt; {len(seg)}&#39;)
                    # Test frag size list at end. The format is f[id..id+n-1] fid n
                    # where fid may be id or 0. sizes must sum to the rest of block.
                    if seglen &lt; 8:
                        raise RuntimeError(&#39;d block too small&#39;)
                    seg.seekset(-8)
                    fid = seg.u32() or frag_id
                    n = seg.u32()
                    if fid != frag_id:
                        raise RuntimeError(&#39;missing ID&#39;)
                    if n &gt; (seglen - 8) // 4:
                        raise RuntimeError(&#39;frag list too big&#39;)
                    fragsum = 0  # computed sum of frag sizes
                    seg.seekset(-4 * (n + 2))
                    for _ in range(n):
                        fragsum += seg.u32()
                    if fragsum + n * 4 + 8 != seglen:
                        raise RuntimeError(&#39;bad frag size list&#39;)
                    # Save frag hashes and sizes. For output, save data too.
                    seg.seekset(fragsum)
                    buffer = seg.getvalue()
                    assert seg.remaining_bytes == n * 4 + 8
                    for i in range(n):
                        while len(frag) &lt;= frag_id + i:
                            frag.append(B&#39;&#39;)
                        if frag[frag_id + i]:
                            raise RuntimeError(&#39;duplicate frag ID&#39;)
                        f = seg.u32()
                        h = hashlib.sha1(buffer[:f]).digest()
                        frag[frag_id + i] = h + f.to_bytes(4, &#39;little&#39;) + buffer[:f]
                        buffer = buffer[f:]

                    assert len(buffer) == n * 4 + 8
                    assert seg.remaining_bytes == 8

                # Test and save h block. Format is: bsize (sha1[20] size)...
                # where bsize is the compressed size of the d block with the same id,
                # and each size corresonds to a fragment in that block. The list
                # must match the list in the d block if present.

                if block_type == &#39;h&#39;:
                    if seglen % 24 != 4:
                        raise RuntimeError(&#39;bad h block size&#39;)
                    b = seg.u32()
                    self.log_debug(F&#39;[{frag_id}..{frag_id + seglen // 24}[ {b}&#39;)
                    fragsum = 0 # uncompressed size of all frags
                    for i in range(seglen // 24):
                        fd = seg.read(24)
                        if index:
                            while len(frag) &lt;= frag_id + i:
                                frag.append(B&#39;&#39;)
                            if frag[frag_id + i]:
                                raise RuntimeError(&#39;data in index&#39;)
                            frag[frag_id + i] = fd
                        elif frag_id + i &gt;= len(frag) or len(frag[frag_id + i]) &lt; 24:
                            raise RuntimeError(&#39;no matching d block&#39;)
                        elif frag[frag_id + i][:24] != fd:
                            raise RuntimeError(&#39;frag size or hash mismatch&#39;)
                        fragsum += int.from_bytes(fd[20:24], &#39;little&#39;)

                # Test i blocks and save files to extract. Format is:
                #   date filename 0 na attr[0..na) ni ptr[0..ni)   (to update)
                #   0    filename                                  (to delete)
                # Date is 64 bits in YYYYMMDDHHMMSS format.

                if block_type == &#39;i&#39;:
                    while not seg.eof:
                        f = DT(seg.u64())
                        f.name = seg.read_c_string(&#39;utf8&#39;)
                        if f.date &gt; 0:
                            na = seg.u32()
                            if na &gt; 65535:
                                raise ValueError(&#39;attr size &gt; 65535&#39;)
                            f.attr = seg.read_integer(na * 8)
                            ni = seg.u32()
                            for i in range(ni):
                                a = seg.u32()
                                f.frag.append(a)
                                if index:
                                    continue
                                elif not 1 &lt;= a &lt; len(frag):
                                    raise RuntimeError(&#39;frag ID out of range&#39;)
                                elif not frag[a]:
                                    raise LookupError(&#39;missing frag data&#39;)
                        dt[f.name] = f

                if streaming:
                    yield self._pack(filename, None, seg.getvalue())

            offset = src.tell()

        self.log_debug(F&#39;{offset} bytes of archive tested&#39;)

        if not journaling:
            return

        for name, f in dt.items():
            if not f.date:
                continue
            size = sum(
                int.from_bytes(frag[fp][20:24], &#39;little&#39;)
                for fp in f.frag
                if 0 &lt; fp &lt; len(frag) and len(frag[fp]) &gt;= 24
            )
            out = MemoryFile()
            for fp in f.frag:
                if fp &lt; len(frag):
                    out.write(memoryview(frag[fp])[24:])
            if len(out) != size:
                self.log_warn(&#39;invalid size during unpacking&#39;)
            yield self._pack(name, f.dt, out.getvalue())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.CompType"><code class="flex name class">
<span>class <span class="ident">CompType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L54-L64" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CompType(IntEnum):
    NONE  = 0 # noqa
    CONS  = 1 # noqa
    CM    = 2 # noqa
    ICM   = 3 # noqa
    MATCH = 4 # noqa
    AVG   = 5 # noqa
    MIX2  = 6 # noqa
    MIX   = 7 # noqa
    ISSE  = 8 # noqa
    SSE   = 9 # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.CompType.NONE"><code class="name">var <span class="ident">NONE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.CompType.CONS"><code class="name">var <span class="ident">CONS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.CompType.CM"><code class="name">var <span class="ident">CM</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.CompType.ICM"><code class="name">var <span class="ident">ICM</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.CompType.MATCH"><code class="name">var <span class="ident">MATCH</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.CompType.AVG"><code class="name">var <span class="ident">AVG</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.CompType.MIX2"><code class="name">var <span class="ident">MIX2</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.CompType.MIX"><code class="name">var <span class="ident">MIX</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.CompType.ISSE"><code class="name">var <span class="ident">ISSE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.CompType.SSE"><code class="name">var <span class="ident">SSE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL"><code class="flex name class">
<span>class <span class="ident">ZPAQL</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L71-L483" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZPAQL:

    output: MemoryFile | None
    header: bytearray # hsize[2] hh hm ph pm n COMP (guard) HCOMP (guard)
    cend: int
    hbegin: int
    hend: int

    m: bytearray
    h: array
    r: array

    a: int
    b: int
    c: int
    d: int
    f: int
    pc: int

    sha1: _Hash | None

    _cpu_defs: dict[int, str]
    _cpu_spec: dict[int, CodeType]

    def __init__(self):
        self.h = array(_TCU32)
        self.r = array(_TCU32)
        self.m = bytearray()
        self.sha1 = None
        self.output = None
        self.header = bytearray()
        self.clear()

        self._cpu_spec = {}
        self._cpu_defs = {
            0x01: &#39;a = a + 1 &amp; 0xFFFFFFFF&#39;,
            0x02: &#39;a = a - 1 &amp; 0xFFFFFFFF&#39;,
            0x03: &#39;a = ~a &amp; 0xFFFFFFFF&#39;,
            0x04: &#39;a = 0&#39;,
            0x07: &#39;a = r[{} % len(r)]&#39;,
            0x08: &#39;b, a = a, b&#39;,
            0x09: &#39;b = b + 1 &amp; 0xFFFFFFFF&#39;,
            0x0A: &#39;b = b - 1 &amp; 0xFFFFFFFF&#39;,
            0x0B: &#39;b = ~b &amp; 0xFFFFFFFF&#39;,
            0x0C: &#39;b = 0&#39;,
            0x0F: &#39;b = r[{} % len(r)]&#39;,
            0x10: &#39;c, a = a, c&#39;,
            0x11: &#39;c = c + 1 &amp; 0xFFFFFFFF&#39;,
            0x12: &#39;c = c - 1 &amp; 0xFFFFFFFF&#39;,
            0x13: &#39;c = ~c &amp; 0xFFFFFFFF&#39;,
            0x14: &#39;c = 0&#39;,
            0x17: &#39;c = r[{} % len(r)]&#39;,
            0x18: &#39;d, a = a, d&#39;,
            0x19: &#39;d = d + 1 &amp; 0xFFFFFFFF&#39;,
            0x1A: &#39;d = d - 1 &amp; 0xFFFFFFFF&#39;,
            0x1B: &#39;d = ~d &amp; 0xFFFFFFFF&#39;,
            0x1C: &#39;d = 0&#39;,
            0x1F: &#39;d = r[{} % len(r)]&#39;,
            0x20: &#39;m[b % len(m)], a = a, m[b % len(m)]&#39;,
            0x21: &#39;m[b % len(m)] += 1&#39;,
            0x22: &#39;m[b % len(m)] -= 1&#39;,
            0x23: &#39;m[b % len(m)] = ~m[b % len(m)] &amp; 0xFF&#39;,
            0x24: &#39;m[b % len(m)] = 0&#39;,
            0x27: &#39;pc += ((header[pc] + 128) &amp; 255) - 127 if f else 1&#39;,
            0x28: &#39;m[c % len(m)], a = a, m[c % len(m)]&#39;,
            0x29: &#39;m[c % len(m)] += 1&#39;,
            0x2A: &#39;m[c % len(m)] -= 1&#39;,
            0x2B: &#39;m[c % len(m)] = ~m[c % len(m)] &amp; 0xFF&#39;,
            0x2C: &#39;m[c % len(m)] = 0 &amp; 0xFF&#39;,
            0x2F: &#39;pc += 1 if f else ((header[pc] + 128) &amp; 255) - 127&#39;,
            0x30: &#39;h[d % len(h)], a = a, h[d % len(h)]&#39;,
            0x31: &#39;h[d % len(h)] += 1&#39;,
            0x32: &#39;h[d % len(h)] -= 1&#39;,
            0x33: &#39;h[d % len(h)] = ~h[d % len(h)]&#39;,
            0x34: &#39;h[d % len(h)] = 0&#39;,
            0x37: &#39;r[{} % len(r)] = a&#39;,
            0x38: &#39;raise halt(pc)&#39;,
            0x39: &#39;out(a &amp; 255)&#39;,
            0x3B: &#39;a = ((a + m[b % len(m)] + 512) * 773) &amp; 0xFFFFFFFF&#39;,
            0x3C: &#39;h[d % len(h)] = (h[d % len(h)] + a + 512) * 773 &amp; 0xFFFFFFFF&#39;,
            0x3F: &#39;pc += ((header[pc] + 128) &amp; 255) - 127&#39;,
            0x40: &#39;&#39;,
            0x41: &#39;a = b&#39;,
            0x42: &#39;a = c&#39;,
            0x43: &#39;a = d&#39;,
            0x44: &#39;a = m[b % len(m)]&#39;,
            0x45: &#39;a = m[c % len(m)]&#39;,
            0x46: &#39;a = h[d % len(h)]&#39;,
            0x47: &#39;a = {}&#39;,
            0x48: &#39;b = a&#39;,
            0x49: &#39;&#39;,
            0x4A: &#39;b = c&#39;,
            0x4B: &#39;b = d&#39;,
            0x4C: &#39;b = m[b % len(m)]&#39;,
            0x4D: &#39;b = m[c % len(m)]&#39;,
            0x4E: &#39;b = h[d % len(h)]&#39;,
            0x4F: &#39;b = {}&#39;,
            0x50: &#39;c = a&#39;,
            0x51: &#39;c = b&#39;,
            0x52: &#39;&#39;,
            0x53: &#39;c = d&#39;,
            0x54: &#39;c = m[b % len(m)]&#39;,
            0x55: &#39;c = m[c % len(m)]&#39;,
            0x56: &#39;c = h[d % len(h)]&#39;,
            0x57: &#39;c = {}&#39;,
            0x58: &#39;d = a&#39;,
            0x59: &#39;d = b&#39;,
            0x5A: &#39;d = c&#39;,
            0x5B: &#39;&#39;,
            0x5C: &#39;d = m[b % len(m)]&#39;,
            0x5D: &#39;d = m[c % len(m)]&#39;,
            0x5E: &#39;d = h[d % len(h)]&#39;,
            0x5F: &#39;d = {}&#39;,
            0x60: &#39;m[b % len(m)] = a &amp; 0xFF&#39;,
            0x61: &#39;m[b % len(m)] = b &amp; 0xFF&#39;,
            0x62: &#39;m[b % len(m)] = c &amp; 0xFF&#39;,
            0x63: &#39;m[b % len(m)] = d &amp; 0xFF&#39;,
            0x64: &#39;&#39;,
            0x65: &#39;m[b % len(m)] = m[c % len(m)]&#39;,
            0x66: &#39;m[b % len(m)] = h[d % len(h)] &amp; 0xFF&#39;,
            0x67: &#39;m[b % len(m)] = {}&#39;,
            0x68: &#39;m[c % len(m)] = a &amp; 0xFF&#39;,
            0x69: &#39;m[c % len(m)] = b &amp; 0xFF&#39;,
            0x6A: &#39;m[c % len(m)] = c &amp; 0xFF&#39;,
            0x6B: &#39;m[c % len(m)] = d &amp; 0xFF&#39;,
            0x6C: &#39;m[c % len(m)] = m[b % len(m)]&#39;,
            0x6D: &#39;&#39;,
            0x6E: &#39;m[c % len(m)] = h[d % len(h)] &amp; 0xFF&#39;,
            0x6F: &#39;m[c % len(m)] = {}&#39;,
            0x70: &#39;h[d % len(h)] = a&#39;,
            0x71: &#39;h[d % len(h)] = b&#39;,
            0x72: &#39;h[d % len(h)] = c&#39;,
            0x73: &#39;h[d % len(h)] = d&#39;,
            0x74: &#39;h[d % len(h)] = m[b % len(m)]&#39;,
            0x75: &#39;h[d % len(h)] = m[c % len(m)]&#39;,
            0x76: &#39;&#39;,
            0x77: &#39;h[d % len(h)] = {}&#39;,
            0x80: &#39;a = a + a &amp; 0xFFFFFFFF&#39;,
            0x81: &#39;a = a + b &amp; 0xFFFFFFFF&#39;,
            0x82: &#39;a = a + c &amp; 0xFFFFFFFF&#39;,
            0x83: &#39;a = a + d &amp; 0xFFFFFFFF&#39;,
            0x84: &#39;a = a + m[b % len(m)] &amp; 0xFFFFFFFF&#39;,
            0x85: &#39;a = a + m[c % len(m)] &amp; 0xFFFFFFFF&#39;,
            0x86: &#39;a = a + h[d % len(h)] &amp; 0xFFFFFFFF&#39;,
            0x87: &#39;a = a + {} &amp; 0xFFFFFFFF&#39;,
            0x88: &#39;a = 0&#39;,
            0x89: &#39;a = a - b &amp; 0xFFFFFFFF&#39;,
            0x8A: &#39;a = a - c &amp; 0xFFFFFFFF&#39;,
            0x8B: &#39;a = a - d &amp; 0xFFFFFFFF&#39;,
            0x8C: &#39;a = a - m[b % len(m)] &amp; 0xFFFFFFFF&#39;,
            0x8D: &#39;a = a - m[c % len(m)] &amp; 0xFFFFFFFF&#39;,
            0x8E: &#39;a = a - h[d % len(h)] &amp; 0xFFFFFFFF&#39;,
            0x8F: &#39;a = a - {} &amp; 0xFFFFFFFF&#39;,
            0x90: &#39;a = a * a &amp; 0xFFFFFFFF&#39;,
            0x91: &#39;a = a * b &amp; 0xFFFFFFFF&#39;,
            0x92: &#39;a = a * c &amp; 0xFFFFFFFF&#39;,
            0x93: &#39;a = a * d &amp; 0xFFFFFFFF&#39;,
            0x94: &#39;a = a * m[b % len(m)] &amp; 0xFFFFFFFF&#39;,
            0x95: &#39;a = a * m[c % len(m)] &amp; 0xFFFFFFFF&#39;,
            0x96: &#39;a = a * h[d % len(h)] &amp; 0xFFFFFFFF&#39;,
            0x97: &#39;a = a * {} &amp; 0xFFFFFFFF&#39;,
            0x98: &#39;a = a//a if a else 0&#39;,
            0x99: &#39;a = a//b if b else 0&#39;,
            0x9A: &#39;a = a//c if c else 0&#39;,
            0x9B: &#39;a = a//d if d else 0&#39;,
            0x9C: &#39;t = m[b % len(m)]\na = a//t if t else 0&#39;,
            0x9D: &#39;t = m[c % len(m)]\na = a//t if t else 0&#39;,
            0x9E: &#39;t = h[d % len(h)]\na = a//t if t else 0&#39;,
            0x9F: &#39;t = {}           \na = a//t if t else 0&#39;,
            0xA0: &#39;a = a % a if a else 0&#39;,
            0xA1: &#39;a = a % b if b else 0&#39;,
            0xA2: &#39;a = a % c if c else 0&#39;,
            0xA3: &#39;a = a % d if d else 0&#39;,
            0xA4: &#39;t = m[b % len(m)]\na = a % t if t else 0&#39;,
            0xA5: &#39;t = m[c % len(m)]\na = a % t if t else 0&#39;,
            0xA6: &#39;t = h[d % len(h)]\na = a % t if t else 0&#39;,
            0xA7: &#39;t = {}           \na = a % t if t else 0&#39;,
            0xA8: &#39;a &amp;= a&#39;,
            0xA9: &#39;a &amp;= b&#39;,
            0xAA: &#39;a &amp;= c&#39;,
            0xAB: &#39;a &amp;= d&#39;,
            0xAC: &#39;a &amp;= m[b % len(m)]&#39;,
            0xAD: &#39;a &amp;= m[c % len(m)]&#39;,
            0xAE: &#39;a &amp;= h[d % len(h)]&#39;,
            0xAF: &#39;a &amp;= {}&#39;,
            0xB0: &#39;a &amp;= ~a&#39;,
            0xB1: &#39;a &amp;= ~b&#39;,
            0xB2: &#39;a &amp;= ~c&#39;,
            0xB3: &#39;a &amp;= ~d&#39;,
            0xB4: &#39;a &amp;= ~m[b % len(m)]&#39;,
            0xB5: &#39;a &amp;= ~m[c % len(m)]&#39;,
            0xB6: &#39;a &amp;= ~h[d % len(h)]&#39;,
            0xB7: &#39;a &amp;= ~{}&#39;,
            0xB8: &#39;a |= a&#39;,
            0xB9: &#39;a |= b&#39;,
            0xBA: &#39;a |= c&#39;,
            0xBB: &#39;a |= d&#39;,
            0xBC: &#39;a |= m[b % len(m)]&#39;,
            0xBD: &#39;a |= m[c % len(m)]&#39;,
            0xBE: &#39;a |= h[d % len(h)]&#39;,
            0xBF: &#39;a |= {}&#39;,
            0xC0: &#39;a ^= a&#39;,
            0xC1: &#39;a ^= b&#39;,
            0xC2: &#39;a ^= c&#39;,
            0xC3: &#39;a ^= d&#39;,
            0xC4: &#39;a ^= m[b % len(m)]&#39;,
            0xC5: &#39;a ^= m[c % len(m)]&#39;,
            0xC6: &#39;a ^= h[d % len(h)]&#39;,
            0xC7: &#39;a ^= {}&#39;,
            0xC8: &#39;a = (a &lt;&lt; (a &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xC9: &#39;a = (a &lt;&lt; (b &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xCA: &#39;a = (a &lt;&lt; (c &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xCB: &#39;a = (a &lt;&lt; (d &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xCC: &#39;a = (a &lt;&lt; (m[b % len(m)] &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xCD: &#39;a = (a &lt;&lt; (m[c % len(m)] &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xCE: &#39;a = (a &lt;&lt; (h[d % len(h)] &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xCF: &#39;a = (a &lt;&lt; ({} &amp; 31)) &amp; 0xFFFFFFFF&#39;,
            0xD0: &#39;a &gt;&gt;= (a &amp; 31)&#39;,
            0xD1: &#39;a &gt;&gt;= (b &amp; 31)&#39;,
            0xD2: &#39;a &gt;&gt;= (c &amp; 31)&#39;,
            0xD3: &#39;a &gt;&gt;= (d &amp; 31)&#39;,
            0xD4: &#39;a &gt;&gt;= (m[b % len(m)] &amp; 31)&#39;,
            0xD5: &#39;a &gt;&gt;= (m[c % len(m)] &amp; 31)&#39;,
            0xD6: &#39;a &gt;&gt;= (h[d % len(h)] &amp; 31)&#39;,
            0xD7: &#39;a &gt;&gt;= ({} &amp; 31)&#39;,
            0xD8: &#39;f = (a == a)&#39;,
            0xD9: &#39;f = (a == b)&#39;,
            0xDA: &#39;f = (a == c)&#39;,
            0xDB: &#39;f = (a == d)&#39;,
            0xDC: &#39;f = (a == m[b % len(m)])&#39;,
            0xDD: &#39;f = (a == m[c % len(m)])&#39;,
            0xDE: &#39;f = (a == h[d % len(h)])&#39;,
            0xDF: &#39;f = (a == {})&#39;,
            0xE0: &#39;f = (a &lt; a)&#39;,
            0xE1: &#39;f = (a &lt; b)&#39;,
            0xE2: &#39;f = (a &lt; c)&#39;,
            0xE3: &#39;f = (a &lt; d)&#39;,
            0xE4: &#39;f = (a &lt; m[b % len(m)])&#39;,
            0xE5: &#39;f = (a &lt; m[c % len(m)])&#39;,
            0xE6: &#39;f = (a &lt; h[d % len(h)])&#39;,
            0xE7: &#39;f = (a &lt; {})&#39;,
            0xE8: &#39;f = (a &gt; a)&#39;,
            0xE9: &#39;f = (a &gt; b)&#39;,
            0xEA: &#39;f = (a &gt; c)&#39;,
            0xEB: &#39;f = (a &gt; d)&#39;,
            0xEC: &#39;f = (a &gt; m[b % len(m)])&#39;,
            0xED: &#39;f = (a &gt; m[c % len(m)])&#39;,
            0xEE: &#39;f = (a &gt; h[d % len(h)])&#39;,
            0xEF: &#39;f = (a &gt; {})&#39;,
            0xFF: (
                &#39;pc = hbegin + header[pc] + 256 * header[pc + 1]\n&#39;
                &#39;if pc &gt;= hend: raise RuntimeError&#39;
            )
        }

    def inith(self):
        self.init(self.header[2], self.header[3])

    def initp(self):
        self.init(self.header[4], self.header[5])

    def run(self, input: int):
        assert self.cend &gt; 6
        assert self.hbegin &gt;= self.cend + 128
        assert self.hend &gt;= self.hbegin
        assert self.hend &lt; len(self.header) - 130
        assert len(self.m) &gt; 0
        assert len(self.h) &gt; 0
        assert self.header[0] + 256 * self.header[1] == self.cend + self.hend - self.hbegin - 2
        self.pc = self.hbegin
        self.a = input
        self.execute_loop()

    def read(self, in2: StructReader) -&gt; int:
        hsize = in2.u16()
        self.header = bytearray(hsize + 300)
        cend = hbegin = hend = 0
        self.header[cend] = hsize &amp; 255
        cend += 1
        self.header[cend] = hsize &gt;&gt; 8
        cend += 1
        while cend &lt; 7:
            self.header[cend] = in2.u8()
            cend += 1
        n = self.header[cend - 1]
        for _ in range(n):
            type = in2.u8()
            self.header[cend] = type
            cend += 1
            size = CompSize[type]
            for _ in range(1, size):
                self.header[cend] = in2.u8()
                cend += 1
        end_byte = in2.u8()
        self.header[cend] = end_byte
        cend += 1
        if end_byte != 0:
            raise ValueError(&#39;missing COMP END&#39;)
        hbegin = hend = cend + 128
        if hend &gt; hsize + 129:
            raise ValueError(&#39;missing HCOMP&#39;)
        while hend &lt; hsize + 129:
            assert hend &lt; len(self.header) - 8
            op = in2.u8()
            self.header[hend] = op
            hend += 1
        end_byte = in2.u8()
        self.header[hend] = end_byte
        hend += 1
        self.cend = cend
        self.hend = hend
        self.hbegin = hbegin
        if end_byte != 0:
            raise ValueError(&#39;missing HCOMP END&#39;)
        assert cend &gt;= 7 and cend &lt; len(self.header)
        assert hbegin == cend + 128 and hbegin &lt; len(self.header)
        assert hend &gt; hbegin and hend &lt; len(self.header)
        assert hsize == self.header[0] + 256 * self.header[1]
        assert hsize == cend - 2 + hend - hbegin
        return cend + hend - hbegin

    def clear(self):
        self.cend = 0
        self.hbegin = 0
        self.hend = 0
        self.a = 0
        self.b = 0
        self.c = 0
        self.d = 0
        self.f = 0
        self.pc = 0
        self.header.clear()
        self.m.clear()
        del self.h[:]
        del self.r[:]

    def outc(self, c: int):
        c &amp;= 0xFF
        if self.output is not None:
            self.output.write_byte(c)
        if self.sha1 is not None:
            self.sha1.update(bytes((c,)))

    def init(self, hbits: int, mbits: int):
        assert len(self.header) &gt; 0
        assert self.cend &gt;= 7
        assert self.hbegin &gt;= self.cend + 128
        assert self.hend &gt;= self.hbegin
        assert self.hend &lt; len(self.header) - 130
        assert self.header[0] + 256 * self.header[1] == self.cend - 2 + self.hend - self.hbegin
        mlen = 1 &lt;&lt; mbits
        hlen = 1 &lt;&lt; hbits
        rlen = 0x100
        del self.m[mlen:]
        self.m.extend(itertools.repeat(0, mlen - len(self.m)))
        del self.h[hlen:]
        self.h.extend(itertools.repeat(0, hlen - len(self.h)))
        del self.r[rlen:]
        self.r.extend(itertools.repeat(0, rlen - len(self.r)))
        _resize(self.r, 256)
        self.a = 0
        self.b = 0
        self.c = 0
        self.d = 0
        self.f = 0
        self.pc = 0

    def execute_loop(self):

        def out(c: int):
            c &amp;= 0xFF
            if self.output is not None:
                self.output.write_byte(c)
            if self.sha1 is not None:
                self.sha1.update(bytes((c,)))

        cpu = dict(self.__dict__)
        cpu.update(out=out, halt=_HaltExecution)

        while True:
            pc = cpu[&#39;pc&#39;]
            try:
                code = self._cpu_spec[pc]
            except KeyError:
                with io.StringIO() as writer:
                    start = pc
                    done = False
                    xtzpaq.log_info(F&#39;precompiling block B{start:08X}&#39;)
                    while not done:
                        opcode = self.header[pc]
                        try:
                            line = self._cpu_defs[opcode]
                        except KeyError:
                            raise RuntimeError(F&#39;invalid opcode: 0x{opcode:02X}&#39;)
                        pc += 1
                        if &#39;{}&#39; in line:
                            line = line.format(self.header[pc])
                            pc += 1
                        if &#39;pc&#39; in line:
                            done = True
                            writer.write(F&#39;pc = {pc}\n&#39;)
                        writer.write(F&#39;{line}\n&#39;)
                    code = writer.getvalue()
                self._cpu_spec[start] = code = compile(
                    code, F&#39;&lt;BB:{start:08X}&gt;&#39;, &#39;exec&#39;, optimize=2)
            try:
                exec(code, {}, cpu)
            except _HaltExecution:
                break
            except Exception as E:
                raise E

        self.__dict__.update((k, cpu[k]) for k in self.__dict__.keys() &amp; cpu.keys())</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.output"><code class="name">var <span class="ident">output</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.header"><code class="name">var <span class="ident">header</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.cend"><code class="name">var <span class="ident">cend</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.hbegin"><code class="name">var <span class="ident">hbegin</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.hend"><code class="name">var <span class="ident">hend</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.m"><code class="name">var <span class="ident">m</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.h"><code class="name">var <span class="ident">h</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.r"><code class="name">var <span class="ident">r</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.a"><code class="name">var <span class="ident">a</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.b"><code class="name">var <span class="ident">b</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.c"><code class="name">var <span class="ident">c</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.d"><code class="name">var <span class="ident">d</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.f"><code class="name">var <span class="ident">f</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.pc"><code class="name">var <span class="ident">pc</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.sha1"><code class="name">var <span class="ident">sha1</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.inith"><code class="name flex">
<span>def <span class="ident">inith</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L326-L327" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def inith(self):
    self.init(self.header[2], self.header[3])</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.initp"><code class="name flex">
<span>def <span class="ident">initp</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L329-L330" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def initp(self):
    self.init(self.header[4], self.header[5])</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, input)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L332-L342" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def run(self, input: int):
    assert self.cend &gt; 6
    assert self.hbegin &gt;= self.cend + 128
    assert self.hend &gt;= self.hbegin
    assert self.hend &lt; len(self.header) - 130
    assert len(self.m) &gt; 0
    assert len(self.h) &gt; 0
    assert self.header[0] + 256 * self.header[1] == self.cend + self.hend - self.hbegin - 2
    self.pc = self.hbegin
    self.a = input
    self.execute_loop()</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, in2)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L344-L390" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read(self, in2: StructReader) -&gt; int:
    hsize = in2.u16()
    self.header = bytearray(hsize + 300)
    cend = hbegin = hend = 0
    self.header[cend] = hsize &amp; 255
    cend += 1
    self.header[cend] = hsize &gt;&gt; 8
    cend += 1
    while cend &lt; 7:
        self.header[cend] = in2.u8()
        cend += 1
    n = self.header[cend - 1]
    for _ in range(n):
        type = in2.u8()
        self.header[cend] = type
        cend += 1
        size = CompSize[type]
        for _ in range(1, size):
            self.header[cend] = in2.u8()
            cend += 1
    end_byte = in2.u8()
    self.header[cend] = end_byte
    cend += 1
    if end_byte != 0:
        raise ValueError(&#39;missing COMP END&#39;)
    hbegin = hend = cend + 128
    if hend &gt; hsize + 129:
        raise ValueError(&#39;missing HCOMP&#39;)
    while hend &lt; hsize + 129:
        assert hend &lt; len(self.header) - 8
        op = in2.u8()
        self.header[hend] = op
        hend += 1
    end_byte = in2.u8()
    self.header[hend] = end_byte
    hend += 1
    self.cend = cend
    self.hend = hend
    self.hbegin = hbegin
    if end_byte != 0:
        raise ValueError(&#39;missing HCOMP END&#39;)
    assert cend &gt;= 7 and cend &lt; len(self.header)
    assert hbegin == cend + 128 and hbegin &lt; len(self.header)
    assert hend &gt; hbegin and hend &lt; len(self.header)
    assert hsize == self.header[0] + 256 * self.header[1]
    assert hsize == cend - 2 + hend - hbegin
    return cend + hend - hbegin</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L392-L405" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clear(self):
    self.cend = 0
    self.hbegin = 0
    self.hend = 0
    self.a = 0
    self.b = 0
    self.c = 0
    self.d = 0
    self.f = 0
    self.pc = 0
    self.header.clear()
    self.m.clear()
    del self.h[:]
    del self.r[:]</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.outc"><code class="name flex">
<span>def <span class="ident">outc</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L407-L412" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def outc(self, c: int):
    c &amp;= 0xFF
    if self.output is not None:
        self.output.write_byte(c)
    if self.sha1 is not None:
        self.sha1.update(bytes((c,)))</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self, hbits, mbits)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L414-L436" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def init(self, hbits: int, mbits: int):
    assert len(self.header) &gt; 0
    assert self.cend &gt;= 7
    assert self.hbegin &gt;= self.cend + 128
    assert self.hend &gt;= self.hbegin
    assert self.hend &lt; len(self.header) - 130
    assert self.header[0] + 256 * self.header[1] == self.cend - 2 + self.hend - self.hbegin
    mlen = 1 &lt;&lt; mbits
    hlen = 1 &lt;&lt; hbits
    rlen = 0x100
    del self.m[mlen:]
    self.m.extend(itertools.repeat(0, mlen - len(self.m)))
    del self.h[hlen:]
    self.h.extend(itertools.repeat(0, hlen - len(self.h)))
    del self.r[rlen:]
    self.r.extend(itertools.repeat(0, rlen - len(self.r)))
    _resize(self.r, 256)
    self.a = 0
    self.b = 0
    self.c = 0
    self.d = 0
    self.f = 0
    self.pc = 0</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.ZPAQL.execute_loop"><code class="name flex">
<span>def <span class="ident">execute_loop</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L438-L483" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def execute_loop(self):

    def out(c: int):
        c &amp;= 0xFF
        if self.output is not None:
            self.output.write_byte(c)
        if self.sha1 is not None:
            self.sha1.update(bytes((c,)))

    cpu = dict(self.__dict__)
    cpu.update(out=out, halt=_HaltExecution)

    while True:
        pc = cpu[&#39;pc&#39;]
        try:
            code = self._cpu_spec[pc]
        except KeyError:
            with io.StringIO() as writer:
                start = pc
                done = False
                xtzpaq.log_info(F&#39;precompiling block B{start:08X}&#39;)
                while not done:
                    opcode = self.header[pc]
                    try:
                        line = self._cpu_defs[opcode]
                    except KeyError:
                        raise RuntimeError(F&#39;invalid opcode: 0x{opcode:02X}&#39;)
                    pc += 1
                    if &#39;{}&#39; in line:
                        line = line.format(self.header[pc])
                        pc += 1
                    if &#39;pc&#39; in line:
                        done = True
                        writer.write(F&#39;pc = {pc}\n&#39;)
                    writer.write(F&#39;{line}\n&#39;)
                code = writer.getvalue()
            self._cpu_spec[start] = code = compile(
                code, F&#39;&lt;BB:{start:08X}&gt;&#39;, &#39;exec&#39;, optimize=2)
        try:
            exec(code, {}, cpu)
        except _HaltExecution:
            break
        except Exception as E:
            raise E

    self.__dict__.update((k, cpu[k]) for k in self.__dict__.keys() &amp; cpu.keys())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Component"><code class="flex name class">
<span>class <span class="ident">Component</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L486-L498" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Component:
    def __init__(self):
        self.init()

    def init(self):
        self.limit = 0
        self.cxt = 0
        self.a = 0
        self.b = 0
        self.c = 0
        self.ht = bytearray()
        self.cm = array(_TCU32)
        self.a16 = array(_TCU32)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.Component.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L490-L498" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def init(self):
    self.limit = 0
    self.cxt = 0
    self.a = 0
    self.b = 0
    self.c = 0
    self.ht = bytearray()
    self.cm = array(_TCU32)
    self.a16 = array(_TCU32)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.StateTable"><code class="flex name class">
<span>class <span class="ident">StateTable</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L501-L574" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StateTable:
    _N = 64
    ns: bytearray

    def next(self, state: int, y: int):
        assert 0 &lt;= state &lt;= 256
        assert 0 &lt;= y &lt;= 3
        return self.ns[state * 4 + y]

    def cminit(self, state: int):
        assert 0 &lt;= state &lt;= 256
        ns = self.ns
        a = (ns[state * 4 + 3] * 2 + 1) &lt;&lt; 22
        b = ns[state * 4 + 2] + ns[state * 4 + 3] + 1
        return a // b

    def num_states(self, n0: int, n1: int):
        bound = (20, 48, 15, 8, 6, 5)
        if n0 &lt; n1:
            return self.num_states(n1, n0)
        if n0 &lt; 0 or n1 &lt; 0 or n1 &gt;= len(bound) or n0 &gt; bound[n1]:
            return 0
        return 1 + int(n1 &gt; 0 and n0 + n1 &lt;= 17)

    def discount(self, n0: int):
        return (n0 &gt;= 1) + (n0 &gt;= 2) + (n0 &gt;= 3) + (n0 &gt;= 4) + (n0 &gt;= 5) + (n0 &gt;= 7) + (n0 &gt;= 8)

    def next_state(self, n0: int, n1: int, y: int):
        if n0 &lt; n1:
            n1, n0 = self.next_state(n1, n0, 1 - y)
            return n0, n1
        if y:
            n1 += 1
            n0 = self.discount(n0)
        else:
            n0 += 1
            n1 = self.discount(n1)
        while not self.num_states(n0, n1):
            if n1 &lt; 2:
                n0 = n0 - 1
            else:
                n0 = (n0 * (n1 - 1) + (n1 // 2)) // n1
                n1 = n1 - 1
        return n0, n1

    def __init__(self):
        N = 50
        t = [[bytearray(N) for _ in range(N)] for _ in range(2)]
        state = 0
        for i in range(N):
            for n1 in range(i + 1):
                n0 = i - n1
                n = self.num_states(n0, n1)
                assert 0 &lt;= n &lt;= 2
                if not n:
                    continue
                t[0][n0][n1] = state
                t[1][n0][n1] = state + n - 1
                state += n
        self.ns = bytearray(1024)
        for n0 in range(N):
            for n1 in range(N):
                for y in range(self.num_states(n0, n1)):
                    assert 0 &lt;= y &lt;= 1
                    s = t[y][n0][n1]
                    assert 0 &lt;= s &lt;= 256
                    s0, s1 = self.next_state(n0, n1, 0)
                    assert 0 &lt;= s0 &lt;= N and 0 &lt;= s1 &lt;= N
                    self.ns[s * 4 + 0] = t[0][s0][s1]
                    s0, s1 = self.next_state(n0, n1, 1)
                    assert 0 &lt;= s0 &lt;= N and 0 &lt;= s1 &lt;= N
                    self.ns[s * 4 + 1] = t[1][s0][s1]
                    self.ns[s * 4 + 2] = n0
                    self.ns[s * 4 + 3] = n1</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.StateTable.ns"><code class="name">var <span class="ident">ns</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.StateTable.next"><code class="name flex">
<span>def <span class="ident">next</span></span>(<span>self, state, y)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L505-L508" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def next(self, state: int, y: int):
    assert 0 &lt;= state &lt;= 256
    assert 0 &lt;= y &lt;= 3
    return self.ns[state * 4 + y]</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.StateTable.cminit"><code class="name flex">
<span>def <span class="ident">cminit</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L510-L515" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cminit(self, state: int):
    assert 0 &lt;= state &lt;= 256
    ns = self.ns
    a = (ns[state * 4 + 3] * 2 + 1) &lt;&lt; 22
    b = ns[state * 4 + 2] + ns[state * 4 + 3] + 1
    return a // b</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.StateTable.num_states"><code class="name flex">
<span>def <span class="ident">num_states</span></span>(<span>self, n0, n1)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L517-L523" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def num_states(self, n0: int, n1: int):
    bound = (20, 48, 15, 8, 6, 5)
    if n0 &lt; n1:
        return self.num_states(n1, n0)
    if n0 &lt; 0 or n1 &lt; 0 or n1 &gt;= len(bound) or n0 &gt; bound[n1]:
        return 0
    return 1 + int(n1 &gt; 0 and n0 + n1 &lt;= 17)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.StateTable.discount"><code class="name flex">
<span>def <span class="ident">discount</span></span>(<span>self, n0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L525-L526" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def discount(self, n0: int):
    return (n0 &gt;= 1) + (n0 &gt;= 2) + (n0 &gt;= 3) + (n0 &gt;= 4) + (n0 &gt;= 5) + (n0 &gt;= 7) + (n0 &gt;= 8)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.StateTable.next_state"><code class="name flex">
<span>def <span class="ident">next_state</span></span>(<span>self, n0, n1, y)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L528-L544" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def next_state(self, n0: int, n1: int, y: int):
    if n0 &lt; n1:
        n1, n0 = self.next_state(n1, n0, 1 - y)
        return n0, n1
    if y:
        n1 += 1
        n0 = self.discount(n0)
    else:
        n0 += 1
        n1 = self.discount(n1)
    while not self.num_states(n0, n1):
        if n1 &lt; 2:
            n0 = n0 - 1
        else:
            n0 = (n0 * (n1 - 1) + (n1 // 2)) // n1
            n1 = n1 - 1
    return n0, n1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor"><code class="flex name class">
<span>class <span class="ident">Predictor</span></span>
<span>(</span><span>z)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L577-L947" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Predictor:

    c8: int
    hmap4: int
    p: array
    h: array
    z: ZPAQL

    comp: list[Component]

    dt2k: array
    dt: array
    squasht: array
    stretcht: array
    st: StateTable

    def __init__(self, z: ZPAQL):
        self.c8 = 1
        self.hmap4 = 1
        self.z = z
        self.st = StateTable()
        self.dt2k = array(_TCI32)
        self.dt = array(_TCI32)
        self.squasht = array(_TCU16)
        self.stretcht = array(_TCI16)
        self.p = array(_TCI32)
        self.h = array(_TCU32)
        self.comp = []
        for _ in range(0x100):
            self.p.append(0)
            self.h.append(0)
            self.comp.append(Component())
        self.p = array(_TCI32)
        self.h = array(_TCU32)
        _resize(self.p, 256)
        _resize(self.h, 256)
        self.dt2k.append(0)
        for i in range(1, 0x100):
            self.dt2k.append(2048 // i)
        for i in range(1024):
            self.dt.append(((1 &lt;&lt; 17) // (i * 2 + 3)) * 2)
        for i in range(32768):
            _k = 100000
            _l = log((i + 0.5) / (32767.5 - i)) * 64 + 0.5
            self.stretcht.append(int(_l + _k) - _k)
        for i in range(4096):
            _e = exp((i - 2048) * (-1.0 / 64)) + 1
            self.squasht.append(int(32768.0 / _e))
        sqsum = 0
        stsum = 0
        for v in reversed(self.stretcht):
            stsum = stsum * 3 + v &amp; 0xFFFFFFFF
        for v in reversed(self.squasht):
            sqsum = sqsum * 3 + v &amp; 0xFFFFFFFF
        if stsum != 3887533746:
            raise RuntimeError(F&#39;checksum failure for stretch {stsum}&#39;)
        if sqsum != 2278286169:
            raise RuntimeError(F&#39;checksum failure for squash {sqsum}&#39;)

    def init(self):
        self.z.inith()
        for i in range(0x100):
            self.h[i] = 0
            self.p[i] = 0
            self.comp[i].init()
        n = self.z.header[6]
        cp = memoryview(self.z.header)[7:self.z.cend]
        for i in range(n):
            assert cp
            cr = self.comp[i]
            ct = CompType(cp[0])
            if ct is CompType.CONS:
                self.p[i] = (cp[1] - 128) * 4
            elif ct is CompType.CM:
                if cp[1] &gt; 32:
                    raise ValueError(&#39;max size for CM is 32&#39;)
                _resize(cr.cm, 1, cp[1])
                cr.limit = cp[2] * 4
                for j in range(len(cr.cm)):
                    cr.cm[j] = 0x80000000
            elif ct is CompType.ICM:
                if cp[1] &gt; 26:
                    raise ValueError(&#39;max size for ICM is 26&#39;)
                cr.limit = 1023
                _resize(cr.cm, 256)
                _resize(cr.ht, 64, cp[1])
                for j in range(256):
                    cr.cm[j] = self.st.cminit(j)
            elif ct is CompType.MATCH:
                if cp[1] &gt; 32 or cp[2] &gt; 32:
                    raise ValueError(&#39;max size for MATCH is 32/32&#39;)
                _resize(cr.cm, 1, cp[1])
                _resize(cr.ht, 1, cp[2])
                cr.ht[0] = 1
            elif ct is CompType.AVG:
                if cp[1] &gt;= i:
                    raise ValueError(&#39;AVG j &gt;= i&#39;)
                if cp[2] &gt;= i:
                    raise ValueError(&#39;AVG k &gt;= i&#39;)
            elif ct is CompType.MIX2:
                if cp[1] &gt; 32:
                    raise ValueError(&#39;max size for MIX2 is 32&#39;)
                if cp[3] &gt;= i:
                    raise ValueError(&#39;MIX2 k &gt;= i&#39;)
                if cp[2] &gt;= i:
                    raise ValueError(&#39;MIX2 j &gt;= i&#39;)
                cr.c = 1 &lt;&lt; cp[1]  # size (number of contexts)
                _resize(cr.a16, 1, cp[1])
                for j in range(len(cr.a16)):
                    cr.a16[j] = 32768
            elif ct is CompType.MIX:
                if cp[1] &gt; 32:
                    raise ValueError(&#39;max size for MIX is 32&#39;)
                if cp[2] &gt;= i:
                    raise ValueError(&#39;MIX j &gt;= i&#39;)
                if cp[3] &lt; 1 or cp[3] &gt; i - cp[2]:
                    raise ValueError(&#39;MIX m not in 1..i-j&#39;)
                m = cp[3] # number of inputs
                assert m &gt;= 1
                cr.c = 1 &lt;&lt; cp[1]  # size (number of contexts)
                _resize(cr.cm, m, cp[1])
                for j in range(len(cr.cm)):
                    cr.cm[j] = 65536 // m
            elif ct is CompType.ISSE:
                if cp[1] &gt; 32:
                    raise ValueError(&#39;max size for ISSE is 32&#39;)
                if cp[2] &gt;= i:
                    raise ValueError(&#39;ISSE j &gt;= i&#39;)
                _resize(cr.ht, 64, cp[1])
                _resize(cr.cm, 512)
                for j in range(256):
                    clamped = self.clamp512k(self.stretch(self.st.cminit(j) &gt;&gt; 8) * 1024)
                    cr.cm[j * 2 + 0] = 1 &lt;&lt; 15
                    cr.cm[j * 2 + 1] = clamped
            elif ct is CompType.SSE:
                if cp[1] &gt; 32:
                    raise ValueError(&#39;max size for SSE is 32&#39;)
                if cp[2] &gt;= i:
                    raise ValueError(&#39;SSE j &gt;= i&#39;)
                if cp[3] &gt; cp[4] * 4:
                    raise ValueError(&#39;SSE start &gt; limit*4&#39;)
                _resize(cr.cm, 32, cp[1])
                cr.limit = cp[4] * 4
                for j in range(len(cr.cm)):
                    cr.cm[j] = self.squash((j &amp; 31) * 64 - 992) &lt;&lt; 17 | cp[3]
            else:
                raise ValueError(&#39;unknown component type&#39;)
            cs = CompSize[cp[0]]
            cp = cp[cs:]

    def predict(self):
        assert 0 &lt; self.c8 &lt; 256
        n = self.z.header[6]
        assert 0 &lt; n &lt; 256
        cp = memoryview(self.z.header)[7:]
        assert self.z.header[6] == n
        p = self.p
        h = self.h
        for i in range(n):
            cr = self.comp[i]
            ct = CompType(cp[0])
            if ct is CompType.CONS:
                pass
            elif ct is CompType.CM:
                cr.cxt = self.h[i] ^ self.hmap4
                p[i] = self.stretch(cr.cm[cr.cxt] &gt;&gt; 17)
            elif ct is CompType.ICM:
                assert self.hmap4 &amp; 15 &gt; 0
                if self.c8 == 1 or (self.c8 &amp; 0xF0) == 16:
                    cr.c = self.find(cr.ht, cp[1] + 2, h[i] + 16 * self.c8)
                cr.cxt = cr.ht[cr.c + (self.hmap4 &amp; 15)]
                p[i] = self.stretch(cr.cm[cr.cxt] &gt;&gt; 8)
            elif ct is CompType.MATCH:
                assert len(cr.cm) == 1 &lt;&lt; cp[1]
                assert len(cr.ht) == 1 &lt;&lt; cp[2]
                assert cr.a &lt;= 255
                assert cr.c in {0, 1}
                assert cr.cxt &lt; 8
                assert cr.limit &lt; len(cr.ht)
                if cr.a == 0:
                    p[i] = 0
                else:
                    cr.c = (cr.ht[cr.limit - cr.b] &gt;&gt; (7 - cr.cxt)) &amp; 1
                    p[i] = self.stretch(self.dt2k[cr.a] * (cr.c * -2 + 1) &amp; 32767)
            elif ct is CompType.AVG:
                p[i] = (p[cp[1]] * cp[3] + p[cp[2]] * (256 - cp[3])) &gt;&gt; 8
            elif ct is CompType.MIX2:
                cr.cxt = (h[i] + (self.c8 &amp; cp[5])) &amp; (cr.c - 1)
                assert cr.cxt &lt; len(cr.a16)
                w = cr.a16[cr.cxt]
                assert 0 &lt;= w &lt; 65536
                p[i] = (w * p[cp[2]] + (65536 - w) * p[cp[3]]) &gt;&gt; 16
                assert -2048 &lt;= p[i] &lt; 2048
            elif ct is CompType.MIX:
                m = cp[3]
                assert 1 &lt;= m &lt;= i
                cr.cxt = h[i] + (self.c8 &amp; cp[5])
                cr.cxt = (cr.cxt &amp; (cr.c - 1)) * m
                assert cr.cxt &lt;= len(cr.cm) - m
                w = cr.cxt
                p[i] = 0
                for j in range(m):
                    p[i] += (_i32(cr.cm[w + j]) &gt;&gt; 8) * p[cp[2] + j]
                p[i] = self.clamp2k(p[i] &gt;&gt; 8)
            elif ct is CompType.ISSE:
                if self.c8 == 1 or (self.c8 &amp; 0xF0) == 16:
                    cr.c = self.find(cr.ht, cp[1] + 2, h[i] + 16 * self.c8)
                cr.cxt = cr.ht[cr.c + (self.hmap4 &amp; 15)]
                wt0 = _i32(cr.cm[cr.cxt * 2 + 0])
                wt1 = _i32(cr.cm[cr.cxt * 2 + 1])
                p[i] = self.clamp2k((wt0 * p[cp[2]] + wt1 * 64) &gt;&gt; 16)
            elif ct is CompType.SSE:
                cr.cxt = (h[i] + self.c8) * 32
                pq = min(max(0, p[cp[2]] + 992), 1983)
                wt = pq &amp; 63
                pq &gt;&gt;= 6
                assert 0 &lt;= pq &lt;= 30
                cr.cxt += pq
                p[i] = self.stretch((
                    (cr.cm[cr.cxt + 0] &gt;&gt; 10) * (64 - wt) + (cr.cm[cr.cxt + 1] &gt;&gt; 10) * wt) &gt;&gt; 13)
                cr.cxt += wt &gt;&gt; 5
            else:
                raise ValueError(&#39;component predict not implemented&#39;)
            cs = CompSize[cp[0]]
            cp = cp[cs:]
        assert CompType(cp[0]) is CompType.NONE
        return self.squash(p[n - 1])

    def update(self, y: int):
        assert y in (0, 1)
        assert 0 &lt; self.c8 &lt; 256
        assert 0 &lt; self.hmap4 &lt; 512
        cp = memoryview(self.z.header)[7:]
        n = self.z.header[6]
        h = self.h
        p = self.p
        assert 0 &lt; n &lt; 256
        for i in range(n):
            cr = self.comp[i]
            ct = CompType(cp[0])
            if ct is CompType.CONS:
                pass
            elif ct is CompType.CM:
                self.train(cr, y)
            elif ct is CompType.ICM:
                k = cr.c + (self.hmap4 &amp; 15)
                cr.ht[k] = self.st.next(cr.ht[k], y)
                pn = cr.cm[cr.cxt]
                pn += (y * 32767 - (pn &gt;&gt; 8)) &gt;&gt; 2
                cr.cm[cr.cxt] = pn
            elif ct is CompType.MATCH:
                assert cr.a &lt;= 255
                assert cr.c in (0, 1)
                assert cr.cxt &lt; 8
                assert len(cr.cm) == 1 &lt;&lt; cp[1]
                assert len(cr.ht) == 1 &lt;&lt; cp[2]
                assert cr.limit &lt; len(cr.ht)
                if cr.c != y:
                    cr.a = 0  # mismatch?
                cr.ht[cr.limit] = (cr.ht[cr.limit] &lt;&lt; 1) + y &amp; 0xFF
                cr.cxt += 1
                if cr.cxt == 8:
                    cr.cxt = 0
                    cr.limit += 1
                    cr.limit &amp;= (1 &lt;&lt; cp[2]) - 1
                    hi = h[i] % len(cr.cm)
                    if cr.a != 0:
                        cr.a += int(cr.a &lt; 255)
                    else:  # look for a match
                        cr.b = cr.limit - cr.cm[hi]
                        if cr.b &amp; (len(cr.ht) - 1):
                            while cr.a &lt; 255 and cr.ht[cr.limit - cr.a - 1] == cr.ht[cr.limit - cr.a - cr.b - 1]:
                                cr.a += 1
                    cr.cm[hi] = cr.limit
            elif ct is CompType.AVG:
                pass
            elif ct is CompType.MIX2:
                assert len(cr.a16) == cr.c
                assert cr.cxt &lt; cr.c
                err = (y * 32767 - self.squash(p[i])) * cp[4] &gt;&gt; 5
                w = cr.a16[cr.cxt]
                w += (err * (p[cp[2]] - p[cp[3]]) + (1 &lt;&lt; 12)) &gt;&gt; 13
                cr.a16[cr.cxt] = min(max(w, 0), 65535)
            elif ct is CompType.MIX:
                m = cp[3]
                assert m &gt; 0 and m &lt;= i
                assert len(cr.cm) == m * cr.c
                assert cr.cxt + m &lt;= len(cr.cm)
                err = (y * 32767 - self.squash(p[i])) * cp[4] &gt;&gt; 4
                w = cr.cxt
                for j in range(m):
                    cr.cm[w + j] = self.clamp512k(_i32(cr.cm[w + j]) + ((err * p[cp[2] + j] + (1 &lt;&lt; 12)) &gt;&gt; 13))
            elif ct is CompType.ISSE:
                assert cr.cxt == cr.ht[cr.c + (self.hmap4 &amp; 15)]
                err = y * 32767 - self.squash(p[i])
                w = cr.cxt * 2
                cr.cm[w + 0] = self.clamp512k(_i32(cr.cm[w + 0]) + ((err * p[cp[2]] + (1 &lt;&lt; 12)) &gt;&gt; 13))
                cr.cm[w + 1] = self.clamp512k(_i32(cr.cm[w + 1]) + ((err + 16) &gt;&gt; 5))
                cr.ht[cr.c + (self.hmap4 &amp; 15)] = self.st.next(cr.cxt, y)
            elif ct is CompType.SSE:
                self.train(cr, y)
            else:
                raise RuntimeError
            cs = CompSize[cp[0]]
            cp = cp[cs:]

        assert CompType(cp[0]) is CompType.NONE

        self.c8 *= 2
        self.c8 += y
        if self.c8 &gt;= 256:
            self.z.run(self.c8 - 256)
            self.hmap4 = 1
            self.c8 = 1
            self.h[:n] = self.z.h[:n]
        elif 16 &lt;= self.c8 &lt; 32:
            self.hmap4 = ((self.hmap4 &amp; 15) &lt;&lt; 5) | (y &lt;&lt; 4) | 1
        else:
            self.hmap4 = (self.hmap4 &amp; 0x1f0) | (((self.hmap4 &amp; 15) * 2 + y) &amp; 15)

    def is_modeled(self):
        return self.z.header[6] != 0

    def train(self, cr: Component, y: int):
        assert 0 &lt;= y &lt;= 1
        cxt = cr.cxt % len(cr.cm)
        pn = cr.cm[cxt]
        count = pn &amp; 0x3FF
        error = y * 32767 - (pn &gt;&gt; 17)
        pn += (error * self.dt[count] &amp; -1024) + (count &lt; cr.limit)
        pn &amp;= 0xFFFFFFFF
        cr.cm[cxt] = pn

    def squash(self, x: int):
        assert -2048 &lt;= x &lt;= 2047
        return self.squasht[x + 2048]

    def stretch(self, x: int):
        assert 0 &lt;= x &lt;= 32767
        return self.stretcht[x]

    def clamp2k(self, x: int):
        return min(max(x, -2048), 2047)

    def clamp512k(self, x: int):
        return min(max(x, -(1 &lt;&lt; 19)), (1 &lt;&lt; 19) - 1) &amp; 0xFFFFFFFF

    def find(self, ht: array[int] | bytearray, sizebits: int, cxt: int):
        assert len(ht) == 16 &lt;&lt; sizebits
        chk = cxt &gt;&gt; sizebits &amp; 255
        h0 = (cxt * 16) &amp; (len(ht) - 16)
        if ht[h0] == chk:
            return h0
        h1 = h0 ^ 16
        if ht[h1] == chk:
            return h1
        h2 = h0 ^ 32
        if ht[h2] == chk:
            return h2
        if ht[h0 + 1] &lt;= ht[h1 + 1] and ht[h0 + 1] &lt;= ht[h2 + 1]:
            _memzap(ht, h0, 16)
            ht[h0] = chk
            return h0
        elif ht[h1 + 1] &lt; ht[h2 + 1]:
            _memzap(ht, h1, 16)
            ht[h1] = chk
            return h1
        else:
            _memzap(ht, h2, 16)
            ht[h2] = chk
            return h2</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.c8"><code class="name">var <span class="ident">c8</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.hmap4"><code class="name">var <span class="ident">hmap4</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.p"><code class="name">var <span class="ident">p</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.h"><code class="name">var <span class="ident">h</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.z"><code class="name">var <span class="ident">z</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.comp"><code class="name">var <span class="ident">comp</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.dt2k"><code class="name">var <span class="ident">dt2k</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.dt"><code class="name">var <span class="ident">dt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.squasht"><code class="name">var <span class="ident">squasht</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.stretcht"><code class="name">var <span class="ident">stretcht</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.st"><code class="name">var <span class="ident">st</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L636-L725" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def init(self):
    self.z.inith()
    for i in range(0x100):
        self.h[i] = 0
        self.p[i] = 0
        self.comp[i].init()
    n = self.z.header[6]
    cp = memoryview(self.z.header)[7:self.z.cend]
    for i in range(n):
        assert cp
        cr = self.comp[i]
        ct = CompType(cp[0])
        if ct is CompType.CONS:
            self.p[i] = (cp[1] - 128) * 4
        elif ct is CompType.CM:
            if cp[1] &gt; 32:
                raise ValueError(&#39;max size for CM is 32&#39;)
            _resize(cr.cm, 1, cp[1])
            cr.limit = cp[2] * 4
            for j in range(len(cr.cm)):
                cr.cm[j] = 0x80000000
        elif ct is CompType.ICM:
            if cp[1] &gt; 26:
                raise ValueError(&#39;max size for ICM is 26&#39;)
            cr.limit = 1023
            _resize(cr.cm, 256)
            _resize(cr.ht, 64, cp[1])
            for j in range(256):
                cr.cm[j] = self.st.cminit(j)
        elif ct is CompType.MATCH:
            if cp[1] &gt; 32 or cp[2] &gt; 32:
                raise ValueError(&#39;max size for MATCH is 32/32&#39;)
            _resize(cr.cm, 1, cp[1])
            _resize(cr.ht, 1, cp[2])
            cr.ht[0] = 1
        elif ct is CompType.AVG:
            if cp[1] &gt;= i:
                raise ValueError(&#39;AVG j &gt;= i&#39;)
            if cp[2] &gt;= i:
                raise ValueError(&#39;AVG k &gt;= i&#39;)
        elif ct is CompType.MIX2:
            if cp[1] &gt; 32:
                raise ValueError(&#39;max size for MIX2 is 32&#39;)
            if cp[3] &gt;= i:
                raise ValueError(&#39;MIX2 k &gt;= i&#39;)
            if cp[2] &gt;= i:
                raise ValueError(&#39;MIX2 j &gt;= i&#39;)
            cr.c = 1 &lt;&lt; cp[1]  # size (number of contexts)
            _resize(cr.a16, 1, cp[1])
            for j in range(len(cr.a16)):
                cr.a16[j] = 32768
        elif ct is CompType.MIX:
            if cp[1] &gt; 32:
                raise ValueError(&#39;max size for MIX is 32&#39;)
            if cp[2] &gt;= i:
                raise ValueError(&#39;MIX j &gt;= i&#39;)
            if cp[3] &lt; 1 or cp[3] &gt; i - cp[2]:
                raise ValueError(&#39;MIX m not in 1..i-j&#39;)
            m = cp[3] # number of inputs
            assert m &gt;= 1
            cr.c = 1 &lt;&lt; cp[1]  # size (number of contexts)
            _resize(cr.cm, m, cp[1])
            for j in range(len(cr.cm)):
                cr.cm[j] = 65536 // m
        elif ct is CompType.ISSE:
            if cp[1] &gt; 32:
                raise ValueError(&#39;max size for ISSE is 32&#39;)
            if cp[2] &gt;= i:
                raise ValueError(&#39;ISSE j &gt;= i&#39;)
            _resize(cr.ht, 64, cp[1])
            _resize(cr.cm, 512)
            for j in range(256):
                clamped = self.clamp512k(self.stretch(self.st.cminit(j) &gt;&gt; 8) * 1024)
                cr.cm[j * 2 + 0] = 1 &lt;&lt; 15
                cr.cm[j * 2 + 1] = clamped
        elif ct is CompType.SSE:
            if cp[1] &gt; 32:
                raise ValueError(&#39;max size for SSE is 32&#39;)
            if cp[2] &gt;= i:
                raise ValueError(&#39;SSE j &gt;= i&#39;)
            if cp[3] &gt; cp[4] * 4:
                raise ValueError(&#39;SSE start &gt; limit*4&#39;)
            _resize(cr.cm, 32, cp[1])
            cr.limit = cp[4] * 4
            for j in range(len(cr.cm)):
                cr.cm[j] = self.squash((j &amp; 31) * 64 - 992) &lt;&lt; 17 | cp[3]
        else:
            raise ValueError(&#39;unknown component type&#39;)
        cs = CompSize[cp[0]]
        cp = cp[cs:]</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L727-L803" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def predict(self):
    assert 0 &lt; self.c8 &lt; 256
    n = self.z.header[6]
    assert 0 &lt; n &lt; 256
    cp = memoryview(self.z.header)[7:]
    assert self.z.header[6] == n
    p = self.p
    h = self.h
    for i in range(n):
        cr = self.comp[i]
        ct = CompType(cp[0])
        if ct is CompType.CONS:
            pass
        elif ct is CompType.CM:
            cr.cxt = self.h[i] ^ self.hmap4
            p[i] = self.stretch(cr.cm[cr.cxt] &gt;&gt; 17)
        elif ct is CompType.ICM:
            assert self.hmap4 &amp; 15 &gt; 0
            if self.c8 == 1 or (self.c8 &amp; 0xF0) == 16:
                cr.c = self.find(cr.ht, cp[1] + 2, h[i] + 16 * self.c8)
            cr.cxt = cr.ht[cr.c + (self.hmap4 &amp; 15)]
            p[i] = self.stretch(cr.cm[cr.cxt] &gt;&gt; 8)
        elif ct is CompType.MATCH:
            assert len(cr.cm) == 1 &lt;&lt; cp[1]
            assert len(cr.ht) == 1 &lt;&lt; cp[2]
            assert cr.a &lt;= 255
            assert cr.c in {0, 1}
            assert cr.cxt &lt; 8
            assert cr.limit &lt; len(cr.ht)
            if cr.a == 0:
                p[i] = 0
            else:
                cr.c = (cr.ht[cr.limit - cr.b] &gt;&gt; (7 - cr.cxt)) &amp; 1
                p[i] = self.stretch(self.dt2k[cr.a] * (cr.c * -2 + 1) &amp; 32767)
        elif ct is CompType.AVG:
            p[i] = (p[cp[1]] * cp[3] + p[cp[2]] * (256 - cp[3])) &gt;&gt; 8
        elif ct is CompType.MIX2:
            cr.cxt = (h[i] + (self.c8 &amp; cp[5])) &amp; (cr.c - 1)
            assert cr.cxt &lt; len(cr.a16)
            w = cr.a16[cr.cxt]
            assert 0 &lt;= w &lt; 65536
            p[i] = (w * p[cp[2]] + (65536 - w) * p[cp[3]]) &gt;&gt; 16
            assert -2048 &lt;= p[i] &lt; 2048
        elif ct is CompType.MIX:
            m = cp[3]
            assert 1 &lt;= m &lt;= i
            cr.cxt = h[i] + (self.c8 &amp; cp[5])
            cr.cxt = (cr.cxt &amp; (cr.c - 1)) * m
            assert cr.cxt &lt;= len(cr.cm) - m
            w = cr.cxt
            p[i] = 0
            for j in range(m):
                p[i] += (_i32(cr.cm[w + j]) &gt;&gt; 8) * p[cp[2] + j]
            p[i] = self.clamp2k(p[i] &gt;&gt; 8)
        elif ct is CompType.ISSE:
            if self.c8 == 1 or (self.c8 &amp; 0xF0) == 16:
                cr.c = self.find(cr.ht, cp[1] + 2, h[i] + 16 * self.c8)
            cr.cxt = cr.ht[cr.c + (self.hmap4 &amp; 15)]
            wt0 = _i32(cr.cm[cr.cxt * 2 + 0])
            wt1 = _i32(cr.cm[cr.cxt * 2 + 1])
            p[i] = self.clamp2k((wt0 * p[cp[2]] + wt1 * 64) &gt;&gt; 16)
        elif ct is CompType.SSE:
            cr.cxt = (h[i] + self.c8) * 32
            pq = min(max(0, p[cp[2]] + 992), 1983)
            wt = pq &amp; 63
            pq &gt;&gt;= 6
            assert 0 &lt;= pq &lt;= 30
            cr.cxt += pq
            p[i] = self.stretch((
                (cr.cm[cr.cxt + 0] &gt;&gt; 10) * (64 - wt) + (cr.cm[cr.cxt + 1] &gt;&gt; 10) * wt) &gt;&gt; 13)
            cr.cxt += wt &gt;&gt; 5
        else:
            raise ValueError(&#39;component predict not implemented&#39;)
        cs = CompSize[cp[0]]
        cp = cp[cs:]
    assert CompType(cp[0]) is CompType.NONE
    return self.squash(p[n - 1])</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L805-L895" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def update(self, y: int):
    assert y in (0, 1)
    assert 0 &lt; self.c8 &lt; 256
    assert 0 &lt; self.hmap4 &lt; 512
    cp = memoryview(self.z.header)[7:]
    n = self.z.header[6]
    h = self.h
    p = self.p
    assert 0 &lt; n &lt; 256
    for i in range(n):
        cr = self.comp[i]
        ct = CompType(cp[0])
        if ct is CompType.CONS:
            pass
        elif ct is CompType.CM:
            self.train(cr, y)
        elif ct is CompType.ICM:
            k = cr.c + (self.hmap4 &amp; 15)
            cr.ht[k] = self.st.next(cr.ht[k], y)
            pn = cr.cm[cr.cxt]
            pn += (y * 32767 - (pn &gt;&gt; 8)) &gt;&gt; 2
            cr.cm[cr.cxt] = pn
        elif ct is CompType.MATCH:
            assert cr.a &lt;= 255
            assert cr.c in (0, 1)
            assert cr.cxt &lt; 8
            assert len(cr.cm) == 1 &lt;&lt; cp[1]
            assert len(cr.ht) == 1 &lt;&lt; cp[2]
            assert cr.limit &lt; len(cr.ht)
            if cr.c != y:
                cr.a = 0  # mismatch?
            cr.ht[cr.limit] = (cr.ht[cr.limit] &lt;&lt; 1) + y &amp; 0xFF
            cr.cxt += 1
            if cr.cxt == 8:
                cr.cxt = 0
                cr.limit += 1
                cr.limit &amp;= (1 &lt;&lt; cp[2]) - 1
                hi = h[i] % len(cr.cm)
                if cr.a != 0:
                    cr.a += int(cr.a &lt; 255)
                else:  # look for a match
                    cr.b = cr.limit - cr.cm[hi]
                    if cr.b &amp; (len(cr.ht) - 1):
                        while cr.a &lt; 255 and cr.ht[cr.limit - cr.a - 1] == cr.ht[cr.limit - cr.a - cr.b - 1]:
                            cr.a += 1
                cr.cm[hi] = cr.limit
        elif ct is CompType.AVG:
            pass
        elif ct is CompType.MIX2:
            assert len(cr.a16) == cr.c
            assert cr.cxt &lt; cr.c
            err = (y * 32767 - self.squash(p[i])) * cp[4] &gt;&gt; 5
            w = cr.a16[cr.cxt]
            w += (err * (p[cp[2]] - p[cp[3]]) + (1 &lt;&lt; 12)) &gt;&gt; 13
            cr.a16[cr.cxt] = min(max(w, 0), 65535)
        elif ct is CompType.MIX:
            m = cp[3]
            assert m &gt; 0 and m &lt;= i
            assert len(cr.cm) == m * cr.c
            assert cr.cxt + m &lt;= len(cr.cm)
            err = (y * 32767 - self.squash(p[i])) * cp[4] &gt;&gt; 4
            w = cr.cxt
            for j in range(m):
                cr.cm[w + j] = self.clamp512k(_i32(cr.cm[w + j]) + ((err * p[cp[2] + j] + (1 &lt;&lt; 12)) &gt;&gt; 13))
        elif ct is CompType.ISSE:
            assert cr.cxt == cr.ht[cr.c + (self.hmap4 &amp; 15)]
            err = y * 32767 - self.squash(p[i])
            w = cr.cxt * 2
            cr.cm[w + 0] = self.clamp512k(_i32(cr.cm[w + 0]) + ((err * p[cp[2]] + (1 &lt;&lt; 12)) &gt;&gt; 13))
            cr.cm[w + 1] = self.clamp512k(_i32(cr.cm[w + 1]) + ((err + 16) &gt;&gt; 5))
            cr.ht[cr.c + (self.hmap4 &amp; 15)] = self.st.next(cr.cxt, y)
        elif ct is CompType.SSE:
            self.train(cr, y)
        else:
            raise RuntimeError
        cs = CompSize[cp[0]]
        cp = cp[cs:]

    assert CompType(cp[0]) is CompType.NONE

    self.c8 *= 2
    self.c8 += y
    if self.c8 &gt;= 256:
        self.z.run(self.c8 - 256)
        self.hmap4 = 1
        self.c8 = 1
        self.h[:n] = self.z.h[:n]
    elif 16 &lt;= self.c8 &lt; 32:
        self.hmap4 = ((self.hmap4 &amp; 15) &lt;&lt; 5) | (y &lt;&lt; 4) | 1
    else:
        self.hmap4 = (self.hmap4 &amp; 0x1f0) | (((self.hmap4 &amp; 15) * 2 + y) &amp; 15)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.is_modeled"><code class="name flex">
<span>def <span class="ident">is_modeled</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L897-L898" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_modeled(self):
    return self.z.header[6] != 0</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.train"><code class="name flex">
<span>def <span class="ident">train</span></span>(<span>self, cr, y)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L900-L908" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def train(self, cr: Component, y: int):
    assert 0 &lt;= y &lt;= 1
    cxt = cr.cxt % len(cr.cm)
    pn = cr.cm[cxt]
    count = pn &amp; 0x3FF
    error = y * 32767 - (pn &gt;&gt; 17)
    pn += (error * self.dt[count] &amp; -1024) + (count &lt; cr.limit)
    pn &amp;= 0xFFFFFFFF
    cr.cm[cxt] = pn</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.squash"><code class="name flex">
<span>def <span class="ident">squash</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L910-L912" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def squash(self, x: int):
    assert -2048 &lt;= x &lt;= 2047
    return self.squasht[x + 2048]</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.stretch"><code class="name flex">
<span>def <span class="ident">stretch</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L914-L916" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def stretch(self, x: int):
    assert 0 &lt;= x &lt;= 32767
    return self.stretcht[x]</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.clamp2k"><code class="name flex">
<span>def <span class="ident">clamp2k</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L918-L919" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clamp2k(self, x: int):
    return min(max(x, -2048), 2047)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.clamp512k"><code class="name flex">
<span>def <span class="ident">clamp512k</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L921-L922" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clamp512k(self, x: int):
    return min(max(x, -(1 &lt;&lt; 19)), (1 &lt;&lt; 19) - 1) &amp; 0xFFFFFFFF</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Predictor.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, ht, sizebits, cxt)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L924-L947" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def find(self, ht: array[int] | bytearray, sizebits: int, cxt: int):
    assert len(ht) == 16 &lt;&lt; sizebits
    chk = cxt &gt;&gt; sizebits &amp; 255
    h0 = (cxt * 16) &amp; (len(ht) - 16)
    if ht[h0] == chk:
        return h0
    h1 = h0 ^ 16
    if ht[h1] == chk:
        return h1
    h2 = h0 ^ 32
    if ht[h2] == chk:
        return h2
    if ht[h0 + 1] &lt;= ht[h1 + 1] and ht[h0 + 1] &lt;= ht[h2 + 1]:
        _memzap(ht, h0, 16)
        ht[h0] = chk
        return h0
    elif ht[h1 + 1] &lt; ht[h2 + 1]:
        _memzap(ht, h1, 16)
        ht[h1] = chk
        return h1
    else:
        _memzap(ht, h2, 16)
        ht[h2] = chk
        return h2</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decoder"><code class="flex name class">
<span>class <span class="ident">Decoder</span></span>
<span>(</span><span>z, src)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L950-L1026" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Decoder:
    src: StructReader
    low: int
    high: int
    curr: int
    pr: Predictor

    def __init__(self, z: ZPAQL, src: StructReader[bytearray]):
        self.src = src
        self.pr = Predictor(z)
        self._set_values(1, 0xFFFFFFFF, 0)

    def _set_values(self, low, high, curr):
        self.low = low
        self.high = high
        self.curr = curr

    def init(self):
        self.pr.init()
        if self.pr.is_modeled():
            self._set_values(1, 0xFFFFFFFF, 0)
        else:
            self._set_values(0, 0x00000000, 0)

    def decode(self, p: int) -&gt; int:
        assert 0 &lt;= p &lt; 65536
        assert 0 &lt; self.low &lt; self.high
        if self.curr &lt; self.low or self.high &lt; self.curr:
            raise RuntimeError(&#39;archive corrupted&#39;)
        mid = self.low + (((self.high - self.low) * p) &gt;&gt; 16) &amp; 0xFFFFFFFF
        assert self.low &lt;= mid &lt;= self.high
        rv = self.curr &lt;= mid
        if rv:
            self.high = mid
        else:
            self.low = mid + 1 &amp; 0xFFFFFFFF
        while (self.high ^ self.low) &lt; 0x1000000:
            self.high &lt;&lt;= 8
            self.high |= 0xFF
            self.high &amp;= 0xFFFFFFFF
            self.low = (self.low &lt;&lt; 8) &amp; 0xFFFFFFFF
            if self.low == 0:
                self.low = 1
            self.curr &lt;&lt;= 8
            self.curr |= self.src.u8fast()
            self.curr &amp;= 0xFFFFFFFF
        return int(rv)

    def decompress(self) -&gt; int | None:
        pr = self.pr
        if pr.is_modeled():
            if self.curr == 0:
                with self.src.be:
                    self.curr = self.src.u32()
            if self.decode(0):
                if self.curr:
                    raise ValueError(&#39;decoding end of input&#39;)
                return None
            else:
                c = 1
                while c &lt; 256:
                    p = pr.predict() * 2 + 1
                    c *= 2
                    c += self.decode(p)
                    pr.update(c &amp; 1)
                return c - 256
        else:
            if self.curr == 0:
                with self.src.be:
                    self.curr = self.src.u32()
            if self.curr == 0:
                return None
            assert self.curr &gt; 0
            self.curr -= 1
            if self.src.eof:
                return None
            return self.src.u8fast()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.Decoder.src"><code class="name">var <span class="ident">src</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decoder.low"><code class="name">var <span class="ident">low</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decoder.high"><code class="name">var <span class="ident">high</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decoder.curr"><code class="name">var <span class="ident">curr</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decoder.pr"><code class="name">var <span class="ident">pr</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.Decoder.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L967-L972" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def init(self):
    self.pr.init()
    if self.pr.is_modeled():
        self._set_values(1, 0xFFFFFFFF, 0)
    else:
        self._set_values(0, 0x00000000, 0)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decoder.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L974-L996" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decode(self, p: int) -&gt; int:
    assert 0 &lt;= p &lt; 65536
    assert 0 &lt; self.low &lt; self.high
    if self.curr &lt; self.low or self.high &lt; self.curr:
        raise RuntimeError(&#39;archive corrupted&#39;)
    mid = self.low + (((self.high - self.low) * p) &gt;&gt; 16) &amp; 0xFFFFFFFF
    assert self.low &lt;= mid &lt;= self.high
    rv = self.curr &lt;= mid
    if rv:
        self.high = mid
    else:
        self.low = mid + 1 &amp; 0xFFFFFFFF
    while (self.high ^ self.low) &lt; 0x1000000:
        self.high &lt;&lt;= 8
        self.high |= 0xFF
        self.high &amp;= 0xFFFFFFFF
        self.low = (self.low &lt;&lt; 8) &amp; 0xFFFFFFFF
        if self.low == 0:
            self.low = 1
        self.curr &lt;&lt;= 8
        self.curr |= self.src.u8fast()
        self.curr &amp;= 0xFFFFFFFF
    return int(rv)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decoder.decompress"><code class="name flex">
<span>def <span class="ident">decompress</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L998-L1026" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decompress(self) -&gt; int | None:
    pr = self.pr
    if pr.is_modeled():
        if self.curr == 0:
            with self.src.be:
                self.curr = self.src.u32()
        if self.decode(0):
            if self.curr:
                raise ValueError(&#39;decoding end of input&#39;)
            return None
        else:
            c = 1
            while c &lt; 256:
                p = pr.predict() * 2 + 1
                c *= 2
                c += self.decode(p)
                pr.update(c &amp; 1)
            return c - 256
    else:
        if self.curr == 0:
            with self.src.be:
                self.curr = self.src.u32()
        if self.curr == 0:
            return None
        assert self.curr &gt; 0
        self.curr -= 1
        if self.src.eof:
            return None
        return self.src.u8fast()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.PostProcessor"><code class="flex name class">
<span>class <span class="ident">PostProcessor</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1029-L1097" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PostProcessor:
    state: int
    hsize: int
    ph: int
    pm: int
    z: ZPAQL

    def __init__(self):
        self.z = ZPAQL()
        self.init(0, 0)

    def init(self, h: int, m: int):
        self.state = 0
        self.hsize = 0
        self.ph = h
        self.pm = m
        self.z.clear()

    def set_output(self, writer: MemoryFile):
        self.z.output = writer

    def set_hasher(self, hasher: _Hash):
        self.z.sha1 = hasher

    def write(self, c: int | None):
        assert c is None or c in range(256)
        z = self.z
        s = self.state
        if c is None:
            if s == 5:
                c = -1
            elif s != 1:
                raise ValueError(&#39;Unexpected EOS&#39;)
        elif s == 0:
            if c is None:
                raise ValueError(&#39;Unexpected EOS&#39;)
            self.state = s = c + 1
            if s &gt; 2:
                raise RuntimeError(&#39;unknown post processing type&#39;)
            if s == 1:
                z.clear()
        elif s == 1:
            z.outc(c)
        elif s == 2:
            self.hsize = c
            self.state = 3
        elif s == 3:
            self.hsize += c * 256
            if self.hsize &lt; 1:
                raise RuntimeError(&#39;Empty PCOMP&#39;)
            _resize(z.header, self.hsize + 300)
            z.cend = 8
            z.hbegin = z.hend = z.cend + 128
            z.header[4] = self.ph
            z.header[5] = self.pm
            self.state = 4
        elif s == 4:
            assert z.hend &lt; len(z.header)
            z.header[z.hend] = c
            z.hend += 1
            if z.hend - z.hbegin == self.hsize:
                self.hsize = z.cend - 2 + z.hend - z.hbegin
                z.header[0] = self.hsize &amp; 255
                z.header[1] = self.hsize &gt;&gt; 8
                z.initp()
                self.state = 5
        elif s == 5:
            z.run(c)
        return self.state</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.PostProcessor.state"><code class="name">var <span class="ident">state</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.PostProcessor.hsize"><code class="name">var <span class="ident">hsize</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.PostProcessor.ph"><code class="name">var <span class="ident">ph</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.PostProcessor.pm"><code class="name">var <span class="ident">pm</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.PostProcessor.z"><code class="name">var <span class="ident">z</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.PostProcessor.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self, h, m)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1040-L1045" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def init(self, h: int, m: int):
    self.state = 0
    self.hsize = 0
    self.ph = h
    self.pm = m
    self.z.clear()</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.PostProcessor.set_output"><code class="name flex">
<span>def <span class="ident">set_output</span></span>(<span>self, writer)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1047-L1048" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_output(self, writer: MemoryFile):
    self.z.output = writer</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.PostProcessor.set_hasher"><code class="name flex">
<span>def <span class="ident">set_hasher</span></span>(<span>self, hasher)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1050-L1051" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_hasher(self, hasher: _Hash):
    self.z.sha1 = hasher</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.PostProcessor.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1053-L1097" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def write(self, c: int | None):
    assert c is None or c in range(256)
    z = self.z
    s = self.state
    if c is None:
        if s == 5:
            c = -1
        elif s != 1:
            raise ValueError(&#39;Unexpected EOS&#39;)
    elif s == 0:
        if c is None:
            raise ValueError(&#39;Unexpected EOS&#39;)
        self.state = s = c + 1
        if s &gt; 2:
            raise RuntimeError(&#39;unknown post processing type&#39;)
        if s == 1:
            z.clear()
    elif s == 1:
        z.outc(c)
    elif s == 2:
        self.hsize = c
        self.state = 3
    elif s == 3:
        self.hsize += c * 256
        if self.hsize &lt; 1:
            raise RuntimeError(&#39;Empty PCOMP&#39;)
        _resize(z.header, self.hsize + 300)
        z.cend = 8
        z.hbegin = z.hend = z.cend + 128
        z.header[4] = self.ph
        z.header[5] = self.pm
        self.state = 4
    elif s == 4:
        assert z.hend &lt; len(z.header)
        z.header[z.hend] = c
        z.hend += 1
        if z.hend - z.hbegin == self.hsize:
            self.hsize = z.cend - 2 + z.hend - z.hbegin
            z.header[0] = self.hsize &amp; 255
            z.header[1] = self.hsize &gt;&gt; 8
            z.initp()
            self.state = 5
    elif s == 5:
        z.run(c)
    return self.state</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decompressor"><code class="flex name class">
<span>class <span class="ident">Decompressor</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1100-L1218" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Decompressor:
    z: ZPAQL
    dec: Decoder
    pp: PostProcessor

    class State(IntEnum):
        BLOCK = 0
        FILENAME = 1
        COMMENT = 2
        DATA = 3
        SEGEND = 4

    state: State
    first_seg: bool

    def __init__(self, data: bytearray):
        self.z = z = ZPAQL()
        self.dec = Decoder(z, StructReader(data))
        self.pp = PostProcessor()
        self.state = Decompressor.State.BLOCK
        self.first_seg = True

    def set_output(self, op: MemoryFile):
        self.pp.set_output(op)

    def set_hasher(self, sha1: _Hash):
        self.pp.set_hasher(sha1)

    def read_block(self) -&gt; bool:
        if self.state is not Decompressor.State.BLOCK:
            raise RuntimeError(&#39;invalid state&#39;)
        h1 = 0x3D49B113
        h2 = 0x29EB7F93
        h3 = 0x2614BE13
        h4 = 0x3828EB13
        ip = self.dec.src
        while not ip.eof:
            c = ip.u8fast()
            h1 = h1 * 12 + c &amp; 0xFFFFFFFF
            h2 = h2 * 20 + c &amp; 0xFFFFFFFF
            h3 = h3 * 28 + c &amp; 0xFFFFFFFF
            h4 = h4 * 44 + c &amp; 0xFFFFFFFF
            if h1 == 0xB16B88F1 and h2 == 0xFF5376F1 and h3 == 0x72AC5BF1 and h4 == 0x2F909AF1:
                break
        if ip.eof:
            return False
        c = ip.u8fast()
        z = self.z
        if c not in (1, 2):
            raise RuntimeError(&#39;unsupported ZPAQ level&#39;)
        if ip.u8fast() != 1:
            raise RuntimeError(&#39;unsupported ZPAQ type&#39;)
        z.read(ip)
        if c == 1 and len(z.header) &gt; 6 and z.header[6] == 0:
            raise RuntimeError(&#39;ZPAQ level 1 requires at least 1 component&#39;)
        self.state = Decompressor.State.FILENAME
        self.first_seg = True
        return True

    def read_filename(self) -&gt; str | None:
        if self.state is not Decompressor.State.FILENAME:
            raise RuntimeError(&#39;invalid state&#39;)
        ip = self.dec.src
        c = ip.u8fast()
        if c == 1:
            self.state = Decompressor.State.COMMENT
            return ip.read_c_string(&#39;utf8&#39;)
        elif c == 0xFF:
            self.state = Decompressor.State.BLOCK
            return None
        else:
            raise RuntimeError(&#39;missing segment or end of block&#39;)

    def read_comment(self) -&gt; str | None:
        if self.state is Decompressor.State.BLOCK:
            return None
        if self.state is not Decompressor.State.COMMENT:
            raise RuntimeError(&#39;invalid state&#39;)
        ip = self.dec.src
        comment = ip.read_c_string(&#39;utf8&#39;)
        if ip.u8fast() != 0:
            raise RuntimeError(&#39;missing reserved byte&#39;)
        self.state = Decompressor.State.DATA
        return comment

    def decompress_data(self):
        if self.state is not Decompressor.State.DATA:
            raise RuntimeError(&#39;invalid state&#39;)
        z = self.z
        dec = self.dec
        pp = self.pp
        if self.first_seg:
            dec.init()
            assert len(z.header) &gt; 5
            pp.init(z.header[4], z.header[5])
            self.first_seg = False
        while pp.state &amp; 3 != 1:
            pp.write(dec.decompress())
        while True:
            c = dec.decompress()
            pp.write(c)
            if c is None:
                self.state = Decompressor.State.SEGEND
                return

    def read_segment_end(self) -&gt; bytes | None:
        if self.state is not Decompressor.State.SEGEND:
            raise RuntimeError(&#39;invalid state&#39;)
        dec = self.dec
        src = dec.src
        c = src.u8fast()
        if c == 254:
            checksum = None
        elif c == 253:
            checksum = src.read(20)
        else:
            raise RuntimeError(&#39;missing end of segment marker&#39;)
        self.state = Decompressor.State.FILENAME
        return checksum</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.Decompressor.z"><code class="name">var <span class="ident">z</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decompressor.dec"><code class="name">var <span class="ident">dec</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decompressor.pp"><code class="name">var <span class="ident">pp</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decompressor.state"><code class="name">var <span class="ident">state</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decompressor.first_seg"><code class="name">var <span class="ident">first_seg</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decompressor.State"><code class="name">var <span class="ident">State</span></code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.Decompressor.set_output"><code class="name flex">
<span>def <span class="ident">set_output</span></span>(<span>self, op)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1122-L1123" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_output(self, op: MemoryFile):
    self.pp.set_output(op)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decompressor.set_hasher"><code class="name flex">
<span>def <span class="ident">set_hasher</span></span>(<span>self, sha1)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1125-L1126" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_hasher(self, sha1: _Hash):
    self.pp.set_hasher(sha1)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decompressor.read_block"><code class="name flex">
<span>def <span class="ident">read_block</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1128-L1157" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_block(self) -&gt; bool:
    if self.state is not Decompressor.State.BLOCK:
        raise RuntimeError(&#39;invalid state&#39;)
    h1 = 0x3D49B113
    h2 = 0x29EB7F93
    h3 = 0x2614BE13
    h4 = 0x3828EB13
    ip = self.dec.src
    while not ip.eof:
        c = ip.u8fast()
        h1 = h1 * 12 + c &amp; 0xFFFFFFFF
        h2 = h2 * 20 + c &amp; 0xFFFFFFFF
        h3 = h3 * 28 + c &amp; 0xFFFFFFFF
        h4 = h4 * 44 + c &amp; 0xFFFFFFFF
        if h1 == 0xB16B88F1 and h2 == 0xFF5376F1 and h3 == 0x72AC5BF1 and h4 == 0x2F909AF1:
            break
    if ip.eof:
        return False
    c = ip.u8fast()
    z = self.z
    if c not in (1, 2):
        raise RuntimeError(&#39;unsupported ZPAQ level&#39;)
    if ip.u8fast() != 1:
        raise RuntimeError(&#39;unsupported ZPAQ type&#39;)
    z.read(ip)
    if c == 1 and len(z.header) &gt; 6 and z.header[6] == 0:
        raise RuntimeError(&#39;ZPAQ level 1 requires at least 1 component&#39;)
    self.state = Decompressor.State.FILENAME
    self.first_seg = True
    return True</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decompressor.read_filename"><code class="name flex">
<span>def <span class="ident">read_filename</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1159-L1171" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_filename(self) -&gt; str | None:
    if self.state is not Decompressor.State.FILENAME:
        raise RuntimeError(&#39;invalid state&#39;)
    ip = self.dec.src
    c = ip.u8fast()
    if c == 1:
        self.state = Decompressor.State.COMMENT
        return ip.read_c_string(&#39;utf8&#39;)
    elif c == 0xFF:
        self.state = Decompressor.State.BLOCK
        return None
    else:
        raise RuntimeError(&#39;missing segment or end of block&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decompressor.read_comment"><code class="name flex">
<span>def <span class="ident">read_comment</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1173-L1183" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_comment(self) -&gt; str | None:
    if self.state is Decompressor.State.BLOCK:
        return None
    if self.state is not Decompressor.State.COMMENT:
        raise RuntimeError(&#39;invalid state&#39;)
    ip = self.dec.src
    comment = ip.read_c_string(&#39;utf8&#39;)
    if ip.u8fast() != 0:
        raise RuntimeError(&#39;missing reserved byte&#39;)
    self.state = Decompressor.State.DATA
    return comment</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decompressor.decompress_data"><code class="name flex">
<span>def <span class="ident">decompress_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1185-L1203" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decompress_data(self):
    if self.state is not Decompressor.State.DATA:
        raise RuntimeError(&#39;invalid state&#39;)
    z = self.z
    dec = self.dec
    pp = self.pp
    if self.first_seg:
        dec.init()
        assert len(z.header) &gt; 5
        pp.init(z.header[4], z.header[5])
        self.first_seg = False
    while pp.state &amp; 3 != 1:
        pp.write(dec.decompress())
    while True:
        c = dec.decompress()
        pp.write(c)
        if c is None:
            self.state = Decompressor.State.SEGEND
            return</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.Decompressor.read_segment_end"><code class="name flex">
<span>def <span class="ident">read_segment_end</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1205-L1218" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_segment_end(self) -&gt; bytes | None:
    if self.state is not Decompressor.State.SEGEND:
        raise RuntimeError(&#39;invalid state&#39;)
    dec = self.dec
    src = dec.src
    c = src.u8fast()
    if c == 254:
        checksum = None
    elif c == 253:
        checksum = src.read(20)
    else:
        raise RuntimeError(&#39;missing end of segment marker&#39;)
    self.state = Decompressor.State.FILENAME
    return checksum</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.xtzpaq"><code class="flex name class">
<span>class <span class="ident">xtzpaq</span></span>
<span>(</span><span>*paths, index=False, pwd=b'', date=b'date', path=b'path', regex=False, exact=False, fuzzy=0, drop_path=False, join_path=False, list=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Extract files from a ZPAQ archive. This unit is a path extractor which extracts data from a hierarchical structure. Each extracted
item is emitted as a separate chunk and has attached to it a meta variable that contains its
path within the source structure. The positional arguments to the command are patterns that can
be used to filter the extracted items by their path. To view only the paths of all chunks, use
the listing switch:</p>
<pre><code>emit something | xtzpaq --list
</code></pre>
<p>Otherwise, extracted items are written to the standard output port and usually require a frame
to properly process. In order to dump all extracted data to disk, the following pipeline can be
used:</p>
<pre><code>emit something | xtzpaq [| dump {path} ]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1221-L1493" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class xtzpaq(ArchiveUnit, docs=&#39;{0}{s}{PathExtractorUnit}&#39;):
    &#34;&#34;&#34;
    Extract files from a ZPAQ archive.
    &#34;&#34;&#34;

    _MAGIC = B&#39;7kSt\xA01\x83\xD3\x8C\xB2\x28\xB0\xD3zPQ&#39;

    def __init__(
        self, *paths,
        index: Param[bool, Arg.Switch(&#39;-i&#39;, help=&#39;Archive is an index (no d-blocks).&#39;)] = False,
        **more
    ):
        for _code, _size in {
            _TCU32: 4,
            _TCI32: 4,
            _TCU16: 2,
            _TCI16: 2,
        }.items():
            _item_size = array(_code).itemsize
            if _item_size == _size:
                continue
            raise RuntimeError(
                F&#39;Expected array type &#34;{_code}&#34; to have entries of size {_size}, but the API &#39;
                F&#39;reports a size of {_item_size}.&#39;)

        super().__init__(*paths, index=index, **more)

    @classmethod
    def handles(cls, data) -&gt; bool | None:
        return data[:len(cls._MAGIC)] == cls._MAGIC

    def unpack(self, data: bytearray):
        def mkdate(date) -&gt; datetime:
            date = int(date)
            year = date // 1000000 // 10000
            month = date // 100000000 % 100
            day = date // 1000000 % 100
            hour = date // 10000 % 100
            minute = date // 100 % 100
            second = date % 100
            return datetime(year, month, day, hour, minute, second, 0)

        @dataclass
        class DT:
            date: int = 0
            attr: int = 0
            name: str = &#34;&#34;
            frag: list[int] = field(default_factory=list)

            @property
            def dt(self) -&gt; datetime | None:
                if self.date &gt; 0:
                    return mkdate(self.date)

        # TODO: implement password-protected archives
        # key = self.args.pwd
        index = self.args.index
        bsize: dict[int, int] = {}  # frag ID -&gt; d block compressed size
        dt: dict[str, DT] = {}      # filename -&gt; date, attr, frags
        frag: list[bytes] = []      # ID -&gt; hash[20] size[4] data
        csize = 0                   # expected offset of next non d block
        streaming = False
        journaling = False

        done = False
        dc = Decompressor(data)
        src = dc.dec.src
        offset = 0

        while not done and dc.read_block():
            while not done:
                filename = dc.read_filename()
                if filename is None:
                    break
                self.log_info(&#39;reading file&#39;, filename)
                comment = dc.read_comment()
                jsize = 0
                if comment and len(comment) &gt;= 4 and comment[-4:] == &#34;jDC\x01&#34;:
                    num = re.search(&#39;^\\d+&#39;, comment)
                    if not num:
                        raise RuntimeError(&#39;missing size in comment&#39;)
                    jsize = int(num[0])
                    if streaming:
                        raise RuntimeError(&#39;journaling block after streaming one&#39;)
                    journaling = True
                    self.log_info(&#39;archive type is journaling&#39;)
                else:
                    if journaling:
                        raise RuntimeError(&#39;streaming block after journaling one&#39;)
                    if index:
                        raise RuntimeError(&#39;streaming block in index&#39;)
                    streaming = True
                    self.log_info(&#39;archive type is streaming&#39;)

                # Test journaling filename. The format must be
                # jDC[YYYYMMDDHHMMSS][t][NNNNNNNNNN]
                # where YYYYMMDDHHMMSS is the date, t is the type {c,d,h,i}, and
                # NNNNNNNNNN is the 10 digit first fragment ID for types c,d,h.
                # They must be in ascending lexicographical order.

                frag_id = 0
                block_type = None

                if journaling:
                    if len(filename) != 28:
                        raise RuntimeError(&#39;filename size not 28&#39;)
                    if filename[:3] != &#39;jDC&#39;:
                        raise RuntimeError(&#39;filename not jDC&#39;)
                    block_type = filename[17]
                    if block_type not in &#39;cdhi&#39;:
                        raise RuntimeError(&#39;type not c,d,h,i&#39;)
                    try:
                        mkdate(filename[3:17])
                    except Exception as E:
                        raise RuntimeError(&#39;invalid date&#39;) from E
                    frag_id = int(filename[18:28])
                    if not 1 &lt;= frag_id &lt;= 4294967295:
                        raise RuntimeError(&#39;fragment ID out of range&#39;)

                seg = MemoryFile(size_limit=jsize)
                dc.set_output(seg)
                sha1 = hashlib.sha1()
                dc.set_hasher(sha1)
                dc.decompress_data()

                if journaling and len(seg) != jsize:
                    raise RuntimeError(&#39;incomplete output&#39;)

                checksum = dc.read_segment_end()
                if checksum is None:
                    self.log_debug(&#39;no checksum&#39;)
                elif checksum != sha1.digest():
                    raise RuntimeError(&#39;SHA1 mismatch&#39;)

                # check csize at first non-d block
                if csize and block_type and block_type in &#39;chi&#39;:
                    if csize != offset:
                        raise RuntimeError(F&#39;csize={csize} does not point to offset={offset}&#39;)
                    csize = 0

                # get csize from c block
                seglen = len(seg)
                seg = StructReader(seg.getvalue())
                if block_type == &#39;c&#39;:
                    if seglen &lt; 8:
                        raise RuntimeError(&#34;c block too small&#34;)
                    csize = seg.u64()
                    offset = src.tell() + 1
                    self.log_debug(F&#39;csize={csize} at offset={offset}&#39;)
                    if csize &gt;&gt; 63:
                        self.log_warn(&#39;incomplete transaction at end of archive&#39;)
                        done = True
                    elif index and csize != 0:
                        raise RuntimeError(&#39;nonzero csize in index&#39;)
                    # Set csize to expected offset of first non d block
                    # assuming 1 more byte for unread end of block marker.
                    csize += offset

                if block_type == &#39;d&#39;:
                    if index:
                        raise RuntimeError(&#39;d block in index&#39;)
                    bsize[frag_id] = src.tell() + 1 - offset  # compressed size
                    self.log_debug(F&#39; {bsize[frag_id]} -&gt; {len(seg)}&#39;)
                    # Test frag size list at end. The format is f[id..id+n-1] fid n
                    # where fid may be id or 0. sizes must sum to the rest of block.
                    if seglen &lt; 8:
                        raise RuntimeError(&#39;d block too small&#39;)
                    seg.seekset(-8)
                    fid = seg.u32() or frag_id
                    n = seg.u32()
                    if fid != frag_id:
                        raise RuntimeError(&#39;missing ID&#39;)
                    if n &gt; (seglen - 8) // 4:
                        raise RuntimeError(&#39;frag list too big&#39;)
                    fragsum = 0  # computed sum of frag sizes
                    seg.seekset(-4 * (n + 2))
                    for _ in range(n):
                        fragsum += seg.u32()
                    if fragsum + n * 4 + 8 != seglen:
                        raise RuntimeError(&#39;bad frag size list&#39;)
                    # Save frag hashes and sizes. For output, save data too.
                    seg.seekset(fragsum)
                    buffer = seg.getvalue()
                    assert seg.remaining_bytes == n * 4 + 8
                    for i in range(n):
                        while len(frag) &lt;= frag_id + i:
                            frag.append(B&#39;&#39;)
                        if frag[frag_id + i]:
                            raise RuntimeError(&#39;duplicate frag ID&#39;)
                        f = seg.u32()
                        h = hashlib.sha1(buffer[:f]).digest()
                        frag[frag_id + i] = h + f.to_bytes(4, &#39;little&#39;) + buffer[:f]
                        buffer = buffer[f:]

                    assert len(buffer) == n * 4 + 8
                    assert seg.remaining_bytes == 8

                # Test and save h block. Format is: bsize (sha1[20] size)...
                # where bsize is the compressed size of the d block with the same id,
                # and each size corresonds to a fragment in that block. The list
                # must match the list in the d block if present.

                if block_type == &#39;h&#39;:
                    if seglen % 24 != 4:
                        raise RuntimeError(&#39;bad h block size&#39;)
                    b = seg.u32()
                    self.log_debug(F&#39;[{frag_id}..{frag_id + seglen // 24}[ {b}&#39;)
                    fragsum = 0 # uncompressed size of all frags
                    for i in range(seglen // 24):
                        fd = seg.read(24)
                        if index:
                            while len(frag) &lt;= frag_id + i:
                                frag.append(B&#39;&#39;)
                            if frag[frag_id + i]:
                                raise RuntimeError(&#39;data in index&#39;)
                            frag[frag_id + i] = fd
                        elif frag_id + i &gt;= len(frag) or len(frag[frag_id + i]) &lt; 24:
                            raise RuntimeError(&#39;no matching d block&#39;)
                        elif frag[frag_id + i][:24] != fd:
                            raise RuntimeError(&#39;frag size or hash mismatch&#39;)
                        fragsum += int.from_bytes(fd[20:24], &#39;little&#39;)

                # Test i blocks and save files to extract. Format is:
                #   date filename 0 na attr[0..na) ni ptr[0..ni)   (to update)
                #   0    filename                                  (to delete)
                # Date is 64 bits in YYYYMMDDHHMMSS format.

                if block_type == &#39;i&#39;:
                    while not seg.eof:
                        f = DT(seg.u64())
                        f.name = seg.read_c_string(&#39;utf8&#39;)
                        if f.date &gt; 0:
                            na = seg.u32()
                            if na &gt; 65535:
                                raise ValueError(&#39;attr size &gt; 65535&#39;)
                            f.attr = seg.read_integer(na * 8)
                            ni = seg.u32()
                            for i in range(ni):
                                a = seg.u32()
                                f.frag.append(a)
                                if index:
                                    continue
                                elif not 1 &lt;= a &lt; len(frag):
                                    raise RuntimeError(&#39;frag ID out of range&#39;)
                                elif not frag[a]:
                                    raise LookupError(&#39;missing frag data&#39;)
                        dt[f.name] = f

                if streaming:
                    yield self._pack(filename, None, seg.getvalue())

            offset = src.tell()

        self.log_debug(F&#39;{offset} bytes of archive tested&#39;)

        if not journaling:
            return

        for name, f in dt.items():
            if not f.date:
                continue
            size = sum(
                int.from_bytes(frag[fp][20:24], &#39;little&#39;)
                for fp in f.frag
                if 0 &lt; fp &lt; len(frag) and len(frag[fp]) &gt;= 24
            )
            out = MemoryFile()
            for fp in f.frag:
                if fp &lt; len(frag):
                    out.write(memoryview(frag[fp])[24:])
            if len(out) != size:
                self.log_warn(&#39;invalid size during unpacking&#39;)
            yield self._pack(name, f.dt, out.getvalue())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.ArchiveUnit" href="index.html#refinery.units.formats.archive.ArchiveUnit">ArchiveUnit</a></li>
<li><a title="refinery.units.formats.PathExtractorUnit" href="../index.html#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></li>
<li><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></li>
<li><a title="refinery.units.Entry" href="../../index.html#refinery.units.Entry">Entry</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtzpaq.xtzpaq" href="#refinery.units.formats.archive.xtzpaq.xtzpaq">xtzpaq</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.xtzpaq.required_dependencies"><code class="name">var <span class="ident">required_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.xtzpaq.optional_dependencies"><code class="name">var <span class="ident">optional_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.xtzpaq.console"><code class="name">var <span class="ident">console</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtzpaq.xtzpaq.reverse"><code class="name">var <span class="ident">reverse</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtzpaq.xtzpaq.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtzpaq.py#L1252-L1493" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpack(self, data: bytearray):
    def mkdate(date) -&gt; datetime:
        date = int(date)
        year = date // 1000000 // 10000
        month = date // 100000000 % 100
        day = date // 1000000 % 100
        hour = date // 10000 % 100
        minute = date // 100 % 100
        second = date % 100
        return datetime(year, month, day, hour, minute, second, 0)

    @dataclass
    class DT:
        date: int = 0
        attr: int = 0
        name: str = &#34;&#34;
        frag: list[int] = field(default_factory=list)

        @property
        def dt(self) -&gt; datetime | None:
            if self.date &gt; 0:
                return mkdate(self.date)

    # TODO: implement password-protected archives
    # key = self.args.pwd
    index = self.args.index
    bsize: dict[int, int] = {}  # frag ID -&gt; d block compressed size
    dt: dict[str, DT] = {}      # filename -&gt; date, attr, frags
    frag: list[bytes] = []      # ID -&gt; hash[20] size[4] data
    csize = 0                   # expected offset of next non d block
    streaming = False
    journaling = False

    done = False
    dc = Decompressor(data)
    src = dc.dec.src
    offset = 0

    while not done and dc.read_block():
        while not done:
            filename = dc.read_filename()
            if filename is None:
                break
            self.log_info(&#39;reading file&#39;, filename)
            comment = dc.read_comment()
            jsize = 0
            if comment and len(comment) &gt;= 4 and comment[-4:] == &#34;jDC\x01&#34;:
                num = re.search(&#39;^\\d+&#39;, comment)
                if not num:
                    raise RuntimeError(&#39;missing size in comment&#39;)
                jsize = int(num[0])
                if streaming:
                    raise RuntimeError(&#39;journaling block after streaming one&#39;)
                journaling = True
                self.log_info(&#39;archive type is journaling&#39;)
            else:
                if journaling:
                    raise RuntimeError(&#39;streaming block after journaling one&#39;)
                if index:
                    raise RuntimeError(&#39;streaming block in index&#39;)
                streaming = True
                self.log_info(&#39;archive type is streaming&#39;)

            # Test journaling filename. The format must be
            # jDC[YYYYMMDDHHMMSS][t][NNNNNNNNNN]
            # where YYYYMMDDHHMMSS is the date, t is the type {c,d,h,i}, and
            # NNNNNNNNNN is the 10 digit first fragment ID for types c,d,h.
            # They must be in ascending lexicographical order.

            frag_id = 0
            block_type = None

            if journaling:
                if len(filename) != 28:
                    raise RuntimeError(&#39;filename size not 28&#39;)
                if filename[:3] != &#39;jDC&#39;:
                    raise RuntimeError(&#39;filename not jDC&#39;)
                block_type = filename[17]
                if block_type not in &#39;cdhi&#39;:
                    raise RuntimeError(&#39;type not c,d,h,i&#39;)
                try:
                    mkdate(filename[3:17])
                except Exception as E:
                    raise RuntimeError(&#39;invalid date&#39;) from E
                frag_id = int(filename[18:28])
                if not 1 &lt;= frag_id &lt;= 4294967295:
                    raise RuntimeError(&#39;fragment ID out of range&#39;)

            seg = MemoryFile(size_limit=jsize)
            dc.set_output(seg)
            sha1 = hashlib.sha1()
            dc.set_hasher(sha1)
            dc.decompress_data()

            if journaling and len(seg) != jsize:
                raise RuntimeError(&#39;incomplete output&#39;)

            checksum = dc.read_segment_end()
            if checksum is None:
                self.log_debug(&#39;no checksum&#39;)
            elif checksum != sha1.digest():
                raise RuntimeError(&#39;SHA1 mismatch&#39;)

            # check csize at first non-d block
            if csize and block_type and block_type in &#39;chi&#39;:
                if csize != offset:
                    raise RuntimeError(F&#39;csize={csize} does not point to offset={offset}&#39;)
                csize = 0

            # get csize from c block
            seglen = len(seg)
            seg = StructReader(seg.getvalue())
            if block_type == &#39;c&#39;:
                if seglen &lt; 8:
                    raise RuntimeError(&#34;c block too small&#34;)
                csize = seg.u64()
                offset = src.tell() + 1
                self.log_debug(F&#39;csize={csize} at offset={offset}&#39;)
                if csize &gt;&gt; 63:
                    self.log_warn(&#39;incomplete transaction at end of archive&#39;)
                    done = True
                elif index and csize != 0:
                    raise RuntimeError(&#39;nonzero csize in index&#39;)
                # Set csize to expected offset of first non d block
                # assuming 1 more byte for unread end of block marker.
                csize += offset

            if block_type == &#39;d&#39;:
                if index:
                    raise RuntimeError(&#39;d block in index&#39;)
                bsize[frag_id] = src.tell() + 1 - offset  # compressed size
                self.log_debug(F&#39; {bsize[frag_id]} -&gt; {len(seg)}&#39;)
                # Test frag size list at end. The format is f[id..id+n-1] fid n
                # where fid may be id or 0. sizes must sum to the rest of block.
                if seglen &lt; 8:
                    raise RuntimeError(&#39;d block too small&#39;)
                seg.seekset(-8)
                fid = seg.u32() or frag_id
                n = seg.u32()
                if fid != frag_id:
                    raise RuntimeError(&#39;missing ID&#39;)
                if n &gt; (seglen - 8) // 4:
                    raise RuntimeError(&#39;frag list too big&#39;)
                fragsum = 0  # computed sum of frag sizes
                seg.seekset(-4 * (n + 2))
                for _ in range(n):
                    fragsum += seg.u32()
                if fragsum + n * 4 + 8 != seglen:
                    raise RuntimeError(&#39;bad frag size list&#39;)
                # Save frag hashes and sizes. For output, save data too.
                seg.seekset(fragsum)
                buffer = seg.getvalue()
                assert seg.remaining_bytes == n * 4 + 8
                for i in range(n):
                    while len(frag) &lt;= frag_id + i:
                        frag.append(B&#39;&#39;)
                    if frag[frag_id + i]:
                        raise RuntimeError(&#39;duplicate frag ID&#39;)
                    f = seg.u32()
                    h = hashlib.sha1(buffer[:f]).digest()
                    frag[frag_id + i] = h + f.to_bytes(4, &#39;little&#39;) + buffer[:f]
                    buffer = buffer[f:]

                assert len(buffer) == n * 4 + 8
                assert seg.remaining_bytes == 8

            # Test and save h block. Format is: bsize (sha1[20] size)...
            # where bsize is the compressed size of the d block with the same id,
            # and each size corresonds to a fragment in that block. The list
            # must match the list in the d block if present.

            if block_type == &#39;h&#39;:
                if seglen % 24 != 4:
                    raise RuntimeError(&#39;bad h block size&#39;)
                b = seg.u32()
                self.log_debug(F&#39;[{frag_id}..{frag_id + seglen // 24}[ {b}&#39;)
                fragsum = 0 # uncompressed size of all frags
                for i in range(seglen // 24):
                    fd = seg.read(24)
                    if index:
                        while len(frag) &lt;= frag_id + i:
                            frag.append(B&#39;&#39;)
                        if frag[frag_id + i]:
                            raise RuntimeError(&#39;data in index&#39;)
                        frag[frag_id + i] = fd
                    elif frag_id + i &gt;= len(frag) or len(frag[frag_id + i]) &lt; 24:
                        raise RuntimeError(&#39;no matching d block&#39;)
                    elif frag[frag_id + i][:24] != fd:
                        raise RuntimeError(&#39;frag size or hash mismatch&#39;)
                    fragsum += int.from_bytes(fd[20:24], &#39;little&#39;)

            # Test i blocks and save files to extract. Format is:
            #   date filename 0 na attr[0..na) ni ptr[0..ni)   (to update)
            #   0    filename                                  (to delete)
            # Date is 64 bits in YYYYMMDDHHMMSS format.

            if block_type == &#39;i&#39;:
                while not seg.eof:
                    f = DT(seg.u64())
                    f.name = seg.read_c_string(&#39;utf8&#39;)
                    if f.date &gt; 0:
                        na = seg.u32()
                        if na &gt; 65535:
                            raise ValueError(&#39;attr size &gt; 65535&#39;)
                        f.attr = seg.read_integer(na * 8)
                        ni = seg.u32()
                        for i in range(ni):
                            a = seg.u32()
                            f.frag.append(a)
                            if index:
                                continue
                            elif not 1 &lt;= a &lt; len(frag):
                                raise RuntimeError(&#39;frag ID out of range&#39;)
                            elif not frag[a]:
                                raise LookupError(&#39;missing frag data&#39;)
                    dt[f.name] = f

            if streaming:
                yield self._pack(filename, None, seg.getvalue())

        offset = src.tell()

    self.log_debug(F&#39;{offset} bytes of archive tested&#39;)

    if not journaling:
        return

    for name, f in dt.items():
        if not f.date:
            continue
        size = sum(
            int.from_bytes(frag[fp][20:24], &#39;little&#39;)
            for fp in f.frag
            if 0 &lt; fp &lt; len(frag) and len(frag[fp]) &gt;= 24
        )
        out = MemoryFile()
        for fp in f.frag:
            if fp &lt; len(frag):
                out.write(memoryview(frag[fp])[24:])
        if len(out) != size:
            self.log_warn(&#39;invalid size during unpacking&#39;)
        yield self._pack(name, f.dt, out.getvalue())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.formats.archive.ArchiveUnit" href="index.html#refinery.units.formats.archive.ArchiveUnit">ArchiveUnit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.CustomPathSeparator" href="../index.html#refinery.units.formats.PathExtractorUnit.CustomPathSeparator">CustomPathSeparator</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.Requires" href="../../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.assemble" href="../../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.filter" href="../../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.finish" href="../../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.handles" href="../../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.is_quiet" href="../../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.labelled" href="../../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.leniency" href="../../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_always" href="../../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_debug" href="../../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_detach" href="../../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_fail" href="../../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_info" href="../../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_level" href="../../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_warn" href="../../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.nozzle" href="../../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.process" href="../../index.html#refinery.units.UnitBase.process">process</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.read" href="../../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.read1" href="../../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.run" href="../../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.source" href="../../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.superinit" href="../../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.formats.archive" href="index.html">refinery.units.formats.archive</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.formats.archive.xtzpaq.CompType" href="#refinery.units.formats.archive.xtzpaq.CompType">CompType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtzpaq.ZPAQL" href="#refinery.units.formats.archive.xtzpaq.ZPAQL">ZPAQL</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.units.formats.archive.xtzpaq.ZPAQL.inith" href="#refinery.units.formats.archive.xtzpaq.ZPAQL.inith">inith</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.ZPAQL.initp" href="#refinery.units.formats.archive.xtzpaq.ZPAQL.initp">initp</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.ZPAQL.run" href="#refinery.units.formats.archive.xtzpaq.ZPAQL.run">run</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.ZPAQL.read" href="#refinery.units.formats.archive.xtzpaq.ZPAQL.read">read</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.ZPAQL.clear" href="#refinery.units.formats.archive.xtzpaq.ZPAQL.clear">clear</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.ZPAQL.outc" href="#refinery.units.formats.archive.xtzpaq.ZPAQL.outc">outc</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.ZPAQL.init" href="#refinery.units.formats.archive.xtzpaq.ZPAQL.init">init</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.ZPAQL.execute_loop" href="#refinery.units.formats.archive.xtzpaq.ZPAQL.execute_loop">execute_loop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtzpaq.Component" href="#refinery.units.formats.archive.xtzpaq.Component">Component</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtzpaq.Component.init" href="#refinery.units.formats.archive.xtzpaq.Component.init">init</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtzpaq.StateTable" href="#refinery.units.formats.archive.xtzpaq.StateTable">StateTable</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtzpaq.StateTable.next" href="#refinery.units.formats.archive.xtzpaq.StateTable.next">next</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.StateTable.cminit" href="#refinery.units.formats.archive.xtzpaq.StateTable.cminit">cminit</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.StateTable.num_states" href="#refinery.units.formats.archive.xtzpaq.StateTable.num_states">num_states</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.StateTable.discount" href="#refinery.units.formats.archive.xtzpaq.StateTable.discount">discount</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.StateTable.next_state" href="#refinery.units.formats.archive.xtzpaq.StateTable.next_state">next_state</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtzpaq.Predictor" href="#refinery.units.formats.archive.xtzpaq.Predictor">Predictor</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.units.formats.archive.xtzpaq.Predictor.init" href="#refinery.units.formats.archive.xtzpaq.Predictor.init">init</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Predictor.predict" href="#refinery.units.formats.archive.xtzpaq.Predictor.predict">predict</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Predictor.update" href="#refinery.units.formats.archive.xtzpaq.Predictor.update">update</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Predictor.is_modeled" href="#refinery.units.formats.archive.xtzpaq.Predictor.is_modeled">is_modeled</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Predictor.train" href="#refinery.units.formats.archive.xtzpaq.Predictor.train">train</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Predictor.squash" href="#refinery.units.formats.archive.xtzpaq.Predictor.squash">squash</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Predictor.stretch" href="#refinery.units.formats.archive.xtzpaq.Predictor.stretch">stretch</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Predictor.clamp2k" href="#refinery.units.formats.archive.xtzpaq.Predictor.clamp2k">clamp2k</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Predictor.clamp512k" href="#refinery.units.formats.archive.xtzpaq.Predictor.clamp512k">clamp512k</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Predictor.find" href="#refinery.units.formats.archive.xtzpaq.Predictor.find">find</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtzpaq.Decoder" href="#refinery.units.formats.archive.xtzpaq.Decoder">Decoder</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtzpaq.Decoder.init" href="#refinery.units.formats.archive.xtzpaq.Decoder.init">init</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Decoder.decode" href="#refinery.units.formats.archive.xtzpaq.Decoder.decode">decode</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Decoder.decompress" href="#refinery.units.formats.archive.xtzpaq.Decoder.decompress">decompress</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtzpaq.PostProcessor" href="#refinery.units.formats.archive.xtzpaq.PostProcessor">PostProcessor</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtzpaq.PostProcessor.init" href="#refinery.units.formats.archive.xtzpaq.PostProcessor.init">init</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.PostProcessor.set_output" href="#refinery.units.formats.archive.xtzpaq.PostProcessor.set_output">set_output</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.PostProcessor.set_hasher" href="#refinery.units.formats.archive.xtzpaq.PostProcessor.set_hasher">set_hasher</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.PostProcessor.write" href="#refinery.units.formats.archive.xtzpaq.PostProcessor.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtzpaq.Decompressor" href="#refinery.units.formats.archive.xtzpaq.Decompressor">Decompressor</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.units.formats.archive.xtzpaq.Decompressor.set_output" href="#refinery.units.formats.archive.xtzpaq.Decompressor.set_output">set_output</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Decompressor.set_hasher" href="#refinery.units.formats.archive.xtzpaq.Decompressor.set_hasher">set_hasher</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Decompressor.read_block" href="#refinery.units.formats.archive.xtzpaq.Decompressor.read_block">read_block</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Decompressor.read_filename" href="#refinery.units.formats.archive.xtzpaq.Decompressor.read_filename">read_filename</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Decompressor.read_comment" href="#refinery.units.formats.archive.xtzpaq.Decompressor.read_comment">read_comment</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Decompressor.decompress_data" href="#refinery.units.formats.archive.xtzpaq.Decompressor.decompress_data">decompress_data</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtzpaq.Decompressor.read_segment_end" href="#refinery.units.formats.archive.xtzpaq.Decompressor.read_segment_end">read_segment_end</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtzpaq.xtzpaq" href="#refinery.units.formats.archive.xtzpaq.xtzpaq">xtzpaq</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtzpaq.xtzpaq.unpack" href="#refinery.units.formats.archive.xtzpaq.xtzpaq.unpack">unpack</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
