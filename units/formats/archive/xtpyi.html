<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.units.formats.archive.xtpyi documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.formats.archive.xtpyi</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L1-L434" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from __future__ import annotations

import codecs
import contextlib
import dataclasses
import enum
import marshal
import os
import os.path
import re
import uuid
import zlib

from typing import TYPE_CHECKING, Callable, cast

from Cryptodome.Cipher import AES

from refinery.lib.py import decompile_buffer, version2tuple
from refinery.lib.shared import xdis
from refinery.lib.structures import StreamDetour, Struct, StructReader
from refinery.lib.types import Param, buf
from refinery.units.formats.archive import ArchiveUnit, Arg
from refinery.units.formats.pym import Marshal
from refinery.units.pattern.carve import carve


class Unmarshal(enum.IntEnum):
    No = 0
    Yes = 1
    YesAndDecompile = 2


def decompress_peek(buffer, size=512) -&gt; bytes | None:
    try:
        return zlib.decompressobj().decompress(buffer[:size])
    except zlib.error:
        return None


class PiType(bytes, enum.Enum):
    BINARY          = B&#39;b&#39;  # noqa / binary
    DEPENDENCY      = B&#39;d&#39;  # noqa / runtime option
    PYZ             = B&#39;z&#39;  # noqa / zlib (pyz) - frozen Python code
    PACKAGE         = B&#39;M&#39;  # noqa / Python package (__init__.py)
    MODULE          = B&#39;m&#39;  # noqa / Python module
    SOURCE          = B&#39;s&#39;  # noqa / Python script (v3)
    DATA            = B&#39;x&#39;  # noqa / data
    RUNTIME_OPTION  = B&#39;o&#39;  # noqa / runtime option
    SPLASH          = B&#39;l&#39;  # noqa / splash resources
    UNKNOWN         = B&#39;uk&#39; # noqa
    DECOMPILED      = B&#39;dc&#39; # noqa
    USERCODE        = B&#39;uc&#39; # noqa
    ENCRYPTED       = B&#39;ec&#39; # noqa


class PzType(enum.IntEnum):
    MODULE = 0
    PKG = 1
    DATA = 2


@dataclasses.dataclass
class PiMeta:
    type: PiType
    name: str
    data: Callable[[], buf] | buf

    def unpack(self) -&gt; buf:
        if callable(self.data):
            self.data = self.data()
        return self.data


def make_decompiled_item(name: str, data: buf, *magics) -&gt; PiMeta:

    def extract(data=data, magics=magics):
        error = None
        if any(data[:4] == m[:4] for m in magics):
            return decompile_buffer(data, name)
        for magic in magics:
            try:
                return decompile_buffer(magic + data, name)
            except Exception as exception:
                error = exception
        return &#39;\n&#39;.join(F&#39;# {line}&#39;
            for line in str(error).splitlines(True)).encode(&#39;utf8&#39;)

    return PiMeta(PiType.DECOMPILED, F&#39;{name}.py&#39;, extract)


class PYZ(Struct):

    MagicSignature = B&#39;PYZ\0&#39;

    def __init__(self, reader: StructReader, version: str):
        reader.bigendian = True
        self.base = reader.tell()
        signature = reader.read(4)
        if signature != self.MagicSignature:
            raise ValueError(&#39;invalid magic&#39;)
        magic = bytes(reader.read(4))
        with contextlib.suppress(KeyError, AttributeError):
            version = xdis.magics.versions[magic]
        vtuple = version2tuple(version)
        padding_size = 4
        if vtuple &gt;= (3, 3):
            padding_size += 4
        if vtuple &gt;= (3, 7):
            padding_size += 4
        self.version = version
        self.magic = magic + padding_size * b&#39;\0&#39;
        self.toc_offset = reader.i32()
        self.reader = reader
        self.entries: list[PiMeta] = []

    def unpack(self, decompile: bool, key: bytes | None = None) -&gt; bool:
        with StreamDetour(self.reader, self.base + self.toc_offset):
            toc_data = self.reader.read()
        try:
            toc = marshal.loads(toc_data)
        except Exception:
            toc = Marshal(memoryview(toc_data)).object()

        if isinstance(toc, list):
            try:
                toc = dict(toc)
            except Exception as error:
                self.entries = []
                self.error = error
                return False

        if TYPE_CHECKING:
            toc = cast(dict[str | bytes, tuple[int, int, int]], toc)

        failures = 0
        attempts = len(toc)

        for name, (_pzt, offset, length) in toc.items():
            if not isinstance(name, str):
                name = codecs.decode(name, &#39;utf-8&#39;)
            try:
                pzt = PzType(_pzt)
            except Exception:
                pzt = PzType.DATA

            name = name.replace(&#39;.&#39;, &#39;/&#39;)
            if pzt is PzType.PKG:
                name = F&#39;{name}/__init__&#39;

            with StreamDetour(self.reader, self.base + offset):
                data = self.reader.read(length)

            if key:
                def decompressed(data=data):
                    cipher = AES.new(key, AES.MODE_CFB, bytes(data[:0x10]))
                    return zlib.decompress(cipher.decrypt(data[0x10:]))
            elif decompress_peek(data):
                def decompressed(data=data):
                    return zlib.decompress(data)
            else:
                failures += 1
                continue

            if decompile and pzt in (PzType.MODULE, PzType.PKG):
                def decompiled(data=data, name=name, magic=self.magic):
                    data = decompressed(data)
                    if data[:4] != magic[:4]:
                        data = magic + data
                    return decompile_buffer(data, name)
                self.entries.append(PiMeta(PiType.DECOMPILED, F&#39;{name}.py&#39;, decompiled))
                name = F&#39;{name}.pyc&#39;
                type = PiType.SOURCE
            else:
                type = PiType.DATA

            self.entries.append(PiMeta(type, name, decompressed))

        if key:
            if failures &gt;= 6:
                xtpyi.logger.warning(F&#39;pyz decompression failed for {failures - 5} additional items&#39;)
            return True
        elif failures &gt; 0.7 * attempts:
            self.entries.clear()
            return False
        else:
            return True


class PiTOCEntry(Struct):

    def __init__(self, reader: StructReader):
        reader.bigendian = True
        entry_start_offset = reader.tell()
        self.size_of_entry = reader.i32()
        self.offset = reader.i32()
        self.size_of_compressed_data = reader.i32()
        self.size_od_uncompressed_data = reader.i32()
        self.is_compressed = bool(reader.read_byte())
        entry_type = bytes(reader.read(1))
        name_length = self.size_of_entry - reader.tell() + entry_start_offset
        if name_length &gt; 0x1000:
            raise RuntimeError(F&#39;Refusing to process TOC entry with name of size {name_length}.&#39;)
        name, *_ = bytes(reader.read(name_length)).partition(B&#39;\0&#39;)
        try:
            name = name.decode(&#39;utf8&#39;, &#39;backslashreplace&#39;)
        except Exception:
            name = str(uuid.uuid4())
        else:
            if not all(part.isprintable() for part in re.split(&#39;\\s*&#39;, name)):
                raise RuntimeError(&#39;Refusing to process TOC entry with non-printable name.&#39;)
        if entry_type == B&#39;Z&#39;:
            entry_type = B&#39;z&#39;
        try:
            self.type = PiType(entry_type)
        except ValueError:
            xtpyi.log_warn(F&#39;unknown type {entry_type!r} in field {name}&#39;)
            self.type = PiType.UNKNOWN
        self.name = name

    def __hash__(self):
        return hash(self.name)


class PyInstallerArchiveEpilogue(Struct):

    MagicSignature = bytes.fromhex(&#39;4D45490C0B0A0B0E&#39;)

    def _read_libname(self, reader: StructReader) -&gt; str | None:
        position = reader.tell()
        try:
            libname, t, rest = reader.read_bytes(64).partition(B&#39;\0&#39;)
        except EOFError:
            reader.seekset(position)
            return None
        try:
            libname = libname.decode(&#39;utf8&#39;)
        except Exception:
            reader.seekset(position)
            return None
        if not t or any(rest) or len(rest) &lt; 10 or not re.fullmatch(R&#39;[\s!-~]+&#39;, libname):
            reader.seekset(position)
            return None
        return libname

    def __init__(self, reader: StructReader, offset: int, unmarshal: Unmarshal = Unmarshal.No, decompile: bool = False):
        self.decompile = decompile
        reader.bigendian = True
        reader.seekset(offset)
        self.reader = reader
        signature = reader.read_bytes(8)
        if signature != self.MagicSignature:
            raise ValueError(
                F&#39;offset 0x{offset:X} has invalid signature {signature.hex().upper()}; &#39;
                F&#39;should be {self.MagicSignature.hex().upper()}&#39;)
        self.size = reader.i32()
        toc_offset = reader.i32()
        toc_length = reader.i32()
        self.py_version = &#39;.&#39;.join(str(reader.u32()))
        self.py_libname = self._read_libname(reader)
        self.offset = reader.tell() - self.size

        self.toc: dict[str, PiTOCEntry] = {}
        toc_end = self.offset + toc_offset + toc_length
        reader.seekset(self.offset + toc_offset)
        while reader.tell() &lt; toc_end:
            try:
                entry = PiTOCEntry(reader)
            except EOFError:
                xtpyi.logger.warning(&#39;end of file while reading TOC&#39;)
                break
            except Exception as error:
                xtpyi.logger.warning(F&#39;unexpected error while reading TOC: {error!s}&#39;)
                break
            if entry.name in self.toc:
                raise KeyError(F&#39;duplicate name {entry.name}&#39;)
            self.toc[entry.name] = entry

        self.files: dict[str, PiMeta] = {}
        no_pyz_found = True
        pyz_entries: dict[str, PYZ] = {}

        for entry in list(self.toc.values()):
            if entry.type is not PiType.PYZ:
                continue
            no_pyz_found = False
            name, xt = os.path.splitext(entry.name)
            name_pyz = F&#39;{name}.pyz&#39;
            if name == entry.name:
                del self.toc[name]
                self.toc[name_pyz] = entry
                entry.name = name_pyz
            reader.seekset(self.offset + entry.offset)
            if entry.is_compressed:
                data = self.extract(entry.name).unpack()
            else:
                data = reader
            pyz_entries[name] = PYZ(data, self.py_version)

        magics = {pyz.magic for pyz in pyz_entries.values()}

        if not magics:
            if not no_pyz_found:
                xtpyi.logger.warning(
                    &#39;no magic signature could be recovered from embedded pyzip archives; this is &#39;
                    &#39;unsual and means that there is no way to guess the missing magic for source &#39;
                    &#39;file entries and it will likely not be possible to decompile them.&#39;)
            return
        elif len(magics) &gt; 1:
            xtpyi.logger.warning(&#39;more than one magic signature was recovered; this is unusual.&#39;)

        magics = list(magics)
        keys: set[bytes] = set()

        for entry in self.toc.values():
            extracted = self.extract(entry.name)
            if entry.type not in (PiType.SOURCE, PiType.MODULE):
                self.files[entry.name] = extracted
                continue
            data = extracted.unpack()
            name, _ = os.path.splitext(extracted.name)
            del self.files[extracted.name]
            extracted.name = F&#39;{name}.pyc&#39;
            self.files[extracted.name] = extracted
            is_crypto_key = name.endswith(&#39;crypto_key&#39;)

            if len(magics) == 1 and data[:4] != magics[0][:4]:
                extracted.data = magics[0] + data

            if is_crypto_key or self.decompile:
                decompiled = make_decompiled_item(name, data, *magics)

                if entry.type is PiType.SOURCE:
                    decompiled.type = PiType.USERCODE
                self.files[decompiled.name] = decompiled

                if is_crypto_key:
                    for key in decompiled.unpack() | carve(&#39;string&#39;, decode=True):
                        if len(key) != 0x10:
                            continue
                        xtpyi.logger.info(F&#39;found key: {key.decode(xtpyi.codec)}&#39;)
                        keys.add(key)

        if unmarshal is Unmarshal.No:
            return

        if not keys:
            key = None
        else:
            key = next(iter(keys))

        for name, pyz in pyz_entries.items():
            pyz.unpack(unmarshal is Unmarshal.YesAndDecompile, key)
            for unpacked in pyz.entries:
                unpacked.name = path = F&#39;{name}/{unpacked.name}&#39;
                if path in self.files:
                    raise ValueError(F&#39;duplicate file name: {path}&#39;)
                self.files[path] = unpacked

    def extract(self, name: str) -&gt; PiMeta:
        try:
            return self.files[name]
        except KeyError:
            pass
        entry = self.toc[name]
        with StreamDetour(self.reader, self.offset + entry.offset):
            data = self.reader.read(entry.size_of_compressed_data)
        if entry.is_compressed:
            def extracted(d=data): return zlib.decompress(d)
        else:
            extracted = data
        result = PiMeta(entry.type, name, extracted)
        self.files[name] = result
        return result


class xtpyi(ArchiveUnit, docs=&#39;{0}{s}{PathExtractorUnit}&#39;):
    &#34;&#34;&#34;
    Extracts and decompiles files from a Python Installer (aka PyInstaller) archive.
    &#34;&#34;&#34;
    def __init__(
        self, *paths, list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False,
        path=b&#39;path&#39;, date=b&#39;date&#39;,
        decompile: Param[bool, Arg.Switch(&#39;-c&#39;, help=&#39;Attempt to decompile PYC files.&#39;)] = False,
        user_code: Param[bool, Arg.Switch(&#39;-u&#39;, group=&#39;FILTER&#39;, help=(
            &#39;Extract only source code files from the root of the archive. These usually implement &#39;
            &#39;the actual domain logic. This implies the --decompile option.&#39;))] = False,
        unmarshal: Param[int, Arg(&#39;-y&#39;, action=&#39;count&#39;, group=&#39;FILTER&#39;, help=(
            &#39;(DANGEROUS) Unmarshal embedded PYZ archives. Warning: Maliciously crafted packages can &#39;
            &#39;potentially exploit this to execute code. It is advised to only use this option inside &#39;
            &#39;an isolated environment. Specify twice to decompile unmarshalled Python bytecode.&#39;
        ))] = 0
    ):
        super().__init__(
            *paths,
            list=list,
            join_path=join_path,
            drop_path=drop_path,
            fuzzy=fuzzy,
            exact=exact,
            regex=regex,
            path=path,
            date=date,
            decompile=decompile,
            unmarshal=unmarshal,
            user_code=user_code,
        )

    def unpack(self, data):
        view = memoryview(data)
        positions = [m.start() for m in re.finditer(re.escape(PyInstallerArchiveEpilogue.MagicSignature), view)]
        mode = Unmarshal(min(2, int(self.args.unmarshal)))
        self.log_debug(F&#39;unmarshal mode: {mode.name}&#39;)
        if not positions:
            raise LookupError(&#39;unable to find PyInstaller signature&#39;)
        if len(positions) &gt; 2:
            # first position is expected to be the sentinel value in the unpacker stub
            width = max(len(F&#39;{p:X}&#39;) for p in positions)
            for position in positions:
                self.log_info(F&#39;magic signature found at offset 0x{position:0{width}X}&#39;)
            self.log_warn(F&#39;found {len(positions) - 1} potential PyInstaller epilogue markers; using last one.&#39;)
        decompile = self.args.decompile
        uc_target = PiType.USERCODE if decompile else PiType.SOURCE
        archive = PyInstallerArchiveEpilogue(view, positions[-1], mode, decompile)
        for name, file in archive.files.items():
            if self.args.user_code:
                if file.type != uc_target:
                    continue
                if name.startswith(&#39;pyiboot&#39;):
                    continue
            yield self._pack(name, None, file.data, type=file.type.name)

    @classmethod
    def handles(cls, data: buf) -&gt; bool | None:
        return PyInstallerArchiveEpilogue.MagicSignature in data</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.decompress_peek"><code class="name flex">
<span>def <span class="ident">decompress_peek</span></span>(<span>buffer, size=512)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L33-L37" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decompress_peek(buffer, size=512) -&gt; bytes | None:
    try:
        return zlib.decompressobj().decompress(buffer[:size])
    except zlib.error:
        return None</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.make_decompiled_item"><code class="name flex">
<span>def <span class="ident">make_decompiled_item</span></span>(<span>name, data, *magics)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L74-L88" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def make_decompiled_item(name: str, data: buf, *magics) -&gt; PiMeta:

    def extract(data=data, magics=magics):
        error = None
        if any(data[:4] == m[:4] for m in magics):
            return decompile_buffer(data, name)
        for magic in magics:
            try:
                return decompile_buffer(magic + data, name)
            except Exception as exception:
                error = exception
        return &#39;\n&#39;.join(F&#39;# {line}&#39;
            for line in str(error).splitlines(True)).encode(&#39;utf8&#39;)

    return PiMeta(PiType.DECOMPILED, F&#39;{name}.py&#39;, extract)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.Unmarshal"><code class="flex name class">
<span>class <span class="ident">Unmarshal</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L27-L30" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Unmarshal(enum.IntEnum):
    No = 0
    Yes = 1
    YesAndDecompile = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.Unmarshal.No"><code class="name">var <span class="ident">No</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.Unmarshal.Yes"><code class="name">var <span class="ident">Yes</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.Unmarshal.YesAndDecompile"><code class="name">var <span class="ident">YesAndDecompile</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType"><code class="flex name class">
<span>class <span class="ident">PiType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>bytes(iterable_of_ints) -&gt; bytes
bytes(string, encoding[, errors]) -&gt; bytes
bytes(bytes_or_buffer) -&gt; immutable copy of bytes_or_buffer
bytes(int) -&gt; bytes object of size given by the parameter initialized with null bytes
bytes() -&gt; empty bytes object</p>
<p>Construct an immutable array of bytes from:
- an iterable yielding integers in range(256)
- a text string encoded using the specified encoding
- any object implementing the buffer API.
- an integer</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L40-L53" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PiType(bytes, enum.Enum):
    BINARY          = B&#39;b&#39;  # noqa / binary
    DEPENDENCY      = B&#39;d&#39;  # noqa / runtime option
    PYZ             = B&#39;z&#39;  # noqa / zlib (pyz) - frozen Python code
    PACKAGE         = B&#39;M&#39;  # noqa / Python package (__init__.py)
    MODULE          = B&#39;m&#39;  # noqa / Python module
    SOURCE          = B&#39;s&#39;  # noqa / Python script (v3)
    DATA            = B&#39;x&#39;  # noqa / data
    RUNTIME_OPTION  = B&#39;o&#39;  # noqa / runtime option
    SPLASH          = B&#39;l&#39;  # noqa / splash resources
    UNKNOWN         = B&#39;uk&#39; # noqa
    DECOMPILED      = B&#39;dc&#39; # noqa
    USERCODE        = B&#39;uc&#39; # noqa
    ENCRYPTED       = B&#39;ec&#39; # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.bytes</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PiType.BINARY"><code class="name">var <span class="ident">BINARY</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.DEPENDENCY"><code class="name">var <span class="ident">DEPENDENCY</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.PYZ"><code class="name">var <span class="ident">PYZ</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.PACKAGE"><code class="name">var <span class="ident">PACKAGE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.MODULE"><code class="name">var <span class="ident">MODULE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.SOURCE"><code class="name">var <span class="ident">SOURCE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.DATA"><code class="name">var <span class="ident">DATA</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.RUNTIME_OPTION"><code class="name">var <span class="ident">RUNTIME_OPTION</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.SPLASH"><code class="name">var <span class="ident">SPLASH</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.UNKNOWN"><code class="name">var <span class="ident">UNKNOWN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.DECOMPILED"><code class="name">var <span class="ident">DECOMPILED</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.USERCODE"><code class="name">var <span class="ident">USERCODE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiType.ENCRYPTED"><code class="name">var <span class="ident">ENCRYPTED</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PzType"><code class="flex name class">
<span>class <span class="ident">PzType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L56-L59" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PzType(enum.IntEnum):
    MODULE = 0
    PKG = 1
    DATA = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PzType.MODULE"><code class="name">var <span class="ident">MODULE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PzType.PKG"><code class="name">var <span class="ident">PKG</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PzType.DATA"><code class="name">var <span class="ident">DATA</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiMeta"><code class="flex name class">
<span>class <span class="ident">PiMeta</span></span>
<span>(</span><span>type, name, data)</span>
</code></dt>
<dd>
<section class="desc"><p>PiMeta(type: 'PiType', name: 'str', data: 'Callable[[], buf] | buf')</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L62-L71" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclasses.dataclass
class PiMeta:
    type: PiType
    name: str
    data: Callable[[], buf] | buf

    def unpack(self) -&gt; buf:
        if callable(self.data):
            self.data = self.data()
        return self.data</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PiMeta.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiMeta.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiMeta.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PiMeta.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L68-L71" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpack(self) -&gt; buf:
    if callable(self.data):
        self.data = self.data()
    return self.data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PYZ"><code class="flex name class">
<span>class <span class="ident">PYZ</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L91-L186" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PYZ(Struct):

    MagicSignature = B&#39;PYZ\0&#39;

    def __init__(self, reader: StructReader, version: str):
        reader.bigendian = True
        self.base = reader.tell()
        signature = reader.read(4)
        if signature != self.MagicSignature:
            raise ValueError(&#39;invalid magic&#39;)
        magic = bytes(reader.read(4))
        with contextlib.suppress(KeyError, AttributeError):
            version = xdis.magics.versions[magic]
        vtuple = version2tuple(version)
        padding_size = 4
        if vtuple &gt;= (3, 3):
            padding_size += 4
        if vtuple &gt;= (3, 7):
            padding_size += 4
        self.version = version
        self.magic = magic + padding_size * b&#39;\0&#39;
        self.toc_offset = reader.i32()
        self.reader = reader
        self.entries: list[PiMeta] = []

    def unpack(self, decompile: bool, key: bytes | None = None) -&gt; bool:
        with StreamDetour(self.reader, self.base + self.toc_offset):
            toc_data = self.reader.read()
        try:
            toc = marshal.loads(toc_data)
        except Exception:
            toc = Marshal(memoryview(toc_data)).object()

        if isinstance(toc, list):
            try:
                toc = dict(toc)
            except Exception as error:
                self.entries = []
                self.error = error
                return False

        if TYPE_CHECKING:
            toc = cast(dict[str | bytes, tuple[int, int, int]], toc)

        failures = 0
        attempts = len(toc)

        for name, (_pzt, offset, length) in toc.items():
            if not isinstance(name, str):
                name = codecs.decode(name, &#39;utf-8&#39;)
            try:
                pzt = PzType(_pzt)
            except Exception:
                pzt = PzType.DATA

            name = name.replace(&#39;.&#39;, &#39;/&#39;)
            if pzt is PzType.PKG:
                name = F&#39;{name}/__init__&#39;

            with StreamDetour(self.reader, self.base + offset):
                data = self.reader.read(length)

            if key:
                def decompressed(data=data):
                    cipher = AES.new(key, AES.MODE_CFB, bytes(data[:0x10]))
                    return zlib.decompress(cipher.decrypt(data[0x10:]))
            elif decompress_peek(data):
                def decompressed(data=data):
                    return zlib.decompress(data)
            else:
                failures += 1
                continue

            if decompile and pzt in (PzType.MODULE, PzType.PKG):
                def decompiled(data=data, name=name, magic=self.magic):
                    data = decompressed(data)
                    if data[:4] != magic[:4]:
                        data = magic + data
                    return decompile_buffer(data, name)
                self.entries.append(PiMeta(PiType.DECOMPILED, F&#39;{name}.py&#39;, decompiled))
                name = F&#39;{name}.pyc&#39;
                type = PiType.SOURCE
            else:
                type = PiType.DATA

            self.entries.append(PiMeta(type, name, decompressed))

        if key:
            if failures &gt;= 6:
                xtpyi.logger.warning(F&#39;pyz decompression failed for {failures - 5} additional items&#39;)
            return True
        elif failures &gt; 0.7 * attempts:
            self.entries.clear()
            return False
        else:
            return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PYZ.MagicSignature"><code class="name">var <span class="ident">MagicSignature</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PYZ.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, decompile, key=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L116-L186" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpack(self, decompile: bool, key: bytes | None = None) -&gt; bool:
    with StreamDetour(self.reader, self.base + self.toc_offset):
        toc_data = self.reader.read()
    try:
        toc = marshal.loads(toc_data)
    except Exception:
        toc = Marshal(memoryview(toc_data)).object()

    if isinstance(toc, list):
        try:
            toc = dict(toc)
        except Exception as error:
            self.entries = []
            self.error = error
            return False

    if TYPE_CHECKING:
        toc = cast(dict[str | bytes, tuple[int, int, int]], toc)

    failures = 0
    attempts = len(toc)

    for name, (_pzt, offset, length) in toc.items():
        if not isinstance(name, str):
            name = codecs.decode(name, &#39;utf-8&#39;)
        try:
            pzt = PzType(_pzt)
        except Exception:
            pzt = PzType.DATA

        name = name.replace(&#39;.&#39;, &#39;/&#39;)
        if pzt is PzType.PKG:
            name = F&#39;{name}/__init__&#39;

        with StreamDetour(self.reader, self.base + offset):
            data = self.reader.read(length)

        if key:
            def decompressed(data=data):
                cipher = AES.new(key, AES.MODE_CFB, bytes(data[:0x10]))
                return zlib.decompress(cipher.decrypt(data[0x10:]))
        elif decompress_peek(data):
            def decompressed(data=data):
                return zlib.decompress(data)
        else:
            failures += 1
            continue

        if decompile and pzt in (PzType.MODULE, PzType.PKG):
            def decompiled(data=data, name=name, magic=self.magic):
                data = decompressed(data)
                if data[:4] != magic[:4]:
                    data = magic + data
                return decompile_buffer(data, name)
            self.entries.append(PiMeta(PiType.DECOMPILED, F&#39;{name}.py&#39;, decompiled))
            name = F&#39;{name}.pyc&#39;
            type = PiType.SOURCE
        else:
            type = PiType.DATA

        self.entries.append(PiMeta(type, name, decompressed))

    if key:
        if failures &gt;= 6:
            xtpyi.logger.warning(F&#39;pyz decompression failed for {failures - 5} additional items&#39;)
        return True
    elif failures &gt; 0.7 * attempts:
        self.entries.clear()
        return False
    else:
        return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PiTOCEntry"><code class="flex name class">
<span>class <span class="ident">PiTOCEntry</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L189-L221" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PiTOCEntry(Struct):

    def __init__(self, reader: StructReader):
        reader.bigendian = True
        entry_start_offset = reader.tell()
        self.size_of_entry = reader.i32()
        self.offset = reader.i32()
        self.size_of_compressed_data = reader.i32()
        self.size_od_uncompressed_data = reader.i32()
        self.is_compressed = bool(reader.read_byte())
        entry_type = bytes(reader.read(1))
        name_length = self.size_of_entry - reader.tell() + entry_start_offset
        if name_length &gt; 0x1000:
            raise RuntimeError(F&#39;Refusing to process TOC entry with name of size {name_length}.&#39;)
        name, *_ = bytes(reader.read(name_length)).partition(B&#39;\0&#39;)
        try:
            name = name.decode(&#39;utf8&#39;, &#39;backslashreplace&#39;)
        except Exception:
            name = str(uuid.uuid4())
        else:
            if not all(part.isprintable() for part in re.split(&#39;\\s*&#39;, name)):
                raise RuntimeError(&#39;Refusing to process TOC entry with non-printable name.&#39;)
        if entry_type == B&#39;Z&#39;:
            entry_type = B&#39;z&#39;
        try:
            self.type = PiType(entry_type)
        except ValueError:
            xtpyi.log_warn(F&#39;unknown type {entry_type!r} in field {name}&#39;)
            self.type = PiType.UNKNOWN
        self.name = name

    def __hash__(self):
        return hash(self.name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue"><code class="flex name class">
<span>class <span class="ident">PyInstallerArchiveEpilogue</span></span>
<span>(</span><span>reader, offset, unmarshal=0, decompile=False)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../../../lib/structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L224-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PyInstallerArchiveEpilogue(Struct):

    MagicSignature = bytes.fromhex(&#39;4D45490C0B0A0B0E&#39;)

    def _read_libname(self, reader: StructReader) -&gt; str | None:
        position = reader.tell()
        try:
            libname, t, rest = reader.read_bytes(64).partition(B&#39;\0&#39;)
        except EOFError:
            reader.seekset(position)
            return None
        try:
            libname = libname.decode(&#39;utf8&#39;)
        except Exception:
            reader.seekset(position)
            return None
        if not t or any(rest) or len(rest) &lt; 10 or not re.fullmatch(R&#39;[\s!-~]+&#39;, libname):
            reader.seekset(position)
            return None
        return libname

    def __init__(self, reader: StructReader, offset: int, unmarshal: Unmarshal = Unmarshal.No, decompile: bool = False):
        self.decompile = decompile
        reader.bigendian = True
        reader.seekset(offset)
        self.reader = reader
        signature = reader.read_bytes(8)
        if signature != self.MagicSignature:
            raise ValueError(
                F&#39;offset 0x{offset:X} has invalid signature {signature.hex().upper()}; &#39;
                F&#39;should be {self.MagicSignature.hex().upper()}&#39;)
        self.size = reader.i32()
        toc_offset = reader.i32()
        toc_length = reader.i32()
        self.py_version = &#39;.&#39;.join(str(reader.u32()))
        self.py_libname = self._read_libname(reader)
        self.offset = reader.tell() - self.size

        self.toc: dict[str, PiTOCEntry] = {}
        toc_end = self.offset + toc_offset + toc_length
        reader.seekset(self.offset + toc_offset)
        while reader.tell() &lt; toc_end:
            try:
                entry = PiTOCEntry(reader)
            except EOFError:
                xtpyi.logger.warning(&#39;end of file while reading TOC&#39;)
                break
            except Exception as error:
                xtpyi.logger.warning(F&#39;unexpected error while reading TOC: {error!s}&#39;)
                break
            if entry.name in self.toc:
                raise KeyError(F&#39;duplicate name {entry.name}&#39;)
            self.toc[entry.name] = entry

        self.files: dict[str, PiMeta] = {}
        no_pyz_found = True
        pyz_entries: dict[str, PYZ] = {}

        for entry in list(self.toc.values()):
            if entry.type is not PiType.PYZ:
                continue
            no_pyz_found = False
            name, xt = os.path.splitext(entry.name)
            name_pyz = F&#39;{name}.pyz&#39;
            if name == entry.name:
                del self.toc[name]
                self.toc[name_pyz] = entry
                entry.name = name_pyz
            reader.seekset(self.offset + entry.offset)
            if entry.is_compressed:
                data = self.extract(entry.name).unpack()
            else:
                data = reader
            pyz_entries[name] = PYZ(data, self.py_version)

        magics = {pyz.magic for pyz in pyz_entries.values()}

        if not magics:
            if not no_pyz_found:
                xtpyi.logger.warning(
                    &#39;no magic signature could be recovered from embedded pyzip archives; this is &#39;
                    &#39;unsual and means that there is no way to guess the missing magic for source &#39;
                    &#39;file entries and it will likely not be possible to decompile them.&#39;)
            return
        elif len(magics) &gt; 1:
            xtpyi.logger.warning(&#39;more than one magic signature was recovered; this is unusual.&#39;)

        magics = list(magics)
        keys: set[bytes] = set()

        for entry in self.toc.values():
            extracted = self.extract(entry.name)
            if entry.type not in (PiType.SOURCE, PiType.MODULE):
                self.files[entry.name] = extracted
                continue
            data = extracted.unpack()
            name, _ = os.path.splitext(extracted.name)
            del self.files[extracted.name]
            extracted.name = F&#39;{name}.pyc&#39;
            self.files[extracted.name] = extracted
            is_crypto_key = name.endswith(&#39;crypto_key&#39;)

            if len(magics) == 1 and data[:4] != magics[0][:4]:
                extracted.data = magics[0] + data

            if is_crypto_key or self.decompile:
                decompiled = make_decompiled_item(name, data, *magics)

                if entry.type is PiType.SOURCE:
                    decompiled.type = PiType.USERCODE
                self.files[decompiled.name] = decompiled

                if is_crypto_key:
                    for key in decompiled.unpack() | carve(&#39;string&#39;, decode=True):
                        if len(key) != 0x10:
                            continue
                        xtpyi.logger.info(F&#39;found key: {key.decode(xtpyi.codec)}&#39;)
                        keys.add(key)

        if unmarshal is Unmarshal.No:
            return

        if not keys:
            key = None
        else:
            key = next(iter(keys))

        for name, pyz in pyz_entries.items():
            pyz.unpack(unmarshal is Unmarshal.YesAndDecompile, key)
            for unpacked in pyz.entries:
                unpacked.name = path = F&#39;{name}/{unpacked.name}&#39;
                if path in self.files:
                    raise ValueError(F&#39;duplicate file name: {path}&#39;)
                self.files[path] = unpacked

    def extract(self, name: str) -&gt; PiMeta:
        try:
            return self.files[name]
        except KeyError:
            pass
        entry = self.toc[name]
        with StreamDetour(self.reader, self.offset + entry.offset):
            data = self.reader.read(entry.size_of_compressed_data)
        if entry.is_compressed:
            def extracted(d=data): return zlib.decompress(d)
        else:
            extracted = data
        result = PiMeta(entry.type, name, extracted)
        self.files[name] = result
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="../../../lib/structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue.MagicSignature"><code class="name">var <span class="ident">MagicSignature</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L359-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def extract(self, name: str) -&gt; PiMeta:
    try:
        return self.files[name]
    except KeyError:
        pass
    entry = self.toc[name]
    with StreamDetour(self.reader, self.offset + entry.offset):
        data = self.reader.read(entry.size_of_compressed_data)
    if entry.is_compressed:
        def extracted(d=data): return zlib.decompress(d)
    else:
        extracted = data
    result = PiMeta(entry.type, name, extracted)
    self.files[name] = result
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.xtpyi"><code class="flex name class">
<span>class <span class="ident">xtpyi</span></span>
<span>(</span><span>*paths, list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False, path=b'path', date=b'date', decompile=False, user_code=False, unmarshal=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts and decompiles files from a Python Installer (aka PyInstaller) archive. This unit is a path extractor which extracts data from a hierarchical structure. Each extracted
item is emitted as a separate chunk and has attached to it a meta variable that contains its
path within the source structure. The positional arguments to the command are patterns that can
be used to filter the extracted items by their path. To view only the paths of all chunks, use
the listing switch:</p>
<pre><code>emit something | xtpyi --list
</code></pre>
<p>Otherwise, extracted items are written to the standard output port and usually require a frame
to properly process. In order to dump all extracted data to disk, the following pipeline can be
used:</p>
<pre><code>emit something | xtpyi [| dump {path} ]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L376-L434" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class xtpyi(ArchiveUnit, docs=&#39;{0}{s}{PathExtractorUnit}&#39;):
    &#34;&#34;&#34;
    Extracts and decompiles files from a Python Installer (aka PyInstaller) archive.
    &#34;&#34;&#34;
    def __init__(
        self, *paths, list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False,
        path=b&#39;path&#39;, date=b&#39;date&#39;,
        decompile: Param[bool, Arg.Switch(&#39;-c&#39;, help=&#39;Attempt to decompile PYC files.&#39;)] = False,
        user_code: Param[bool, Arg.Switch(&#39;-u&#39;, group=&#39;FILTER&#39;, help=(
            &#39;Extract only source code files from the root of the archive. These usually implement &#39;
            &#39;the actual domain logic. This implies the --decompile option.&#39;))] = False,
        unmarshal: Param[int, Arg(&#39;-y&#39;, action=&#39;count&#39;, group=&#39;FILTER&#39;, help=(
            &#39;(DANGEROUS) Unmarshal embedded PYZ archives. Warning: Maliciously crafted packages can &#39;
            &#39;potentially exploit this to execute code. It is advised to only use this option inside &#39;
            &#39;an isolated environment. Specify twice to decompile unmarshalled Python bytecode.&#39;
        ))] = 0
    ):
        super().__init__(
            *paths,
            list=list,
            join_path=join_path,
            drop_path=drop_path,
            fuzzy=fuzzy,
            exact=exact,
            regex=regex,
            path=path,
            date=date,
            decompile=decompile,
            unmarshal=unmarshal,
            user_code=user_code,
        )

    def unpack(self, data):
        view = memoryview(data)
        positions = [m.start() for m in re.finditer(re.escape(PyInstallerArchiveEpilogue.MagicSignature), view)]
        mode = Unmarshal(min(2, int(self.args.unmarshal)))
        self.log_debug(F&#39;unmarshal mode: {mode.name}&#39;)
        if not positions:
            raise LookupError(&#39;unable to find PyInstaller signature&#39;)
        if len(positions) &gt; 2:
            # first position is expected to be the sentinel value in the unpacker stub
            width = max(len(F&#39;{p:X}&#39;) for p in positions)
            for position in positions:
                self.log_info(F&#39;magic signature found at offset 0x{position:0{width}X}&#39;)
            self.log_warn(F&#39;found {len(positions) - 1} potential PyInstaller epilogue markers; using last one.&#39;)
        decompile = self.args.decompile
        uc_target = PiType.USERCODE if decompile else PiType.SOURCE
        archive = PyInstallerArchiveEpilogue(view, positions[-1], mode, decompile)
        for name, file in archive.files.items():
            if self.args.user_code:
                if file.type != uc_target:
                    continue
                if name.startswith(&#39;pyiboot&#39;):
                    continue
            yield self._pack(name, None, file.data, type=file.type.name)

    @classmethod
    def handles(cls, data: buf) -&gt; bool | None:
        return PyInstallerArchiveEpilogue.MagicSignature in data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.ArchiveUnit" href="index.html#refinery.units.formats.archive.ArchiveUnit">ArchiveUnit</a></li>
<li><a title="refinery.units.formats.PathExtractorUnit" href="../index.html#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></li>
<li><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></li>
<li><a title="refinery.units.Entry" href="../../index.html#refinery.units.Entry">Entry</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.archive.xtpyi.xtpyi" href="#refinery.units.formats.archive.xtpyi.xtpyi">xtpyi</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.xtpyi.required_dependencies"><code class="name">var <span class="ident">required_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.xtpyi.optional_dependencies"><code class="name">var <span class="ident">optional_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.xtpyi.console"><code class="name">var <span class="ident">console</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.archive.xtpyi.xtpyi.reverse"><code class="name">var <span class="ident">reverse</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.archive.xtpyi.xtpyi.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/archive/xtpyi.py#L408-L430" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpack(self, data):
    view = memoryview(data)
    positions = [m.start() for m in re.finditer(re.escape(PyInstallerArchiveEpilogue.MagicSignature), view)]
    mode = Unmarshal(min(2, int(self.args.unmarshal)))
    self.log_debug(F&#39;unmarshal mode: {mode.name}&#39;)
    if not positions:
        raise LookupError(&#39;unable to find PyInstaller signature&#39;)
    if len(positions) &gt; 2:
        # first position is expected to be the sentinel value in the unpacker stub
        width = max(len(F&#39;{p:X}&#39;) for p in positions)
        for position in positions:
            self.log_info(F&#39;magic signature found at offset 0x{position:0{width}X}&#39;)
        self.log_warn(F&#39;found {len(positions) - 1} potential PyInstaller epilogue markers; using last one.&#39;)
    decompile = self.args.decompile
    uc_target = PiType.USERCODE if decompile else PiType.SOURCE
    archive = PyInstallerArchiveEpilogue(view, positions[-1], mode, decompile)
    for name, file in archive.files.items():
        if self.args.user_code:
            if file.type != uc_target:
                continue
            if name.startswith(&#39;pyiboot&#39;):
                continue
        yield self._pack(name, None, file.data, type=file.type.name)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.formats.archive.ArchiveUnit" href="index.html#refinery.units.formats.archive.ArchiveUnit">ArchiveUnit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.CustomPathSeparator" href="../index.html#refinery.units.formats.PathExtractorUnit.CustomPathSeparator">CustomPathSeparator</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.Requires" href="../../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.assemble" href="../../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.filter" href="../../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.finish" href="../../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.handles" href="../../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.is_quiet" href="../../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.labelled" href="../../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.leniency" href="../../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_always" href="../../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_debug" href="../../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_detach" href="../../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_fail" href="../../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_info" href="../../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_level" href="../../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.log_warn" href="../../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.nozzle" href="../../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.process" href="../../index.html#refinery.units.UnitBase.process">process</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.read" href="../../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.read1" href="../../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.run" href="../../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.source" href="../../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.formats.archive.ArchiveUnit.superinit" href="../../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.formats.archive" href="index.html">refinery.units.formats.archive</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtpyi.decompress_peek" href="#refinery.units.formats.archive.xtpyi.decompress_peek">decompress_peek</a></code></li>
<li><code><a title="refinery.units.formats.archive.xtpyi.make_decompiled_item" href="#refinery.units.formats.archive.xtpyi.make_decompiled_item">make_decompiled_item</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.Unmarshal" href="#refinery.units.formats.archive.xtpyi.Unmarshal">Unmarshal</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.PiType" href="#refinery.units.formats.archive.xtpyi.PiType">PiType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.PzType" href="#refinery.units.formats.archive.xtpyi.PzType">PzType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.PiMeta" href="#refinery.units.formats.archive.xtpyi.PiMeta">PiMeta</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtpyi.PiMeta.unpack" href="#refinery.units.formats.archive.xtpyi.PiMeta.unpack">unpack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.PYZ" href="#refinery.units.formats.archive.xtpyi.PYZ">PYZ</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtpyi.PYZ.unpack" href="#refinery.units.formats.archive.xtpyi.PYZ.unpack">unpack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.PiTOCEntry" href="#refinery.units.formats.archive.xtpyi.PiTOCEntry">PiTOCEntry</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue" href="#refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue">PyInstallerArchiveEpilogue</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue.extract" href="#refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue.extract">extract</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.archive.xtpyi.xtpyi" href="#refinery.units.formats.archive.xtpyi.xtpyi">xtpyi</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.archive.xtpyi.xtpyi.unpack" href="#refinery.units.formats.archive.xtpyi.xtpyi.unpack">unpack</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
