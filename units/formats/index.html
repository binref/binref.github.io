<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.units.formats documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.formats</code></h1>
</header>
<section id="section-intro">
<p>A package containing several sub-packages for various data formats.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/__init__.py#L1-L443" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
A package containing several sub-packages for various data formats.
&#34;&#34;&#34;
from __future__ import annotations

import abc
import collections
import fnmatch
import re

from collections import Counter
from zlib import adler32

from refinery.lib.json import BytesAsArrayEncoder, BytesAsStringEncoder
from refinery.lib.loader import load
from refinery.lib.meta import ByteStringWrapper, LazyMetaOracle, metavars
from refinery.lib.tools import exception_to_string
from refinery.lib.types import Callable, Iterable, Param, buf
from refinery.lib.xml import XMLNodeBase
from refinery.units import Arg, Chunk, RefineryPartialResult, RefineryPotentialUserError, Unit


def pathspec(expression):
    &#34;&#34;&#34;
    Normalizes a path which is separated by backward or forward slashes to be
    separated by forward slashes.
    &#34;&#34;&#34;
    return &#39;/&#39;.join(re.split(R&#39;[\\\/]&#39;, expression))


class UnpackResult:

    def get_data(self) -&gt; buf:
        if callable(self.data):
            self.data = self.data()
        return self.data

    def __init__(self, _br__path: str, _br__data: buf | Callable[[], buf], **_br__meta):
        self.path = _br__path
        self.data = _br__data
        self.meta = _br__meta
        for key in [key for key, value in _br__meta.items() if value is None]:
            del _br__meta[key]


class EndOfStringNotFound(ValueError):
    def __init__(self):
        super().__init__(&#39;end of string could not be determined&#39;)


class PathPattern:
    def __init__(self, query: str | re.Pattern, regex=False, fuzzy=0):
        self.query = query
        self.regex = regex
        self.fuzzy = fuzzy
        self.compile()

    def compile(self, **kw):
        query = self.query
        if isinstance(query, re.Pattern):
            self.stops = []
            self.pattern = query
            return
        elif not self.regex:
            self.stops = re.split(R&#39;([/*?]+)&#39;, query)
            query, _, _ = fnmatch.translate(query).partition(r&#39;\Z&#39;)
        p1 = re.compile(query, **kw)
        p2 = re.compile(F&#39;.*?{query}&#39;)
        self.matchers = [p1.fullmatch, p2.fullmatch, p1.search]

    def reach(self, path):
        if not any(self.stops):
            return True
        for stop in self.stops[0::2]:
            if fnmatch.fnmatch(path, F&#39;*{stop}&#39;):
                return True
        return False

    def check(self, path, fuzzy=0):
        fuzzy = min(max(fuzzy, self.fuzzy), 2)
        return self.matchers[fuzzy](path)

    def __repr__(self):
        return F&#39;&lt;PathPattern:{&#34;&#34;.join(self.stops) or &#34;RE&#34;}&gt;&#39;


class PathExtractorUnit(Unit, abstract=True):
    &#34;&#34;&#34;
    This unit is a path extractor which extracts data from a hierarchical structure. Each extracted
    item is emitted as a separate chunk and has attached to it a meta variable that contains its
    path within the source structure. The positional arguments to the command are patterns that can
    be used to filter the extracted items by their path. To view only the paths of all chunks, use
    the listing switch:

        emit something | &lt;this&gt; --list

    Otherwise, extracted items are written to the standard output port and usually require a frame
    to properly process. In order to dump all extracted data to disk, the following pipeline can be
    used:

        emit something | &lt;this&gt; [| dump {path} ]
    &#34;&#34;&#34;

    CustomPathSeparator = None
    &#34;&#34;&#34;
    This class variable can be overwritten by child classes to change the path separator from the
    default forward slash to something else.
    &#34;&#34;&#34;

    def __init__(
        self,
        *paths: Param[str, Arg.FsPath(metavar=&#39;path&#39;, nargs=&#39;*&#39;, help=(
            &#39;Wildcard pattern for the path of the item to be extracted. Each item is returned &#39;
            &#39;as a separate output of this unit. Paths may contain wildcards; The default &#39;
            &#39;argument is a single wildcard, which means that every item will be extracted. If &#39;
            &#39;a given path yields no results, the unit performs increasingly fuzzy searches &#39;
            &#39;with it. This can be disabled using the --exact switch.&#39;))],
        list: Param[bool, Arg.Switch(&#39;-l&#39;,
            help=&#39;Return all matching paths as UTF8-encoded output chunks.&#39;)] = False,
        join_path: Param[bool, Arg.Switch(&#39;-j&#39;, group=&#39;PATH&#39;, help=(
            &#39;Join path names with the previously existing one.&#39;))] = False,
        drop_path: Param[bool, Arg.Switch(&#39;-d&#39;, group=&#39;PATH&#39;,
            help=&#39;Do not modify the path variable for output chunks.&#39;)] = False,
        fuzzy: Param[int, Arg.Counts(&#39;-z&#39;, group=&#39;MATCH&#39;, help=(
            &#39;Specify once to add a leading wildcard to each patterns, twice to also add a &#39;
            &#39;trailing wildcard.&#39;))] = 0,
        exact: Param[bool, Arg.Switch(&#39;-e&#39;, group=&#39;MATCH&#39;,
            help=&#39;Path patterns never match on substrings.&#39;)] = False,
        regex: Param[bool, Arg.Switch(&#39;-r&#39;,
            help=&#39;Use regular expressions instead of wildcard patterns.&#39;)] = False,
        path: Param[buf, Arg(&#39;-P&#39;, metavar=&#39;NAME&#39;, help=(
            &#39;Name of the meta variable to receive the extracted path. The default value is &#39;
            &#39;&#34;{default}&#34;.&#39;))] = b&#39;path&#39;,
        **keywords
    ):
        super().__init__(
            paths=paths,
            list=list,
            join=join_path,
            drop=drop_path,
            path=path,
            fuzzy=fuzzy,
            exact=exact,
            regex=regex,
            **keywords
        )

    def _get_path_separator(self) -&gt; str:
        return self.CustomPathSeparator or &#39;/&#39;

    @property
    def _patterns(self):
        paths = self.args.paths
        if not paths:
            if self.args.regex:
                paths = [&#39;.*&#39;]
            else:
                paths = [&#39;*&#39;]
        else:
            def check_pattern(t: str) -&gt; str:
                try:
                    if len(t) &gt;= 0x1000:
                        raise OverflowError
                except Exception as E:
                    raise RefineryPotentialUserError(
                        F&#39;Invalid path pattern of length {len(t)}.&#39;) from E
                else:
                    return t
            paths = [check_pattern(p) for p in paths]
        for path in paths:
            self.log_debug(&#39;path:&#39;, path)
        return [
            PathPattern(
                path,
                self.args.regex,
                self.args.fuzzy,
            ) for path in paths
        ]

    @abc.abstractmethod
    def unpack(self, data: Chunk) -&gt; Iterable[UnpackResult]:
        raise NotImplementedError

    def process(self, data: Chunk) -&gt; buf:
        meta = metavars(data)
        results: list[UnpackResult] = list(self.unpack(data))

        patterns = self._patterns

        metavar = self.args.path.decode(self.codec)
        occurrences = collections.defaultdict(int)
        checksums = collections.defaultdict(set)
        root = &#39;&#39;
        uuid = 0

        def get_data(result: UnpackResult):
            try:
                data = result.get_data()
            except RefineryPartialResult as error:
                if not self.args.lenient:
                    raise
                result.data = data = error.partial
            return data

        def _uuid():
            nonlocal uuid
            crc = meta[&#39;crc32&#39;].decode(&#39;ascii&#39;).upper()
            uid = uuid
            uuid += 1
            return F&#39;_{crc}.{uid:04X}&#39;

        def normalize(_path: str) -&gt; str:
            pathsep = self.CustomPathSeparator
            pattern = &#39;[\\\\/]&#39;
            if pathsep is None:
                pathsep = &#39;/&#39;
            else:
                pattern = re.escape(pathsep)
            parts = re.split(pattern, F&#39;{root}{pathsep}{_path}&#39;)
            while True:
                for k, part in enumerate(parts):
                    if not part.strip(&#39;.&#39;):
                        break
                else:
                    break
                size = len(part)
                j = max(k - size, 0)
                del parts[j:k + 1]
            path = pathsep.join(parts)
            return path

        if self.args.join:
            try:
                root = str(ByteStringWrapper(meta[metavar], self.codec))
            except KeyError:
                pass

        for result in results:
            path = normalize(result.path)
            if not path:
                from refinery.lib.mime import FileMagicInfo
                path = _uuid()
                ext = FileMagicInfo(get_data(result)).extension
                if ext != &#39;bin&#39;:
                    path = F&#39;{path}.{ext}&#39;
                self.log_warn(F&#39;read chunk with empty path; using generated name {path}&#39;)
            result.path = path
            occurrences[path] += 1

        for result in results:
            path = result.path
            if occurrences[path] &gt; 1:
                checksum = adler32(get_data(result))
                if checksum in checksums[path]:
                    continue
                checksums[path].add(checksum)
                counter = len(checksums[path])
                slash = self._get_path_separator()
                if any(F&#39;{result.path}{slash}{c}&#39; in occurrences for c in range(occurrences[path])):
                    counter = _uuid()
                result.path = F&#39;{result.path}{slash}{counter}&#39;
                self.log_info(F&#39;read chunk with duplicate path; deduplicating to {result.path}&#39;)

        if len({r.path.lower() for r in results}) == len(results):
            for p in patterns:
                p.compile(flags=re.IGNORECASE)

        for p in patterns:
            for fuzzy in range(3):
                done = self.args.exact
                for result in results:
                    path = result.path
                    if not p.check(path, fuzzy):
                        continue
                    done = True
                    if self.args.list:
                        yield self.labelled(path.encode(self.codec), **result.meta)
                        continue
                    if not self.args.drop:
                        result.meta[metavar] = path
                    try:
                        chunk = get_data(result)
                    except Exception as error:
                        if self.log_debug():
                            raise
                        self.log_warn(F&#39;extraction failure for {path}: {exception_to_string(error)}&#39;)
                    else:
                        self.log_debug(F&#39;extraction success for {path}&#39;)
                        yield self.labelled(chunk, **result.meta)
                if done or self.args.fuzzy:
                    break


class XMLToPathExtractorUnit(PathExtractorUnit, abstract=True):
    def __init__(
        self, *paths,
        format: Param[str | None, Arg.String(&#39;-f&#39;, metavar=&#39;F&#39;, help=(
            &#39;A format expression to be applied for computing the path of an item. This must use &#39;
            &#39;metadata that is available on the item. The current tag can be accessed as {{tag}}. &#39;
            &#39;If no format is specified, the unit attempts to derive a good attribute from the XML &#39;
            &#39;tree to use for generating paths.&#39;
        ))] = None,
        list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False,
        path=b&#39;path&#39;, **keywords
    ):
        super().__init__(
            *paths,
            format=format,
            list=list,
            path=path,
            join_path=join_path,
            drop_path=drop_path,
            fuzzy=fuzzy,
            exact=exact,
            regex=regex,
            **keywords
        )

    @staticmethod
    def _normalize_val(attr: str):
        _bad = &#39;[/\\$&amp;%#:.]&#39;
        attr = attr.replace(&#39;[&#39;, &#39;(&#39;)
        attr = attr.replace(&#39;]&#39;, &#39;)&#39;)
        attr = re.sub(F&#39;\\s*{_bad}+\\s+&#39;, &#39; &#39;, attr)
        attr = re.sub(F&#39;\\s*{_bad}+\\s*&#39;, &#39;.&#39;, attr)
        return attr.strip()

    @staticmethod
    def _normalize_key(attribute: str):
        _, _, a = attribute.rpartition(&#39;:&#39;)
        return a

    def _make_path_builder(
        self,
        meta: LazyMetaOracle,
        root: XMLNodeBase
    ) -&gt; Callable[[XMLNodeBase], str]:

        nfmt = self.args.format
        nkey = self._normalize_key
        nval = self._normalize_val
        nmap = {}

        if nfmt is None:
            def rank_attribute(attribute: str):
                length = len(attribute)
                scount = length - len(re.sub(r&#39;\s+&#39;, &#39;&#39;, attribute))
                return (1 / length, scount)

            def walk(node: XMLNodeBase):
                children = node.children
                __tags = set()
                for child in children:
                    if (tag := child.tag) not in __tags:
                        __tags.add(tag)
                        continue
                    candidates = [
                        candidate for candidate, count in Counter(
                            key for child in children for key, val in child.attributes.items()
                            if len(val) in range(2, 65) and re.fullmatch(R&#39;[-\s\w+,.;@()]+&#39;, nval(val))
                        ).items()
                        if count == len(children) == len(
                            {child.attributes[candidate] for child in children})
                    ]
                    break
                else:
                    candidates = None
                if not candidates:
                    attr = None
                else:
                    candidates.sort(key=rank_attribute)
                    attr = candidates[0]
                for child in children:
                    nmap[child.path] = attr
                    walk(child)

            walk(root)

        def path_builder(node: XMLNodeBase) -&gt; str:
            if node.tag is None:
                raise ValueError(F&#39;Attempt to format node without a tag: {node!r}&#39;)
            attrs = node.attributes
            if nfmt and meta is not None:
                try:
                    symbols = {nkey(key): nval(val) for key, val in attrs.items()}
                    return meta.format_str(nfmt, self.codec, node.tag, symbols)
                except KeyError:
                    pass
            try:
                return nval(attrs[nmap[node.path]])
            except KeyError:
                index = node.index
                name = nval(node.tag)
                if index is not None:
                    name = F&#39;{index}.{name}&#39;
                return name

        return path_builder


class JSONEncoderUnit(Unit, abstract=True):
    &#34;&#34;&#34;
    An abstract unit that provides the interface for displaying parsed data as JSON. By default,
    binary data is converted to latin1 strings.
    &#34;&#34;&#34;

    EncoderBase = BytesAsStringEncoder

    def __init__(
        self,
        encode: Param[str | None, Arg.String(&#39;-e&#39;, group=&#39;BIN&#39;, metavar=&#39;U&#39;, help=(
            &#39;Select an encoder unit used to represent binary data in the JSON output. This unit &#39;
            &#39;must be reversible and produce UTF8 encoded string output when operated in reverse.&#39;
            &#39; Common examples are hex and b64.&#39;))] = None,
        digest: Param[str | None, Arg.String(&#39;-d&#39;, group=&#39;BIN&#39;, metavar=&#39;U&#39;, help=(
            &#39;Select a hashing unit to digest all byte strings: Instead of the data, only the hash &#39;
            &#39;will be displayed.&#39;))] = None,
        arrays: Param[bool, Arg.Switch(&#39;-a&#39;, group=&#39;BIN&#39;, help=(
            &#39;Encode all byte strings as integer arrays. These arrays will have unsigned integer &#39;
            &#39;entires between 0 and 255.&#39;))] = False,
        **keywords
    ):
        if sum(1 for x in (encode, digest, arrays) if x) &gt; 1:
            raise ValueError(&#39;Can only set one option for byte string encoding.&#39;)
        super().__init__(encode=encode, digest=digest, arrays=arrays, **keywords)

    def to_json(self, obj) -&gt; bytes:
        def UnitEncoderFactory(unit: Unit):
            class Encoder(self.EncoderBase):
                def encode_bytes(self, obj):
                    return obj | unit | str
            return Encoder
        if self.args.arrays:
            encoder = BytesAsArrayEncoder
        elif u := self.args.encode:
            encoder = UnitEncoderFactory(load(u, reverse=True))
        elif u := self.args.digest:
            encoder = UnitEncoderFactory(load(u, text=True))
        else:
            encoder = self.EncoderBase

        with encoder as enc:
            return enc.dumps(obj).encode(self.codec)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="refinery.units.formats.a3x" href="a3x.html">refinery.units.formats.a3x</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.archive" href="archive/index.html">refinery.units.formats.archive</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.bat" href="bat.html">refinery.units.formats.bat</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.csv" href="csv.html">refinery.units.formats.csv</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.deserialize_php" href="deserialize_php.html">refinery.units.formats.deserialize_php</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.dexstr" href="dexstr.html">refinery.units.formats.dexstr</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.email" href="email.html">refinery.units.formats.email</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.evtx" href="evtx.html">refinery.units.formats.evtx</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.exe" href="exe/index.html">refinery.units.formats.exe</a></code></dt>
<dd>
<section class="desc"><p>A package with units for generic executables. Usually, PE, ELF, and MachO formats are covered.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.hexload" href="hexload.html">refinery.units.formats.hexload</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.html" href="html.html">refinery.units.formats.html</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.httprequest" href="httprequest.html">refinery.units.formats.httprequest</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.httpresponse" href="httpresponse.html">refinery.units.formats.httpresponse</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.ifps" href="ifps.html">refinery.units.formats.ifps</a></code></dt>
<dd>
<section class="desc"><p>The code is based on the logic implemented in IFPSTools:
<a href="https://github.com/Wack0/IFPSTools">https://github.com/Wack0/IFPSTools</a></p></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.ifpsstr" href="ifpsstr.html">refinery.units.formats.ifpsstr</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.imgdb" href="imgdb.html">refinery.units.formats.imgdb</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.imgto" href="imgto.html">refinery.units.formats.imgto</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.imgtp" href="imgtp.html">refinery.units.formats.imgtp</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.java" href="java/index.html">refinery.units.formats.java</a></code></dt>
<dd>
<section class="desc"><p>Units that process Java related binary formats such as class files and serialized Java objects.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.json" href="json.html">refinery.units.formats.json</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.lnk" href="lnk.html">refinery.units.formats.lnk</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.macho" href="macho/index.html">refinery.units.formats.macho</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.msgpack" href="msgpack.html">refinery.units.formats.msgpack</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.msi" href="msi.html">refinery.units.formats.msi</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.office" href="office/index.html">refinery.units.formats.office</a></code></dt>
<dd>
<section class="desc"><p>These units process data formats related to Microsoft Office.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pbuf" href="pbuf.html">refinery.units.formats.pbuf</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pcap" href="pcap.html">refinery.units.formats.pcap</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pcap_http" href="pcap_http.html">refinery.units.formats.pcap_http</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pdf" href="pdf.html">refinery.units.formats.pdf</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pdfcrypt" href="pdfcrypt.html">refinery.units.formats.pdfcrypt</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pe" href="pe/index.html">refinery.units.formats.pe</a></code></dt>
<dd>
<section class="desc"><p>A package containing Portable Executable (PE) file related units.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pkcs7" href="pkcs7.html">refinery.units.formats.pkcs7</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pkcs7sig" href="pkcs7sig.html">refinery.units.formats.pkcs7sig</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pyc" href="pyc.html">refinery.units.formats.pyc</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pym" href="pym.html">refinery.units.formats.pym</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pymstr" href="pymstr.html">refinery.units.formats.pymstr</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.qr" href="qr.html">refinery.units.formats.qr</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.sqlite" href="sqlite.html">refinery.units.formats.sqlite</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.stego" href="stego.html">refinery.units.formats.stego</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.winreg" href="winreg.html">refinery.units.formats.winreg</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.xml" href="xml.html">refinery.units.formats.xml</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.units.formats.pathspec"><code class="name flex">
<span>def <span class="ident">pathspec</span></span>(<span>expression)</span>
</code></dt>
<dd>
<section class="desc"><p>Normalizes a path which is separated by backward or forward slashes to be
separated by forward slashes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/__init__.py#L23-L28" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pathspec(expression):
    &#34;&#34;&#34;
    Normalizes a path which is separated by backward or forward slashes to be
    separated by forward slashes.
    &#34;&#34;&#34;
    return &#39;/&#39;.join(re.split(R&#39;[\\\/]&#39;, expression))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.formats.UnpackResult"><code class="flex name class">
<span>class <span class="ident">UnpackResult</span></span>
<span>(</span><span>_br__path, _br__data, **_br__meta)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/__init__.py#L31-L43" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class UnpackResult:

    def get_data(self) -&gt; buf:
        if callable(self.data):
            self.data = self.data()
        return self.data

    def __init__(self, _br__path: str, _br__data: buf | Callable[[], buf], **_br__meta):
        self.path = _br__path
        self.data = _br__data
        self.meta = _br__meta
        for key in [key for key, value in _br__meta.items() if value is None]:
            del _br__meta[key]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.UnpackResult.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/__init__.py#L33-L36" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_data(self) -&gt; buf:
    if callable(self.data):
        self.data = self.data()
    return self.data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.EndOfStringNotFound"><code class="flex name class">
<span>class <span class="ident">EndOfStringNotFound</span></span>
</code></dt>
<dd>
<section class="desc"><p>Inappropriate argument value (of correct type).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/__init__.py#L46-L48" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class EndOfStringNotFound(ValueError):
    def __init__(self):
        super().__init__(&#39;end of string could not be determined&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.units.formats.PathPattern"><code class="flex name class">
<span>class <span class="ident">PathPattern</span></span>
<span>(</span><span>query, regex=False, fuzzy=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/__init__.py#L51-L84" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PathPattern:
    def __init__(self, query: str | re.Pattern, regex=False, fuzzy=0):
        self.query = query
        self.regex = regex
        self.fuzzy = fuzzy
        self.compile()

    def compile(self, **kw):
        query = self.query
        if isinstance(query, re.Pattern):
            self.stops = []
            self.pattern = query
            return
        elif not self.regex:
            self.stops = re.split(R&#39;([/*?]+)&#39;, query)
            query, _, _ = fnmatch.translate(query).partition(r&#39;\Z&#39;)
        p1 = re.compile(query, **kw)
        p2 = re.compile(F&#39;.*?{query}&#39;)
        self.matchers = [p1.fullmatch, p2.fullmatch, p1.search]

    def reach(self, path):
        if not any(self.stops):
            return True
        for stop in self.stops[0::2]:
            if fnmatch.fnmatch(path, F&#39;*{stop}&#39;):
                return True
        return False

    def check(self, path, fuzzy=0):
        fuzzy = min(max(fuzzy, self.fuzzy), 2)
        return self.matchers[fuzzy](path)

    def __repr__(self):
        return F&#39;&lt;PathPattern:{&#34;&#34;.join(self.stops) or &#34;RE&#34;}&gt;&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.PathPattern.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self, **kw)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/__init__.py#L58-L69" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def compile(self, **kw):
    query = self.query
    if isinstance(query, re.Pattern):
        self.stops = []
        self.pattern = query
        return
    elif not self.regex:
        self.stops = re.split(R&#39;([/*?]+)&#39;, query)
        query, _, _ = fnmatch.translate(query).partition(r&#39;\Z&#39;)
    p1 = re.compile(query, **kw)
    p2 = re.compile(F&#39;.*?{query}&#39;)
    self.matchers = [p1.fullmatch, p2.fullmatch, p1.search]</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.PathPattern.reach"><code class="name flex">
<span>def <span class="ident">reach</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/__init__.py#L71-L77" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reach(self, path):
    if not any(self.stops):
        return True
    for stop in self.stops[0::2]:
        if fnmatch.fnmatch(path, F&#39;*{stop}&#39;):
            return True
    return False</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.PathPattern.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, path, fuzzy=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/__init__.py#L79-L81" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check(self, path, fuzzy=0):
    fuzzy = min(max(fuzzy, self.fuzzy), 2)
    return self.matchers[fuzzy](path)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.PathExtractorUnit"><code class="flex name class">
<span>class <span class="ident">PathExtractorUnit</span></span>
<span>(</span><span>*paths, list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False, path=b'path', **keywords)</span>
</code></dt>
<dd>
<section class="desc"><p>This unit is a path extractor which extracts data from a hierarchical structure. Each extracted
item is emitted as a separate chunk and has attached to it a meta variable that contains its
path within the source structure. The positional arguments to the command are patterns that can
be used to filter the extracted items by their path. To view only the paths of all chunks, use
the listing switch:</p>
<pre><code>emit something | &lt;this&gt; --list
</code></pre>
<p>Otherwise, extracted items are written to the standard output port and usually require a frame
to properly process. In order to dump all extracted data to disk, the following pipeline can be
used:</p>
<pre><code>emit something | &lt;this&gt; [| dump {path} ]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/__init__.py#L87-L291" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PathExtractorUnit(Unit, abstract=True):
    &#34;&#34;&#34;
    This unit is a path extractor which extracts data from a hierarchical structure. Each extracted
    item is emitted as a separate chunk and has attached to it a meta variable that contains its
    path within the source structure. The positional arguments to the command are patterns that can
    be used to filter the extracted items by their path. To view only the paths of all chunks, use
    the listing switch:

        emit something | &lt;this&gt; --list

    Otherwise, extracted items are written to the standard output port and usually require a frame
    to properly process. In order to dump all extracted data to disk, the following pipeline can be
    used:

        emit something | &lt;this&gt; [| dump {path} ]
    &#34;&#34;&#34;

    CustomPathSeparator = None
    &#34;&#34;&#34;
    This class variable can be overwritten by child classes to change the path separator from the
    default forward slash to something else.
    &#34;&#34;&#34;

    def __init__(
        self,
        *paths: Param[str, Arg.FsPath(metavar=&#39;path&#39;, nargs=&#39;*&#39;, help=(
            &#39;Wildcard pattern for the path of the item to be extracted. Each item is returned &#39;
            &#39;as a separate output of this unit. Paths may contain wildcards; The default &#39;
            &#39;argument is a single wildcard, which means that every item will be extracted. If &#39;
            &#39;a given path yields no results, the unit performs increasingly fuzzy searches &#39;
            &#39;with it. This can be disabled using the --exact switch.&#39;))],
        list: Param[bool, Arg.Switch(&#39;-l&#39;,
            help=&#39;Return all matching paths as UTF8-encoded output chunks.&#39;)] = False,
        join_path: Param[bool, Arg.Switch(&#39;-j&#39;, group=&#39;PATH&#39;, help=(
            &#39;Join path names with the previously existing one.&#39;))] = False,
        drop_path: Param[bool, Arg.Switch(&#39;-d&#39;, group=&#39;PATH&#39;,
            help=&#39;Do not modify the path variable for output chunks.&#39;)] = False,
        fuzzy: Param[int, Arg.Counts(&#39;-z&#39;, group=&#39;MATCH&#39;, help=(
            &#39;Specify once to add a leading wildcard to each patterns, twice to also add a &#39;
            &#39;trailing wildcard.&#39;))] = 0,
        exact: Param[bool, Arg.Switch(&#39;-e&#39;, group=&#39;MATCH&#39;,
            help=&#39;Path patterns never match on substrings.&#39;)] = False,
        regex: Param[bool, Arg.Switch(&#39;-r&#39;,
            help=&#39;Use regular expressions instead of wildcard patterns.&#39;)] = False,
        path: Param[buf, Arg(&#39;-P&#39;, metavar=&#39;NAME&#39;, help=(
            &#39;Name of the meta variable to receive the extracted path. The default value is &#39;
            &#39;&#34;{default}&#34;.&#39;))] = b&#39;path&#39;,
        **keywords
    ):
        super().__init__(
            paths=paths,
            list=list,
            join=join_path,
            drop=drop_path,
            path=path,
            fuzzy=fuzzy,
            exact=exact,
            regex=regex,
            **keywords
        )

    def _get_path_separator(self) -&gt; str:
        return self.CustomPathSeparator or &#39;/&#39;

    @property
    def _patterns(self):
        paths = self.args.paths
        if not paths:
            if self.args.regex:
                paths = [&#39;.*&#39;]
            else:
                paths = [&#39;*&#39;]
        else:
            def check_pattern(t: str) -&gt; str:
                try:
                    if len(t) &gt;= 0x1000:
                        raise OverflowError
                except Exception as E:
                    raise RefineryPotentialUserError(
                        F&#39;Invalid path pattern of length {len(t)}.&#39;) from E
                else:
                    return t
            paths = [check_pattern(p) for p in paths]
        for path in paths:
            self.log_debug(&#39;path:&#39;, path)
        return [
            PathPattern(
                path,
                self.args.regex,
                self.args.fuzzy,
            ) for path in paths
        ]

    @abc.abstractmethod
    def unpack(self, data: Chunk) -&gt; Iterable[UnpackResult]:
        raise NotImplementedError

    def process(self, data: Chunk) -&gt; buf:
        meta = metavars(data)
        results: list[UnpackResult] = list(self.unpack(data))

        patterns = self._patterns

        metavar = self.args.path.decode(self.codec)
        occurrences = collections.defaultdict(int)
        checksums = collections.defaultdict(set)
        root = &#39;&#39;
        uuid = 0

        def get_data(result: UnpackResult):
            try:
                data = result.get_data()
            except RefineryPartialResult as error:
                if not self.args.lenient:
                    raise
                result.data = data = error.partial
            return data

        def _uuid():
            nonlocal uuid
            crc = meta[&#39;crc32&#39;].decode(&#39;ascii&#39;).upper()
            uid = uuid
            uuid += 1
            return F&#39;_{crc}.{uid:04X}&#39;

        def normalize(_path: str) -&gt; str:
            pathsep = self.CustomPathSeparator
            pattern = &#39;[\\\\/]&#39;
            if pathsep is None:
                pathsep = &#39;/&#39;
            else:
                pattern = re.escape(pathsep)
            parts = re.split(pattern, F&#39;{root}{pathsep}{_path}&#39;)
            while True:
                for k, part in enumerate(parts):
                    if not part.strip(&#39;.&#39;):
                        break
                else:
                    break
                size = len(part)
                j = max(k - size, 0)
                del parts[j:k + 1]
            path = pathsep.join(parts)
            return path

        if self.args.join:
            try:
                root = str(ByteStringWrapper(meta[metavar], self.codec))
            except KeyError:
                pass

        for result in results:
            path = normalize(result.path)
            if not path:
                from refinery.lib.mime import FileMagicInfo
                path = _uuid()
                ext = FileMagicInfo(get_data(result)).extension
                if ext != &#39;bin&#39;:
                    path = F&#39;{path}.{ext}&#39;
                self.log_warn(F&#39;read chunk with empty path; using generated name {path}&#39;)
            result.path = path
            occurrences[path] += 1

        for result in results:
            path = result.path
            if occurrences[path] &gt; 1:
                checksum = adler32(get_data(result))
                if checksum in checksums[path]:
                    continue
                checksums[path].add(checksum)
                counter = len(checksums[path])
                slash = self._get_path_separator()
                if any(F&#39;{result.path}{slash}{c}&#39; in occurrences for c in range(occurrences[path])):
                    counter = _uuid()
                result.path = F&#39;{result.path}{slash}{counter}&#39;
                self.log_info(F&#39;read chunk with duplicate path; deduplicating to {result.path}&#39;)

        if len({r.path.lower() for r in results}) == len(results):
            for p in patterns:
                p.compile(flags=re.IGNORECASE)

        for p in patterns:
            for fuzzy in range(3):
                done = self.args.exact
                for result in results:
                    path = result.path
                    if not p.check(path, fuzzy):
                        continue
                    done = True
                    if self.args.list:
                        yield self.labelled(path.encode(self.codec), **result.meta)
                        continue
                    if not self.args.drop:
                        result.meta[metavar] = path
                    try:
                        chunk = get_data(result)
                    except Exception as error:
                        if self.log_debug():
                            raise
                        self.log_warn(F&#39;extraction failure for {path}: {exception_to_string(error)}&#39;)
                    else:
                        self.log_debug(F&#39;extraction success for {path}&#39;)
                        yield self.labelled(chunk, **result.meta)
                if done or self.args.fuzzy:
                    break</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.XMLToPathExtractorUnit" href="#refinery.units.formats.XMLToPathExtractorUnit">XMLToPathExtractorUnit</a></li>
<li><a title="refinery.units.formats.a3x.a3x" href="a3x.html#refinery.units.formats.a3x.a3x">a3x</a></li>
<li><a title="refinery.units.formats.archive.ArchiveUnit" href="archive/index.html#refinery.units.formats.archive.ArchiveUnit">ArchiveUnit</a></li>
<li><a title="refinery.units.formats.archive.xtchm.xtchm" href="archive/xtchm.html#refinery.units.formats.archive.xtchm.xtchm">xtchm</a></li>
<li><a title="refinery.units.formats.archive.xtnuitka.xtnuitka" href="archive/xtnuitka.html#refinery.units.formats.archive.xtnuitka.xtnuitka">xtnuitka</a></li>
<li><a title="refinery.units.formats.archive.xtsql.xtsql" href="archive/xtsql.html#refinery.units.formats.archive.xtsql.xtsql">xtsql</a></li>
<li><a title="refinery.units.formats.email.xtmail" href="email.html#refinery.units.formats.email.xtmail">xtmail</a></li>
<li><a title="refinery.units.formats.exe.vsect.vsect" href="exe/vsect.html#refinery.units.formats.exe.vsect.vsect">vsect</a></li>
<li><a title="refinery.units.formats.java.jvdasm.jvdasm" href="java/jvdasm.html#refinery.units.formats.java.jvdasm.jvdasm">jvdasm</a></li>
<li><a title="refinery.units.formats.json.xtjson" href="json.html#refinery.units.formats.json.xtjson">xtjson</a></li>
<li><a title="refinery.units.formats.office.docmeta.docmeta" href="office/docmeta.html#refinery.units.formats.office.docmeta.docmeta">docmeta</a></li>
<li><a title="refinery.units.formats.office.vbastr.vbastr" href="office/vbastr.html#refinery.units.formats.office.vbastr.vbastr">vbastr</a></li>
<li><a title="refinery.units.formats.office.xtdoc.xtdoc" href="office/xtdoc.html#refinery.units.formats.office.xtdoc.xtdoc">xtdoc</a></li>
<li><a title="refinery.units.formats.office.xtone.xtone" href="office/xtone.html#refinery.units.formats.office.xtone.xtone">xtone</a></li>
<li><a title="refinery.units.formats.office.xtrtf.xtrtf" href="office/xtrtf.html#refinery.units.formats.office.xtrtf.xtrtf">xtrtf</a></li>
<li><a title="refinery.units.formats.office.xtvba.xtvba" href="office/xtvba.html#refinery.units.formats.office.xtvba.xtvba">xtvba</a></li>
<li><a title="refinery.units.formats.office.xtxs.xtxs" href="office/xtxs.html#refinery.units.formats.office.xtxs.xtxs">xtxs</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnfields.dnfields" href="pe/dotnet/dnfields.html#refinery.units.formats.pe.dotnet.dnfields.dnfields">dnfields</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnmr.dnmr" href="pe/dotnet/dnmr.html#refinery.units.formats.pe.dotnet.dnmr.dnmr">dnmr</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnrc.dnrc" href="pe/dotnet/dnrc.html#refinery.units.formats.pe.dotnet.dnrc.dnrc">dnrc</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnsfx.dnsfx" href="pe/dotnet/dnsfx.html#refinery.units.formats.pe.dotnet.dnsfx.dnsfx">dnsfx</a></li>
<li><a title="refinery.units.formats.pe.perc.perc" href="pe/perc.html#refinery.units.formats.pe.perc.perc">perc</a></li>
<li><a title="refinery.units.formats.winreg.winreg" href="winreg.html#refinery.units.formats.winreg.winreg">winreg</a></li>
<li><a title="refinery.units.pattern.carve_pe.carve_pe" href="../pattern/carve_pe.html#refinery.units.pattern.carve_pe.carve_pe">carve_pe</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.PathExtractorUnit.required_dependencies"><code class="name">var <span class="ident">required_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.PathExtractorUnit.optional_dependencies"><code class="name">var <span class="ident">optional_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.PathExtractorUnit.console"><code class="name">var <span class="ident">console</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.PathExtractorUnit.CustomPathSeparator"><code class="name">var <span class="ident">CustomPathSeparator</span></code></dt>
<dd>
<section class="desc"><p>This class variable can be overwritten by child classes to change the path separator from the
default forward slash to something else.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.PathExtractorUnit.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/__init__.py#L180-L182" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def unpack(self, data: Chunk) -&gt; Iterable[UnpackResult]:
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.Requires" href="../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.Unit.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.Unit.finish" href="../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.Unit.handles" href="../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.Unit.is_quiet" href="../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.Unit.labelled" href="../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.Unit.leniency" href="../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.Unit.log_always" href="../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.Unit.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.Unit.log_detach" href="../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.Unit.log_fail" href="../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.Unit.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.Unit.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.Unit.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.Unit.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.Unit.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.Unit.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.Unit.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.Unit.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.Unit.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.process" href="../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.filter" href="../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.units.formats.XMLToPathExtractorUnit"><code class="flex name class">
<span>class <span class="ident">XMLToPathExtractorUnit</span></span>
<span>(</span><span>*paths, format=None, list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False, path=b'path', **keywords)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/__init__.py#L294-L398" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class XMLToPathExtractorUnit(PathExtractorUnit, abstract=True):
    def __init__(
        self, *paths,
        format: Param[str | None, Arg.String(&#39;-f&#39;, metavar=&#39;F&#39;, help=(
            &#39;A format expression to be applied for computing the path of an item. This must use &#39;
            &#39;metadata that is available on the item. The current tag can be accessed as {{tag}}. &#39;
            &#39;If no format is specified, the unit attempts to derive a good attribute from the XML &#39;
            &#39;tree to use for generating paths.&#39;
        ))] = None,
        list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False,
        path=b&#39;path&#39;, **keywords
    ):
        super().__init__(
            *paths,
            format=format,
            list=list,
            path=path,
            join_path=join_path,
            drop_path=drop_path,
            fuzzy=fuzzy,
            exact=exact,
            regex=regex,
            **keywords
        )

    @staticmethod
    def _normalize_val(attr: str):
        _bad = &#39;[/\\$&amp;%#:.]&#39;
        attr = attr.replace(&#39;[&#39;, &#39;(&#39;)
        attr = attr.replace(&#39;]&#39;, &#39;)&#39;)
        attr = re.sub(F&#39;\\s*{_bad}+\\s+&#39;, &#39; &#39;, attr)
        attr = re.sub(F&#39;\\s*{_bad}+\\s*&#39;, &#39;.&#39;, attr)
        return attr.strip()

    @staticmethod
    def _normalize_key(attribute: str):
        _, _, a = attribute.rpartition(&#39;:&#39;)
        return a

    def _make_path_builder(
        self,
        meta: LazyMetaOracle,
        root: XMLNodeBase
    ) -&gt; Callable[[XMLNodeBase], str]:

        nfmt = self.args.format
        nkey = self._normalize_key
        nval = self._normalize_val
        nmap = {}

        if nfmt is None:
            def rank_attribute(attribute: str):
                length = len(attribute)
                scount = length - len(re.sub(r&#39;\s+&#39;, &#39;&#39;, attribute))
                return (1 / length, scount)

            def walk(node: XMLNodeBase):
                children = node.children
                __tags = set()
                for child in children:
                    if (tag := child.tag) not in __tags:
                        __tags.add(tag)
                        continue
                    candidates = [
                        candidate for candidate, count in Counter(
                            key for child in children for key, val in child.attributes.items()
                            if len(val) in range(2, 65) and re.fullmatch(R&#39;[-\s\w+,.;@()]+&#39;, nval(val))
                        ).items()
                        if count == len(children) == len(
                            {child.attributes[candidate] for child in children})
                    ]
                    break
                else:
                    candidates = None
                if not candidates:
                    attr = None
                else:
                    candidates.sort(key=rank_attribute)
                    attr = candidates[0]
                for child in children:
                    nmap[child.path] = attr
                    walk(child)

            walk(root)

        def path_builder(node: XMLNodeBase) -&gt; str:
            if node.tag is None:
                raise ValueError(F&#39;Attempt to format node without a tag: {node!r}&#39;)
            attrs = node.attributes
            if nfmt and meta is not None:
                try:
                    symbols = {nkey(key): nval(val) for key, val in attrs.items()}
                    return meta.format_str(nfmt, self.codec, node.tag, symbols)
                except KeyError:
                    pass
            try:
                return nval(attrs[nmap[node.path]])
            except KeyError:
                index = node.index
                name = nval(node.tag)
                if index is not None:
                    name = F&#39;{index}.{name}&#39;
                return name

        return path_builder</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.PathExtractorUnit" href="#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></li>
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.html.xthtml" href="html.html#refinery.units.formats.html.xthtml">xthtml</a></li>
<li><a title="refinery.units.formats.xml.xtxml" href="xml.html#refinery.units.formats.xml.xtxml">xtxml</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.XMLToPathExtractorUnit.required_dependencies"><code class="name">var <span class="ident">required_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.XMLToPathExtractorUnit.optional_dependencies"><code class="name">var <span class="ident">optional_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.XMLToPathExtractorUnit.console"><code class="name">var <span class="ident">console</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.formats.PathExtractorUnit" href="#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.formats.PathExtractorUnit.CustomPathSeparator" href="#refinery.units.formats.PathExtractorUnit.CustomPathSeparator">CustomPathSeparator</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.Requires" href="../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.filter" href="../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.finish" href="../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.handles" href="../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.is_quiet" href="../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.labelled" href="../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.leniency" href="../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_always" href="../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_detach" href="../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_fail" href="../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.process" href="../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.units.formats.JSONEncoderUnit"><code class="flex name class">
<span>class <span class="ident">JSONEncoderUnit</span></span>
<span>(</span><span>encode=None, digest=None, arrays=False, **keywords)</span>
</code></dt>
<dd>
<section class="desc"><p>An abstract unit that provides the interface for displaying parsed data as JSON. By default,
binary data is converted to latin1 strings.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/__init__.py#L401-L443" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class JSONEncoderUnit(Unit, abstract=True):
    &#34;&#34;&#34;
    An abstract unit that provides the interface for displaying parsed data as JSON. By default,
    binary data is converted to latin1 strings.
    &#34;&#34;&#34;

    EncoderBase = BytesAsStringEncoder

    def __init__(
        self,
        encode: Param[str | None, Arg.String(&#39;-e&#39;, group=&#39;BIN&#39;, metavar=&#39;U&#39;, help=(
            &#39;Select an encoder unit used to represent binary data in the JSON output. This unit &#39;
            &#39;must be reversible and produce UTF8 encoded string output when operated in reverse.&#39;
            &#39; Common examples are hex and b64.&#39;))] = None,
        digest: Param[str | None, Arg.String(&#39;-d&#39;, group=&#39;BIN&#39;, metavar=&#39;U&#39;, help=(
            &#39;Select a hashing unit to digest all byte strings: Instead of the data, only the hash &#39;
            &#39;will be displayed.&#39;))] = None,
        arrays: Param[bool, Arg.Switch(&#39;-a&#39;, group=&#39;BIN&#39;, help=(
            &#39;Encode all byte strings as integer arrays. These arrays will have unsigned integer &#39;
            &#39;entires between 0 and 255.&#39;))] = False,
        **keywords
    ):
        if sum(1 for x in (encode, digest, arrays) if x) &gt; 1:
            raise ValueError(&#39;Can only set one option for byte string encoding.&#39;)
        super().__init__(encode=encode, digest=digest, arrays=arrays, **keywords)

    def to_json(self, obj) -&gt; bytes:
        def UnitEncoderFactory(unit: Unit):
            class Encoder(self.EncoderBase):
                def encode_bytes(self, obj):
                    return obj | unit | str
            return Encoder
        if self.args.arrays:
            encoder = BytesAsArrayEncoder
        elif u := self.args.encode:
            encoder = UnitEncoderFactory(load(u, reverse=True))
        elif u := self.args.digest:
            encoder = UnitEncoderFactory(load(u, text=True))
        else:
            encoder = self.EncoderBase

        with encoder as enc:
            return enc.dumps(obj).encode(self.codec)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.pbuf.pbuf" href="pbuf.html#refinery.units.formats.pbuf.pbuf">pbuf</a></li>
<li><a title="refinery.units.formats.pe.dotnet.DotNetJSONEncoderUnit" href="pe/dotnet/index.html#refinery.units.formats.pe.dotnet.DotNetJSONEncoderUnit">DotNetJSONEncoderUnit</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.JSONEncoderUnit.required_dependencies"><code class="name">var <span class="ident">required_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.JSONEncoderUnit.optional_dependencies"><code class="name">var <span class="ident">optional_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.JSONEncoderUnit.console"><code class="name">var <span class="ident">console</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.formats.JSONEncoderUnit.EncoderBase"><code class="name">var <span class="ident">EncoderBase</span></code></dt>
<dd>
<section class="desc"><p>This JSON Encoder encodes byte strings as escaped strings.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.JSONEncoderUnit.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/formats/__init__.py#L427-L443" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def to_json(self, obj) -&gt; bytes:
    def UnitEncoderFactory(unit: Unit):
        class Encoder(self.EncoderBase):
            def encode_bytes(self, obj):
                return obj | unit | str
        return Encoder
    if self.args.arrays:
        encoder = BytesAsArrayEncoder
    elif u := self.args.encode:
        encoder = UnitEncoderFactory(load(u, reverse=True))
    elif u := self.args.digest:
        encoder = UnitEncoderFactory(load(u, text=True))
    else:
        encoder = self.EncoderBase

    with encoder as enc:
        return enc.dumps(obj).encode(self.codec)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.Requires" href="../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.Unit.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.Unit.finish" href="../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.Unit.handles" href="../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.Unit.is_quiet" href="../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.Unit.labelled" href="../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.Unit.leniency" href="../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.Unit.log_always" href="../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.Unit.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.Unit.log_detach" href="../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.Unit.log_fail" href="../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.Unit.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.Unit.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.Unit.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.Unit.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.Unit.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.Unit.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.Unit.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.Unit.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.Unit.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.filter" href="../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.UnitBase.process" href="../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units" href="../index.html">refinery.units</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="refinery.units.formats.a3x" href="a3x.html">refinery.units.formats.a3x</a></code></li>
<li><code><a title="refinery.units.formats.archive" href="archive/index.html">refinery.units.formats.archive</a></code></li>
<li><code><a title="refinery.units.formats.bat" href="bat.html">refinery.units.formats.bat</a></code></li>
<li><code><a title="refinery.units.formats.csv" href="csv.html">refinery.units.formats.csv</a></code></li>
<li><code><a title="refinery.units.formats.deserialize_php" href="deserialize_php.html">refinery.units.formats.deserialize_php</a></code></li>
<li><code><a title="refinery.units.formats.dexstr" href="dexstr.html">refinery.units.formats.dexstr</a></code></li>
<li><code><a title="refinery.units.formats.email" href="email.html">refinery.units.formats.email</a></code></li>
<li><code><a title="refinery.units.formats.evtx" href="evtx.html">refinery.units.formats.evtx</a></code></li>
<li><code><a title="refinery.units.formats.exe" href="exe/index.html">refinery.units.formats.exe</a></code></li>
<li><code><a title="refinery.units.formats.hexload" href="hexload.html">refinery.units.formats.hexload</a></code></li>
<li><code><a title="refinery.units.formats.html" href="html.html">refinery.units.formats.html</a></code></li>
<li><code><a title="refinery.units.formats.httprequest" href="httprequest.html">refinery.units.formats.httprequest</a></code></li>
<li><code><a title="refinery.units.formats.httpresponse" href="httpresponse.html">refinery.units.formats.httpresponse</a></code></li>
<li><code><a title="refinery.units.formats.ifps" href="ifps.html">refinery.units.formats.ifps</a></code></li>
<li><code><a title="refinery.units.formats.ifpsstr" href="ifpsstr.html">refinery.units.formats.ifpsstr</a></code></li>
<li><code><a title="refinery.units.formats.imgdb" href="imgdb.html">refinery.units.formats.imgdb</a></code></li>
<li><code><a title="refinery.units.formats.imgto" href="imgto.html">refinery.units.formats.imgto</a></code></li>
<li><code><a title="refinery.units.formats.imgtp" href="imgtp.html">refinery.units.formats.imgtp</a></code></li>
<li><code><a title="refinery.units.formats.java" href="java/index.html">refinery.units.formats.java</a></code></li>
<li><code><a title="refinery.units.formats.json" href="json.html">refinery.units.formats.json</a></code></li>
<li><code><a title="refinery.units.formats.lnk" href="lnk.html">refinery.units.formats.lnk</a></code></li>
<li><code><a title="refinery.units.formats.macho" href="macho/index.html">refinery.units.formats.macho</a></code></li>
<li><code><a title="refinery.units.formats.msgpack" href="msgpack.html">refinery.units.formats.msgpack</a></code></li>
<li><code><a title="refinery.units.formats.msi" href="msi.html">refinery.units.formats.msi</a></code></li>
<li><code><a title="refinery.units.formats.office" href="office/index.html">refinery.units.formats.office</a></code></li>
<li><code><a title="refinery.units.formats.pbuf" href="pbuf.html">refinery.units.formats.pbuf</a></code></li>
<li><code><a title="refinery.units.formats.pcap" href="pcap.html">refinery.units.formats.pcap</a></code></li>
<li><code><a title="refinery.units.formats.pcap_http" href="pcap_http.html">refinery.units.formats.pcap_http</a></code></li>
<li><code><a title="refinery.units.formats.pdf" href="pdf.html">refinery.units.formats.pdf</a></code></li>
<li><code><a title="refinery.units.formats.pdfcrypt" href="pdfcrypt.html">refinery.units.formats.pdfcrypt</a></code></li>
<li><code><a title="refinery.units.formats.pe" href="pe/index.html">refinery.units.formats.pe</a></code></li>
<li><code><a title="refinery.units.formats.pkcs7" href="pkcs7.html">refinery.units.formats.pkcs7</a></code></li>
<li><code><a title="refinery.units.formats.pkcs7sig" href="pkcs7sig.html">refinery.units.formats.pkcs7sig</a></code></li>
<li><code><a title="refinery.units.formats.pyc" href="pyc.html">refinery.units.formats.pyc</a></code></li>
<li><code><a title="refinery.units.formats.pym" href="pym.html">refinery.units.formats.pym</a></code></li>
<li><code><a title="refinery.units.formats.pymstr" href="pymstr.html">refinery.units.formats.pymstr</a></code></li>
<li><code><a title="refinery.units.formats.qr" href="qr.html">refinery.units.formats.qr</a></code></li>
<li><code><a title="refinery.units.formats.sqlite" href="sqlite.html">refinery.units.formats.sqlite</a></code></li>
<li><code><a title="refinery.units.formats.stego" href="stego.html">refinery.units.formats.stego</a></code></li>
<li><code><a title="refinery.units.formats.winreg" href="winreg.html">refinery.units.formats.winreg</a></code></li>
<li><code><a title="refinery.units.formats.xml" href="xml.html">refinery.units.formats.xml</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.units.formats.pathspec" href="#refinery.units.formats.pathspec">pathspec</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.formats.UnpackResult" href="#refinery.units.formats.UnpackResult">UnpackResult</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.UnpackResult.get_data" href="#refinery.units.formats.UnpackResult.get_data">get_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.EndOfStringNotFound" href="#refinery.units.formats.EndOfStringNotFound">EndOfStringNotFound</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.PathPattern" href="#refinery.units.formats.PathPattern">PathPattern</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.PathPattern.compile" href="#refinery.units.formats.PathPattern.compile">compile</a></code></li>
<li><code><a title="refinery.units.formats.PathPattern.reach" href="#refinery.units.formats.PathPattern.reach">reach</a></code></li>
<li><code><a title="refinery.units.formats.PathPattern.check" href="#refinery.units.formats.PathPattern.check">check</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.PathExtractorUnit" href="#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.PathExtractorUnit.unpack" href="#refinery.units.formats.PathExtractorUnit.unpack">unpack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.XMLToPathExtractorUnit" href="#refinery.units.formats.XMLToPathExtractorUnit">XMLToPathExtractorUnit</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.JSONEncoderUnit" href="#refinery.units.formats.JSONEncoderUnit">JSONEncoderUnit</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.JSONEncoderUnit.to_json" href="#refinery.units.formats.JSONEncoderUnit.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
