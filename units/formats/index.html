<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.units.formats documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.formats</code></h1>
</header>
<section id="section-intro">
<p>A package containing several sub-packages for various data formats.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L1-L518" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
A package containing several sub-packages for various data formats.
&#34;&#34;&#34;
from __future__ import annotations

import abc
import codecs
import collections
import fnmatch
import re

from collections import Counter
from zlib import adler32

from refinery.lib import json as libjson
from refinery.lib.loader import load
from refinery.lib.meta import ByteStringWrapper, LazyMetaOracle, metavars
from refinery.lib.tools import exception_to_string, get_terminal_size
from refinery.lib.types import Callable, Iterable, Param, buf, isbuffer
from refinery.lib.xml import XMLNodeBase
from refinery.units import Arg, Chunk, RefineryPartialResult, RefineryPotentialUserError, Unit


def pathspec(expression):
    &#34;&#34;&#34;
    Normalizes a path which is separated by backward or forward slashes to be
    separated by forward slashes.
    &#34;&#34;&#34;
    return &#39;/&#39;.join(re.split(R&#39;[\\\/]&#39;, expression))


class UnpackResult:

    def get_data(self) -&gt; buf:
        if callable(self.data):
            self.data = self.data()
        return self.data

    def __init__(self, _br__path: str, _br__data: buf | Callable[[], buf], **_br__meta):
        self.path = _br__path
        self.data = _br__data
        self.meta = _br__meta
        for key in [key for key, value in _br__meta.items() if value is None]:
            del _br__meta[key]


class EndOfStringNotFound(ValueError):
    def __init__(self):
        super().__init__(&#39;end of string could not be determined&#39;)


class PathPattern:
    def __init__(self, query: str, regex=False, fuzzy=0):
        self.query = query
        self.regex = regex
        self.fuzzy = fuzzy
        self.compile()

    def compile(self, **kw):
        query = self.query
        if not self.regex:
            self.stops = re.split(R&#39;([/*?]+)&#39;, query)
            query, _, _ = fnmatch.translate(query).partition(r&#39;\Z&#39;)
        p1 = re.compile(query, **kw)
        p2 = re.compile(F&#39;.*?{query}&#39;)
        self.matchers = [p1.fullmatch, p2.fullmatch, p1.search]

    def reach(self, path: str):
        &#34;&#34;&#34;
        This is a crude heuristic to determine whether the pattern can likely reach any files
        that have the given path as a parent.
        &#34;&#34;&#34;
        if len(self.stops) == 1:
            # a specific file could always be somewhere
            return True
        for stop in self.stops[0::2]:
            if fnmatch.fnmatch(path, F&#39;*{stop}*&#39;):
                return True
        return False

    def check(self, path, fuzzy=0):
        fuzzy = min(max(fuzzy, self.fuzzy), 2)
        return self.matchers[fuzzy](path)

    def __repr__(self):
        return F&#39;&lt;PathPattern:{&#34;&#34;.join(self.stops) or &#34;RE&#34;}&gt;&#39;


class PathExtractorUnit(Unit, abstract=True):
    &#34;&#34;&#34;
    This unit is a path extractor which extracts data from a hierarchical structure. Each extracted
    item is emitted as a separate chunk and has attached to it a meta variable that contains its
    path within the source structure. The positional arguments to the command are patterns that can
    be used to filter the extracted items by their path. To view only the paths of all chunks, use
    the listing switch:

        emit something | &lt;this&gt; --list

    Otherwise, extracted items are written to the standard output port and usually require a frame
    to properly process. In order to dump all extracted data to disk, the following pipeline can be
    used:

        emit something | &lt;this&gt; [| d2p ]

    If you using &lt;this&gt; to unpack a file on disk, the following pattern can be useful:

        ef pack.foo [| &lt;this&gt; -j | d2p ]

    The unit `refinery.ef` is also a path extractor. By specifying `-j` (or `--join`), the paths of
    extracted items are combined. The `refinery.d2p` unit will deconflict these with the local file
    system. For example, if `pack.foo` contains items `one.txt` and `two.txt`, the following local
    file tree would be the result:

        pack.foo
        pack/one.txt
        pack/two.txt

    Finally, the `-d` (or `--drop`) switch can be used to not create (or alter) the path metadata
    at all, which is useful in cases where path metadata from a previous unit should be preserved.
    &#34;&#34;&#34;

    CustomJoinBehaviour = &#39;{root}{sep}{path}&#39;
    &#34;&#34;&#34;
    This class variable can be overwritten to change how paths are joined.
    &#34;&#34;&#34;

    CustomPathSeparator = None
    &#34;&#34;&#34;
    This class variable can be overwritten by child classes to change the path separator from the
    default forward slash to something else.
    &#34;&#34;&#34;

    def __init__(
        self,
        *paths: Param[str, Arg.FsPath(metavar=&#39;path&#39;, nargs=&#39;*&#39;, help=(
            &#39;Wildcard pattern for the path of the item to be extracted. Each item is returned &#39;
            &#39;as a separate output of this unit. Paths may contain wildcards; The default &#39;
            &#39;argument is a single wildcard, which means that every item will be extracted. If &#39;
            &#39;a given path yields no results, the unit performs increasingly fuzzy searches &#39;
            &#39;with it. This can be disabled using the --exact switch.&#39;))],
        list: Param[bool, Arg.Switch(&#39;-l&#39;,
            help=&#39;Return all matching paths as UTF8-encoded output chunks.&#39;)] = False,
        join_path: Param[bool, Arg.Switch(&#39;-j&#39;, group=&#39;PATH&#39;, help=(
            &#39;Join path names with the previously existing one.&#39;))] = False,
        drop_path: Param[bool, Arg.Switch(&#39;-d&#39;, group=&#39;PATH&#39;,
            help=&#39;Do not modify the path variable for output chunks.&#39;)] = False,
        fuzzy: Param[int, Arg.Counts(&#39;-z&#39;, group=&#39;MATCH&#39;, help=(
            &#39;Specify once to add a leading wildcard to each patterns, twice to also add a &#39;
            &#39;trailing wildcard.&#39;))] = 0,
        exact: Param[bool, Arg.Switch(&#39;-e&#39;, group=&#39;MATCH&#39;,
            help=&#39;Path patterns never match on substrings.&#39;)] = False,
        regex: Param[bool, Arg.Switch(&#39;-r&#39;,
            help=&#39;Use regular expressions instead of wildcard patterns.&#39;)] = False,
        path: Param[buf, Arg(&#39;-P&#39;, metavar=&#39;NAME&#39;, help=(
            &#39;Name of the meta variable to receive the extracted path. The default value is &#39;
            &#39;&#34;{default}&#34;.&#39;))] = b&#39;path&#39;,
        **keywords
    ):
        super().__init__(
            paths=paths,
            list=list,
            join=join_path,
            drop=drop_path,
            path=path,
            fuzzy=fuzzy,
            exact=exact,
            regex=regex,
            **keywords
        )

    def _get_path_separator(self) -&gt; str:
        return self.CustomPathSeparator or &#39;/&#39;

    @property
    def _patterns(self):
        paths = self.args.paths
        if not paths:
            if self.args.regex:
                paths = [&#39;.*&#39;]
            else:
                paths = [&#39;*&#39;]
        else:
            def check_pattern(t: str) -&gt; str:
                try:
                    if len(t) &gt;= 0x1000:
                        raise OverflowError
                except Exception as E:
                    raise RefineryPotentialUserError(
                        F&#39;Invalid path pattern of length {len(t)}.&#39;) from E
                else:
                    return t
            paths = [check_pattern(p) for p in paths]
        for path in paths:
            self.log_debug(&#39;path:&#39;, path)
        return [
            PathPattern(
                path,
                self.args.regex,
                self.args.fuzzy,
            ) for path in paths
        ]

    @abc.abstractmethod
    def unpack(self, data: Chunk) -&gt; Iterable[UnpackResult]:
        raise NotImplementedError

    def process(self, data: Chunk) -&gt; buf:
        meta = metavars(data)
        results: list[UnpackResult] = list(self.unpack(data))

        patterns = self._patterns

        metavar = self.args.path.decode(self.codec)
        occurrences = collections.defaultdict(int)
        checksums = collections.defaultdict(set)
        root = &#39;&#39;
        uuid = 0

        def get_data(result: UnpackResult):
            try:
                data = result.get_data()
            except RefineryPartialResult as error:
                if not self.args.lenient:
                    raise
                result.data = data = error.partial
            return data

        def _uuid():
            nonlocal uuid
            crc = meta[&#39;crc32&#39;].decode(&#39;ascii&#39;).upper()
            uid = uuid
            uuid += 1
            return F&#39;_{crc}.{uid:04X}&#39;

        def normalize(_path: str) -&gt; str:
            if (pathsep := self.CustomPathSeparator):
                pattern = re.escape(pathsep)
            else:
                pattern = &#39;[\\\\/]&#39;
                pathsep = &#39;/&#39;
            parts = re.split(pattern, self.CustomJoinBehaviour.format(
                root=root, sep=pathsep, path=_path))
            while True:
                for k, part in enumerate(parts):
                    if not part.strip(&#39;.&#39;):
                        break
                else:
                    break
                size = len(part)
                j = max(k - size, 0)
                del parts[j:k + 1]
            path = pathsep.join(parts)
            return path

        if self.args.join:
            try:
                root = str(ByteStringWrapper(meta[metavar], self.codec))
            except KeyError:
                pass

        for result in results:
            path = normalize(result.path)
            if not path:
                from refinery.lib.mime import FileMagicInfo
                path = _uuid()
                ext = FileMagicInfo(get_data(result)).extension
                if ext != &#39;bin&#39;:
                    path = F&#39;{path}.{ext}&#39;
                self.log_warn(F&#39;read chunk with empty path; using generated name {path}&#39;)
            result.path = path
            occurrences[path] += 1

        for result in results:
            path = result.path
            if occurrences[path] &gt; 1:
                checksum = adler32(get_data(result))
                if checksum in checksums[path]:
                    continue
                checksums[path].add(checksum)
                counter = len(checksums[path])
                slash = self._get_path_separator()
                if any(F&#39;{result.path}{slash}{c}&#39; in occurrences for c in range(occurrences[path])):
                    counter = _uuid()
                result.path = F&#39;{result.path}{slash}{counter}&#39;
                self.log_info(F&#39;read chunk with duplicate path; deduplicating to {result.path}&#39;)

        if len({r.path.lower() for r in results}) == len(results):
            for p in patterns:
                p.compile(flags=re.IGNORECASE)

        for p in patterns:
            for fuzzy in range(3):
                done = self.args.exact
                for result in results:
                    path = result.path
                    if not p.check(path, fuzzy):
                        continue
                    done = True
                    if self.args.list:
                        yield self.labelled(path.encode(self.codec), **result.meta)
                        continue
                    if not self.args.drop:
                        result.meta[metavar] = path
                    try:
                        chunk = get_data(result)
                    except Exception as error:
                        if self.log_debug():
                            raise
                        self.log_warn(F&#39;extraction failure for {path}: {exception_to_string(error)}&#39;)
                    else:
                        self.log_debug(F&#39;extraction success for {path}&#39;)
                        yield self.labelled(chunk, **result.meta)
                if done or self.args.fuzzy:
                    break


class XMLToPathExtractorUnit(PathExtractorUnit, abstract=True):
    def __init__(
        self, *paths,
        format: Param[str | None, Arg.String(&#39;-f&#39;, metavar=&#39;F&#39;, help=(
            &#39;A format expression to be applied for computing the path of an item. This must use &#39;
            &#39;metadata that is available on the item. The current tag can be accessed as {{tag}}. &#39;
            &#39;If no format is specified, the unit attempts to derive a good attribute from the XML &#39;
            &#39;tree to use for generating paths.&#39;
        ))] = None,
        list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False,
        path=b&#39;path&#39;, **keywords
    ):
        super().__init__(
            *paths,
            format=format,
            list=list,
            path=path,
            join_path=join_path,
            drop_path=drop_path,
            fuzzy=fuzzy,
            exact=exact,
            regex=regex,
            **keywords
        )

    @staticmethod
    def _normalize_val(attr: str):
        _bad = &#39;[/\\$&amp;%#:.]&#39;
        attr = attr.replace(&#39;[&#39;, &#39;(&#39;)
        attr = attr.replace(&#39;]&#39;, &#39;)&#39;)
        attr = re.sub(F&#39;\\s*{_bad}+\\s+&#39;, &#39; &#39;, attr)
        attr = re.sub(F&#39;\\s*{_bad}+\\s*&#39;, &#39;.&#39;, attr)
        return attr.strip()

    @staticmethod
    def _normalize_key(attribute: str):
        a = attribute.rpartition(&#39;:&#39;)[2]
        a = re.sub(r&#39;[^\w]+&#39;, &#39;_&#39;, a)
        return a

    def _make_path_builder(
        self,
        meta: LazyMetaOracle,
        root: XMLNodeBase
    ) -&gt; Callable[[XMLNodeBase], str]:

        nfmt = self.args.format
        nkey = self._normalize_key
        nval = self._normalize_val
        nmap = {}

        if nfmt is None:
            def rank_attribute(attribute: str):
                length = len(attribute)
                scount = length - len(re.sub(r&#39;\s+&#39;, &#39;&#39;, attribute))
                return (1 / length, scount)

            def walk(node: XMLNodeBase):
                children = node.children
                __tags = set()
                for child in children:
                    if (tag := child.tag) not in __tags:
                        __tags.add(tag)
                        continue
                    candidates = [
                        candidate for candidate, count in Counter(
                            key for child in children for key, val in child.attributes.items()
                            if len(val) in range(2, 65) and re.fullmatch(R&#39;[-\s\w+,.;@()]+&#39;, nval(val))
                        ).items()
                        if count == len(children) == len(
                            {child.attributes[candidate] for child in children})
                    ]
                    break
                else:
                    candidates = None
                if not candidates:
                    attr = None
                else:
                    candidates.sort(key=rank_attribute)
                    attr = candidates[0]
                for child in children:
                    nmap[child.path] = attr
                    walk(child)

            walk(root)

        def path_builder(node: XMLNodeBase) -&gt; str:
            if node.tag is None:
                raise ValueError(F&#39;Attempt to format node without a tag: {node!r}&#39;)
            attrs = node.attributes
            if nfmt and meta is not None:
                try:
                    symbols = {nkey(key): nval(val) for key, val in attrs.items()}
                    return meta.format_str(nfmt, self.codec, [node.tag], symbols)
                except KeyError:
                    pass
            try:
                return nval(attrs[nmap[node.path]])
            except KeyError:
                index = node.index
                name = nval(node.tag)
                if index is not None:
                    name = F&#39;{index}.{name}&#39;
                return name

        return path_builder


class JSONTableUnit(Unit, abstract=True):

    def __init__(
        self,
        tabular: Param[bool, Arg.Switch(&#39;-t&#39;, group=&#39;OUT&#39;,
            help=&#39;Do not output JSON but a flattened ASCII table.&#39;)] = False,
        minimal: Param[bool, Arg.Switch(&#39;-m&#39;, group=&#39;OUT&#39;,
            help=&#39;Minify the JSON output instead of pretty-printing.&#39;)] = False,
        **kwargs
    ):
        super().__init__(tabular=tabular, minimal=minimal, **kwargs)

    @abc.abstractmethod
    def json(self, data: Chunk) -&gt; dict | None:
        ...

    def process(self, data: Chunk):
        if not (parsed := self.json(data)):
            return None
        if not self.args.tabular:
            pretty = not self.args.minimal
            yield libjson.dumps(parsed, pretty=pretty)
        else:
            import textwrap
            table = list(libjson.flattened(parsed))
            width = max(len(key) for key, _ in table)
            tsize = get_terminal_size(80) - width - 4
            for key, value in table:
                if isinstance(value, str):
                    value = value.strip()
                    if not value.isprintable() and all(ord(c) &lt; 0x100 for c in value):
                        value = value.encode(&#39;latin1&#39;).hex(&#39;:&#39;)
                elif isinstance(value, libjson.datetime):
                    value = value.isoformat(&#39; &#39;, &#39;seconds&#39;)
                else:
                    value = str(value).rstrip()
                value = textwrap.wrap(value, tsize)
                it = iter(value)
                try:
                    item = next(it)
                except StopIteration:
                    continue
                yield F&#39;{key:&lt;{width}} : {item}&#39;.encode(self.codec)
                for wrap in it:
                    yield F&#39;{&#34;&#34;:&lt;{width + 3}}{wrap}&#39;.encode(self.codec)


class JSONEncoderUnit(Unit, abstract=True):
    &#34;&#34;&#34;
    An abstract unit that provides the interface for displaying parsed data as JSON. By default,
    binary data is converted to latin1 strings.
    &#34;&#34;&#34;
    def __init__(
        self,
        encode: Param[str | None, Arg.String(&#39;-e&#39;, group=&#39;BIN&#39;, metavar=&#39;U&#39;, help=(
            &#39;Select an encoder unit used to represent binary data in the JSON output. This unit &#39;
            &#39;must be reversible and produce UTF8 encoded string output when operated in reverse.&#39;
            &#39; Common examples are hex and b64.&#39;))] = None,
        digest: Param[str | None, Arg.String(&#39;-d&#39;, group=&#39;BIN&#39;, metavar=&#39;U&#39;, help=(
            &#39;Select a hashing unit to digest all byte strings: Instead of the data, only the hash &#39;
            &#39;will be displayed.&#39;))] = None,
        arrays: Param[bool, Arg.Switch(&#39;-a&#39;, group=&#39;BIN&#39;, help=(
            &#39;Encode all byte strings as integer arrays. These arrays will have unsigned integer &#39;
            &#39;entires between 0 and 255.&#39;))] = False,
        **keywords
    ):
        if sum(1 for x in (encode, digest, arrays) if x) &gt; 1:
            raise ValueError(&#39;Can only set one option for byte string encoding.&#39;)
        super().__init__(encode=encode, digest=digest, arrays=arrays, **keywords)

    def to_json(self, obj, checks: bool = True) -&gt; bytes:
        if self.args.arrays:
            _byte_converter = list
        elif u := self.args.encode:
            def _encode(o: buf):
                return o | unit | str
            unit = load(u, reverse=True)
            _byte_converter = _encode
        elif u := self.args.digest:
            def _digest(o: buf):
                return o | unit | str
            unit = load(u, test=True)
            _byte_converter = _digest
        else:
            def _str_encode(o: buf):
                return codecs.decode(o, encoding=&#39;latin1&#39;)
            _byte_converter = _str_encode

        def default(o: buf):
            if isbuffer(o):
                return _byte_converter(o)
            return libjson.standard_conversions(o)

        return libjson.dumps(obj, tojson=default, checks=checks)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="refinery.units.formats.a3x" href="a3x.html">refinery.units.formats.a3x</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.archive" href="archive/index.html">refinery.units.formats.archive</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.asn1" href="asn1.html">refinery.units.formats.asn1</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.bat" href="bat.html">refinery.units.formats.bat</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.cbor" href="cbor.html">refinery.units.formats.cbor</a></code></dt>
<dd>
<section class="desc"><p>Implements parsing of CBOR (Concise Binary Object Representation) data as specified in RFC 8949.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.csv" href="csv.html">refinery.units.formats.csv</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.deserialize_php" href="deserialize_php.html">refinery.units.formats.deserialize_php</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.dexstr" href="dexstr.html">refinery.units.formats.dexstr</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.email" href="email.html">refinery.units.formats.email</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.evtx" href="evtx.html">refinery.units.formats.evtx</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.exe" href="exe/index.html">refinery.units.formats.exe</a></code></dt>
<dd>
<section class="desc"><p>A package with units for generic executables. Usually, PE, ELF, and MachO formats are covered.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.hexload" href="hexload.html">refinery.units.formats.hexload</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.html" href="html.html">refinery.units.formats.html</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.httprequest" href="httprequest.html">refinery.units.formats.httprequest</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.httpresponse" href="httpresponse.html">refinery.units.formats.httpresponse</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.idbmeta" href="idbmeta.html">refinery.units.formats.idbmeta</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.ifps" href="ifps.html">refinery.units.formats.ifps</a></code></dt>
<dd>
<section class="desc"><p>The code is based on the logic implemented in IFPSTools:
<a href="https://github.com/Wack0/IFPSTools">https://github.com/Wack0/IFPSTools</a></p></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.ifpsstr" href="ifpsstr.html">refinery.units.formats.ifpsstr</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.imgdb" href="imgdb.html">refinery.units.formats.imgdb</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.imgto" href="imgto.html">refinery.units.formats.imgto</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.imgtp" href="imgtp.html">refinery.units.formats.imgtp</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.java" href="java/index.html">refinery.units.formats.java</a></code></dt>
<dd>
<section class="desc"><p>Units that process Java related binary formats such as class files and serialized Java objects.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.jpeg" href="jpeg.html">refinery.units.formats.jpeg</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.json" href="json.html">refinery.units.formats.json</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.lnk" href="lnk.html">refinery.units.formats.lnk</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.macho" href="macho/index.html">refinery.units.formats.macho</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.msgpack" href="msgpack.html">refinery.units.formats.msgpack</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.msi" href="msi.html">refinery.units.formats.msi</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.office" href="office/index.html">refinery.units.formats.office</a></code></dt>
<dd>
<section class="desc"><p>These units process data formats related to Microsoft Office.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pbuf" href="pbuf.html">refinery.units.formats.pbuf</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pcap" href="pcap.html">refinery.units.formats.pcap</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pcap_http" href="pcap_http.html">refinery.units.formats.pcap_http</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pdf" href="pdf.html">refinery.units.formats.pdf</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pdfcrypt" href="pdfcrypt.html">refinery.units.formats.pdfcrypt</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pe" href="pe/index.html">refinery.units.formats.pe</a></code></dt>
<dd>
<section class="desc"><p>A package containing Portable Executable (PE) file related units.</p></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pkcs7" href="pkcs7.html">refinery.units.formats.pkcs7</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pkcs7sig" href="pkcs7sig.html">refinery.units.formats.pkcs7sig</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pyc" href="pyc.html">refinery.units.formats.pyc</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pym" href="pym.html">refinery.units.formats.pym</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.pymstr" href="pymstr.html">refinery.units.formats.pymstr</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.qr" href="qr.html">refinery.units.formats.qr</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.sqlite" href="sqlite.html">refinery.units.formats.sqlite</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.stego" href="stego.html">refinery.units.formats.stego</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.winreg" href="winreg.html">refinery.units.formats.winreg</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.formats.xml" href="xml.html">refinery.units.formats.xml</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.units.formats.pathspec"><code class="name flex">
<span>def <span class="ident">pathspec</span></span>(<span>expression)</span>
</code></dt>
<dd>
<section class="desc"><p>Normalizes a path which is separated by backward or forward slashes to be
separated by forward slashes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L24-L29" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pathspec(expression):
    &#34;&#34;&#34;
    Normalizes a path which is separated by backward or forward slashes to be
    separated by forward slashes.
    &#34;&#34;&#34;
    return &#39;/&#39;.join(re.split(R&#39;[\\\/]&#39;, expression))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.formats.UnpackResult"><code class="flex name class">
<span>class <span class="ident">UnpackResult</span></span>
<span>(</span><span>_br__path, _br__data, **_br__meta)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L32-L44" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class UnpackResult:

    def get_data(self) -&gt; buf:
        if callable(self.data):
            self.data = self.data()
        return self.data

    def __init__(self, _br__path: str, _br__data: buf | Callable[[], buf], **_br__meta):
        self.path = _br__path
        self.data = _br__data
        self.meta = _br__meta
        for key in [key for key, value in _br__meta.items() if value is None]:
            del _br__meta[key]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.UnpackResult.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L34-L37" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_data(self) -&gt; buf:
    if callable(self.data):
        self.data = self.data()
    return self.data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.EndOfStringNotFound"><code class="flex name class">
<span>class <span class="ident">EndOfStringNotFound</span></span>
</code></dt>
<dd>
<section class="desc"><p>Inappropriate argument value (of correct type).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L47-L49" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class EndOfStringNotFound(ValueError):
    def __init__(self):
        super().__init__(&#39;end of string could not be determined&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.units.formats.PathPattern"><code class="flex name class">
<span>class <span class="ident">PathPattern</span></span>
<span>(</span><span>query, regex=False, fuzzy=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L52-L86" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PathPattern:
    def __init__(self, query: str, regex=False, fuzzy=0):
        self.query = query
        self.regex = regex
        self.fuzzy = fuzzy
        self.compile()

    def compile(self, **kw):
        query = self.query
        if not self.regex:
            self.stops = re.split(R&#39;([/*?]+)&#39;, query)
            query, _, _ = fnmatch.translate(query).partition(r&#39;\Z&#39;)
        p1 = re.compile(query, **kw)
        p2 = re.compile(F&#39;.*?{query}&#39;)
        self.matchers = [p1.fullmatch, p2.fullmatch, p1.search]

    def reach(self, path: str):
        &#34;&#34;&#34;
        This is a crude heuristic to determine whether the pattern can likely reach any files
        that have the given path as a parent.
        &#34;&#34;&#34;
        if len(self.stops) == 1:
            # a specific file could always be somewhere
            return True
        for stop in self.stops[0::2]:
            if fnmatch.fnmatch(path, F&#39;*{stop}*&#39;):
                return True
        return False

    def check(self, path, fuzzy=0):
        fuzzy = min(max(fuzzy, self.fuzzy), 2)
        return self.matchers[fuzzy](path)

    def __repr__(self):
        return F&#39;&lt;PathPattern:{&#34;&#34;.join(self.stops) or &#34;RE&#34;}&gt;&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.PathPattern.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self, **kw)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L59-L66" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def compile(self, **kw):
    query = self.query
    if not self.regex:
        self.stops = re.split(R&#39;([/*?]+)&#39;, query)
        query, _, _ = fnmatch.translate(query).partition(r&#39;\Z&#39;)
    p1 = re.compile(query, **kw)
    p2 = re.compile(F&#39;.*?{query}&#39;)
    self.matchers = [p1.fullmatch, p2.fullmatch, p1.search]</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.PathPattern.reach"><code class="name flex">
<span>def <span class="ident">reach</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<section class="desc"><p>This is a crude heuristic to determine whether the pattern can likely reach any files
that have the given path as a parent.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L68-L79" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reach(self, path: str):
    &#34;&#34;&#34;
    This is a crude heuristic to determine whether the pattern can likely reach any files
    that have the given path as a parent.
    &#34;&#34;&#34;
    if len(self.stops) == 1:
        # a specific file could always be somewhere
        return True
    for stop in self.stops[0::2]:
        if fnmatch.fnmatch(path, F&#39;*{stop}*&#39;):
            return True
    return False</code></pre>
</details>
</dd>
<dt id="refinery.units.formats.PathPattern.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, path, fuzzy=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L81-L83" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check(self, path, fuzzy=0):
    fuzzy = min(max(fuzzy, self.fuzzy), 2)
    return self.matchers[fuzzy](path)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.formats.PathExtractorUnit"><code class="flex name class">
<span>class <span class="ident">PathExtractorUnit</span></span>
<span>(</span><span>*paths, list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False, path=b'path', **keywords)</span>
</code></dt>
<dd>
<section class="desc"><p>This unit is a path extractor which extracts data from a hierarchical structure. Each extracted
item is emitted as a separate chunk and has attached to it a meta variable that contains its
path within the source structure. The positional arguments to the command are patterns that can
be used to filter the extracted items by their path. To view only the paths of all chunks, use
the listing switch:</p>
<pre><code>emit something | &lt;this&gt; --list
</code></pre>
<p>Otherwise, extracted items are written to the standard output port and usually require a frame
to properly process. In order to dump all extracted data to disk, the following pipeline can be
used:</p>
<pre><code>emit something | &lt;this&gt; [| d2p ]
</code></pre>
<p>If you using <this> to unpack a file on disk, the following pattern can be useful:</p>
<pre><code>ef pack.foo [| &lt;this&gt; -j | d2p ]
</code></pre>
<p>The unit <code><a title="refinery.ef" href="../../index.html#refinery.ef">ef</a></code> is also a path extractor. By specifying <code>-j</code> (or <code>--join</code>), the paths of
extracted items are combined. The <code><a title="refinery.d2p" href="../../index.html#refinery.d2p">d2p</a></code> unit will deconflict these with the local file
system. For example, if <code>pack.foo</code> contains items <code>one.txt</code> and <code>two.txt</code>, the following local
file tree would be the result:</p>
<pre><code>pack.foo
pack/one.txt
pack/two.txt
</code></pre>
<p>Finally, the <code>-d</code> (or <code>--drop</code>) switch can be used to not create (or alter) the path metadata
at all, which is useful in cases where path metadata from a previous unit should be preserved.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L89-L314" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PathExtractorUnit(Unit, abstract=True):
    &#34;&#34;&#34;
    This unit is a path extractor which extracts data from a hierarchical structure. Each extracted
    item is emitted as a separate chunk and has attached to it a meta variable that contains its
    path within the source structure. The positional arguments to the command are patterns that can
    be used to filter the extracted items by their path. To view only the paths of all chunks, use
    the listing switch:

        emit something | &lt;this&gt; --list

    Otherwise, extracted items are written to the standard output port and usually require a frame
    to properly process. In order to dump all extracted data to disk, the following pipeline can be
    used:

        emit something | &lt;this&gt; [| d2p ]

    If you using &lt;this&gt; to unpack a file on disk, the following pattern can be useful:

        ef pack.foo [| &lt;this&gt; -j | d2p ]

    The unit `refinery.ef` is also a path extractor. By specifying `-j` (or `--join`), the paths of
    extracted items are combined. The `refinery.d2p` unit will deconflict these with the local file
    system. For example, if `pack.foo` contains items `one.txt` and `two.txt`, the following local
    file tree would be the result:

        pack.foo
        pack/one.txt
        pack/two.txt

    Finally, the `-d` (or `--drop`) switch can be used to not create (or alter) the path metadata
    at all, which is useful in cases where path metadata from a previous unit should be preserved.
    &#34;&#34;&#34;

    CustomJoinBehaviour = &#39;{root}{sep}{path}&#39;
    &#34;&#34;&#34;
    This class variable can be overwritten to change how paths are joined.
    &#34;&#34;&#34;

    CustomPathSeparator = None
    &#34;&#34;&#34;
    This class variable can be overwritten by child classes to change the path separator from the
    default forward slash to something else.
    &#34;&#34;&#34;

    def __init__(
        self,
        *paths: Param[str, Arg.FsPath(metavar=&#39;path&#39;, nargs=&#39;*&#39;, help=(
            &#39;Wildcard pattern for the path of the item to be extracted. Each item is returned &#39;
            &#39;as a separate output of this unit. Paths may contain wildcards; The default &#39;
            &#39;argument is a single wildcard, which means that every item will be extracted. If &#39;
            &#39;a given path yields no results, the unit performs increasingly fuzzy searches &#39;
            &#39;with it. This can be disabled using the --exact switch.&#39;))],
        list: Param[bool, Arg.Switch(&#39;-l&#39;,
            help=&#39;Return all matching paths as UTF8-encoded output chunks.&#39;)] = False,
        join_path: Param[bool, Arg.Switch(&#39;-j&#39;, group=&#39;PATH&#39;, help=(
            &#39;Join path names with the previously existing one.&#39;))] = False,
        drop_path: Param[bool, Arg.Switch(&#39;-d&#39;, group=&#39;PATH&#39;,
            help=&#39;Do not modify the path variable for output chunks.&#39;)] = False,
        fuzzy: Param[int, Arg.Counts(&#39;-z&#39;, group=&#39;MATCH&#39;, help=(
            &#39;Specify once to add a leading wildcard to each patterns, twice to also add a &#39;
            &#39;trailing wildcard.&#39;))] = 0,
        exact: Param[bool, Arg.Switch(&#39;-e&#39;, group=&#39;MATCH&#39;,
            help=&#39;Path patterns never match on substrings.&#39;)] = False,
        regex: Param[bool, Arg.Switch(&#39;-r&#39;,
            help=&#39;Use regular expressions instead of wildcard patterns.&#39;)] = False,
        path: Param[buf, Arg(&#39;-P&#39;, metavar=&#39;NAME&#39;, help=(
            &#39;Name of the meta variable to receive the extracted path. The default value is &#39;
            &#39;&#34;{default}&#34;.&#39;))] = b&#39;path&#39;,
        **keywords
    ):
        super().__init__(
            paths=paths,
            list=list,
            join=join_path,
            drop=drop_path,
            path=path,
            fuzzy=fuzzy,
            exact=exact,
            regex=regex,
            **keywords
        )

    def _get_path_separator(self) -&gt; str:
        return self.CustomPathSeparator or &#39;/&#39;

    @property
    def _patterns(self):
        paths = self.args.paths
        if not paths:
            if self.args.regex:
                paths = [&#39;.*&#39;]
            else:
                paths = [&#39;*&#39;]
        else:
            def check_pattern(t: str) -&gt; str:
                try:
                    if len(t) &gt;= 0x1000:
                        raise OverflowError
                except Exception as E:
                    raise RefineryPotentialUserError(
                        F&#39;Invalid path pattern of length {len(t)}.&#39;) from E
                else:
                    return t
            paths = [check_pattern(p) for p in paths]
        for path in paths:
            self.log_debug(&#39;path:&#39;, path)
        return [
            PathPattern(
                path,
                self.args.regex,
                self.args.fuzzy,
            ) for path in paths
        ]

    @abc.abstractmethod
    def unpack(self, data: Chunk) -&gt; Iterable[UnpackResult]:
        raise NotImplementedError

    def process(self, data: Chunk) -&gt; buf:
        meta = metavars(data)
        results: list[UnpackResult] = list(self.unpack(data))

        patterns = self._patterns

        metavar = self.args.path.decode(self.codec)
        occurrences = collections.defaultdict(int)
        checksums = collections.defaultdict(set)
        root = &#39;&#39;
        uuid = 0

        def get_data(result: UnpackResult):
            try:
                data = result.get_data()
            except RefineryPartialResult as error:
                if not self.args.lenient:
                    raise
                result.data = data = error.partial
            return data

        def _uuid():
            nonlocal uuid
            crc = meta[&#39;crc32&#39;].decode(&#39;ascii&#39;).upper()
            uid = uuid
            uuid += 1
            return F&#39;_{crc}.{uid:04X}&#39;

        def normalize(_path: str) -&gt; str:
            if (pathsep := self.CustomPathSeparator):
                pattern = re.escape(pathsep)
            else:
                pattern = &#39;[\\\\/]&#39;
                pathsep = &#39;/&#39;
            parts = re.split(pattern, self.CustomJoinBehaviour.format(
                root=root, sep=pathsep, path=_path))
            while True:
                for k, part in enumerate(parts):
                    if not part.strip(&#39;.&#39;):
                        break
                else:
                    break
                size = len(part)
                j = max(k - size, 0)
                del parts[j:k + 1]
            path = pathsep.join(parts)
            return path

        if self.args.join:
            try:
                root = str(ByteStringWrapper(meta[metavar], self.codec))
            except KeyError:
                pass

        for result in results:
            path = normalize(result.path)
            if not path:
                from refinery.lib.mime import FileMagicInfo
                path = _uuid()
                ext = FileMagicInfo(get_data(result)).extension
                if ext != &#39;bin&#39;:
                    path = F&#39;{path}.{ext}&#39;
                self.log_warn(F&#39;read chunk with empty path; using generated name {path}&#39;)
            result.path = path
            occurrences[path] += 1

        for result in results:
            path = result.path
            if occurrences[path] &gt; 1:
                checksum = adler32(get_data(result))
                if checksum in checksums[path]:
                    continue
                checksums[path].add(checksum)
                counter = len(checksums[path])
                slash = self._get_path_separator()
                if any(F&#39;{result.path}{slash}{c}&#39; in occurrences for c in range(occurrences[path])):
                    counter = _uuid()
                result.path = F&#39;{result.path}{slash}{counter}&#39;
                self.log_info(F&#39;read chunk with duplicate path; deduplicating to {result.path}&#39;)

        if len({r.path.lower() for r in results}) == len(results):
            for p in patterns:
                p.compile(flags=re.IGNORECASE)

        for p in patterns:
            for fuzzy in range(3):
                done = self.args.exact
                for result in results:
                    path = result.path
                    if not p.check(path, fuzzy):
                        continue
                    done = True
                    if self.args.list:
                        yield self.labelled(path.encode(self.codec), **result.meta)
                        continue
                    if not self.args.drop:
                        result.meta[metavar] = path
                    try:
                        chunk = get_data(result)
                    except Exception as error:
                        if self.log_debug():
                            raise
                        self.log_warn(F&#39;extraction failure for {path}: {exception_to_string(error)}&#39;)
                    else:
                        self.log_debug(F&#39;extraction success for {path}&#39;)
                        yield self.labelled(chunk, **result.meta)
                if done or self.args.fuzzy:
                    break</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.XMLToPathExtractorUnit" href="#refinery.units.formats.XMLToPathExtractorUnit">XMLToPathExtractorUnit</a></li>
<li><a title="refinery.units.formats.a3x.a3x" href="a3x.html#refinery.units.formats.a3x.a3x">a3x</a></li>
<li><a title="refinery.units.formats.archive.ArchiveUnit" href="archive/index.html#refinery.units.formats.archive.ArchiveUnit">ArchiveUnit</a></li>
<li><a title="refinery.units.formats.archive.xtchm.xtchm" href="archive/xtchm.html#refinery.units.formats.archive.xtchm.xtchm">xtchm</a></li>
<li><a title="refinery.units.formats.archive.xtnuitka.xtnuitka" href="archive/xtnuitka.html#refinery.units.formats.archive.xtnuitka.xtnuitka">xtnuitka</a></li>
<li><a title="refinery.units.formats.archive.xtrpa.xtrpa" href="archive/xtrpa.html#refinery.units.formats.archive.xtrpa.xtrpa">xtrpa</a></li>
<li><a title="refinery.units.formats.archive.xtsql.xtsql" href="archive/xtsql.html#refinery.units.formats.archive.xtsql.xtsql">xtsql</a></li>
<li><a title="refinery.units.formats.email.xtmail" href="email.html#refinery.units.formats.email.xtmail">xtmail</a></li>
<li><a title="refinery.units.formats.exe.vsect.vsect" href="exe/vsect.html#refinery.units.formats.exe.vsect.vsect">vsect</a></li>
<li><a title="refinery.units.formats.java.jvdasm.jvdasm" href="java/jvdasm.html#refinery.units.formats.java.jvdasm.jvdasm">jvdasm</a></li>
<li><a title="refinery.units.formats.jpeg.jpeg" href="jpeg.html#refinery.units.formats.jpeg.jpeg">jpeg</a></li>
<li><a title="refinery.units.formats.json.xtjson" href="json.html#refinery.units.formats.json.xtjson">xtjson</a></li>
<li><a title="refinery.units.formats.office.vbastr.vbastr" href="office/vbastr.html#refinery.units.formats.office.vbastr.vbastr">vbastr</a></li>
<li><a title="refinery.units.formats.office.xtdoc.xtdoc" href="office/xtdoc.html#refinery.units.formats.office.xtdoc.xtdoc">xtdoc</a></li>
<li><a title="refinery.units.formats.office.xtone.xtone" href="office/xtone.html#refinery.units.formats.office.xtone.xtone">xtone</a></li>
<li><a title="refinery.units.formats.office.xtrtf.xtrtf" href="office/xtrtf.html#refinery.units.formats.office.xtrtf.xtrtf">xtrtf</a></li>
<li><a title="refinery.units.formats.office.xtvba.xtvba" href="office/xtvba.html#refinery.units.formats.office.xtvba.xtvba">xtvba</a></li>
<li><a title="refinery.units.formats.office.xtxs.xtxs" href="office/xtxs.html#refinery.units.formats.office.xtxs.xtxs">xtxs</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnfields.dnfields" href="pe/dotnet/dnfields.html#refinery.units.formats.pe.dotnet.dnfields.dnfields">dnfields</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnmr.dnmr" href="pe/dotnet/dnmr.html#refinery.units.formats.pe.dotnet.dnmr.dnmr">dnmr</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnrc.dnrc" href="pe/dotnet/dnrc.html#refinery.units.formats.pe.dotnet.dnrc.dnrc">dnrc</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnsfx.dnsfx" href="pe/dotnet/dnsfx.html#refinery.units.formats.pe.dotnet.dnsfx.dnsfx">dnsfx</a></li>
<li><a title="refinery.units.formats.pe.perc.perc" href="pe/perc.html#refinery.units.formats.pe.perc.perc">perc</a></li>
<li><a title="refinery.units.formats.winreg.winreg" href="winreg.html#refinery.units.formats.winreg.winreg">winreg</a></li>
<li><a title="refinery.units.pattern.carve_pe.carve_pe" href="../pattern/carve_pe.html#refinery.units.pattern.carve_pe.carve_pe">carve_pe</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.formats.PathExtractorUnit.CustomJoinBehaviour"><code class="name">var <span class="ident">CustomJoinBehaviour</span></code></dt>
<dd>
<section class="desc"><p>This class variable can be overwritten to change how paths are joined.</p></section>
</dd>
<dt id="refinery.units.formats.PathExtractorUnit.CustomPathSeparator"><code class="name">var <span class="ident">CustomPathSeparator</span></code></dt>
<dd>
<section class="desc"><p>This class variable can be overwritten by child classes to change the path separator from the
default forward slash to something else.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.PathExtractorUnit.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L203-L205" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def unpack(self, data: Chunk) -&gt; Iterable[UnpackResult]:
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.console" href="../index.html#refinery.units.Unit.console">console</a></code></li>
<li><code><a title="refinery.units.Unit.optional_dependencies" href="../index.html#refinery.units.Unit.optional_dependencies">optional_dependencies</a></code></li>
<li><code><a title="refinery.units.Unit.required_dependencies" href="../index.html#refinery.units.Unit.required_dependencies">required_dependencies</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.FilterEverything" href="../index.html#refinery.units.UnitBase.FilterEverything">FilterEverything</a></code></li>
<li><code><a title="refinery.units.Unit.Requires" href="../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.Unit.act" href="../index.html#refinery.units.Unit.act">act</a></code></li>
<li><code><a title="refinery.units.Unit.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.Unit.codec" href="../index.html#refinery.units.Unit.codec">codec</a></code></li>
<li><code><a title="refinery.units.Unit.finish" href="../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.Unit.handles" href="../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.Unit.is_quiet" href="../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.Unit.is_reversible" href="../index.html#refinery.units.Unit.is_reversible">is_reversible</a></code></li>
<li><code><a title="refinery.units.Unit.isatty" href="../index.html#refinery.units.Unit.isatty">isatty</a></code></li>
<li><code><a title="refinery.units.Unit.labelled" href="../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.Unit.leniency" href="../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.Unit.log_always" href="../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.Unit.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.Unit.log_detach" href="../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.Unit.log_fail" href="../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.Unit.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.Unit.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.Unit.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.Unit.logger" href="../index.html#refinery.units.Unit.logger">logger</a></code></li>
<li><code><a title="refinery.units.Unit.name" href="../index.html#refinery.units.Unit.name">name</a></code></li>
<li><code><a title="refinery.units.Unit.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.Unit.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.Unit.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.Unit.reset" href="../index.html#refinery.units.Unit.reset">reset</a></code></li>
<li><code><a title="refinery.units.Unit.reverse" href="../index.html#refinery.units.UnitBase.reverse">reverse</a></code></li>
<li><code><a title="refinery.units.Unit.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.Unit.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.Unit.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.process" href="../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.filter" href="../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.units.formats.XMLToPathExtractorUnit"><code class="flex name class">
<span>class <span class="ident">XMLToPathExtractorUnit</span></span>
<span>(</span><span>*paths, format=None, list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False, path=b'path', **keywords)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L317-L422" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class XMLToPathExtractorUnit(PathExtractorUnit, abstract=True):
    def __init__(
        self, *paths,
        format: Param[str | None, Arg.String(&#39;-f&#39;, metavar=&#39;F&#39;, help=(
            &#39;A format expression to be applied for computing the path of an item. This must use &#39;
            &#39;metadata that is available on the item. The current tag can be accessed as {{tag}}. &#39;
            &#39;If no format is specified, the unit attempts to derive a good attribute from the XML &#39;
            &#39;tree to use for generating paths.&#39;
        ))] = None,
        list=False, join_path=False, drop_path=False, fuzzy=0, exact=False, regex=False,
        path=b&#39;path&#39;, **keywords
    ):
        super().__init__(
            *paths,
            format=format,
            list=list,
            path=path,
            join_path=join_path,
            drop_path=drop_path,
            fuzzy=fuzzy,
            exact=exact,
            regex=regex,
            **keywords
        )

    @staticmethod
    def _normalize_val(attr: str):
        _bad = &#39;[/\\$&amp;%#:.]&#39;
        attr = attr.replace(&#39;[&#39;, &#39;(&#39;)
        attr = attr.replace(&#39;]&#39;, &#39;)&#39;)
        attr = re.sub(F&#39;\\s*{_bad}+\\s+&#39;, &#39; &#39;, attr)
        attr = re.sub(F&#39;\\s*{_bad}+\\s*&#39;, &#39;.&#39;, attr)
        return attr.strip()

    @staticmethod
    def _normalize_key(attribute: str):
        a = attribute.rpartition(&#39;:&#39;)[2]
        a = re.sub(r&#39;[^\w]+&#39;, &#39;_&#39;, a)
        return a

    def _make_path_builder(
        self,
        meta: LazyMetaOracle,
        root: XMLNodeBase
    ) -&gt; Callable[[XMLNodeBase], str]:

        nfmt = self.args.format
        nkey = self._normalize_key
        nval = self._normalize_val
        nmap = {}

        if nfmt is None:
            def rank_attribute(attribute: str):
                length = len(attribute)
                scount = length - len(re.sub(r&#39;\s+&#39;, &#39;&#39;, attribute))
                return (1 / length, scount)

            def walk(node: XMLNodeBase):
                children = node.children
                __tags = set()
                for child in children:
                    if (tag := child.tag) not in __tags:
                        __tags.add(tag)
                        continue
                    candidates = [
                        candidate for candidate, count in Counter(
                            key for child in children for key, val in child.attributes.items()
                            if len(val) in range(2, 65) and re.fullmatch(R&#39;[-\s\w+,.;@()]+&#39;, nval(val))
                        ).items()
                        if count == len(children) == len(
                            {child.attributes[candidate] for child in children})
                    ]
                    break
                else:
                    candidates = None
                if not candidates:
                    attr = None
                else:
                    candidates.sort(key=rank_attribute)
                    attr = candidates[0]
                for child in children:
                    nmap[child.path] = attr
                    walk(child)

            walk(root)

        def path_builder(node: XMLNodeBase) -&gt; str:
            if node.tag is None:
                raise ValueError(F&#39;Attempt to format node without a tag: {node!r}&#39;)
            attrs = node.attributes
            if nfmt and meta is not None:
                try:
                    symbols = {nkey(key): nval(val) for key, val in attrs.items()}
                    return meta.format_str(nfmt, self.codec, [node.tag], symbols)
                except KeyError:
                    pass
            try:
                return nval(attrs[nmap[node.path]])
            except KeyError:
                index = node.index
                name = nval(node.tag)
                if index is not None:
                    name = F&#39;{index}.{name}&#39;
                return name

        return path_builder</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.PathExtractorUnit" href="#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></li>
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.html.xthtml" href="html.html#refinery.units.formats.html.xthtml">xthtml</a></li>
<li><a title="refinery.units.formats.xml.xtxml" href="xml.html#refinery.units.formats.xml.xtxml">xtxml</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.formats.PathExtractorUnit" href="#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.formats.PathExtractorUnit.CustomJoinBehaviour" href="#refinery.units.formats.PathExtractorUnit.CustomJoinBehaviour">CustomJoinBehaviour</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.CustomPathSeparator" href="#refinery.units.formats.PathExtractorUnit.CustomPathSeparator">CustomPathSeparator</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.FilterEverything" href="../index.html#refinery.units.UnitBase.FilterEverything">FilterEverything</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.Requires" href="../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.act" href="../index.html#refinery.units.Unit.act">act</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.codec" href="../index.html#refinery.units.Unit.codec">codec</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.console" href="../index.html#refinery.units.Unit.console">console</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.filter" href="../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.finish" href="../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.handles" href="../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.is_quiet" href="../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.is_reversible" href="../index.html#refinery.units.Unit.is_reversible">is_reversible</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.isatty" href="../index.html#refinery.units.Unit.isatty">isatty</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.labelled" href="../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.leniency" href="../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_always" href="../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_detach" href="../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_fail" href="../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.logger" href="../index.html#refinery.units.Unit.logger">logger</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.name" href="../index.html#refinery.units.Unit.name">name</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.optional_dependencies" href="../index.html#refinery.units.Unit.optional_dependencies">optional_dependencies</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.required_dependencies" href="../index.html#refinery.units.Unit.required_dependencies">required_dependencies</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.reset" href="../index.html#refinery.units.Unit.reset">reset</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.reverse" href="../index.html#refinery.units.UnitBase.reverse">reverse</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.formats.PathExtractorUnit.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.process" href="../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.units.formats.JSONTableUnit"><code class="flex name class">
<span>class <span class="ident">JSONTableUnit</span></span>
<span>(</span><span>tabular=False, minimal=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L425-L469" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class JSONTableUnit(Unit, abstract=True):

    def __init__(
        self,
        tabular: Param[bool, Arg.Switch(&#39;-t&#39;, group=&#39;OUT&#39;,
            help=&#39;Do not output JSON but a flattened ASCII table.&#39;)] = False,
        minimal: Param[bool, Arg.Switch(&#39;-m&#39;, group=&#39;OUT&#39;,
            help=&#39;Minify the JSON output instead of pretty-printing.&#39;)] = False,
        **kwargs
    ):
        super().__init__(tabular=tabular, minimal=minimal, **kwargs)

    @abc.abstractmethod
    def json(self, data: Chunk) -&gt; dict | None:
        ...

    def process(self, data: Chunk):
        if not (parsed := self.json(data)):
            return None
        if not self.args.tabular:
            pretty = not self.args.minimal
            yield libjson.dumps(parsed, pretty=pretty)
        else:
            import textwrap
            table = list(libjson.flattened(parsed))
            width = max(len(key) for key, _ in table)
            tsize = get_terminal_size(80) - width - 4
            for key, value in table:
                if isinstance(value, str):
                    value = value.strip()
                    if not value.isprintable() and all(ord(c) &lt; 0x100 for c in value):
                        value = value.encode(&#39;latin1&#39;).hex(&#39;:&#39;)
                elif isinstance(value, libjson.datetime):
                    value = value.isoformat(&#39; &#39;, &#39;seconds&#39;)
                else:
                    value = str(value).rstrip()
                value = textwrap.wrap(value, tsize)
                it = iter(value)
                try:
                    item = next(it)
                except StopIteration:
                    continue
                yield F&#39;{key:&lt;{width}} : {item}&#39;.encode(self.codec)
                for wrap in it:
                    yield F&#39;{&#34;&#34;:&lt;{width + 3}}{wrap}&#39;.encode(self.codec)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.idbmeta.idb" href="idbmeta.html#refinery.units.formats.idbmeta.idb">idb</a></li>
<li><a title="refinery.units.formats.lnk.lnk" href="lnk.html#refinery.units.formats.lnk.lnk">lnk</a></li>
<li><a title="refinery.units.formats.macho.machometa.machometa" href="macho/machometa.html#refinery.units.formats.macho.machometa.machometa">machometa</a></li>
<li><a title="refinery.units.formats.office.docmeta.docmeta" href="office/docmeta.html#refinery.units.formats.office.docmeta.docmeta">docmeta</a></li>
<li><a title="refinery.units.formats.pe.pemeta.pemeta" href="pe/pemeta.html#refinery.units.formats.pe.pemeta.pemeta">pemeta</a></li>
<li><a title="refinery.units.formats.pkcs7sig.pkcs7sig" href="pkcs7sig.html#refinery.units.formats.pkcs7sig.pkcs7sig">pkcs7sig</a></li>
<li><a title="refinery.units.sinks.ppjson.ppjson" href="../sinks/ppjson.html#refinery.units.sinks.ppjson.ppjson">ppjson</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.JSONTableUnit.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L437-L439" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def json(self, data: Chunk) -&gt; dict | None:
    ...</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.console" href="../index.html#refinery.units.Unit.console">console</a></code></li>
<li><code><a title="refinery.units.Unit.optional_dependencies" href="../index.html#refinery.units.Unit.optional_dependencies">optional_dependencies</a></code></li>
<li><code><a title="refinery.units.Unit.required_dependencies" href="../index.html#refinery.units.Unit.required_dependencies">required_dependencies</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.FilterEverything" href="../index.html#refinery.units.UnitBase.FilterEverything">FilterEverything</a></code></li>
<li><code><a title="refinery.units.Unit.Requires" href="../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.Unit.act" href="../index.html#refinery.units.Unit.act">act</a></code></li>
<li><code><a title="refinery.units.Unit.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.Unit.codec" href="../index.html#refinery.units.Unit.codec">codec</a></code></li>
<li><code><a title="refinery.units.Unit.finish" href="../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.Unit.handles" href="../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.Unit.is_quiet" href="../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.Unit.is_reversible" href="../index.html#refinery.units.Unit.is_reversible">is_reversible</a></code></li>
<li><code><a title="refinery.units.Unit.isatty" href="../index.html#refinery.units.Unit.isatty">isatty</a></code></li>
<li><code><a title="refinery.units.Unit.labelled" href="../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.Unit.leniency" href="../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.Unit.log_always" href="../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.Unit.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.Unit.log_detach" href="../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.Unit.log_fail" href="../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.Unit.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.Unit.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.Unit.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.Unit.logger" href="../index.html#refinery.units.Unit.logger">logger</a></code></li>
<li><code><a title="refinery.units.Unit.name" href="../index.html#refinery.units.Unit.name">name</a></code></li>
<li><code><a title="refinery.units.Unit.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.Unit.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.Unit.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.Unit.reset" href="../index.html#refinery.units.Unit.reset">reset</a></code></li>
<li><code><a title="refinery.units.Unit.reverse" href="../index.html#refinery.units.UnitBase.reverse">reverse</a></code></li>
<li><code><a title="refinery.units.Unit.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.Unit.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.Unit.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.process" href="../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.filter" href="../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.units.formats.JSONEncoderUnit"><code class="flex name class">
<span>class <span class="ident">JSONEncoderUnit</span></span>
<span>(</span><span>encode=None, digest=None, arrays=False, **keywords)</span>
</code></dt>
<dd>
<section class="desc"><p>An abstract unit that provides the interface for displaying parsed data as JSON. By default,
binary data is converted to latin1 strings.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L472-L518" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class JSONEncoderUnit(Unit, abstract=True):
    &#34;&#34;&#34;
    An abstract unit that provides the interface for displaying parsed data as JSON. By default,
    binary data is converted to latin1 strings.
    &#34;&#34;&#34;
    def __init__(
        self,
        encode: Param[str | None, Arg.String(&#39;-e&#39;, group=&#39;BIN&#39;, metavar=&#39;U&#39;, help=(
            &#39;Select an encoder unit used to represent binary data in the JSON output. This unit &#39;
            &#39;must be reversible and produce UTF8 encoded string output when operated in reverse.&#39;
            &#39; Common examples are hex and b64.&#39;))] = None,
        digest: Param[str | None, Arg.String(&#39;-d&#39;, group=&#39;BIN&#39;, metavar=&#39;U&#39;, help=(
            &#39;Select a hashing unit to digest all byte strings: Instead of the data, only the hash &#39;
            &#39;will be displayed.&#39;))] = None,
        arrays: Param[bool, Arg.Switch(&#39;-a&#39;, group=&#39;BIN&#39;, help=(
            &#39;Encode all byte strings as integer arrays. These arrays will have unsigned integer &#39;
            &#39;entires between 0 and 255.&#39;))] = False,
        **keywords
    ):
        if sum(1 for x in (encode, digest, arrays) if x) &gt; 1:
            raise ValueError(&#39;Can only set one option for byte string encoding.&#39;)
        super().__init__(encode=encode, digest=digest, arrays=arrays, **keywords)

    def to_json(self, obj, checks: bool = True) -&gt; bytes:
        if self.args.arrays:
            _byte_converter = list
        elif u := self.args.encode:
            def _encode(o: buf):
                return o | unit | str
            unit = load(u, reverse=True)
            _byte_converter = _encode
        elif u := self.args.digest:
            def _digest(o: buf):
                return o | unit | str
            unit = load(u, test=True)
            _byte_converter = _digest
        else:
            def _str_encode(o: buf):
                return codecs.decode(o, encoding=&#39;latin1&#39;)
            _byte_converter = _str_encode

        def default(o: buf):
            if isbuffer(o):
                return _byte_converter(o)
            return libjson.standard_conversions(o)

        return libjson.dumps(obj, tojson=default, checks=checks)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.asn1.asn1" href="asn1.html#refinery.units.formats.asn1.asn1">asn1</a></li>
<li><a title="refinery.units.formats.cbor.cbor" href="cbor.html#refinery.units.formats.cbor.cbor">cbor</a></li>
<li><a title="refinery.units.formats.pbuf.pbuf" href="pbuf.html#refinery.units.formats.pbuf.pbuf">pbuf</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnds.dnds" href="pe/dotnet/dnds.html#refinery.units.formats.pe.dotnet.dnds.dnds">dnds</a></li>
<li><a title="refinery.units.formats.pe.dotnet.dnhdr.dnhdr" href="pe/dotnet/dnhdr.html#refinery.units.formats.pe.dotnet.dnhdr.dnhdr">dnhdr</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.formats.JSONEncoderUnit.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, obj, checks=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/units/formats/__init__.py#L495-L518" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def to_json(self, obj, checks: bool = True) -&gt; bytes:
    if self.args.arrays:
        _byte_converter = list
    elif u := self.args.encode:
        def _encode(o: buf):
            return o | unit | str
        unit = load(u, reverse=True)
        _byte_converter = _encode
    elif u := self.args.digest:
        def _digest(o: buf):
            return o | unit | str
        unit = load(u, test=True)
        _byte_converter = _digest
    else:
        def _str_encode(o: buf):
            return codecs.decode(o, encoding=&#39;latin1&#39;)
        _byte_converter = _str_encode

    def default(o: buf):
        if isbuffer(o):
            return _byte_converter(o)
        return libjson.standard_conversions(o)

    return libjson.dumps(obj, tojson=default, checks=checks)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.Unit" href="../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.FilterEverything" href="../index.html#refinery.units.UnitBase.FilterEverything">FilterEverything</a></code></li>
<li><code><a title="refinery.units.Unit.Requires" href="../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.Unit.act" href="../index.html#refinery.units.Unit.act">act</a></code></li>
<li><code><a title="refinery.units.Unit.assemble" href="../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.Unit.codec" href="../index.html#refinery.units.Unit.codec">codec</a></code></li>
<li><code><a title="refinery.units.Unit.console" href="../index.html#refinery.units.Unit.console">console</a></code></li>
<li><code><a title="refinery.units.Unit.finish" href="../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.Unit.handles" href="../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.Unit.is_quiet" href="../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.Unit.is_reversible" href="../index.html#refinery.units.Unit.is_reversible">is_reversible</a></code></li>
<li><code><a title="refinery.units.Unit.isatty" href="../index.html#refinery.units.Unit.isatty">isatty</a></code></li>
<li><code><a title="refinery.units.Unit.labelled" href="../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.Unit.leniency" href="../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.Unit.log_always" href="../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.Unit.log_debug" href="../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.Unit.log_detach" href="../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.Unit.log_fail" href="../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.Unit.log_info" href="../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.Unit.log_level" href="../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.Unit.log_warn" href="../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.Unit.logger" href="../index.html#refinery.units.Unit.logger">logger</a></code></li>
<li><code><a title="refinery.units.Unit.name" href="../index.html#refinery.units.Unit.name">name</a></code></li>
<li><code><a title="refinery.units.Unit.nozzle" href="../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.Unit.optional_dependencies" href="../index.html#refinery.units.Unit.optional_dependencies">optional_dependencies</a></code></li>
<li><code><a title="refinery.units.Unit.read" href="../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.Unit.read1" href="../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.Unit.required_dependencies" href="../index.html#refinery.units.Unit.required_dependencies">required_dependencies</a></code></li>
<li><code><a title="refinery.units.Unit.reset" href="../index.html#refinery.units.Unit.reset">reset</a></code></li>
<li><code><a title="refinery.units.Unit.reverse" href="../index.html#refinery.units.UnitBase.reverse">reverse</a></code></li>
<li><code><a title="refinery.units.Unit.run" href="../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.Unit.source" href="../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.Unit.superinit" href="../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.filter" href="../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.UnitBase.process" href="../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units" href="../index.html">refinery.units</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="refinery.units.formats.a3x" href="a3x.html">refinery.units.formats.a3x</a></code></li>
<li><code><a title="refinery.units.formats.archive" href="archive/index.html">refinery.units.formats.archive</a></code></li>
<li><code><a title="refinery.units.formats.asn1" href="asn1.html">refinery.units.formats.asn1</a></code></li>
<li><code><a title="refinery.units.formats.bat" href="bat.html">refinery.units.formats.bat</a></code></li>
<li><code><a title="refinery.units.formats.cbor" href="cbor.html">refinery.units.formats.cbor</a></code></li>
<li><code><a title="refinery.units.formats.csv" href="csv.html">refinery.units.formats.csv</a></code></li>
<li><code><a title="refinery.units.formats.deserialize_php" href="deserialize_php.html">refinery.units.formats.deserialize_php</a></code></li>
<li><code><a title="refinery.units.formats.dexstr" href="dexstr.html">refinery.units.formats.dexstr</a></code></li>
<li><code><a title="refinery.units.formats.email" href="email.html">refinery.units.formats.email</a></code></li>
<li><code><a title="refinery.units.formats.evtx" href="evtx.html">refinery.units.formats.evtx</a></code></li>
<li><code><a title="refinery.units.formats.exe" href="exe/index.html">refinery.units.formats.exe</a></code></li>
<li><code><a title="refinery.units.formats.hexload" href="hexload.html">refinery.units.formats.hexload</a></code></li>
<li><code><a title="refinery.units.formats.html" href="html.html">refinery.units.formats.html</a></code></li>
<li><code><a title="refinery.units.formats.httprequest" href="httprequest.html">refinery.units.formats.httprequest</a></code></li>
<li><code><a title="refinery.units.formats.httpresponse" href="httpresponse.html">refinery.units.formats.httpresponse</a></code></li>
<li><code><a title="refinery.units.formats.idbmeta" href="idbmeta.html">refinery.units.formats.idbmeta</a></code></li>
<li><code><a title="refinery.units.formats.ifps" href="ifps.html">refinery.units.formats.ifps</a></code></li>
<li><code><a title="refinery.units.formats.ifpsstr" href="ifpsstr.html">refinery.units.formats.ifpsstr</a></code></li>
<li><code><a title="refinery.units.formats.imgdb" href="imgdb.html">refinery.units.formats.imgdb</a></code></li>
<li><code><a title="refinery.units.formats.imgto" href="imgto.html">refinery.units.formats.imgto</a></code></li>
<li><code><a title="refinery.units.formats.imgtp" href="imgtp.html">refinery.units.formats.imgtp</a></code></li>
<li><code><a title="refinery.units.formats.java" href="java/index.html">refinery.units.formats.java</a></code></li>
<li><code><a title="refinery.units.formats.jpeg" href="jpeg.html">refinery.units.formats.jpeg</a></code></li>
<li><code><a title="refinery.units.formats.json" href="json.html">refinery.units.formats.json</a></code></li>
<li><code><a title="refinery.units.formats.lnk" href="lnk.html">refinery.units.formats.lnk</a></code></li>
<li><code><a title="refinery.units.formats.macho" href="macho/index.html">refinery.units.formats.macho</a></code></li>
<li><code><a title="refinery.units.formats.msgpack" href="msgpack.html">refinery.units.formats.msgpack</a></code></li>
<li><code><a title="refinery.units.formats.msi" href="msi.html">refinery.units.formats.msi</a></code></li>
<li><code><a title="refinery.units.formats.office" href="office/index.html">refinery.units.formats.office</a></code></li>
<li><code><a title="refinery.units.formats.pbuf" href="pbuf.html">refinery.units.formats.pbuf</a></code></li>
<li><code><a title="refinery.units.formats.pcap" href="pcap.html">refinery.units.formats.pcap</a></code></li>
<li><code><a title="refinery.units.formats.pcap_http" href="pcap_http.html">refinery.units.formats.pcap_http</a></code></li>
<li><code><a title="refinery.units.formats.pdf" href="pdf.html">refinery.units.formats.pdf</a></code></li>
<li><code><a title="refinery.units.formats.pdfcrypt" href="pdfcrypt.html">refinery.units.formats.pdfcrypt</a></code></li>
<li><code><a title="refinery.units.formats.pe" href="pe/index.html">refinery.units.formats.pe</a></code></li>
<li><code><a title="refinery.units.formats.pkcs7" href="pkcs7.html">refinery.units.formats.pkcs7</a></code></li>
<li><code><a title="refinery.units.formats.pkcs7sig" href="pkcs7sig.html">refinery.units.formats.pkcs7sig</a></code></li>
<li><code><a title="refinery.units.formats.pyc" href="pyc.html">refinery.units.formats.pyc</a></code></li>
<li><code><a title="refinery.units.formats.pym" href="pym.html">refinery.units.formats.pym</a></code></li>
<li><code><a title="refinery.units.formats.pymstr" href="pymstr.html">refinery.units.formats.pymstr</a></code></li>
<li><code><a title="refinery.units.formats.qr" href="qr.html">refinery.units.formats.qr</a></code></li>
<li><code><a title="refinery.units.formats.sqlite" href="sqlite.html">refinery.units.formats.sqlite</a></code></li>
<li><code><a title="refinery.units.formats.stego" href="stego.html">refinery.units.formats.stego</a></code></li>
<li><code><a title="refinery.units.formats.winreg" href="winreg.html">refinery.units.formats.winreg</a></code></li>
<li><code><a title="refinery.units.formats.xml" href="xml.html">refinery.units.formats.xml</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.units.formats.pathspec" href="#refinery.units.formats.pathspec">pathspec</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.formats.UnpackResult" href="#refinery.units.formats.UnpackResult">UnpackResult</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.UnpackResult.get_data" href="#refinery.units.formats.UnpackResult.get_data">get_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.EndOfStringNotFound" href="#refinery.units.formats.EndOfStringNotFound">EndOfStringNotFound</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.PathPattern" href="#refinery.units.formats.PathPattern">PathPattern</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.PathPattern.compile" href="#refinery.units.formats.PathPattern.compile">compile</a></code></li>
<li><code><a title="refinery.units.formats.PathPattern.reach" href="#refinery.units.formats.PathPattern.reach">reach</a></code></li>
<li><code><a title="refinery.units.formats.PathPattern.check" href="#refinery.units.formats.PathPattern.check">check</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.PathExtractorUnit" href="#refinery.units.formats.PathExtractorUnit">PathExtractorUnit</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.PathExtractorUnit.unpack" href="#refinery.units.formats.PathExtractorUnit.unpack">unpack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.XMLToPathExtractorUnit" href="#refinery.units.formats.XMLToPathExtractorUnit">XMLToPathExtractorUnit</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.formats.JSONTableUnit" href="#refinery.units.formats.JSONTableUnit">JSONTableUnit</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.JSONTableUnit.json" href="#refinery.units.formats.JSONTableUnit.json">json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.formats.JSONEncoderUnit" href="#refinery.units.formats.JSONEncoderUnit">JSONEncoderUnit</a></code></h4>
<ul class="">
<li><code><a title="refinery.units.formats.JSONEncoderUnit.to_json" href="#refinery.units.formats.JSONEncoderUnit.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
