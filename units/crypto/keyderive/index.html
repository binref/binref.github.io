<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.units.crypto.keyderive documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.units.crypto.keyderive</code></h1>
</header>
<section id="section-intro">
<p>Implements key derivation routines. These are mostly meant to be used as
modifiers for multibin expressions that can be passed as key arguments to
modules in <code><a title="refinery.units.crypto.cipher" href="../cipher/index.html">refinery.units.crypto.cipher</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/crypto/keyderive/__init__.py#L1-L72" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Implements key derivation routines. These are mostly meant to be used as
modifiers for multibin expressions that can be passed as key arguments to
modules in `refinery.units.crypto.cipher`.
&#34;&#34;&#34;
from __future__ import annotations

import importlib

from enum import Enum
from typing import TYPE_CHECKING, Callable, cast

from refinery.lib.types import Param, buf
from refinery.units import Arg, Unit

if TYPE_CHECKING:
    from typing import Protocol

    class _Hash(Protocol):
        def update(self, data: buf): ...
        def digest(self) -&gt; buf: ...
        def hexdigest(self) -&gt; str: ...

    class _HashModule(Protocol):
        def new(self, data=None) -&gt; _Hash: ...


__all__ = [&#39;Arg&#39;, &#39;HASH&#39;, &#39;KeyDerivation&#39;]


class HASH(str, Enum):
    MD2 = &#39;MD2&#39;
    MD4 = &#39;MD4&#39;
    MD5 = &#39;MD5&#39;
    SHA1 = &#39;SHA&#39;
    SHA256 = &#39;SHA256&#39;
    SHA512 = &#39;SHA512&#39;
    SHA224 = &#39;SHA224&#39;
    SHA384 = &#39;SHA384&#39;


def multidecode(data: buf, function: Callable[[str], buf]) -&gt; buf:
    for codec in [&#39;utf8&#39;, &#39;latin1&#39;, &#39;cp1252&#39;]:
        try:
            return function(data.decode(codec))
        except UnicodeError:
            continue
    else:
        return function(&#39;&#39;.join(chr(t) for t in data))


class KeyDerivation(Unit, abstract=True):

    def __init__(
        self,
        size: Param[int, Arg.Number(help=&#39;The number of bytes to generate.&#39;)],
        salt: Param[buf, Arg.Binary(help=&#39;Salt for the derivation.&#39;)],
        hash: Param[str, Arg.Option(choices=HASH, metavar=&#39;hash&#39;,
            help=&#39;Specify one of these algorithms (default is {default}): {choices}&#39;)] = HASH.SHA1,
        iter: Param[int, Arg.Number(metavar=&#39;iter&#39;,
            help=&#39;Number of iterations; default is {default}.&#39;)] = 0,
        **kw
    ):
        if hash is not None:
            hash = Arg.AsOption(hash, HASH)
        return super().__init__(salt=salt, size=size, iter=iter, hash=hash, **kw)

    @property
    def hash(self) -&gt; _HashModule:
        name = self.args.hash.value
        hash = importlib.import_module(F&#39;Cryptodome.Hash.{name}&#39;)
        return cast(&#39;_HashModule&#39;, hash)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="refinery.units.crypto.keyderive.argon2id" href="argon2id.html">refinery.units.crypto.keyderive.argon2id</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.crypto.keyderive.deskd" href="deskd.html">refinery.units.crypto.keyderive.deskd</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.crypto.keyderive.hkdf" href="hkdf.html">refinery.units.crypto.keyderive.hkdf</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.crypto.keyderive.hmac" href="hmac.html">refinery.units.crypto.keyderive.hmac</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.crypto.keyderive.kblob" href="kblob.html">refinery.units.crypto.keyderive.kblob</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.crypto.keyderive.mscdk" href="mscdk.html">refinery.units.crypto.keyderive.mscdk</a></code></dt>
<dd>
<section class="desc"><p>Reference:
<a href="https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptderivekey">https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptderivekey</a></p></section>
</dd>
<dt><code class="name"><a title="refinery.units.crypto.keyderive.mspdb" href="mspdb.html">refinery.units.crypto.keyderive.mspdb</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.crypto.keyderive.pbkdf1" href="pbkdf1.html">refinery.units.crypto.keyderive.pbkdf1</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.crypto.keyderive.pbkdf2" href="pbkdf2.html">refinery.units.crypto.keyderive.pbkdf2</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.units.crypto.keyderive.unixcrypt" href="unixcrypt.html">refinery.units.crypto.keyderive.unixcrypt</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.units.crypto.keyderive.Arg"><code class="flex name class">
<span>class <span class="ident">Arg</span></span>
<span>(</span><span>*args, action=refinery.units.Arg.omit, choices=refinery.units.Arg.omit, const=refinery.units.Arg.omit, default=refinery.units.Arg.omit, dest=refinery.units.Arg.omit, help=refinery.units.Arg.omit, metavar=refinery.units.Arg.omit, nargs=refinery.units.Arg.omit, required=refinery.units.Arg.omit, type=refinery.units.Arg.omit, group=None, guessed=None)</span>
</code></dt>
<dd>
<section class="desc"><p>This class is specifically an argument for the <code>add_argument</code> method of an <code>ArgumentParser</code> from
the <code>argparse</code> module. It can also be used as a decorator or annotation for the constructor of a
refinery unit to better control the argument parser of that unit's command line interface.
Example:</p>
<pre><code>class prefixer(Unit):
    def __init__(
        self,
        prefix: Arg.Binary(help='This data will be prepended to the input.')
    ): ...
    def process(self, data):
        return self.args.prefix + data
</code></pre>
<p>Note that when the init of a unit has a return annotation that is a base class of itself, then
all its parameters will automatically be forwarded to that base class.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/__init__.py#L277-L841" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Arg(Argument):
    &#34;&#34;&#34;
    This class is specifically an argument for the `add_argument` method of an `ArgumentParser` from
    the `argparse` module. It can also be used as a decorator or annotation for the constructor of a
    refinery unit to better control the argument parser of that unit&#39;s command line interface.
    Example:
    ```
    class prefixer(Unit):
        def __init__(
            self,
            prefix: Arg.Binary(help=&#39;This data will be prepended to the input.&#39;)
        ): ...
        def process(self, data):
            return self.args.prefix + data
    ```
    Note that when the init of a unit has a return annotation that is a base class of itself, then
    all its parameters will automatically be forwarded to that base class.
    &#34;&#34;&#34;

    class delete:
        &#34;&#34;&#34;
        A sentinel class to mark deleted arguments for the argument parser.
        &#34;&#34;&#34;

    class omit:
        &#34;&#34;&#34;
        A sentinel class to mark arguments as omitted for the argument parser.
        &#34;&#34;&#34;

    args: list[str]

    __slots__ = &#39;args&#39;, &#39;group&#39;, &#39;guessed&#39;

    def __init__(
        self, *args: str,
            action   : type[omit] | str                     = omit, # noqa
            choices  : type[omit] | Iterable[Any]           = omit, # noqa
            const    : type[omit] | Any                     = omit, # noqa
            default  : type[omit] | Any                     = omit, # noqa
            dest     : type[omit] | str                     = omit, # noqa
            help     : type[omit] | str                     = omit, # noqa
            metavar  : type[omit] | str                     = omit, # noqa
            nargs    : type[omit] | type[delete] | int | str  = omit, # noqa
            required : type[omit] | bool                    = omit, # noqa
            type     : type[omit] | type | Callable          = omit, # noqa
            group    : str | None                              = None, # noqa
            guessed  : set[str] | None                         = None, # noqa
    ) -&gt; None:
        kwargs = dict(action=action, choices=choices, const=const, default=default, dest=dest,
            help=help, metavar=metavar, nargs=nargs, required=required, type=type)
        kwargs = {key: value for key, value in kwargs.items() if value is not self.omit}
        self.group = group
        self.guessed = set(guessed or ())
        super().__init__(*args, **kwargs)

    def update_help(self):
        &#34;&#34;&#34;
        This method is called to format the help text of the argument retroactively. The primary
        purpose is to fill in default arguments via the formatting symbol `{default}`. These
        default values are not necessarily part of the `refinery.units.Arg` object itself: They
        may be a default value in the `__init__` function of the `refinery.units.Unit` subclass.
        Therefore, it is necessary to format the help text after all information has been
        compiled.
        &#34;&#34;&#34;
        class formatting(dict):
            arg = self

            def __missing__(self, key):
                if key == &#39;choices&#39;:
                    return &#39;, &#39;.join(self.arg.kwargs[&#39;choices&#39;])
                if key == &#39;default&#39;:
                    default: bytes | int | str | slice = self.arg.kwargs[&#39;default&#39;]
                    if isinstance(default, (list, tuple, set)):
                        if not default:
                            return &#39;empty&#39;
                        elif len(default) == 1:
                            default = next(iter(default))
                    if isinstance(default, slice):
                        parts = [default.start or &#39;&#39;, default.stop or &#39;&#39;, default.step]
                        default = &#39;:&#39;.join(str(x) for x in parts if x is not None)
                    if isinstance(default, int):
                        return default
                    if isinstance(default, str) or not isbuffer(default):
                        return default
                    default = bytes(default)
                    if default.isalnum():
                        return default.decode(&#39;latin-1&#39;)
                    return F&#39;H:{default.hex()}&#39;
                if key == &#39;varname&#39;:
                    return self.arg.kwargs.get(&#39;metavar&#39;, self.arg.destination)

        try:
            help_string: str = self.kwargs[&#39;help&#39;]
            self.kwargs.update(
                help=help_string.format_map(formatting()))
        except Exception:
            pass

    def __rmatmul__(self, method):
        self.update_help()
        return super().__rmatmul__(method)

    @staticmethod
    def AsRegExp(
        codec: str,
        regex: str | buf,
        flags: int = 0
    ):
        import re
        if isinstance(regex, str):
            regex = regex.encode(codec)
        else:
            regex = bytes(regex)
        return re.compile(regex, flags=flags)

    @overload
    @staticmethod
    def AsOption(value: _E, cls: type[_E]) -&gt; _E:
        ...

    @overload
    @staticmethod
    def AsOption(value: type[None], cls: type[_E]) -&gt; None:
        ...

    @overload
    @staticmethod
    def AsOption(value: str | None | _E, cls: type[_E]) -&gt; _E:
        ...

    @staticmethod
    def AsOption(value, cls: type[_E]) -&gt; _E | None:
        &#34;&#34;&#34;
        This method converts the input `value` to an instance of the enum `cls`. It is intended to
        be used on values that are passed as an argument marked with the `refinery.units.Arg.Option`
        decorator. If the input value is `None` or already an instance of `cls`, it is returned
        unchanged. Otherwise, the function attempts to find an element of the enumeration that
        matches the input, either by name or by value.
        &#34;&#34;&#34;
        if value is None or isinstance(value, cls):
            return value
        if isinstance(value, str):
            try:
                return cls[value]
            except KeyError:
                pass
            needle = normalize_to_identifier(value).casefold()
            for item in cls.__members__:
                if not isinstance(item, str):
                    break
                if item.casefold() == needle:
                    return cls[item]
        try:
            return cls(value)
        except Exception as E:
            choices = &#39;, &#39;.join(normalize_to_display(m) for m in cls.__members__)
            raise ValueError(F&#39;Could not transform {value} into {cls.__name__}; the choices are: {choices}&#39;) from E

    @classmethod
    def Delete(cls):
        &#34;&#34;&#34;
        This should be specified when the argument is present for a (potentially abstract) parent
        unit but should be removed on the child.
        &#34;&#34;&#34;
        return cls(nargs=cls.delete)

    @classmethod
    def Counts(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        A convenience method to add argparse arguments that introduce a counter.
        &#34;&#34;&#34;
        return cls(*args, group=group, help=help, dest=dest, action=&#39;count&#39;)

    @classmethod
    def Switch(
        cls,
        *args   : str, off=False,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        A convenience method to add argparse arguments that change a boolean value from True to False or
        vice versa. By default, a switch will have a False default and change it to True when specified.
        &#34;&#34;&#34;
        return cls(*args, group=group, help=help, dest=dest, action=&#39;store_false&#39; if off else &#39;store_true&#39;)

    @classmethod
    def FsPath(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain path patterns.
        &#34;&#34;&#34;
        if metavar is cls.omit and any(&#39;-&#39; in a for a in args):
            metavar = &#39;B&#39;
        return cls(*args, group=group, help=help, dest=dest, nargs=nargs, type=pathvar, metavar=metavar)

    @classmethod
    def Binary(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain binary data.
        &#34;&#34;&#34;
        if metavar is cls.omit and any(&#39;-&#39; in a for a in args):
            metavar = &#39;B&#39;
        return cls(*args, group=group, help=help, dest=dest, nargs=nargs, type=multibin, metavar=metavar)

    @classmethod
    def String(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        default : type[omit] | str | tuple[str, ...] = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain string data.
        &#34;&#34;&#34;
        if metavar is cls.omit and any(&#39;-&#39; in a for a in args):
            metavar = &#39;STR&#39;
        return cls(*args, group=group, default=default, help=help, dest=dest, nargs=nargs, type=str, metavar=metavar)

    @classmethod
    def RegExp(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a regular expression.
        &#34;&#34;&#34;
        if metavar is None and any(&#39;-&#39; in a for a in args):
            metavar = &#39;REGEX&#39;
        return cls(*args, group=group, help=help, dest=dest, nargs=nargs, type=regexp, metavar=metavar)

    @classmethod
    def NumSeq(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        check   : bool = True,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a numeric sequence.
        &#34;&#34;&#34;
        t = numseq if check else partial(numseq, typecheck=False)
        return cls(*args, group=group, help=help, nargs=nargs, dest=dest, type=t, metavar=metavar)

    @classmethod
    def Bounds(
        cls,
        *args   : str,
        help    : type[omit] | str | None = None,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        default : type[omit] | Any = omit,
        intok   : bool = False,
        metavar : type[omit] | str = &#39;start:end:step&#39;,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a slice.
        &#34;&#34;&#34;
        def parser(t: str):
            return sliceobj(t, intok=intok)
        if help is None:
            help = &#39;Specify start:end:step in Python slice syntax.&#39;
            if default is not cls.omit:
                help = F&#39;{help} The default is {{default}}.&#39;
        return cls(*args, group=group, help=help, default=default, nargs=nargs, dest=dest, type=parser, metavar=metavar)

    @classmethod
    def Double(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a floating point number.
        &#34;&#34;&#34;
        return cls(*args, group=group, help=help, dest=dest, type=percent, metavar=metavar)

    @classmethod
    def Number(
        cls,
        *args   : str,
        bound   : type[omit] | tuple[int, int] = omit,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a number.
        &#34;&#34;&#34;
        nt = number
        if bound is not cls.omit:
            assert isinstance(bound, tuple)
            lower, upper = bound
            nt = nt[lower:upper]
        if metavar is cls.omit:
            metavar = &#39;N&#39;
        return cls(*args, group=group, help=help, dest=dest, type=nt, metavar=metavar)

    @classmethod
    def Option(
        cls,
        *args   : str,
        choices : type[Enum],
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments with a fixed set of options, based on an enumeration.
        &#34;&#34;&#34;
        cnames = [normalize_to_display(c).casefold() for c in choices.__members__]
        metavar = metavar or choices.__name__
        return cls(*args, group=group, help=help, metavar=metavar, dest=dest, choices=cnames, type=str.casefold)

    @classmethod
    def Choice(
        cls,
        *args   : str,
        choices : list[str],
        help    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        type    : type | Callable = str.lower,
        nargs   : type[omit] | int | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments with a fixed set of options, based on a list of strings.
        &#34;&#34;&#34;
        return cls(*args, group=group, type=type, metavar=metavar, nargs=nargs,
            dest=dest, help=help, choices=choices)

    @property
    def positional(self) -&gt; bool:
        &#34;&#34;&#34;
        Indicates whether the argument is positional. This is crudely determined by whether it has
        a specifier that does not start with a dash.
        &#34;&#34;&#34;
        return any(a[0] != &#39;-&#39; for a in self.args)

    @property
    def destination(self) -&gt; str:
        &#34;&#34;&#34;
        The name of the variable where the contents of this parsed argument will be stored.
        &#34;&#34;&#34;
        for a in self.args:
            if a[0] != &#39;-&#39;:
                return a
        try:
            return self.kwargs[&#39;dest&#39;]
        except KeyError:
            for a in self.args:
                if a.startswith(&#39;--&#39;):
                    dest = normalize_to_identifier(a)
                    if dest.isidentifier():
                        return dest
            raise AttributeError(F&#39;The argument with these values has no destination: {self!r}&#39;)

    @classmethod
    def Infer(cls, pt: inspect.Parameter, module: str | None = None):
        &#34;&#34;&#34;
        This class method can be used to infer the argparse argument for a Python function
        parameter. This guess is based on the annotation, name, and default value.
        &#34;&#34;&#34;

        def needs_type(item: dict[str, str]):
            return item.get(&#39;action&#39;, &#39;store&#39;) == &#39;store&#39;

        def get_argp_type(at):
            if at is type(None):
                return None
            if issubclass(at, tuple):
                return numseq
            if issubclass(at, (bytes, bytearray, memoryview)):
                return multibin
            if issubclass(at, int):
                return number
            if issubclass(at, slice):
                return sliceobj
            if issubclass(at, float):
                return percent
            return at

        name = normalize_to_display(pt.name, False)
        default = pt.default
        empty = pt.empty
        guessed_pos_args = []
        guessed_kwd_args: dict[str, Any] = dict(dest=pt.name)
        guessed = set()
        annotation = pt.annotation

        def guess(key, value):
            try:
                return guessed_kwd_args[key]
            except KeyError:
                guessed_kwd_args[key] = value
                guessed.add(key)
                return value

        if isinstance(annotation, str):
            if module is None:
                _symbols = None
            else:
                __import__(module)
                _symbols = sys.modules[module].__dict__
            try:
                annotation = evaluate(annotation, _symbols)
            except Exception:
                pass

        if annotation is not empty:
            if isinstance(annotation, Arg):
                if annotation.kwargs.get(&#39;dest&#39;, pt.name) != pt.name:
                    raise ValueError(
                        F&#39;Incompatible argument destination specified; parameter {pt.name} &#39;
                        F&#39;was annotated with {annotation!r}.&#39;)
                guessed_pos_args = annotation.args
                guessed_kwd_args.update(annotation.kwargs)
                guessed_kwd_args.update(group=annotation.group)
            elif isinstance(annotation, type):
                guessed.add(&#39;type&#39;)
                if not issubclass(annotation, bool) and needs_type(guessed_kwd_args):
                    guessed_kwd_args.update(type=get_argp_type(annotation))
                elif not isinstance(default, bool):
                    raise ValueError(&#39;Default value for boolean arguments must be provided.&#39;)

        if not guessed_pos_args:
            guessed_pos_args = guessed_pos_args or [F&#39;--{name}&#39; if pt.kind is pt.KEYWORD_ONLY else name]

        if pt.kind is pt.VAR_POSITIONAL:
            oldnargs = guess(&#39;nargs&#39;, ZERO_OR_MORE)
            if oldnargs not in (ONE_OR_MORE, ZERO_OR_MORE, REMAINDER):
                raise ValueError(F&#39;Variadic positional arguments has nargs set to {oldnargs!r}&#39;)
            return cls(*guessed_pos_args, **guessed_kwd_args)

        if default is not empty:
            if isinstance(default, Enum):
                default = default.name

            guess(&#39;default&#39;, default)

            if isinstance(default, list):
                guess(&#39;nargs&#39;, ZERO_OR_MORE)
            elif pt.kind is pt.POSITIONAL_ONLY:
                guess(&#39;nargs&#39;, OPTIONAL)

            if isinstance(default, bool):
                guessed_kwd_args[&#39;action&#39;] = F&#39;store_{not default!s}&#39;.lower()
            elif needs_type(guessed_kwd_args):
                if isinstance(default, list) and default:
                    default = default[0]
                guess(&#39;type&#39;, get_argp_type(type(default)))

        return cls(*guessed_pos_args, **guessed_kwd_args, guessed=guessed)

    def merge_args(self, them: Argument) -&gt; None:
        &#34;&#34;&#34;
        Merge the `args` component of another `refinery.units.Argument` into this one without
        overwriting or removing any of the `args` in this instance.
        &#34;&#34;&#34;
        def iterboth():
            yield from them.args
            yield from self.args
        if not self.args:
            self.args = list(them.args)
            return
        sflag = None
        lflag = None
        for a in iterboth():
            if a[:2] == &#39;--&#39;:
                lflag = lflag or a
            elif a[0] == &#39;-&#39;:
                sflag = sflag or a
        self.args = []
        if sflag:
            self.args.append(sflag)
        if lflag:
            self.args.append(lflag)
        if not self.args:
            self.args = list(them.args)

    def merge_all(self, them: Arg) -&gt; None:
        &#34;&#34;&#34;
        Merge another `refinery.units.Arg` into the current instance. This is an additive process
        where no data on the present instance is destroyed unless `refinery.units.Arg.Delete` was
        used on `them` to explicitly remove an option.
        &#34;&#34;&#34;
        for key, value in them.kwargs.items():
            if value is Arg.delete:
                self.kwargs.pop(key, None)
                self.guessed.discard(key)
                continue
            if key in them.guessed:
                if key not in self.guessed:
                    if key == &#39;type&#39; and self.kwargs.get(&#39;action&#39;, None) != &#39;store&#39;:
                        continue
                    if key in self.kwargs:
                        continue
                self.guessed.add(key)
            self.kwargs[key] = value
        self.merge_args(them)
        self.group = them.group or self.group

    def __copy__(self) -&gt; Argument:
        cls = self.__class__
        clone = cls.__new__(cls)
        clone.kwargs = dict(self.kwargs)
        clone.args = list(self.args)
        clone.group = self.group
        clone.guessed = set(self.guessed)
        return clone

    def __repr__(self) -&gt; str:
        return F&#39;{self.__class__.__name__}({super().__repr__()})&#39;

    def __call__(self, init: Callable) -&gt; Callable:
        parameters = inspect.signature(init).parameters
        try:
            inferred = Arg.Infer(parameters[self.destination])
            inferred.merge_all(self)
            init.__annotations__[self.destination] = inferred
        except KeyError:
            raise ValueError(F&#39;Unable to decorate because no parameter with name {self.destination} exists.&#39;)
        return init</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Argument" href="../../index.html#refinery.units.Argument">Argument</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.crypto.keyderive.Arg.delete"><code class="name">var <span class="ident">delete</span></code></dt>
<dd>
<section class="desc"><p>A sentinel class to mark deleted arguments for the argument parser.</p></section>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.omit"><code class="name">var <span class="ident">omit</span></code></dt>
<dd>
<section class="desc"><p>A sentinel class to mark arguments as omitted for the argument parser.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.units.crypto.keyderive.Arg.AsRegExp"><code class="name flex">
<span>def <span class="ident">AsRegExp</span></span>(<span>codec, regex, flags=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/__init__.py#L379-L390" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def AsRegExp(
    codec: str,
    regex: str | buf,
    flags: int = 0
):
    import re
    if isinstance(regex, str):
        regex = regex.encode(codec)
    else:
        regex = bytes(regex)
    return re.compile(regex, flags=flags)</code></pre>
</details>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.AsOption"><code class="name flex">
<span>def <span class="ident">AsOption</span></span>(<span>value, cls)</span>
</code></dt>
<dd>
<section class="desc"><p>This method converts the input <code>value</code> to an instance of the enum <code>cls</code>. It is intended to
be used on values that are passed as an argument marked with the <code><a title="refinery.units.Arg.Option" href="../../index.html#refinery.units.Arg.Option">Arg.Option()</a></code>
decorator. If the input value is <code>None</code> or already an instance of <code>cls</code>, it is returned
unchanged. Otherwise, the function attempts to find an element of the enumeration that
matches the input, either by name or by value.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/__init__.py#L407-L433" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def AsOption(value, cls: type[_E]) -&gt; _E | None:
    &#34;&#34;&#34;
    This method converts the input `value` to an instance of the enum `cls`. It is intended to
    be used on values that are passed as an argument marked with the `refinery.units.Arg.Option`
    decorator. If the input value is `None` or already an instance of `cls`, it is returned
    unchanged. Otherwise, the function attempts to find an element of the enumeration that
    matches the input, either by name or by value.
    &#34;&#34;&#34;
    if value is None or isinstance(value, cls):
        return value
    if isinstance(value, str):
        try:
            return cls[value]
        except KeyError:
            pass
        needle = normalize_to_identifier(value).casefold()
        for item in cls.__members__:
            if not isinstance(item, str):
                break
            if item.casefold() == needle:
                return cls[item]
    try:
        return cls(value)
    except Exception as E:
        choices = &#39;, &#39;.join(normalize_to_display(m) for m in cls.__members__)
        raise ValueError(F&#39;Could not transform {value} into {cls.__name__}; the choices are: {choices}&#39;) from E</code></pre>
</details>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.Delete"><code class="name flex">
<span>def <span class="ident">Delete</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>This should be specified when the argument is present for a (potentially abstract) parent
unit but should be removed on the child.</p></section>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.Counts"><code class="name flex">
<span>def <span class="ident">Counts</span></span>(<span>*args, help=refinery.units.Arg.omit, dest=refinery.units.Arg.omit, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A convenience method to add argparse arguments that introduce a counter.</p></section>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.Switch"><code class="name flex">
<span>def <span class="ident">Switch</span></span>(<span>*args, off=False, help=refinery.units.Arg.omit, dest=refinery.units.Arg.omit, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A convenience method to add argparse arguments that change a boolean value from True to False or
vice versa. By default, a switch will have a False default and change it to True when specified.</p></section>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.FsPath"><code class="name flex">
<span>def <span class="ident">FsPath</span></span>(<span>*args, help=refinery.units.Arg.omit, dest=refinery.units.Arg.omit, nargs=refinery.units.Arg.omit, metavar=refinery.units.Arg.omit, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Used to add argparse arguments that contain path patterns.</p></section>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.Binary"><code class="name flex">
<span>def <span class="ident">Binary</span></span>(<span>*args, help=refinery.units.Arg.omit, dest=refinery.units.Arg.omit, nargs=refinery.units.Arg.omit, metavar=refinery.units.Arg.omit, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Used to add argparse arguments that contain binary data.</p></section>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.String"><code class="name flex">
<span>def <span class="ident">String</span></span>(<span>*args, help=refinery.units.Arg.omit, dest=refinery.units.Arg.omit, nargs=refinery.units.Arg.omit, metavar=refinery.units.Arg.omit, default=refinery.units.Arg.omit, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Used to add argparse arguments that contain string data.</p></section>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.RegExp"><code class="name flex">
<span>def <span class="ident">RegExp</span></span>(<span>*args, help=refinery.units.Arg.omit, dest=refinery.units.Arg.omit, nargs=refinery.units.Arg.omit, metavar=refinery.units.Arg.omit, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Used to add argparse arguments that contain a regular expression.</p></section>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.NumSeq"><code class="name flex">
<span>def <span class="ident">NumSeq</span></span>(<span>*args, help=refinery.units.Arg.omit, dest=refinery.units.Arg.omit, nargs=refinery.units.Arg.omit, metavar=refinery.units.Arg.omit, check=True, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Used to add argparse arguments that contain a numeric sequence.</p></section>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.Bounds"><code class="name flex">
<span>def <span class="ident">Bounds</span></span>(<span>*args, help=None, dest=refinery.units.Arg.omit, nargs=refinery.units.Arg.omit, default=refinery.units.Arg.omit, intok=False, metavar='start:end:step', group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Used to add argparse arguments that contain a slice.</p></section>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.Double"><code class="name flex">
<span>def <span class="ident">Double</span></span>(<span>*args, help=refinery.units.Arg.omit, dest=refinery.units.Arg.omit, metavar=refinery.units.Arg.omit, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Used to add argparse arguments that contain a floating point number.</p></section>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.Number"><code class="name flex">
<span>def <span class="ident">Number</span></span>(<span>*args, bound=refinery.units.Arg.omit, help=refinery.units.Arg.omit, dest=refinery.units.Arg.omit, metavar=refinery.units.Arg.omit, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Used to add argparse arguments that contain a number.</p></section>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.Option"><code class="name flex">
<span>def <span class="ident">Option</span></span>(<span>*args, choices, help=refinery.units.Arg.omit, dest=refinery.units.Arg.omit, metavar=refinery.units.Arg.omit, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Used to add argparse arguments with a fixed set of options, based on an enumeration.</p></section>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.Choice"><code class="name flex">
<span>def <span class="ident">Choice</span></span>(<span>*args, choices, help=refinery.units.Arg.omit, metavar=refinery.units.Arg.omit, dest=refinery.units.Arg.omit, type=&lt;method &#x27;lower&#x27; of &#x27;str&#x27; objects&gt;, nargs=refinery.units.Arg.omit, group=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Used to add argparse arguments with a fixed set of options, based on a list of strings.</p></section>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.Infer"><code class="name flex">
<span>def <span class="ident">Infer</span></span>(<span>pt, module=None)</span>
</code></dt>
<dd>
<section class="desc"><p>This class method can be used to infer the argparse argument for a Python function
parameter. This guess is based on the annotation, name, and default value.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.crypto.keyderive.Arg.positional"><code class="name">var <span class="ident">positional</span></code></dt>
<dd>
<section class="desc"><p>Indicates whether the argument is positional. This is crudely determined by whether it has
a specifier that does not start with a dash.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/__init__.py#L650-L656" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def positional(self) -&gt; bool:
    &#34;&#34;&#34;
    Indicates whether the argument is positional. This is crudely determined by whether it has
    a specifier that does not start with a dash.
    &#34;&#34;&#34;
    return any(a[0] != &#39;-&#39; for a in self.args)</code></pre>
</details>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.destination"><code class="name">var <span class="ident">destination</span></code></dt>
<dd>
<section class="desc"><p>The name of the variable where the contents of this parsed argument will be stored.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/__init__.py#L658-L674" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def destination(self) -&gt; str:
    &#34;&#34;&#34;
    The name of the variable where the contents of this parsed argument will be stored.
    &#34;&#34;&#34;
    for a in self.args:
        if a[0] != &#39;-&#39;:
            return a
    try:
        return self.kwargs[&#39;dest&#39;]
    except KeyError:
        for a in self.args:
            if a.startswith(&#39;--&#39;):
                dest = normalize_to_identifier(a)
                if dest.isidentifier():
                    return dest
        raise AttributeError(F&#39;The argument with these values has no destination: {self!r}&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.args"><code class="name">var <span class="ident">args</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/__init__.py#L277-L841" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Arg(Argument):
    &#34;&#34;&#34;
    This class is specifically an argument for the `add_argument` method of an `ArgumentParser` from
    the `argparse` module. It can also be used as a decorator or annotation for the constructor of a
    refinery unit to better control the argument parser of that unit&#39;s command line interface.
    Example:
    ```
    class prefixer(Unit):
        def __init__(
            self,
            prefix: Arg.Binary(help=&#39;This data will be prepended to the input.&#39;)
        ): ...
        def process(self, data):
            return self.args.prefix + data
    ```
    Note that when the init of a unit has a return annotation that is a base class of itself, then
    all its parameters will automatically be forwarded to that base class.
    &#34;&#34;&#34;

    class delete:
        &#34;&#34;&#34;
        A sentinel class to mark deleted arguments for the argument parser.
        &#34;&#34;&#34;

    class omit:
        &#34;&#34;&#34;
        A sentinel class to mark arguments as omitted for the argument parser.
        &#34;&#34;&#34;

    args: list[str]

    __slots__ = &#39;args&#39;, &#39;group&#39;, &#39;guessed&#39;

    def __init__(
        self, *args: str,
            action   : type[omit] | str                     = omit, # noqa
            choices  : type[omit] | Iterable[Any]           = omit, # noqa
            const    : type[omit] | Any                     = omit, # noqa
            default  : type[omit] | Any                     = omit, # noqa
            dest     : type[omit] | str                     = omit, # noqa
            help     : type[omit] | str                     = omit, # noqa
            metavar  : type[omit] | str                     = omit, # noqa
            nargs    : type[omit] | type[delete] | int | str  = omit, # noqa
            required : type[omit] | bool                    = omit, # noqa
            type     : type[omit] | type | Callable          = omit, # noqa
            group    : str | None                              = None, # noqa
            guessed  : set[str] | None                         = None, # noqa
    ) -&gt; None:
        kwargs = dict(action=action, choices=choices, const=const, default=default, dest=dest,
            help=help, metavar=metavar, nargs=nargs, required=required, type=type)
        kwargs = {key: value for key, value in kwargs.items() if value is not self.omit}
        self.group = group
        self.guessed = set(guessed or ())
        super().__init__(*args, **kwargs)

    def update_help(self):
        &#34;&#34;&#34;
        This method is called to format the help text of the argument retroactively. The primary
        purpose is to fill in default arguments via the formatting symbol `{default}`. These
        default values are not necessarily part of the `refinery.units.Arg` object itself: They
        may be a default value in the `__init__` function of the `refinery.units.Unit` subclass.
        Therefore, it is necessary to format the help text after all information has been
        compiled.
        &#34;&#34;&#34;
        class formatting(dict):
            arg = self

            def __missing__(self, key):
                if key == &#39;choices&#39;:
                    return &#39;, &#39;.join(self.arg.kwargs[&#39;choices&#39;])
                if key == &#39;default&#39;:
                    default: bytes | int | str | slice = self.arg.kwargs[&#39;default&#39;]
                    if isinstance(default, (list, tuple, set)):
                        if not default:
                            return &#39;empty&#39;
                        elif len(default) == 1:
                            default = next(iter(default))
                    if isinstance(default, slice):
                        parts = [default.start or &#39;&#39;, default.stop or &#39;&#39;, default.step]
                        default = &#39;:&#39;.join(str(x) for x in parts if x is not None)
                    if isinstance(default, int):
                        return default
                    if isinstance(default, str) or not isbuffer(default):
                        return default
                    default = bytes(default)
                    if default.isalnum():
                        return default.decode(&#39;latin-1&#39;)
                    return F&#39;H:{default.hex()}&#39;
                if key == &#39;varname&#39;:
                    return self.arg.kwargs.get(&#39;metavar&#39;, self.arg.destination)

        try:
            help_string: str = self.kwargs[&#39;help&#39;]
            self.kwargs.update(
                help=help_string.format_map(formatting()))
        except Exception:
            pass

    def __rmatmul__(self, method):
        self.update_help()
        return super().__rmatmul__(method)

    @staticmethod
    def AsRegExp(
        codec: str,
        regex: str | buf,
        flags: int = 0
    ):
        import re
        if isinstance(regex, str):
            regex = regex.encode(codec)
        else:
            regex = bytes(regex)
        return re.compile(regex, flags=flags)

    @overload
    @staticmethod
    def AsOption(value: _E, cls: type[_E]) -&gt; _E:
        ...

    @overload
    @staticmethod
    def AsOption(value: type[None], cls: type[_E]) -&gt; None:
        ...

    @overload
    @staticmethod
    def AsOption(value: str | None | _E, cls: type[_E]) -&gt; _E:
        ...

    @staticmethod
    def AsOption(value, cls: type[_E]) -&gt; _E | None:
        &#34;&#34;&#34;
        This method converts the input `value` to an instance of the enum `cls`. It is intended to
        be used on values that are passed as an argument marked with the `refinery.units.Arg.Option`
        decorator. If the input value is `None` or already an instance of `cls`, it is returned
        unchanged. Otherwise, the function attempts to find an element of the enumeration that
        matches the input, either by name or by value.
        &#34;&#34;&#34;
        if value is None or isinstance(value, cls):
            return value
        if isinstance(value, str):
            try:
                return cls[value]
            except KeyError:
                pass
            needle = normalize_to_identifier(value).casefold()
            for item in cls.__members__:
                if not isinstance(item, str):
                    break
                if item.casefold() == needle:
                    return cls[item]
        try:
            return cls(value)
        except Exception as E:
            choices = &#39;, &#39;.join(normalize_to_display(m) for m in cls.__members__)
            raise ValueError(F&#39;Could not transform {value} into {cls.__name__}; the choices are: {choices}&#39;) from E

    @classmethod
    def Delete(cls):
        &#34;&#34;&#34;
        This should be specified when the argument is present for a (potentially abstract) parent
        unit but should be removed on the child.
        &#34;&#34;&#34;
        return cls(nargs=cls.delete)

    @classmethod
    def Counts(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        A convenience method to add argparse arguments that introduce a counter.
        &#34;&#34;&#34;
        return cls(*args, group=group, help=help, dest=dest, action=&#39;count&#39;)

    @classmethod
    def Switch(
        cls,
        *args   : str, off=False,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        A convenience method to add argparse arguments that change a boolean value from True to False or
        vice versa. By default, a switch will have a False default and change it to True when specified.
        &#34;&#34;&#34;
        return cls(*args, group=group, help=help, dest=dest, action=&#39;store_false&#39; if off else &#39;store_true&#39;)

    @classmethod
    def FsPath(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain path patterns.
        &#34;&#34;&#34;
        if metavar is cls.omit and any(&#39;-&#39; in a for a in args):
            metavar = &#39;B&#39;
        return cls(*args, group=group, help=help, dest=dest, nargs=nargs, type=pathvar, metavar=metavar)

    @classmethod
    def Binary(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain binary data.
        &#34;&#34;&#34;
        if metavar is cls.omit and any(&#39;-&#39; in a for a in args):
            metavar = &#39;B&#39;
        return cls(*args, group=group, help=help, dest=dest, nargs=nargs, type=multibin, metavar=metavar)

    @classmethod
    def String(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        default : type[omit] | str | tuple[str, ...] = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain string data.
        &#34;&#34;&#34;
        if metavar is cls.omit and any(&#39;-&#39; in a for a in args):
            metavar = &#39;STR&#39;
        return cls(*args, group=group, default=default, help=help, dest=dest, nargs=nargs, type=str, metavar=metavar)

    @classmethod
    def RegExp(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a regular expression.
        &#34;&#34;&#34;
        if metavar is None and any(&#39;-&#39; in a for a in args):
            metavar = &#39;REGEX&#39;
        return cls(*args, group=group, help=help, dest=dest, nargs=nargs, type=regexp, metavar=metavar)

    @classmethod
    def NumSeq(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        check   : bool = True,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a numeric sequence.
        &#34;&#34;&#34;
        t = numseq if check else partial(numseq, typecheck=False)
        return cls(*args, group=group, help=help, nargs=nargs, dest=dest, type=t, metavar=metavar)

    @classmethod
    def Bounds(
        cls,
        *args   : str,
        help    : type[omit] | str | None = None,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        default : type[omit] | Any = omit,
        intok   : bool = False,
        metavar : type[omit] | str = &#39;start:end:step&#39;,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a slice.
        &#34;&#34;&#34;
        def parser(t: str):
            return sliceobj(t, intok=intok)
        if help is None:
            help = &#39;Specify start:end:step in Python slice syntax.&#39;
            if default is not cls.omit:
                help = F&#39;{help} The default is {{default}}.&#39;
        return cls(*args, group=group, help=help, default=default, nargs=nargs, dest=dest, type=parser, metavar=metavar)

    @classmethod
    def Double(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a floating point number.
        &#34;&#34;&#34;
        return cls(*args, group=group, help=help, dest=dest, type=percent, metavar=metavar)

    @classmethod
    def Number(
        cls,
        *args   : str,
        bound   : type[omit] | tuple[int, int] = omit,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a number.
        &#34;&#34;&#34;
        nt = number
        if bound is not cls.omit:
            assert isinstance(bound, tuple)
            lower, upper = bound
            nt = nt[lower:upper]
        if metavar is cls.omit:
            metavar = &#39;N&#39;
        return cls(*args, group=group, help=help, dest=dest, type=nt, metavar=metavar)

    @classmethod
    def Option(
        cls,
        *args   : str,
        choices : type[Enum],
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments with a fixed set of options, based on an enumeration.
        &#34;&#34;&#34;
        cnames = [normalize_to_display(c).casefold() for c in choices.__members__]
        metavar = metavar or choices.__name__
        return cls(*args, group=group, help=help, metavar=metavar, dest=dest, choices=cnames, type=str.casefold)

    @classmethod
    def Choice(
        cls,
        *args   : str,
        choices : list[str],
        help    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        type    : type | Callable = str.lower,
        nargs   : type[omit] | int | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments with a fixed set of options, based on a list of strings.
        &#34;&#34;&#34;
        return cls(*args, group=group, type=type, metavar=metavar, nargs=nargs,
            dest=dest, help=help, choices=choices)

    @property
    def positional(self) -&gt; bool:
        &#34;&#34;&#34;
        Indicates whether the argument is positional. This is crudely determined by whether it has
        a specifier that does not start with a dash.
        &#34;&#34;&#34;
        return any(a[0] != &#39;-&#39; for a in self.args)

    @property
    def destination(self) -&gt; str:
        &#34;&#34;&#34;
        The name of the variable where the contents of this parsed argument will be stored.
        &#34;&#34;&#34;
        for a in self.args:
            if a[0] != &#39;-&#39;:
                return a
        try:
            return self.kwargs[&#39;dest&#39;]
        except KeyError:
            for a in self.args:
                if a.startswith(&#39;--&#39;):
                    dest = normalize_to_identifier(a)
                    if dest.isidentifier():
                        return dest
            raise AttributeError(F&#39;The argument with these values has no destination: {self!r}&#39;)

    @classmethod
    def Infer(cls, pt: inspect.Parameter, module: str | None = None):
        &#34;&#34;&#34;
        This class method can be used to infer the argparse argument for a Python function
        parameter. This guess is based on the annotation, name, and default value.
        &#34;&#34;&#34;

        def needs_type(item: dict[str, str]):
            return item.get(&#39;action&#39;, &#39;store&#39;) == &#39;store&#39;

        def get_argp_type(at):
            if at is type(None):
                return None
            if issubclass(at, tuple):
                return numseq
            if issubclass(at, (bytes, bytearray, memoryview)):
                return multibin
            if issubclass(at, int):
                return number
            if issubclass(at, slice):
                return sliceobj
            if issubclass(at, float):
                return percent
            return at

        name = normalize_to_display(pt.name, False)
        default = pt.default
        empty = pt.empty
        guessed_pos_args = []
        guessed_kwd_args: dict[str, Any] = dict(dest=pt.name)
        guessed = set()
        annotation = pt.annotation

        def guess(key, value):
            try:
                return guessed_kwd_args[key]
            except KeyError:
                guessed_kwd_args[key] = value
                guessed.add(key)
                return value

        if isinstance(annotation, str):
            if module is None:
                _symbols = None
            else:
                __import__(module)
                _symbols = sys.modules[module].__dict__
            try:
                annotation = evaluate(annotation, _symbols)
            except Exception:
                pass

        if annotation is not empty:
            if isinstance(annotation, Arg):
                if annotation.kwargs.get(&#39;dest&#39;, pt.name) != pt.name:
                    raise ValueError(
                        F&#39;Incompatible argument destination specified; parameter {pt.name} &#39;
                        F&#39;was annotated with {annotation!r}.&#39;)
                guessed_pos_args = annotation.args
                guessed_kwd_args.update(annotation.kwargs)
                guessed_kwd_args.update(group=annotation.group)
            elif isinstance(annotation, type):
                guessed.add(&#39;type&#39;)
                if not issubclass(annotation, bool) and needs_type(guessed_kwd_args):
                    guessed_kwd_args.update(type=get_argp_type(annotation))
                elif not isinstance(default, bool):
                    raise ValueError(&#39;Default value for boolean arguments must be provided.&#39;)

        if not guessed_pos_args:
            guessed_pos_args = guessed_pos_args or [F&#39;--{name}&#39; if pt.kind is pt.KEYWORD_ONLY else name]

        if pt.kind is pt.VAR_POSITIONAL:
            oldnargs = guess(&#39;nargs&#39;, ZERO_OR_MORE)
            if oldnargs not in (ONE_OR_MORE, ZERO_OR_MORE, REMAINDER):
                raise ValueError(F&#39;Variadic positional arguments has nargs set to {oldnargs!r}&#39;)
            return cls(*guessed_pos_args, **guessed_kwd_args)

        if default is not empty:
            if isinstance(default, Enum):
                default = default.name

            guess(&#39;default&#39;, default)

            if isinstance(default, list):
                guess(&#39;nargs&#39;, ZERO_OR_MORE)
            elif pt.kind is pt.POSITIONAL_ONLY:
                guess(&#39;nargs&#39;, OPTIONAL)

            if isinstance(default, bool):
                guessed_kwd_args[&#39;action&#39;] = F&#39;store_{not default!s}&#39;.lower()
            elif needs_type(guessed_kwd_args):
                if isinstance(default, list) and default:
                    default = default[0]
                guess(&#39;type&#39;, get_argp_type(type(default)))

        return cls(*guessed_pos_args, **guessed_kwd_args, guessed=guessed)

    def merge_args(self, them: Argument) -&gt; None:
        &#34;&#34;&#34;
        Merge the `args` component of another `refinery.units.Argument` into this one without
        overwriting or removing any of the `args` in this instance.
        &#34;&#34;&#34;
        def iterboth():
            yield from them.args
            yield from self.args
        if not self.args:
            self.args = list(them.args)
            return
        sflag = None
        lflag = None
        for a in iterboth():
            if a[:2] == &#39;--&#39;:
                lflag = lflag or a
            elif a[0] == &#39;-&#39;:
                sflag = sflag or a
        self.args = []
        if sflag:
            self.args.append(sflag)
        if lflag:
            self.args.append(lflag)
        if not self.args:
            self.args = list(them.args)

    def merge_all(self, them: Arg) -&gt; None:
        &#34;&#34;&#34;
        Merge another `refinery.units.Arg` into the current instance. This is an additive process
        where no data on the present instance is destroyed unless `refinery.units.Arg.Delete` was
        used on `them` to explicitly remove an option.
        &#34;&#34;&#34;
        for key, value in them.kwargs.items():
            if value is Arg.delete:
                self.kwargs.pop(key, None)
                self.guessed.discard(key)
                continue
            if key in them.guessed:
                if key not in self.guessed:
                    if key == &#39;type&#39; and self.kwargs.get(&#39;action&#39;, None) != &#39;store&#39;:
                        continue
                    if key in self.kwargs:
                        continue
                self.guessed.add(key)
            self.kwargs[key] = value
        self.merge_args(them)
        self.group = them.group or self.group

    def __copy__(self) -&gt; Argument:
        cls = self.__class__
        clone = cls.__new__(cls)
        clone.kwargs = dict(self.kwargs)
        clone.args = list(self.args)
        clone.group = self.group
        clone.guessed = set(self.guessed)
        return clone

    def __repr__(self) -&gt; str:
        return F&#39;{self.__class__.__name__}({super().__repr__()})&#39;

    def __call__(self, init: Callable) -&gt; Callable:
        parameters = inspect.signature(init).parameters
        try:
            inferred = Arg.Infer(parameters[self.destination])
            inferred.merge_all(self)
            init.__annotations__[self.destination] = inferred
        except KeyError:
            raise ValueError(F&#39;Unable to decorate because no parameter with name {self.destination} exists.&#39;)
        return init</code></pre>
</details>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.group"><code class="name">var <span class="ident">group</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/__init__.py#L277-L841" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Arg(Argument):
    &#34;&#34;&#34;
    This class is specifically an argument for the `add_argument` method of an `ArgumentParser` from
    the `argparse` module. It can also be used as a decorator or annotation for the constructor of a
    refinery unit to better control the argument parser of that unit&#39;s command line interface.
    Example:
    ```
    class prefixer(Unit):
        def __init__(
            self,
            prefix: Arg.Binary(help=&#39;This data will be prepended to the input.&#39;)
        ): ...
        def process(self, data):
            return self.args.prefix + data
    ```
    Note that when the init of a unit has a return annotation that is a base class of itself, then
    all its parameters will automatically be forwarded to that base class.
    &#34;&#34;&#34;

    class delete:
        &#34;&#34;&#34;
        A sentinel class to mark deleted arguments for the argument parser.
        &#34;&#34;&#34;

    class omit:
        &#34;&#34;&#34;
        A sentinel class to mark arguments as omitted for the argument parser.
        &#34;&#34;&#34;

    args: list[str]

    __slots__ = &#39;args&#39;, &#39;group&#39;, &#39;guessed&#39;

    def __init__(
        self, *args: str,
            action   : type[omit] | str                     = omit, # noqa
            choices  : type[omit] | Iterable[Any]           = omit, # noqa
            const    : type[omit] | Any                     = omit, # noqa
            default  : type[omit] | Any                     = omit, # noqa
            dest     : type[omit] | str                     = omit, # noqa
            help     : type[omit] | str                     = omit, # noqa
            metavar  : type[omit] | str                     = omit, # noqa
            nargs    : type[omit] | type[delete] | int | str  = omit, # noqa
            required : type[omit] | bool                    = omit, # noqa
            type     : type[omit] | type | Callable          = omit, # noqa
            group    : str | None                              = None, # noqa
            guessed  : set[str] | None                         = None, # noqa
    ) -&gt; None:
        kwargs = dict(action=action, choices=choices, const=const, default=default, dest=dest,
            help=help, metavar=metavar, nargs=nargs, required=required, type=type)
        kwargs = {key: value for key, value in kwargs.items() if value is not self.omit}
        self.group = group
        self.guessed = set(guessed or ())
        super().__init__(*args, **kwargs)

    def update_help(self):
        &#34;&#34;&#34;
        This method is called to format the help text of the argument retroactively. The primary
        purpose is to fill in default arguments via the formatting symbol `{default}`. These
        default values are not necessarily part of the `refinery.units.Arg` object itself: They
        may be a default value in the `__init__` function of the `refinery.units.Unit` subclass.
        Therefore, it is necessary to format the help text after all information has been
        compiled.
        &#34;&#34;&#34;
        class formatting(dict):
            arg = self

            def __missing__(self, key):
                if key == &#39;choices&#39;:
                    return &#39;, &#39;.join(self.arg.kwargs[&#39;choices&#39;])
                if key == &#39;default&#39;:
                    default: bytes | int | str | slice = self.arg.kwargs[&#39;default&#39;]
                    if isinstance(default, (list, tuple, set)):
                        if not default:
                            return &#39;empty&#39;
                        elif len(default) == 1:
                            default = next(iter(default))
                    if isinstance(default, slice):
                        parts = [default.start or &#39;&#39;, default.stop or &#39;&#39;, default.step]
                        default = &#39;:&#39;.join(str(x) for x in parts if x is not None)
                    if isinstance(default, int):
                        return default
                    if isinstance(default, str) or not isbuffer(default):
                        return default
                    default = bytes(default)
                    if default.isalnum():
                        return default.decode(&#39;latin-1&#39;)
                    return F&#39;H:{default.hex()}&#39;
                if key == &#39;varname&#39;:
                    return self.arg.kwargs.get(&#39;metavar&#39;, self.arg.destination)

        try:
            help_string: str = self.kwargs[&#39;help&#39;]
            self.kwargs.update(
                help=help_string.format_map(formatting()))
        except Exception:
            pass

    def __rmatmul__(self, method):
        self.update_help()
        return super().__rmatmul__(method)

    @staticmethod
    def AsRegExp(
        codec: str,
        regex: str | buf,
        flags: int = 0
    ):
        import re
        if isinstance(regex, str):
            regex = regex.encode(codec)
        else:
            regex = bytes(regex)
        return re.compile(regex, flags=flags)

    @overload
    @staticmethod
    def AsOption(value: _E, cls: type[_E]) -&gt; _E:
        ...

    @overload
    @staticmethod
    def AsOption(value: type[None], cls: type[_E]) -&gt; None:
        ...

    @overload
    @staticmethod
    def AsOption(value: str | None | _E, cls: type[_E]) -&gt; _E:
        ...

    @staticmethod
    def AsOption(value, cls: type[_E]) -&gt; _E | None:
        &#34;&#34;&#34;
        This method converts the input `value` to an instance of the enum `cls`. It is intended to
        be used on values that are passed as an argument marked with the `refinery.units.Arg.Option`
        decorator. If the input value is `None` or already an instance of `cls`, it is returned
        unchanged. Otherwise, the function attempts to find an element of the enumeration that
        matches the input, either by name or by value.
        &#34;&#34;&#34;
        if value is None or isinstance(value, cls):
            return value
        if isinstance(value, str):
            try:
                return cls[value]
            except KeyError:
                pass
            needle = normalize_to_identifier(value).casefold()
            for item in cls.__members__:
                if not isinstance(item, str):
                    break
                if item.casefold() == needle:
                    return cls[item]
        try:
            return cls(value)
        except Exception as E:
            choices = &#39;, &#39;.join(normalize_to_display(m) for m in cls.__members__)
            raise ValueError(F&#39;Could not transform {value} into {cls.__name__}; the choices are: {choices}&#39;) from E

    @classmethod
    def Delete(cls):
        &#34;&#34;&#34;
        This should be specified when the argument is present for a (potentially abstract) parent
        unit but should be removed on the child.
        &#34;&#34;&#34;
        return cls(nargs=cls.delete)

    @classmethod
    def Counts(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        A convenience method to add argparse arguments that introduce a counter.
        &#34;&#34;&#34;
        return cls(*args, group=group, help=help, dest=dest, action=&#39;count&#39;)

    @classmethod
    def Switch(
        cls,
        *args   : str, off=False,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        A convenience method to add argparse arguments that change a boolean value from True to False or
        vice versa. By default, a switch will have a False default and change it to True when specified.
        &#34;&#34;&#34;
        return cls(*args, group=group, help=help, dest=dest, action=&#39;store_false&#39; if off else &#39;store_true&#39;)

    @classmethod
    def FsPath(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain path patterns.
        &#34;&#34;&#34;
        if metavar is cls.omit and any(&#39;-&#39; in a for a in args):
            metavar = &#39;B&#39;
        return cls(*args, group=group, help=help, dest=dest, nargs=nargs, type=pathvar, metavar=metavar)

    @classmethod
    def Binary(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain binary data.
        &#34;&#34;&#34;
        if metavar is cls.omit and any(&#39;-&#39; in a for a in args):
            metavar = &#39;B&#39;
        return cls(*args, group=group, help=help, dest=dest, nargs=nargs, type=multibin, metavar=metavar)

    @classmethod
    def String(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        default : type[omit] | str | tuple[str, ...] = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain string data.
        &#34;&#34;&#34;
        if metavar is cls.omit and any(&#39;-&#39; in a for a in args):
            metavar = &#39;STR&#39;
        return cls(*args, group=group, default=default, help=help, dest=dest, nargs=nargs, type=str, metavar=metavar)

    @classmethod
    def RegExp(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a regular expression.
        &#34;&#34;&#34;
        if metavar is None and any(&#39;-&#39; in a for a in args):
            metavar = &#39;REGEX&#39;
        return cls(*args, group=group, help=help, dest=dest, nargs=nargs, type=regexp, metavar=metavar)

    @classmethod
    def NumSeq(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        check   : bool = True,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a numeric sequence.
        &#34;&#34;&#34;
        t = numseq if check else partial(numseq, typecheck=False)
        return cls(*args, group=group, help=help, nargs=nargs, dest=dest, type=t, metavar=metavar)

    @classmethod
    def Bounds(
        cls,
        *args   : str,
        help    : type[omit] | str | None = None,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        default : type[omit] | Any = omit,
        intok   : bool = False,
        metavar : type[omit] | str = &#39;start:end:step&#39;,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a slice.
        &#34;&#34;&#34;
        def parser(t: str):
            return sliceobj(t, intok=intok)
        if help is None:
            help = &#39;Specify start:end:step in Python slice syntax.&#39;
            if default is not cls.omit:
                help = F&#39;{help} The default is {{default}}.&#39;
        return cls(*args, group=group, help=help, default=default, nargs=nargs, dest=dest, type=parser, metavar=metavar)

    @classmethod
    def Double(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a floating point number.
        &#34;&#34;&#34;
        return cls(*args, group=group, help=help, dest=dest, type=percent, metavar=metavar)

    @classmethod
    def Number(
        cls,
        *args   : str,
        bound   : type[omit] | tuple[int, int] = omit,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a number.
        &#34;&#34;&#34;
        nt = number
        if bound is not cls.omit:
            assert isinstance(bound, tuple)
            lower, upper = bound
            nt = nt[lower:upper]
        if metavar is cls.omit:
            metavar = &#39;N&#39;
        return cls(*args, group=group, help=help, dest=dest, type=nt, metavar=metavar)

    @classmethod
    def Option(
        cls,
        *args   : str,
        choices : type[Enum],
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments with a fixed set of options, based on an enumeration.
        &#34;&#34;&#34;
        cnames = [normalize_to_display(c).casefold() for c in choices.__members__]
        metavar = metavar or choices.__name__
        return cls(*args, group=group, help=help, metavar=metavar, dest=dest, choices=cnames, type=str.casefold)

    @classmethod
    def Choice(
        cls,
        *args   : str,
        choices : list[str],
        help    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        type    : type | Callable = str.lower,
        nargs   : type[omit] | int | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments with a fixed set of options, based on a list of strings.
        &#34;&#34;&#34;
        return cls(*args, group=group, type=type, metavar=metavar, nargs=nargs,
            dest=dest, help=help, choices=choices)

    @property
    def positional(self) -&gt; bool:
        &#34;&#34;&#34;
        Indicates whether the argument is positional. This is crudely determined by whether it has
        a specifier that does not start with a dash.
        &#34;&#34;&#34;
        return any(a[0] != &#39;-&#39; for a in self.args)

    @property
    def destination(self) -&gt; str:
        &#34;&#34;&#34;
        The name of the variable where the contents of this parsed argument will be stored.
        &#34;&#34;&#34;
        for a in self.args:
            if a[0] != &#39;-&#39;:
                return a
        try:
            return self.kwargs[&#39;dest&#39;]
        except KeyError:
            for a in self.args:
                if a.startswith(&#39;--&#39;):
                    dest = normalize_to_identifier(a)
                    if dest.isidentifier():
                        return dest
            raise AttributeError(F&#39;The argument with these values has no destination: {self!r}&#39;)

    @classmethod
    def Infer(cls, pt: inspect.Parameter, module: str | None = None):
        &#34;&#34;&#34;
        This class method can be used to infer the argparse argument for a Python function
        parameter. This guess is based on the annotation, name, and default value.
        &#34;&#34;&#34;

        def needs_type(item: dict[str, str]):
            return item.get(&#39;action&#39;, &#39;store&#39;) == &#39;store&#39;

        def get_argp_type(at):
            if at is type(None):
                return None
            if issubclass(at, tuple):
                return numseq
            if issubclass(at, (bytes, bytearray, memoryview)):
                return multibin
            if issubclass(at, int):
                return number
            if issubclass(at, slice):
                return sliceobj
            if issubclass(at, float):
                return percent
            return at

        name = normalize_to_display(pt.name, False)
        default = pt.default
        empty = pt.empty
        guessed_pos_args = []
        guessed_kwd_args: dict[str, Any] = dict(dest=pt.name)
        guessed = set()
        annotation = pt.annotation

        def guess(key, value):
            try:
                return guessed_kwd_args[key]
            except KeyError:
                guessed_kwd_args[key] = value
                guessed.add(key)
                return value

        if isinstance(annotation, str):
            if module is None:
                _symbols = None
            else:
                __import__(module)
                _symbols = sys.modules[module].__dict__
            try:
                annotation = evaluate(annotation, _symbols)
            except Exception:
                pass

        if annotation is not empty:
            if isinstance(annotation, Arg):
                if annotation.kwargs.get(&#39;dest&#39;, pt.name) != pt.name:
                    raise ValueError(
                        F&#39;Incompatible argument destination specified; parameter {pt.name} &#39;
                        F&#39;was annotated with {annotation!r}.&#39;)
                guessed_pos_args = annotation.args
                guessed_kwd_args.update(annotation.kwargs)
                guessed_kwd_args.update(group=annotation.group)
            elif isinstance(annotation, type):
                guessed.add(&#39;type&#39;)
                if not issubclass(annotation, bool) and needs_type(guessed_kwd_args):
                    guessed_kwd_args.update(type=get_argp_type(annotation))
                elif not isinstance(default, bool):
                    raise ValueError(&#39;Default value for boolean arguments must be provided.&#39;)

        if not guessed_pos_args:
            guessed_pos_args = guessed_pos_args or [F&#39;--{name}&#39; if pt.kind is pt.KEYWORD_ONLY else name]

        if pt.kind is pt.VAR_POSITIONAL:
            oldnargs = guess(&#39;nargs&#39;, ZERO_OR_MORE)
            if oldnargs not in (ONE_OR_MORE, ZERO_OR_MORE, REMAINDER):
                raise ValueError(F&#39;Variadic positional arguments has nargs set to {oldnargs!r}&#39;)
            return cls(*guessed_pos_args, **guessed_kwd_args)

        if default is not empty:
            if isinstance(default, Enum):
                default = default.name

            guess(&#39;default&#39;, default)

            if isinstance(default, list):
                guess(&#39;nargs&#39;, ZERO_OR_MORE)
            elif pt.kind is pt.POSITIONAL_ONLY:
                guess(&#39;nargs&#39;, OPTIONAL)

            if isinstance(default, bool):
                guessed_kwd_args[&#39;action&#39;] = F&#39;store_{not default!s}&#39;.lower()
            elif needs_type(guessed_kwd_args):
                if isinstance(default, list) and default:
                    default = default[0]
                guess(&#39;type&#39;, get_argp_type(type(default)))

        return cls(*guessed_pos_args, **guessed_kwd_args, guessed=guessed)

    def merge_args(self, them: Argument) -&gt; None:
        &#34;&#34;&#34;
        Merge the `args` component of another `refinery.units.Argument` into this one without
        overwriting or removing any of the `args` in this instance.
        &#34;&#34;&#34;
        def iterboth():
            yield from them.args
            yield from self.args
        if not self.args:
            self.args = list(them.args)
            return
        sflag = None
        lflag = None
        for a in iterboth():
            if a[:2] == &#39;--&#39;:
                lflag = lflag or a
            elif a[0] == &#39;-&#39;:
                sflag = sflag or a
        self.args = []
        if sflag:
            self.args.append(sflag)
        if lflag:
            self.args.append(lflag)
        if not self.args:
            self.args = list(them.args)

    def merge_all(self, them: Arg) -&gt; None:
        &#34;&#34;&#34;
        Merge another `refinery.units.Arg` into the current instance. This is an additive process
        where no data on the present instance is destroyed unless `refinery.units.Arg.Delete` was
        used on `them` to explicitly remove an option.
        &#34;&#34;&#34;
        for key, value in them.kwargs.items():
            if value is Arg.delete:
                self.kwargs.pop(key, None)
                self.guessed.discard(key)
                continue
            if key in them.guessed:
                if key not in self.guessed:
                    if key == &#39;type&#39; and self.kwargs.get(&#39;action&#39;, None) != &#39;store&#39;:
                        continue
                    if key in self.kwargs:
                        continue
                self.guessed.add(key)
            self.kwargs[key] = value
        self.merge_args(them)
        self.group = them.group or self.group

    def __copy__(self) -&gt; Argument:
        cls = self.__class__
        clone = cls.__new__(cls)
        clone.kwargs = dict(self.kwargs)
        clone.args = list(self.args)
        clone.group = self.group
        clone.guessed = set(self.guessed)
        return clone

    def __repr__(self) -&gt; str:
        return F&#39;{self.__class__.__name__}({super().__repr__()})&#39;

    def __call__(self, init: Callable) -&gt; Callable:
        parameters = inspect.signature(init).parameters
        try:
            inferred = Arg.Infer(parameters[self.destination])
            inferred.merge_all(self)
            init.__annotations__[self.destination] = inferred
        except KeyError:
            raise ValueError(F&#39;Unable to decorate because no parameter with name {self.destination} exists.&#39;)
        return init</code></pre>
</details>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.guessed"><code class="name">var <span class="ident">guessed</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/__init__.py#L277-L841" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Arg(Argument):
    &#34;&#34;&#34;
    This class is specifically an argument for the `add_argument` method of an `ArgumentParser` from
    the `argparse` module. It can also be used as a decorator or annotation for the constructor of a
    refinery unit to better control the argument parser of that unit&#39;s command line interface.
    Example:
    ```
    class prefixer(Unit):
        def __init__(
            self,
            prefix: Arg.Binary(help=&#39;This data will be prepended to the input.&#39;)
        ): ...
        def process(self, data):
            return self.args.prefix + data
    ```
    Note that when the init of a unit has a return annotation that is a base class of itself, then
    all its parameters will automatically be forwarded to that base class.
    &#34;&#34;&#34;

    class delete:
        &#34;&#34;&#34;
        A sentinel class to mark deleted arguments for the argument parser.
        &#34;&#34;&#34;

    class omit:
        &#34;&#34;&#34;
        A sentinel class to mark arguments as omitted for the argument parser.
        &#34;&#34;&#34;

    args: list[str]

    __slots__ = &#39;args&#39;, &#39;group&#39;, &#39;guessed&#39;

    def __init__(
        self, *args: str,
            action   : type[omit] | str                     = omit, # noqa
            choices  : type[omit] | Iterable[Any]           = omit, # noqa
            const    : type[omit] | Any                     = omit, # noqa
            default  : type[omit] | Any                     = omit, # noqa
            dest     : type[omit] | str                     = omit, # noqa
            help     : type[omit] | str                     = omit, # noqa
            metavar  : type[omit] | str                     = omit, # noqa
            nargs    : type[omit] | type[delete] | int | str  = omit, # noqa
            required : type[omit] | bool                    = omit, # noqa
            type     : type[omit] | type | Callable          = omit, # noqa
            group    : str | None                              = None, # noqa
            guessed  : set[str] | None                         = None, # noqa
    ) -&gt; None:
        kwargs = dict(action=action, choices=choices, const=const, default=default, dest=dest,
            help=help, metavar=metavar, nargs=nargs, required=required, type=type)
        kwargs = {key: value for key, value in kwargs.items() if value is not self.omit}
        self.group = group
        self.guessed = set(guessed or ())
        super().__init__(*args, **kwargs)

    def update_help(self):
        &#34;&#34;&#34;
        This method is called to format the help text of the argument retroactively. The primary
        purpose is to fill in default arguments via the formatting symbol `{default}`. These
        default values are not necessarily part of the `refinery.units.Arg` object itself: They
        may be a default value in the `__init__` function of the `refinery.units.Unit` subclass.
        Therefore, it is necessary to format the help text after all information has been
        compiled.
        &#34;&#34;&#34;
        class formatting(dict):
            arg = self

            def __missing__(self, key):
                if key == &#39;choices&#39;:
                    return &#39;, &#39;.join(self.arg.kwargs[&#39;choices&#39;])
                if key == &#39;default&#39;:
                    default: bytes | int | str | slice = self.arg.kwargs[&#39;default&#39;]
                    if isinstance(default, (list, tuple, set)):
                        if not default:
                            return &#39;empty&#39;
                        elif len(default) == 1:
                            default = next(iter(default))
                    if isinstance(default, slice):
                        parts = [default.start or &#39;&#39;, default.stop or &#39;&#39;, default.step]
                        default = &#39;:&#39;.join(str(x) for x in parts if x is not None)
                    if isinstance(default, int):
                        return default
                    if isinstance(default, str) or not isbuffer(default):
                        return default
                    default = bytes(default)
                    if default.isalnum():
                        return default.decode(&#39;latin-1&#39;)
                    return F&#39;H:{default.hex()}&#39;
                if key == &#39;varname&#39;:
                    return self.arg.kwargs.get(&#39;metavar&#39;, self.arg.destination)

        try:
            help_string: str = self.kwargs[&#39;help&#39;]
            self.kwargs.update(
                help=help_string.format_map(formatting()))
        except Exception:
            pass

    def __rmatmul__(self, method):
        self.update_help()
        return super().__rmatmul__(method)

    @staticmethod
    def AsRegExp(
        codec: str,
        regex: str | buf,
        flags: int = 0
    ):
        import re
        if isinstance(regex, str):
            regex = regex.encode(codec)
        else:
            regex = bytes(regex)
        return re.compile(regex, flags=flags)

    @overload
    @staticmethod
    def AsOption(value: _E, cls: type[_E]) -&gt; _E:
        ...

    @overload
    @staticmethod
    def AsOption(value: type[None], cls: type[_E]) -&gt; None:
        ...

    @overload
    @staticmethod
    def AsOption(value: str | None | _E, cls: type[_E]) -&gt; _E:
        ...

    @staticmethod
    def AsOption(value, cls: type[_E]) -&gt; _E | None:
        &#34;&#34;&#34;
        This method converts the input `value` to an instance of the enum `cls`. It is intended to
        be used on values that are passed as an argument marked with the `refinery.units.Arg.Option`
        decorator. If the input value is `None` or already an instance of `cls`, it is returned
        unchanged. Otherwise, the function attempts to find an element of the enumeration that
        matches the input, either by name or by value.
        &#34;&#34;&#34;
        if value is None or isinstance(value, cls):
            return value
        if isinstance(value, str):
            try:
                return cls[value]
            except KeyError:
                pass
            needle = normalize_to_identifier(value).casefold()
            for item in cls.__members__:
                if not isinstance(item, str):
                    break
                if item.casefold() == needle:
                    return cls[item]
        try:
            return cls(value)
        except Exception as E:
            choices = &#39;, &#39;.join(normalize_to_display(m) for m in cls.__members__)
            raise ValueError(F&#39;Could not transform {value} into {cls.__name__}; the choices are: {choices}&#39;) from E

    @classmethod
    def Delete(cls):
        &#34;&#34;&#34;
        This should be specified when the argument is present for a (potentially abstract) parent
        unit but should be removed on the child.
        &#34;&#34;&#34;
        return cls(nargs=cls.delete)

    @classmethod
    def Counts(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        A convenience method to add argparse arguments that introduce a counter.
        &#34;&#34;&#34;
        return cls(*args, group=group, help=help, dest=dest, action=&#39;count&#39;)

    @classmethod
    def Switch(
        cls,
        *args   : str, off=False,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        A convenience method to add argparse arguments that change a boolean value from True to False or
        vice versa. By default, a switch will have a False default and change it to True when specified.
        &#34;&#34;&#34;
        return cls(*args, group=group, help=help, dest=dest, action=&#39;store_false&#39; if off else &#39;store_true&#39;)

    @classmethod
    def FsPath(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain path patterns.
        &#34;&#34;&#34;
        if metavar is cls.omit and any(&#39;-&#39; in a for a in args):
            metavar = &#39;B&#39;
        return cls(*args, group=group, help=help, dest=dest, nargs=nargs, type=pathvar, metavar=metavar)

    @classmethod
    def Binary(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain binary data.
        &#34;&#34;&#34;
        if metavar is cls.omit and any(&#39;-&#39; in a for a in args):
            metavar = &#39;B&#39;
        return cls(*args, group=group, help=help, dest=dest, nargs=nargs, type=multibin, metavar=metavar)

    @classmethod
    def String(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        default : type[omit] | str | tuple[str, ...] = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain string data.
        &#34;&#34;&#34;
        if metavar is cls.omit and any(&#39;-&#39; in a for a in args):
            metavar = &#39;STR&#39;
        return cls(*args, group=group, default=default, help=help, dest=dest, nargs=nargs, type=str, metavar=metavar)

    @classmethod
    def RegExp(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a regular expression.
        &#34;&#34;&#34;
        if metavar is None and any(&#39;-&#39; in a for a in args):
            metavar = &#39;REGEX&#39;
        return cls(*args, group=group, help=help, dest=dest, nargs=nargs, type=regexp, metavar=metavar)

    @classmethod
    def NumSeq(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        metavar : type[omit] | str = omit,
        check   : bool = True,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a numeric sequence.
        &#34;&#34;&#34;
        t = numseq if check else partial(numseq, typecheck=False)
        return cls(*args, group=group, help=help, nargs=nargs, dest=dest, type=t, metavar=metavar)

    @classmethod
    def Bounds(
        cls,
        *args   : str,
        help    : type[omit] | str | None = None,
        dest    : type[omit] | str = omit,
        nargs   : type[omit] | int | str = omit,
        default : type[omit] | Any = omit,
        intok   : bool = False,
        metavar : type[omit] | str = &#39;start:end:step&#39;,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a slice.
        &#34;&#34;&#34;
        def parser(t: str):
            return sliceobj(t, intok=intok)
        if help is None:
            help = &#39;Specify start:end:step in Python slice syntax.&#39;
            if default is not cls.omit:
                help = F&#39;{help} The default is {{default}}.&#39;
        return cls(*args, group=group, help=help, default=default, nargs=nargs, dest=dest, type=parser, metavar=metavar)

    @classmethod
    def Double(
        cls,
        *args   : str,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a floating point number.
        &#34;&#34;&#34;
        return cls(*args, group=group, help=help, dest=dest, type=percent, metavar=metavar)

    @classmethod
    def Number(
        cls,
        *args   : str,
        bound   : type[omit] | tuple[int, int] = omit,
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments that contain a number.
        &#34;&#34;&#34;
        nt = number
        if bound is not cls.omit:
            assert isinstance(bound, tuple)
            lower, upper = bound
            nt = nt[lower:upper]
        if metavar is cls.omit:
            metavar = &#39;N&#39;
        return cls(*args, group=group, help=help, dest=dest, type=nt, metavar=metavar)

    @classmethod
    def Option(
        cls,
        *args   : str,
        choices : type[Enum],
        help    : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments with a fixed set of options, based on an enumeration.
        &#34;&#34;&#34;
        cnames = [normalize_to_display(c).casefold() for c in choices.__members__]
        metavar = metavar or choices.__name__
        return cls(*args, group=group, help=help, metavar=metavar, dest=dest, choices=cnames, type=str.casefold)

    @classmethod
    def Choice(
        cls,
        *args   : str,
        choices : list[str],
        help    : type[omit] | str = omit,
        metavar : type[omit] | str = omit,
        dest    : type[omit] | str = omit,
        type    : type | Callable = str.lower,
        nargs   : type[omit] | int | str = omit,
        group   : str | None = None,
    ):
        &#34;&#34;&#34;
        Used to add argparse arguments with a fixed set of options, based on a list of strings.
        &#34;&#34;&#34;
        return cls(*args, group=group, type=type, metavar=metavar, nargs=nargs,
            dest=dest, help=help, choices=choices)

    @property
    def positional(self) -&gt; bool:
        &#34;&#34;&#34;
        Indicates whether the argument is positional. This is crudely determined by whether it has
        a specifier that does not start with a dash.
        &#34;&#34;&#34;
        return any(a[0] != &#39;-&#39; for a in self.args)

    @property
    def destination(self) -&gt; str:
        &#34;&#34;&#34;
        The name of the variable where the contents of this parsed argument will be stored.
        &#34;&#34;&#34;
        for a in self.args:
            if a[0] != &#39;-&#39;:
                return a
        try:
            return self.kwargs[&#39;dest&#39;]
        except KeyError:
            for a in self.args:
                if a.startswith(&#39;--&#39;):
                    dest = normalize_to_identifier(a)
                    if dest.isidentifier():
                        return dest
            raise AttributeError(F&#39;The argument with these values has no destination: {self!r}&#39;)

    @classmethod
    def Infer(cls, pt: inspect.Parameter, module: str | None = None):
        &#34;&#34;&#34;
        This class method can be used to infer the argparse argument for a Python function
        parameter. This guess is based on the annotation, name, and default value.
        &#34;&#34;&#34;

        def needs_type(item: dict[str, str]):
            return item.get(&#39;action&#39;, &#39;store&#39;) == &#39;store&#39;

        def get_argp_type(at):
            if at is type(None):
                return None
            if issubclass(at, tuple):
                return numseq
            if issubclass(at, (bytes, bytearray, memoryview)):
                return multibin
            if issubclass(at, int):
                return number
            if issubclass(at, slice):
                return sliceobj
            if issubclass(at, float):
                return percent
            return at

        name = normalize_to_display(pt.name, False)
        default = pt.default
        empty = pt.empty
        guessed_pos_args = []
        guessed_kwd_args: dict[str, Any] = dict(dest=pt.name)
        guessed = set()
        annotation = pt.annotation

        def guess(key, value):
            try:
                return guessed_kwd_args[key]
            except KeyError:
                guessed_kwd_args[key] = value
                guessed.add(key)
                return value

        if isinstance(annotation, str):
            if module is None:
                _symbols = None
            else:
                __import__(module)
                _symbols = sys.modules[module].__dict__
            try:
                annotation = evaluate(annotation, _symbols)
            except Exception:
                pass

        if annotation is not empty:
            if isinstance(annotation, Arg):
                if annotation.kwargs.get(&#39;dest&#39;, pt.name) != pt.name:
                    raise ValueError(
                        F&#39;Incompatible argument destination specified; parameter {pt.name} &#39;
                        F&#39;was annotated with {annotation!r}.&#39;)
                guessed_pos_args = annotation.args
                guessed_kwd_args.update(annotation.kwargs)
                guessed_kwd_args.update(group=annotation.group)
            elif isinstance(annotation, type):
                guessed.add(&#39;type&#39;)
                if not issubclass(annotation, bool) and needs_type(guessed_kwd_args):
                    guessed_kwd_args.update(type=get_argp_type(annotation))
                elif not isinstance(default, bool):
                    raise ValueError(&#39;Default value for boolean arguments must be provided.&#39;)

        if not guessed_pos_args:
            guessed_pos_args = guessed_pos_args or [F&#39;--{name}&#39; if pt.kind is pt.KEYWORD_ONLY else name]

        if pt.kind is pt.VAR_POSITIONAL:
            oldnargs = guess(&#39;nargs&#39;, ZERO_OR_MORE)
            if oldnargs not in (ONE_OR_MORE, ZERO_OR_MORE, REMAINDER):
                raise ValueError(F&#39;Variadic positional arguments has nargs set to {oldnargs!r}&#39;)
            return cls(*guessed_pos_args, **guessed_kwd_args)

        if default is not empty:
            if isinstance(default, Enum):
                default = default.name

            guess(&#39;default&#39;, default)

            if isinstance(default, list):
                guess(&#39;nargs&#39;, ZERO_OR_MORE)
            elif pt.kind is pt.POSITIONAL_ONLY:
                guess(&#39;nargs&#39;, OPTIONAL)

            if isinstance(default, bool):
                guessed_kwd_args[&#39;action&#39;] = F&#39;store_{not default!s}&#39;.lower()
            elif needs_type(guessed_kwd_args):
                if isinstance(default, list) and default:
                    default = default[0]
                guess(&#39;type&#39;, get_argp_type(type(default)))

        return cls(*guessed_pos_args, **guessed_kwd_args, guessed=guessed)

    def merge_args(self, them: Argument) -&gt; None:
        &#34;&#34;&#34;
        Merge the `args` component of another `refinery.units.Argument` into this one without
        overwriting or removing any of the `args` in this instance.
        &#34;&#34;&#34;
        def iterboth():
            yield from them.args
            yield from self.args
        if not self.args:
            self.args = list(them.args)
            return
        sflag = None
        lflag = None
        for a in iterboth():
            if a[:2] == &#39;--&#39;:
                lflag = lflag or a
            elif a[0] == &#39;-&#39;:
                sflag = sflag or a
        self.args = []
        if sflag:
            self.args.append(sflag)
        if lflag:
            self.args.append(lflag)
        if not self.args:
            self.args = list(them.args)

    def merge_all(self, them: Arg) -&gt; None:
        &#34;&#34;&#34;
        Merge another `refinery.units.Arg` into the current instance. This is an additive process
        where no data on the present instance is destroyed unless `refinery.units.Arg.Delete` was
        used on `them` to explicitly remove an option.
        &#34;&#34;&#34;
        for key, value in them.kwargs.items():
            if value is Arg.delete:
                self.kwargs.pop(key, None)
                self.guessed.discard(key)
                continue
            if key in them.guessed:
                if key not in self.guessed:
                    if key == &#39;type&#39; and self.kwargs.get(&#39;action&#39;, None) != &#39;store&#39;:
                        continue
                    if key in self.kwargs:
                        continue
                self.guessed.add(key)
            self.kwargs[key] = value
        self.merge_args(them)
        self.group = them.group or self.group

    def __copy__(self) -&gt; Argument:
        cls = self.__class__
        clone = cls.__new__(cls)
        clone.kwargs = dict(self.kwargs)
        clone.args = list(self.args)
        clone.group = self.group
        clone.guessed = set(self.guessed)
        return clone

    def __repr__(self) -&gt; str:
        return F&#39;{self.__class__.__name__}({super().__repr__()})&#39;

    def __call__(self, init: Callable) -&gt; Callable:
        parameters = inspect.signature(init).parameters
        try:
            inferred = Arg.Infer(parameters[self.destination])
            inferred.merge_all(self)
            init.__annotations__[self.destination] = inferred
        except KeyError:
            raise ValueError(F&#39;Unable to decorate because no parameter with name {self.destination} exists.&#39;)
        return init</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.units.crypto.keyderive.Arg.update_help"><code class="name flex">
<span>def <span class="ident">update_help</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This method is called to format the help text of the argument retroactively. The primary
purpose is to fill in default arguments via the formatting symbol <code>{default}</code>. These
default values are not necessarily part of the <code><a title="refinery.units.Arg" href="../../index.html#refinery.units.Arg">Arg</a></code> object itself: They
may be a default value in the <code>__init__</code> function of the <code><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></code> subclass.
Therefore, it is necessary to format the help text after all information has been
compiled.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/__init__.py#L332-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def update_help(self):
    &#34;&#34;&#34;
    This method is called to format the help text of the argument retroactively. The primary
    purpose is to fill in default arguments via the formatting symbol `{default}`. These
    default values are not necessarily part of the `refinery.units.Arg` object itself: They
    may be a default value in the `__init__` function of the `refinery.units.Unit` subclass.
    Therefore, it is necessary to format the help text after all information has been
    compiled.
    &#34;&#34;&#34;
    class formatting(dict):
        arg = self

        def __missing__(self, key):
            if key == &#39;choices&#39;:
                return &#39;, &#39;.join(self.arg.kwargs[&#39;choices&#39;])
            if key == &#39;default&#39;:
                default: bytes | int | str | slice = self.arg.kwargs[&#39;default&#39;]
                if isinstance(default, (list, tuple, set)):
                    if not default:
                        return &#39;empty&#39;
                    elif len(default) == 1:
                        default = next(iter(default))
                if isinstance(default, slice):
                    parts = [default.start or &#39;&#39;, default.stop or &#39;&#39;, default.step]
                    default = &#39;:&#39;.join(str(x) for x in parts if x is not None)
                if isinstance(default, int):
                    return default
                if isinstance(default, str) or not isbuffer(default):
                    return default
                default = bytes(default)
                if default.isalnum():
                    return default.decode(&#39;latin-1&#39;)
                return F&#39;H:{default.hex()}&#39;
            if key == &#39;varname&#39;:
                return self.arg.kwargs.get(&#39;metavar&#39;, self.arg.destination)

    try:
        help_string: str = self.kwargs[&#39;help&#39;]
        self.kwargs.update(
            help=help_string.format_map(formatting()))
    except Exception:
        pass</code></pre>
</details>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.merge_args"><code class="name flex">
<span>def <span class="ident">merge_args</span></span>(<span>self, them)</span>
</code></dt>
<dd>
<section class="desc"><p>Merge the <code>args</code> component of another <code><a title="refinery.units.Argument" href="../../index.html#refinery.units.Argument">Argument</a></code> into this one without
overwriting or removing any of the <code>args</code> in this instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/__init__.py#L773-L797" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def merge_args(self, them: Argument) -&gt; None:
    &#34;&#34;&#34;
    Merge the `args` component of another `refinery.units.Argument` into this one without
    overwriting or removing any of the `args` in this instance.
    &#34;&#34;&#34;
    def iterboth():
        yield from them.args
        yield from self.args
    if not self.args:
        self.args = list(them.args)
        return
    sflag = None
    lflag = None
    for a in iterboth():
        if a[:2] == &#39;--&#39;:
            lflag = lflag or a
        elif a[0] == &#39;-&#39;:
            sflag = sflag or a
    self.args = []
    if sflag:
        self.args.append(sflag)
    if lflag:
        self.args.append(lflag)
    if not self.args:
        self.args = list(them.args)</code></pre>
</details>
</dd>
<dt id="refinery.units.crypto.keyderive.Arg.merge_all"><code class="name flex">
<span>def <span class="ident">merge_all</span></span>(<span>self, them)</span>
</code></dt>
<dd>
<section class="desc"><p>Merge another <code><a title="refinery.units.Arg" href="../../index.html#refinery.units.Arg">Arg</a></code> into the current instance. This is an additive process
where no data on the present instance is destroyed unless <code><a title="refinery.units.Arg.Delete" href="../../index.html#refinery.units.Arg.Delete">Arg.Delete()</a></code> was
used on <code>them</code> to explicitly remove an option.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/__init__.py#L799-L819" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def merge_all(self, them: Arg) -&gt; None:
    &#34;&#34;&#34;
    Merge another `refinery.units.Arg` into the current instance. This is an additive process
    where no data on the present instance is destroyed unless `refinery.units.Arg.Delete` was
    used on `them` to explicitly remove an option.
    &#34;&#34;&#34;
    for key, value in them.kwargs.items():
        if value is Arg.delete:
            self.kwargs.pop(key, None)
            self.guessed.discard(key)
            continue
        if key in them.guessed:
            if key not in self.guessed:
                if key == &#39;type&#39; and self.kwargs.get(&#39;action&#39;, None) != &#39;store&#39;:
                    continue
                if key in self.kwargs:
                    continue
            self.guessed.add(key)
        self.kwargs[key] = value
    self.merge_args(them)
    self.group = them.group or self.group</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.units.crypto.keyderive.HASH"><code class="flex name class">
<span>class <span class="ident">HASH</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/crypto/keyderive/__init__.py#L31-L39" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class HASH(str, Enum):
    MD2 = &#39;MD2&#39;
    MD4 = &#39;MD4&#39;
    MD5 = &#39;MD5&#39;
    SHA1 = &#39;SHA&#39;
    SHA256 = &#39;SHA256&#39;
    SHA512 = &#39;SHA512&#39;
    SHA224 = &#39;SHA224&#39;
    SHA384 = &#39;SHA384&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.crypto.keyderive.HASH.MD2"><code class="name">var <span class="ident">MD2</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.crypto.keyderive.HASH.MD4"><code class="name">var <span class="ident">MD4</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.crypto.keyderive.HASH.MD5"><code class="name">var <span class="ident">MD5</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.crypto.keyderive.HASH.SHA1"><code class="name">var <span class="ident">SHA1</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.crypto.keyderive.HASH.SHA256"><code class="name">var <span class="ident">SHA256</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.crypto.keyderive.HASH.SHA512"><code class="name">var <span class="ident">SHA512</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.crypto.keyderive.HASH.SHA224"><code class="name">var <span class="ident">SHA224</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.crypto.keyderive.HASH.SHA384"><code class="name">var <span class="ident">SHA384</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.units.crypto.keyderive.KeyDerivation"><code class="flex name class">
<span>class <span class="ident">KeyDerivation</span></span>
<span>(</span><span>size, salt, hash=HASH.SHA1, iter=0, **kw)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/crypto/keyderive/__init__.py#L52-L72" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class KeyDerivation(Unit, abstract=True):

    def __init__(
        self,
        size: Param[int, Arg.Number(help=&#39;The number of bytes to generate.&#39;)],
        salt: Param[buf, Arg.Binary(help=&#39;Salt for the derivation.&#39;)],
        hash: Param[str, Arg.Option(choices=HASH, metavar=&#39;hash&#39;,
            help=&#39;Specify one of these algorithms (default is {default}): {choices}&#39;)] = HASH.SHA1,
        iter: Param[int, Arg.Number(metavar=&#39;iter&#39;,
            help=&#39;Number of iterations; default is {default}.&#39;)] = 0,
        **kw
    ):
        if hash is not None:
            hash = Arg.AsOption(hash, HASH)
        return super().__init__(salt=salt, size=size, iter=iter, hash=hash, **kw)

    @property
    def hash(self) -&gt; _HashModule:
        name = self.args.hash.value
        hash = importlib.import_module(F&#39;Cryptodome.Hash.{name}&#39;)
        return cast(&#39;_HashModule&#39;, hash)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></li>
<li><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.crypto.keyderive.deskd.deskd" href="deskd.html#refinery.units.crypto.keyderive.deskd.deskd">deskd</a></li>
<li><a title="refinery.units.crypto.keyderive.hkdf.hkdf" href="hkdf.html#refinery.units.crypto.keyderive.hkdf.hkdf">hkdf</a></li>
<li><a title="refinery.units.crypto.keyderive.hmac.hmac" href="hmac.html#refinery.units.crypto.keyderive.hmac.hmac">hmac</a></li>
<li><a title="refinery.units.crypto.keyderive.mscdk.mscdk" href="mscdk.html#refinery.units.crypto.keyderive.mscdk.mscdk">mscdk</a></li>
<li><a title="refinery.units.crypto.keyderive.mspdb.mspdb" href="mspdb.html#refinery.units.crypto.keyderive.mspdb.mspdb">mspdb</a></li>
<li><a title="refinery.units.crypto.keyderive.pbkdf1.pbkdf1" href="pbkdf1.html#refinery.units.crypto.keyderive.pbkdf1.pbkdf1">pbkdf1</a></li>
<li><a title="refinery.units.crypto.keyderive.pbkdf2.pbkdf2" href="pbkdf2.html#refinery.units.crypto.keyderive.pbkdf2.pbkdf2">pbkdf2</a></li>
<li><a title="refinery.units.crypto.keyderive.unixcrypt.ucrypt" href="unixcrypt.html#refinery.units.crypto.keyderive.unixcrypt.ucrypt">ucrypt</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.units.crypto.keyderive.KeyDerivation.required_dependencies"><code class="name">var <span class="ident">required_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.crypto.keyderive.KeyDerivation.optional_dependencies"><code class="name">var <span class="ident">optional_dependencies</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.units.crypto.keyderive.KeyDerivation.console"><code class="name">var <span class="ident">console</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.units.crypto.keyderive.KeyDerivation.hash"><code class="name">var <span class="ident">hash</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/units/crypto/keyderive/__init__.py#L68-L72" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def hash(self) -&gt; _HashModule:
    name = self.args.hash.value
    hash = importlib.import_module(F&#39;Cryptodome.Hash.{name}&#39;)
    return cast(&#39;_HashModule&#39;, hash)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.units.Unit" href="../../index.html#refinery.units.Unit">Unit</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.Unit.Requires" href="../../index.html#refinery.units.Unit.Requires">Requires</a></code></li>
<li><code><a title="refinery.units.Unit.assemble" href="../../index.html#refinery.units.Unit.assemble">assemble</a></code></li>
<li><code><a title="refinery.units.Unit.finish" href="../../index.html#refinery.units.UnitBase.finish">finish</a></code></li>
<li><code><a title="refinery.units.Unit.handles" href="../../index.html#refinery.units.UnitBase.handles">handles</a></code></li>
<li><code><a title="refinery.units.Unit.is_quiet" href="../../index.html#refinery.units.Unit.is_quiet">is_quiet</a></code></li>
<li><code><a title="refinery.units.Unit.labelled" href="../../index.html#refinery.units.Unit.labelled">labelled</a></code></li>
<li><code><a title="refinery.units.Unit.leniency" href="../../index.html#refinery.units.Unit.leniency">leniency</a></code></li>
<li><code><a title="refinery.units.Unit.log_always" href="../../index.html#refinery.units.Unit.log_always">log_always</a></code></li>
<li><code><a title="refinery.units.Unit.log_debug" href="../../index.html#refinery.units.Unit.log_debug">log_debug</a></code></li>
<li><code><a title="refinery.units.Unit.log_detach" href="../../index.html#refinery.units.Unit.log_detach">log_detach</a></code></li>
<li><code><a title="refinery.units.Unit.log_fail" href="../../index.html#refinery.units.Unit.log_fail">log_fail</a></code></li>
<li><code><a title="refinery.units.Unit.log_info" href="../../index.html#refinery.units.Unit.log_info">log_info</a></code></li>
<li><code><a title="refinery.units.Unit.log_level" href="../../index.html#refinery.units.Unit.log_level">log_level</a></code></li>
<li><code><a title="refinery.units.Unit.log_warn" href="../../index.html#refinery.units.Unit.log_warn">log_warn</a></code></li>
<li><code><a title="refinery.units.Unit.nozzle" href="../../index.html#refinery.units.Unit.nozzle">nozzle</a></code></li>
<li><code><a title="refinery.units.Unit.read" href="../../index.html#refinery.units.Unit.read">read</a></code></li>
<li><code><a title="refinery.units.Unit.read1" href="../../index.html#refinery.units.Unit.read1">read1</a></code></li>
<li><code><a title="refinery.units.Unit.run" href="../../index.html#refinery.units.Unit.run">run</a></code></li>
<li><code><a title="refinery.units.Unit.source" href="../../index.html#refinery.units.Unit.source">source</a></code></li>
<li><code><a title="refinery.units.Unit.superinit" href="../../index.html#refinery.units.Unit.superinit">superinit</a></code></li>
</ul>
</li>
<li><code><b><a title="refinery.units.UnitBase" href="../../index.html#refinery.units.UnitBase">UnitBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.units.UnitBase.filter" href="../../index.html#refinery.units.UnitBase.filter">filter</a></code></li>
<li><code><a title="refinery.units.UnitBase.process" href="../../index.html#refinery.units.UnitBase.process">process</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.units.crypto" href="../index.html">refinery.units.crypto</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="refinery.units.crypto.keyderive.argon2id" href="argon2id.html">refinery.units.crypto.keyderive.argon2id</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.deskd" href="deskd.html">refinery.units.crypto.keyderive.deskd</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.hkdf" href="hkdf.html">refinery.units.crypto.keyderive.hkdf</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.hmac" href="hmac.html">refinery.units.crypto.keyderive.hmac</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.kblob" href="kblob.html">refinery.units.crypto.keyderive.kblob</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.mscdk" href="mscdk.html">refinery.units.crypto.keyderive.mscdk</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.mspdb" href="mspdb.html">refinery.units.crypto.keyderive.mspdb</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.pbkdf1" href="pbkdf1.html">refinery.units.crypto.keyderive.pbkdf1</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.pbkdf2" href="pbkdf2.html">refinery.units.crypto.keyderive.pbkdf2</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.unixcrypt" href="unixcrypt.html">refinery.units.crypto.keyderive.unixcrypt</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.units.crypto.keyderive.Arg" href="#refinery.units.crypto.keyderive.Arg">Arg</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.units.crypto.keyderive.Arg.AsRegExp" href="#refinery.units.crypto.keyderive.Arg.AsRegExp">AsRegExp</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.AsOption" href="#refinery.units.crypto.keyderive.Arg.AsOption">AsOption</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.Delete" href="#refinery.units.crypto.keyderive.Arg.Delete">Delete</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.Counts" href="#refinery.units.crypto.keyderive.Arg.Counts">Counts</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.Switch" href="#refinery.units.crypto.keyderive.Arg.Switch">Switch</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.FsPath" href="#refinery.units.crypto.keyderive.Arg.FsPath">FsPath</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.Binary" href="#refinery.units.crypto.keyderive.Arg.Binary">Binary</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.String" href="#refinery.units.crypto.keyderive.Arg.String">String</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.RegExp" href="#refinery.units.crypto.keyderive.Arg.RegExp">RegExp</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.NumSeq" href="#refinery.units.crypto.keyderive.Arg.NumSeq">NumSeq</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.Bounds" href="#refinery.units.crypto.keyderive.Arg.Bounds">Bounds</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.Double" href="#refinery.units.crypto.keyderive.Arg.Double">Double</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.Number" href="#refinery.units.crypto.keyderive.Arg.Number">Number</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.Option" href="#refinery.units.crypto.keyderive.Arg.Option">Option</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.Choice" href="#refinery.units.crypto.keyderive.Arg.Choice">Choice</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.Infer" href="#refinery.units.crypto.keyderive.Arg.Infer">Infer</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.update_help" href="#refinery.units.crypto.keyderive.Arg.update_help">update_help</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.merge_args" href="#refinery.units.crypto.keyderive.Arg.merge_args">merge_args</a></code></li>
<li><code><a title="refinery.units.crypto.keyderive.Arg.merge_all" href="#refinery.units.crypto.keyderive.Arg.merge_all">merge_all</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.units.crypto.keyderive.HASH" href="#refinery.units.crypto.keyderive.HASH">HASH</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.units.crypto.keyderive.KeyDerivation" href="#refinery.units.crypto.keyderive.KeyDerivation">KeyDerivation</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
