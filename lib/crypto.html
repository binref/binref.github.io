<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.crypto documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.crypto</code></h1>
</header>
<section id="section-intro">
<p>Primitives used in custom cryptographic implementations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L1-L770" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Primitives used in custom cryptographic implementations.
&#34;&#34;&#34;
from __future__ import annotations

from abc import ABC, abstractmethod
from enum import Enum
from typing import Callable, ClassVar, Collection, Generator

from refinery.lib.types import buf as BufferType

CIPHER_MODES: dict[str, type[CipherMode]] = {}


def strxor(a: bytes, b: bytes):
    &#34;&#34;&#34;
    Return the XOR of the two byte strings `a` and `b`. The shorter of the two strings defines the
    length of the output.
    &#34;&#34;&#34;
    return bytes(a ^ b for a, b in zip(a, b))


def _register_cipher_mode(cls: type[CipherMode]):
    cls._identifier = len(CIPHER_MODES)
    CIPHER_MODES[cls.__name__] = cls
    return cls


def rotl128(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 128-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x80 - c))) &amp; 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF


def rotl64(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 64-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x40 - c))) &amp; 0xFFFFFFFFFFFFFFFF


def rotl32(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 32-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x20 - c))) &amp; 0xFFFFFFFF


def rotl16(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 16-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x10 - c))) &amp; 0xFFFF


def rotl8(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the byte `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x08 - c))) &amp; 0xFF


def rotr128(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 128-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x80 - c) &amp; 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | (x &gt;&gt; c)


def rotr64(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 64-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x40 - c) &amp; 0xFFFFFFFFFFFFFFFF) | (x &gt;&gt; c)


def rotr32(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 32-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x20 - c) &amp; 0xFFFFFFFF) | (x &gt;&gt; c)


def rotr16(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 16-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x10 - c) &amp; 0xFFFF) | (x &gt;&gt; c)


def rotr8(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the byte `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x08 - c) &amp; 0xFF) | (x &gt;&gt; c)


def rotr(n: int, x: int, c: int) -&gt; int:
    &#34;&#34;&#34;
    Rotate the `n`-bit integer `x` by `c` positions to the right. If `n` is among the common bit
    sizes 8, 16, 32, 64, or 128, then one of the more specific functions in this module should be
    used instead.
    &#34;&#34;&#34;
    mask = (1 &lt;&lt; n) - 1
    c %= n
    return (x &gt;&gt; c) | (x &lt;&lt; (n - c) &amp; mask)


def rotl(n: int, x: int, c: int) -&gt; int:
    &#34;&#34;&#34;
    Rotate the `n`-bit integer `x` by `c` positions to the left. If `n` is among the common bit
    sizes 8, 16, 32, 64, or 128, then one of the more specific functions in this module should be
    used instead.
    &#34;&#34;&#34;
    mask = (1 &lt;&lt; n) - 1
    c %= n
    return (x &gt;&gt; (n - c)) | (x &lt;&lt; c &amp; mask)


def pad_pkcs7(data: bytearray, block_size: int) -&gt; None:
    &#34;&#34;&#34;
    Pad a bytearray in-place using the PKCS7 padding type.
    &#34;&#34;&#34;
    for _ in range(p := block_size - len(data) % block_size):
        data.append(p)


def pad_x923(data: bytearray, block_size: int) -&gt; None:
    &#34;&#34;&#34;
    Pad a bytearray in-place using the ANSI x923 padding type.
    &#34;&#34;&#34;
    p = block_size - len(data) % block_size
    data.extend(0 for _ in range(p - 1))
    data.append(p)


def pad_iso7816(data: bytearray, block_size: int) -&gt; None:
    &#34;&#34;&#34;
    Pad a bytearray in-place using the ISO-7816 padding type.
    &#34;&#34;&#34;
    data.append(0x80)
    for _ in range(-len(data) % block_size):
        data.append(0)


def unpad_pkcs7(data: bytearray, block_size: int) -&gt; None:
    &#34;&#34;&#34;
    Remove a PKCS7 padding in-place. When an exception occurs, the data is left unchanged.
    &#34;&#34;&#34;
    if not 1 &lt;= (p := data[-1]) &lt;= block_size:
        raise ValueError
    if not all(data[-k] == p for k in range(1, p + 1)):
        raise ValueError
    del data[-p:]


def unpad_x923(data: bytearray, block_size: int) -&gt; None:
    &#34;&#34;&#34;
    Remove an ANSI x923 padding in-place. When an exception occurs, the data is left unchanged.
    &#34;&#34;&#34;
    if not 1 &lt;= (p := data[-1]) &lt;= block_size:
        raise ValueError
    for k in range(2, p + 1):
        if data[-k]:
            raise ValueError
    del data[-p:]


def unpad_iso7816(data: bytearray, block_size: int) -&gt; None:
    &#34;&#34;&#34;
    Remove an ISO-7816 padding in-place. When an exception occurs, the data is left unchanged.
    &#34;&#34;&#34;
    for k in range(1, block_size + 1):
        b = data[-k]
        if b == 0x80:
            del data[-k:]
            return
        if b != 0x00:
            raise ValueError


class Padding(str, Enum):
    &#34;&#34;&#34;
    Supported padding methods for `refinery.lib.crypto.unpad` and `refinery.lib.crypto.pad`.
    &#34;&#34;&#34;
    PKCS7 = &#39;pkcs7&#39;
    ISO7816 = &#39;iso7816&#39;
    X923 = &#39;x923&#39;


def unpad(data: bytearray, block_size: int, method: str | Padding):
    &#34;&#34;&#34;
    Remove padding from the given buffer in place for the given block size according to the given
    padding method.
    &#34;&#34;&#34;
    if method == Padding.PKCS7:
        return unpad_pkcs7(data, block_size)
    if method == Padding.X923:
        return unpad_x923(data, block_size)
    if method == Padding.ISO7816:
        return unpad_iso7816(data, block_size)
    raise ValueError(method)


def pad(data: bytearray, block_size: int, method: str | Padding):
    &#34;&#34;&#34;
    Pad the given buffer in place to the given block size according to the given padding method.
    &#34;&#34;&#34;
    if method == Padding.PKCS7:
        return pad_pkcs7(data, block_size)
    if method == Padding.X923:
        return pad_x923(data, block_size)
    if method == Padding.ISO7816:
        return pad_iso7816(data, block_size)
    raise ValueError(method)


class Operation(str, Enum):
    &#34;&#34;&#34;
    Specifies whether data is currently being encrypted or decrypted.
    &#34;&#34;&#34;
    Encrypt = &#39;encrypt&#39;
    Decrypt = &#39;decrypt&#39;


class CipherMode(ABC):
    &#34;&#34;&#34;
    Abstract base class for a cipher mode of operation.
    &#34;&#34;&#34;

    encrypt_block: Callable[[BufferType], BufferType]
    decrypt_block: Callable[[BufferType], BufferType]
    aligned: bool = True
    _identifier: ClassVar[int]

    @abstractmethod
    def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        &#34;&#34;&#34;
        Implements data encryption according to the current cipher mode and underlying cipher.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def decrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        &#34;&#34;&#34;
        Implements data decryption according to the current cipher mode and underlying cipher.
        &#34;&#34;&#34;
        raise NotImplementedError

    def apply(
        self,
        operation: Operation,
        dst: memoryview,
        src: memoryview,
        encrypt_block: Callable[[BufferType], BufferType],
        decrypt_block: Callable[[BufferType], BufferType],
        blocksize: int,
    ) -&gt; memoryview:
        &#34;&#34;&#34;
        This method is used to perform a cryptographic `refinery.lib.crypto.Operation` to a given
        source `src` and write the result to the memory at `dst` according to the current cipher
        mode. To this end, it requires the block encryption and decryption primitives of the
        underlying cipher and the current block size.
        &#34;&#34;&#34;
        self.encrypt_block = encrypt_block
        self.decrypt_block = decrypt_block
        engine: Generator[BufferType, memoryview, None] = {
            Operation.Encrypt: self.encrypt,
            Operation.Decrypt: self.decrypt,
        }[operation]()
        next(engine)
        top, rest = divmod(len(src), blocksize)
        top *= blocksize
        for k in range(0, top, blocksize):
            dst[k:k + blocksize] = engine.send(src[k:k + blocksize])
        if rest:
            dst[-rest:] = engine.send(src[-rest:])[:rest]
        engine.close()
        return dst


@_register_cipher_mode
class ECB(CipherMode):
    &#34;&#34;&#34;
    The Electronic Codebook (ECB) is the most simple cipher mode of operation. The underlying
    cipher is applied block-wise with no additional safeguards.
    &#34;&#34;&#34;

    def decrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        M = B&#39;&#39;
        D = self.decrypt_block
        while True:
            C = yield M
            M = D(C)

    def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        C = B&#39;&#39;
        E = self.encrypt_block
        while True:
            M = yield C
            C = E(M)


class DataUnaligned(ValueError):
    &#34;&#34;&#34;
    Raised when input data is unexpectedly unaligned to the current block size.
    &#34;&#34;&#34;
    def __init__(self, b: int, k: int) -&gt; None:
        super().__init__(F&#39;Data not aligned to block size {b}, with {k} missing bytes to complete the block.&#39;)


class StatefulCipherMode(CipherMode):
    &#34;&#34;&#34;
    A subclass of `refinery.lib.crypto.CipherMode` that holds a state while performing any of
    its cryptographic `refinery.lib.crypto.Operation`s.
    &#34;&#34;&#34;

    iv: BufferType
    &#34;&#34;&#34;
    The initial vector for the internal state of the cipher mode.
    &#34;&#34;&#34;

    def __init__(self, iv: BufferType):
        self.iv = iv


@_register_cipher_mode
class CBC(StatefulCipherMode):
    &#34;&#34;&#34;
    An implementation of the popular Cipher Block Chaining mode of operation.
    &#34;&#34;&#34;

    def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        C = self.iv
        E = self.encrypt_block
        while True:
            M = yield C
            C = E(strxor(M, C))

    def decrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        S = self.iv
        M = B&#39;&#39;
        D = self.decrypt_block
        while True:
            C = yield M
            M = strxor(D(C), S)
            S = bytes(C)


@_register_cipher_mode
class PCBC(StatefulCipherMode):
    &#34;&#34;&#34;
    An implementation of Propagating Cipher Block Chaining.
    &#34;&#34;&#34;

    def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        S = self.iv
        C = B&#39;&#39;
        E = self.encrypt_block
        while True:
            M = yield C
            C = E(strxor(M, S))
            S = strxor(C, M)

    def decrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        S = self.iv
        M = B&#39;&#39;
        D = self.decrypt_block
        while True:
            C = yield M
            M = strxor(S, D(C))
            S = strxor(M, C)


@_register_cipher_mode
class CFB(CipherMode):
    &#34;&#34;&#34;
    Cipher Feedback Mode: https://csrc.nist.gov/publications/detail/sp/800-38a/final
    &#34;&#34;&#34;

    iv: BufferType
    segment_size: int
    aligned = False

    def __init__(self, iv: BufferType, segment_size: int | None = None):
        if segment_size is None:
            segment_size = 8
        if segment_size % 8 != 0:
            raise NotImplementedError(&#39;segment sizes may only be multiples of 8&#39;)
        segment_size = segment_size // 8
        if len(iv) % segment_size != 0:
            raise NotImplementedError(
                F&#39;the block size {len(iv) * 8} is not an even multiple of the segment &#39;
                F&#39;size {segment_size * 8}; this is currently not supported.&#39;)
        self.segment_size = segment_size
        self.iv = iv

    def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        s = self.segment_size
        S = bytearray(self.iv)
        E = self.encrypt_block
        C = bytearray(len(self.iv))
        if s == 1:
            while True:
                M = yield C
                for k, m in enumerate(M):
                    C[k] = c = m ^ E(S)[0]
                    S[:-1], S[-1] = memoryview(S)[1:], c
        else:
            segments = [slice(i, i + s) for i in range(0, len(S), s)]
            while True:
                M = yield C
                for k in segments:
                    m = M[k]
                    C[k] = c = strxor(m, E(S)[:s])
                    S[:-s], S[-s:] = memoryview(S)[s:], c

    def decrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        s = self.segment_size
        S = bytearray(self.iv)
        E = self.encrypt_block
        M = bytearray(len(self.iv))
        if s == 1:
            while True:
                C = yield M
                for k, c in enumerate(C):
                    M[k] = c ^ E(S)[0]
                    S[:-1], S[-1] = memoryview(S)[1:], c
        else:
            segments = [slice(i, i + s) for i in range(0, len(S), s)]
            while True:
                C = yield M
                for k in segments:
                    c = C[k]
                    M[k] = strxor(c, E(S)[:s])
                    S[:-s], S[-s:] = memoryview(S)[s:], c


@_register_cipher_mode
class OFB(StatefulCipherMode):
    &#34;&#34;&#34;
    An implementation of Output Feedback Mode.
    &#34;&#34;&#34;

    aligned = False

    def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        S = self.iv
        C = B&#39;&#39;
        E = self.encrypt_block
        while True:
            M = yield C
            S = E(S)
            C = strxor(M, S)

    decrypt = encrypt


@_register_cipher_mode
class CTR(CipherMode):
    &#34;&#34;&#34;
    An implementation of Counter mode.
    &#34;&#34;&#34;

    counter_len: int
    prefix: BufferType
    suffix: BufferType
    initial_value: int
    little_endian: bool
    block_size: int

    aligned = False

    @property
    def byte_order(self):
        return &#39;little&#39; if self.little_endian else &#39;big&#39;

    def __init__(
        self,
        block_size: int | None = None,
        counter: dict | None = None,
        nonce: BufferType | None = None,
        initial_value: int | None = 0,
        little_endian: bool = False
    ):
        if counter is not None:
            self.initial_value = counter.get(&#39;initial_value&#39;, initial_value)
            self.little_endian = counter.get(&#39;little_endian&#39;, little_endian)
            self.prefix = counter[&#39;prefix&#39;]
            self.suffix = counter[&#39;suffix&#39;]
            self.counter_len = counter[&#39;counter_len&#39;]
            self.block_size = self.counter_len + len(self.prefix) + len(self.suffix)
            if block_size not in {None, self.block_size}:
                raise ValueError(&#39;Information in counter object does not align with block size.&#39;)
            return
        if block_size is None:
            raise ValueError(&#39;Unable to construct CTR mode object without block_size or counter argument.&#39;)

        self.initial_value = initial_value or 0
        self.little_endian = little_endian
        self.suffix = B&#39;&#39;
        self.block_size = block_size

        if nonce is not None:
            if len(nonce) &gt; block_size:
                raise ValueError(&#39;Nonce length exceeds block length.&#39;)
            self.counter_len = block_size - len(nonce)
            self.prefix = nonce
        else:
            self.counter_len = block_size // 2
            self.prefix = B&#39;\0&#39; * (block_size - self.counter_len)

    def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        S = bytearray(self.block_size)
        J = slice(len(self.prefix), self.block_size - len(self.suffix))
        K = self.initial_value
        if self.prefix:
            S[:+len(self.prefix)] = self.prefix
        if self.suffix:
            S[-len(self.suffix):] = self.suffix
        C = B&#39;&#39;
        E = self.encrypt_block
        order = self.byte_order
        csize = self.counter_len
        mask = (1 &lt;&lt; (csize * 8)) - 1
        while True:
            M = yield C
            S[J] = K.to_bytes(csize, order)
            K = K + 1 &amp; mask
            C = strxor(E(S), M)

    decrypt = encrypt


class CipherInterface(ABC):
    &#34;&#34;&#34;
    Abstract base class for refinery&#39;s block cipher interface.
    &#34;&#34;&#34;

    key_size: Collection[int]
    &#34;&#34;&#34;
    A sequence containing all valid key sizes for this cipher.
    &#34;&#34;&#34;

    block_size: int
    &#34;&#34;&#34;
    The block size of this cipher.
    &#34;&#34;&#34;

    @abstractmethod
    def encrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Data encryption according to this cipher interface.
        &#34;&#34;&#34;

    @abstractmethod
    def decrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Data decryption according to this cipher interface.
        &#34;&#34;&#34;

    def update(self, D: BufferType) -&gt; None:
        &#34;&#34;&#34;
        Provide additional authenticated data to a cipher that supports authentication. This method
        must be called before decryption.
        &#34;&#34;&#34;
        return

    def verify(self, T: BufferType) -&gt; bool:
        &#34;&#34;&#34;
        Verify that the decrypted message is authentic given the input tag.
        &#34;&#34;&#34;
        raise NotImplementedError

    def digest(self) -&gt; BufferType:
        &#34;&#34;&#34;
        Compute the binary authentication tag (MAC).
        &#34;&#34;&#34;
        raise NotImplementedError


class CipherObjectFactory(ABC):
    &#34;&#34;&#34;
    An abstract class to build `refinery.lib.crypto.CipherInterface`s from an asortment of
    cryptographic secrets and parameters.
    &#34;&#34;&#34;

    name: str
    key_size: Collection[int] | None = None
    block_size: int | None = None

    @abstractmethod
    def new(
        self,
        key: BufferType,
        *,
        iv: BufferType | None = None,
        counter: int | None = None,
        initial_value: int | None = 0,
        nonce: BufferType | None = None,
        mode: str | None = None,
        segment_size: int | None = None,
        block_size: int | None = None,
        **cipher_args
    ) -&gt; CipherInterface:
        &#34;&#34;&#34;
        Build the actual `refinery.lib.crypto.CipherInterface` from the given input parameters.
        This mimics the PyCrypto interface for new ciphers in order to make the refinery factory
        cross-compatible with that library.
        &#34;&#34;&#34;
        ...


class PyCryptoFactoryWrapper(CipherObjectFactory):
    &#34;&#34;&#34;
    Wraps a PyCrypto module as a `refinery.lib.crypto.CipherObjectFactory`.
    &#34;&#34;&#34;

    def __init__(self, module):
        self.module = module

    def new(self, *a, **k) -&gt; CipherInterface:
        return self.module.new(*a, **k)

    @property
    def key_size(self):
        try:
            value = self.module.key_size
        except AttributeError:
            return None
        if isinstance(value, int):
            return {value}
        return value

    @property
    def block_size(self):
        try:
            value = self.module.block_size
        except AttributeError:
            return None
        return value

    def __repr__(self):
        return repr(self.module)

    def __dir__(self):
        return dir(self.module)

    def __getattr__(self, key):
        return getattr(self.module, key)


class BlockCipherFactory(CipherObjectFactory):
    &#34;&#34;&#34;
    A `refinery.lib.crypto.CipherObjectFactory` for custom block ciphers.
    &#34;&#34;&#34;

    cipher: type[BlockCipher]

    def __init__(self, cipher: type[BlockCipher]):
        self.cipher = cipher
        self._modes = []
        for name, mode in CIPHER_MODES.items():
            setattr(self, F&#39;MODE_{name}&#39;, mode._identifier)
            self._modes.append(mode)

    def new(self, key, mode=None, **args) -&gt; CipherInterface:
        if mode is not None:
            mode = self._modes[mode]
        mode_arguments = {}
        cipher = self.cipher
        for arg in (&#39;iv&#39;, &#39;counter&#39;, &#39;initial_value&#39;, &#39;nonce&#39;, &#39;mode&#39;, &#39;segment_size&#39;):
            try:
                mode_arguments[arg] = args.pop(arg)
            except KeyError:
                pass
        if mode is CTR:
            block_size = self.block_size
            if block_size is None:
                # This happens for ciphers that do not have a fixed block size, i.e. the
                # block size is truly an instance attribute and not a class property.
                # In this case, we create a temporary cipher object and use it to obtain
                # the true block size.
                block_size = cipher(key, ECB(), **args).block_size
            mode_arguments.update(block_size=block_size)
        if mode is None:
            mode = ECB
        mode = mode(**mode_arguments)
        return cipher(key, mode, **args)

    @property
    def name(self):
        return self.cipher.__name__

    @property
    def key_size(self):
        try:
            value = self.cipher.key_size
        except AttributeError:
            return None
        if isinstance(value, property):
            return None
        return value

    @property
    def block_size(self):
        try:
            value = self.cipher.block_size
        except AttributeError:
            return None
        if not isinstance(value, int):
            return None
        return value


class BlockCipher(CipherInterface, ABC):
    block_size: int
    key: BufferType
    mode: CipherMode
    key_size: Collection[int]

    def __init__(self, key: BufferType, mode: CipherMode | None):
        if len(key) not in self.key_size:
            raise ValueError(F&#39;The key size {len(key)} is not supported by {self.__class__.__name__.lower()}.&#39;)
        self.key = key
        self.mode = mode or ECB()

    @abstractmethod
    def block_encrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Encryption of a single block of data.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def block_decrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Decryption of a single block of data.
        &#34;&#34;&#34;
        raise NotImplementedError

    def _apply_blockwise(self, operation: Operation, data: BufferType) -&gt; BufferType:
        block_size = self.block_size
        mode = self.mode
        if (k := -len(data) % block_size) and mode.aligned:
            raise DataUnaligned(block_size, k)
        dst = src = memoryview(data)
        if dst.readonly:
            dst = memoryview(bytearray(src))
        return mode.apply(
            operation,
            dst,
            src,
            self.block_encrypt,
            self.block_decrypt,
            block_size
        )

    def encrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Encrypt the input data.
        &#34;&#34;&#34;
        return self._apply_blockwise(Operation.Encrypt, data)

    def decrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Decrypt the input data.
        &#34;&#34;&#34;
        return self._apply_blockwise(Operation.Decrypt, data)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.crypto.strxor"><code class="name flex">
<span>def <span class="ident">strxor</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the XOR of the two byte strings <code>a</code> and <code>b</code>. The shorter of the two strings defines the
length of the output.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L15-L20" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def strxor(a: bytes, b: bytes):
    &#34;&#34;&#34;
    Return the XOR of the two byte strings `a` and `b`. The shorter of the two strings defines the
    length of the output.
    &#34;&#34;&#34;
    return bytes(a ^ b for a, b in zip(a, b))</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotl128"><code class="name flex">
<span>def <span class="ident">rotl128</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 128-bit integer <code>x</code> by <code>c</code> positions to the left.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L29-L33" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotl128(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 128-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x80 - c))) &amp; 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotl64"><code class="name flex">
<span>def <span class="ident">rotl64</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 64-bit integer <code>x</code> by <code>c</code> positions to the left.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L36-L40" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotl64(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 64-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x40 - c))) &amp; 0xFFFFFFFFFFFFFFFF</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotl32"><code class="name flex">
<span>def <span class="ident">rotl32</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 32-bit integer <code>x</code> by <code>c</code> positions to the left.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L43-L47" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotl32(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 32-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x20 - c))) &amp; 0xFFFFFFFF</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotl16"><code class="name flex">
<span>def <span class="ident">rotl16</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 16-bit integer <code>x</code> by <code>c</code> positions to the left.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L50-L54" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotl16(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 16-bit integer `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x10 - c))) &amp; 0xFFFF</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotl8"><code class="name flex">
<span>def <span class="ident">rotl8</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the byte <code>x</code> by <code>c</code> positions to the left.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L57-L61" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotl8(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the byte `x` by `c` positions to the left.
    &#34;&#34;&#34;
    return ((x &lt;&lt; c) | (x &gt;&gt; (0x08 - c))) &amp; 0xFF</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotr128"><code class="name flex">
<span>def <span class="ident">rotr128</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 128-bit integer <code>x</code> by <code>c</code> positions to the right.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L64-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotr128(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 128-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x80 - c) &amp; 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | (x &gt;&gt; c)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotr64"><code class="name flex">
<span>def <span class="ident">rotr64</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 64-bit integer <code>x</code> by <code>c</code> positions to the right.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L71-L75" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotr64(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 64-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x40 - c) &amp; 0xFFFFFFFFFFFFFFFF) | (x &gt;&gt; c)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotr32"><code class="name flex">
<span>def <span class="ident">rotr32</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 32-bit integer <code>x</code> by <code>c</code> positions to the right.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L78-L82" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotr32(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 32-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x20 - c) &amp; 0xFFFFFFFF) | (x &gt;&gt; c)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotr16"><code class="name flex">
<span>def <span class="ident">rotr16</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the 16-bit integer <code>x</code> by <code>c</code> positions to the right.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L85-L89" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotr16(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the 16-bit integer `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x10 - c) &amp; 0xFFFF) | (x &gt;&gt; c)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotr8"><code class="name flex">
<span>def <span class="ident">rotr8</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the byte <code>x</code> by <code>c</code> positions to the right.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L92-L96" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotr8(x: int, c: int):
    &#34;&#34;&#34;
    Rotate the byte `x` by `c` positions to the right.
    &#34;&#34;&#34;
    return (x &lt;&lt; (0x08 - c) &amp; 0xFF) | (x &gt;&gt; c)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotr"><code class="name flex">
<span>def <span class="ident">rotr</span></span>(<span>n, x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the <code>n</code>-bit integer <code>x</code> by <code>c</code> positions to the right. If <code>n</code> is among the common bit
sizes 8, 16, 32, 64, or 128, then one of the more specific functions in this module should be
used instead.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L99-L107" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotr(n: int, x: int, c: int) -&gt; int:
    &#34;&#34;&#34;
    Rotate the `n`-bit integer `x` by `c` positions to the right. If `n` is among the common bit
    sizes 8, 16, 32, 64, or 128, then one of the more specific functions in this module should be
    used instead.
    &#34;&#34;&#34;
    mask = (1 &lt;&lt; n) - 1
    c %= n
    return (x &gt;&gt; c) | (x &lt;&lt; (n - c) &amp; mask)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.rotl"><code class="name flex">
<span>def <span class="ident">rotl</span></span>(<span>n, x, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate the <code>n</code>-bit integer <code>x</code> by <code>c</code> positions to the left. If <code>n</code> is among the common bit
sizes 8, 16, 32, 64, or 128, then one of the more specific functions in this module should be
used instead.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L110-L118" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotl(n: int, x: int, c: int) -&gt; int:
    &#34;&#34;&#34;
    Rotate the `n`-bit integer `x` by `c` positions to the left. If `n` is among the common bit
    sizes 8, 16, 32, 64, or 128, then one of the more specific functions in this module should be
    used instead.
    &#34;&#34;&#34;
    mask = (1 &lt;&lt; n) - 1
    c %= n
    return (x &gt;&gt; (n - c)) | (x &lt;&lt; c &amp; mask)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.pad_pkcs7"><code class="name flex">
<span>def <span class="ident">pad_pkcs7</span></span>(<span>data, block_size)</span>
</code></dt>
<dd>
<section class="desc"><p>Pad a bytearray in-place using the PKCS7 padding type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L121-L126" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pad_pkcs7(data: bytearray, block_size: int) -&gt; None:
    &#34;&#34;&#34;
    Pad a bytearray in-place using the PKCS7 padding type.
    &#34;&#34;&#34;
    for _ in range(p := block_size - len(data) % block_size):
        data.append(p)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.pad_x923"><code class="name flex">
<span>def <span class="ident">pad_x923</span></span>(<span>data, block_size)</span>
</code></dt>
<dd>
<section class="desc"><p>Pad a bytearray in-place using the ANSI x923 padding type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L129-L135" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pad_x923(data: bytearray, block_size: int) -&gt; None:
    &#34;&#34;&#34;
    Pad a bytearray in-place using the ANSI x923 padding type.
    &#34;&#34;&#34;
    p = block_size - len(data) % block_size
    data.extend(0 for _ in range(p - 1))
    data.append(p)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.pad_iso7816"><code class="name flex">
<span>def <span class="ident">pad_iso7816</span></span>(<span>data, block_size)</span>
</code></dt>
<dd>
<section class="desc"><p>Pad a bytearray in-place using the ISO-7816 padding type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L138-L144" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pad_iso7816(data: bytearray, block_size: int) -&gt; None:
    &#34;&#34;&#34;
    Pad a bytearray in-place using the ISO-7816 padding type.
    &#34;&#34;&#34;
    data.append(0x80)
    for _ in range(-len(data) % block_size):
        data.append(0)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.unpad_pkcs7"><code class="name flex">
<span>def <span class="ident">unpad_pkcs7</span></span>(<span>data, block_size)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove a PKCS7 padding in-place. When an exception occurs, the data is left unchanged.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L147-L155" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpad_pkcs7(data: bytearray, block_size: int) -&gt; None:
    &#34;&#34;&#34;
    Remove a PKCS7 padding in-place. When an exception occurs, the data is left unchanged.
    &#34;&#34;&#34;
    if not 1 &lt;= (p := data[-1]) &lt;= block_size:
        raise ValueError
    if not all(data[-k] == p for k in range(1, p + 1)):
        raise ValueError
    del data[-p:]</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.unpad_x923"><code class="name flex">
<span>def <span class="ident">unpad_x923</span></span>(<span>data, block_size)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove an ANSI x923 padding in-place. When an exception occurs, the data is left unchanged.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L158-L167" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpad_x923(data: bytearray, block_size: int) -&gt; None:
    &#34;&#34;&#34;
    Remove an ANSI x923 padding in-place. When an exception occurs, the data is left unchanged.
    &#34;&#34;&#34;
    if not 1 &lt;= (p := data[-1]) &lt;= block_size:
        raise ValueError
    for k in range(2, p + 1):
        if data[-k]:
            raise ValueError
    del data[-p:]</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.unpad_iso7816"><code class="name flex">
<span>def <span class="ident">unpad_iso7816</span></span>(<span>data, block_size)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove an ISO-7816 padding in-place. When an exception occurs, the data is left unchanged.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L170-L180" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpad_iso7816(data: bytearray, block_size: int) -&gt; None:
    &#34;&#34;&#34;
    Remove an ISO-7816 padding in-place. When an exception occurs, the data is left unchanged.
    &#34;&#34;&#34;
    for k in range(1, block_size + 1):
        b = data[-k]
        if b == 0x80:
            del data[-k:]
            return
        if b != 0x00:
            raise ValueError</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.unpad"><code class="name flex">
<span>def <span class="ident">unpad</span></span>(<span>data, block_size, method)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove padding from the given buffer in place for the given block size according to the given
padding method.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L192-L203" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpad(data: bytearray, block_size: int, method: str | Padding):
    &#34;&#34;&#34;
    Remove padding from the given buffer in place for the given block size according to the given
    padding method.
    &#34;&#34;&#34;
    if method == Padding.PKCS7:
        return unpad_pkcs7(data, block_size)
    if method == Padding.X923:
        return unpad_x923(data, block_size)
    if method == Padding.ISO7816:
        return unpad_iso7816(data, block_size)
    raise ValueError(method)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.pad"><code class="name flex">
<span>def <span class="ident">pad</span></span>(<span>data, block_size, method)</span>
</code></dt>
<dd>
<section class="desc"><p>Pad the given buffer in place to the given block size according to the given padding method.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L206-L216" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pad(data: bytearray, block_size: int, method: str | Padding):
    &#34;&#34;&#34;
    Pad the given buffer in place to the given block size according to the given padding method.
    &#34;&#34;&#34;
    if method == Padding.PKCS7:
        return pad_pkcs7(data, block_size)
    if method == Padding.X923:
        return pad_x923(data, block_size)
    if method == Padding.ISO7816:
        return pad_iso7816(data, block_size)
    raise ValueError(method)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.crypto.Padding"><code class="flex name class">
<span>class <span class="ident">Padding</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Supported padding methods for <code><a title="refinery.lib.crypto.unpad" href="#refinery.lib.crypto.unpad">unpad()</a></code> and <code><a title="refinery.lib.crypto.pad" href="#refinery.lib.crypto.pad">pad()</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L183-L189" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Padding(str, Enum):
    &#34;&#34;&#34;
    Supported padding methods for `refinery.lib.crypto.unpad` and `refinery.lib.crypto.pad`.
    &#34;&#34;&#34;
    PKCS7 = &#39;pkcs7&#39;
    ISO7816 = &#39;iso7816&#39;
    X923 = &#39;x923&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.Padding.PKCS7"><code class="name">var <span class="ident">PKCS7</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.Padding.ISO7816"><code class="name">var <span class="ident">ISO7816</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.Padding.X923"><code class="name">var <span class="ident">X923</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.crypto.Operation"><code class="flex name class">
<span>class <span class="ident">Operation</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Specifies whether data is currently being encrypted or decrypted.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L219-L224" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Operation(str, Enum):
    &#34;&#34;&#34;
    Specifies whether data is currently being encrypted or decrypted.
    &#34;&#34;&#34;
    Encrypt = &#39;encrypt&#39;
    Decrypt = &#39;decrypt&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.Operation.Encrypt"><code class="name">var <span class="ident">Encrypt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.Operation.Decrypt"><code class="name">var <span class="ident">Decrypt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.crypto.CipherMode"><code class="flex name class">
<span>class <span class="ident">CipherMode</span></span>
</code></dt>
<dd>
<section class="desc"><p>Abstract base class for a cipher mode of operation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L227-L280" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CipherMode(ABC):
    &#34;&#34;&#34;
    Abstract base class for a cipher mode of operation.
    &#34;&#34;&#34;

    encrypt_block: Callable[[BufferType], BufferType]
    decrypt_block: Callable[[BufferType], BufferType]
    aligned: bool = True
    _identifier: ClassVar[int]

    @abstractmethod
    def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        &#34;&#34;&#34;
        Implements data encryption according to the current cipher mode and underlying cipher.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def decrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        &#34;&#34;&#34;
        Implements data decryption according to the current cipher mode and underlying cipher.
        &#34;&#34;&#34;
        raise NotImplementedError

    def apply(
        self,
        operation: Operation,
        dst: memoryview,
        src: memoryview,
        encrypt_block: Callable[[BufferType], BufferType],
        decrypt_block: Callable[[BufferType], BufferType],
        blocksize: int,
    ) -&gt; memoryview:
        &#34;&#34;&#34;
        This method is used to perform a cryptographic `refinery.lib.crypto.Operation` to a given
        source `src` and write the result to the memory at `dst` according to the current cipher
        mode. To this end, it requires the block encryption and decryption primitives of the
        underlying cipher and the current block size.
        &#34;&#34;&#34;
        self.encrypt_block = encrypt_block
        self.decrypt_block = decrypt_block
        engine: Generator[BufferType, memoryview, None] = {
            Operation.Encrypt: self.encrypt,
            Operation.Decrypt: self.decrypt,
        }[operation]()
        next(engine)
        top, rest = divmod(len(src), blocksize)
        top *= blocksize
        for k in range(0, top, blocksize):
            dst[k:k + blocksize] = engine.send(src[k:k + blocksize])
        if rest:
            dst[-rest:] = engine.send(src[-rest:])[:rest]
        engine.close()
        return dst</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CFB" href="#refinery.lib.crypto.CFB">CFB</a></li>
<li><a title="refinery.lib.crypto.CTR" href="#refinery.lib.crypto.CTR">CTR</a></li>
<li><a title="refinery.lib.crypto.ECB" href="#refinery.lib.crypto.ECB">ECB</a></li>
<li><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.CipherMode.encrypt_block"><code class="name">var <span class="ident">encrypt_block</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CipherMode.decrypt_block"><code class="name">var <span class="ident">decrypt_block</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CipherMode.aligned"><code class="name">var <span class="ident">aligned</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.crypto.CipherMode.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements data encryption according to the current cipher mode and underlying cipher.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L237-L242" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
    &#34;&#34;&#34;
    Implements data encryption according to the current cipher mode and underlying cipher.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.CipherMode.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements data decryption according to the current cipher mode and underlying cipher.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L244-L249" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def decrypt(self) -&gt; Generator[BufferType, memoryview, None]:
    &#34;&#34;&#34;
    Implements data decryption according to the current cipher mode and underlying cipher.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.CipherMode.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, operation, dst, src, encrypt_block, decrypt_block, blocksize)</span>
</code></dt>
<dd>
<section class="desc"><p>This method is used to perform a cryptographic <code><a title="refinery.lib.crypto.Operation" href="#refinery.lib.crypto.Operation">Operation</a></code> to a given
source <code>src</code> and write the result to the memory at <code>dst</code> according to the current cipher
mode. To this end, it requires the block encryption and decryption primitives of the
underlying cipher and the current block size.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L251-L280" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def apply(
    self,
    operation: Operation,
    dst: memoryview,
    src: memoryview,
    encrypt_block: Callable[[BufferType], BufferType],
    decrypt_block: Callable[[BufferType], BufferType],
    blocksize: int,
) -&gt; memoryview:
    &#34;&#34;&#34;
    This method is used to perform a cryptographic `refinery.lib.crypto.Operation` to a given
    source `src` and write the result to the memory at `dst` according to the current cipher
    mode. To this end, it requires the block encryption and decryption primitives of the
    underlying cipher and the current block size.
    &#34;&#34;&#34;
    self.encrypt_block = encrypt_block
    self.decrypt_block = decrypt_block
    engine: Generator[BufferType, memoryview, None] = {
        Operation.Encrypt: self.encrypt,
        Operation.Decrypt: self.decrypt,
    }[operation]()
    next(engine)
    top, rest = divmod(len(src), blocksize)
    top *= blocksize
    for k in range(0, top, blocksize):
        dst[k:k + blocksize] = engine.send(src[k:k + blocksize])
    if rest:
        dst[-rest:] = engine.send(src[-rest:])[:rest]
    engine.close()
    return dst</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.crypto.ECB"><code class="flex name class">
<span>class <span class="ident">ECB</span></span>
</code></dt>
<dd>
<section class="desc"><p>The Electronic Codebook (ECB) is the most simple cipher mode of operation. The underlying
cipher is applied block-wise with no additional safeguards.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L283-L302" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_register_cipher_mode
class ECB(CipherMode):
    &#34;&#34;&#34;
    The Electronic Codebook (ECB) is the most simple cipher mode of operation. The underlying
    cipher is applied block-wise with no additional safeguards.
    &#34;&#34;&#34;

    def decrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        M = B&#39;&#39;
        D = self.decrypt_block
        while True:
            C = yield M
            M = D(C)

    def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        C = B&#39;&#39;
        E = self.encrypt_block
        while True:
            M = yield C
            C = E(M)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.CipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.decrypt" href="#refinery.lib.crypto.CipherMode.decrypt">decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.DataUnaligned"><code class="flex name class">
<span>class <span class="ident">DataUnaligned</span></span>
<span>(</span><span>b, k)</span>
</code></dt>
<dd>
<section class="desc"><p>Raised when input data is unexpectedly unaligned to the current block size.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L305-L310" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DataUnaligned(ValueError):
    &#34;&#34;&#34;
    Raised when input data is unexpectedly unaligned to the current block size.
    &#34;&#34;&#34;
    def __init__(self, b: int, k: int) -&gt; None:
        super().__init__(F&#39;Data not aligned to block size {b}, with {k} missing bytes to complete the block.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.StatefulCipherMode"><code class="flex name class">
<span>class <span class="ident">StatefulCipherMode</span></span>
<span>(</span><span>iv)</span>
</code></dt>
<dd>
<section class="desc"><p>A subclass of <code><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></code> that holds a state while performing any of
its cryptographic <code><a title="refinery.lib.crypto.Operation" href="#refinery.lib.crypto.Operation">Operation</a></code>s.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L313-L325" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StatefulCipherMode(CipherMode):
    &#34;&#34;&#34;
    A subclass of `refinery.lib.crypto.CipherMode` that holds a state while performing any of
    its cryptographic `refinery.lib.crypto.Operation`s.
    &#34;&#34;&#34;

    iv: BufferType
    &#34;&#34;&#34;
    The initial vector for the internal state of the cipher mode.
    &#34;&#34;&#34;

    def __init__(self, iv: BufferType):
        self.iv = iv</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CBC" href="#refinery.lib.crypto.CBC">CBC</a></li>
<li><a title="refinery.lib.crypto.OFB" href="#refinery.lib.crypto.OFB">OFB</a></li>
<li><a title="refinery.lib.crypto.PCBC" href="#refinery.lib.crypto.PCBC">PCBC</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.StatefulCipherMode.iv"><code class="name">var <span class="ident">iv</span></code></dt>
<dd>
<section class="desc"><p>The initial vector for the internal state of the cipher mode.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.CipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.decrypt" href="#refinery.lib.crypto.CipherMode.decrypt">decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.CBC"><code class="flex name class">
<span>class <span class="ident">CBC</span></span>
<span>(</span><span>iv)</span>
</code></dt>
<dd>
<section class="desc"><p>An implementation of the popular Cipher Block Chaining mode of operation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L328-L348" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_register_cipher_mode
class CBC(StatefulCipherMode):
    &#34;&#34;&#34;
    An implementation of the popular Cipher Block Chaining mode of operation.
    &#34;&#34;&#34;

    def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        C = self.iv
        E = self.encrypt_block
        while True:
            M = yield C
            C = E(strxor(M, C))

    def decrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        S = self.iv
        M = B&#39;&#39;
        D = self.decrypt_block
        while True:
            C = yield M
            M = strxor(D(C), S)
            S = bytes(C)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></li>
<li><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.decrypt" href="#refinery.lib.crypto.CipherMode.decrypt">decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.iv" href="#refinery.lib.crypto.StatefulCipherMode.iv">iv</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.PCBC"><code class="flex name class">
<span>class <span class="ident">PCBC</span></span>
<span>(</span><span>iv)</span>
</code></dt>
<dd>
<section class="desc"><p>An implementation of Propagating Cipher Block Chaining.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L351-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_register_cipher_mode
class PCBC(StatefulCipherMode):
    &#34;&#34;&#34;
    An implementation of Propagating Cipher Block Chaining.
    &#34;&#34;&#34;

    def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        S = self.iv
        C = B&#39;&#39;
        E = self.encrypt_block
        while True:
            M = yield C
            C = E(strxor(M, S))
            S = strxor(C, M)

    def decrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        S = self.iv
        M = B&#39;&#39;
        D = self.decrypt_block
        while True:
            C = yield M
            M = strxor(S, D(C))
            S = strxor(M, C)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></li>
<li><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.decrypt" href="#refinery.lib.crypto.CipherMode.decrypt">decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.iv" href="#refinery.lib.crypto.StatefulCipherMode.iv">iv</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.CFB"><code class="flex name class">
<span>class <span class="ident">CFB</span></span>
<span>(</span><span>iv, segment_size=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Cipher Feedback Mode: <a href="https://csrc.nist.gov/publications/detail/sp/800-38a/final">https://csrc.nist.gov/publications/detail/sp/800-38a/final</a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L376-L437" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_register_cipher_mode
class CFB(CipherMode):
    &#34;&#34;&#34;
    Cipher Feedback Mode: https://csrc.nist.gov/publications/detail/sp/800-38a/final
    &#34;&#34;&#34;

    iv: BufferType
    segment_size: int
    aligned = False

    def __init__(self, iv: BufferType, segment_size: int | None = None):
        if segment_size is None:
            segment_size = 8
        if segment_size % 8 != 0:
            raise NotImplementedError(&#39;segment sizes may only be multiples of 8&#39;)
        segment_size = segment_size // 8
        if len(iv) % segment_size != 0:
            raise NotImplementedError(
                F&#39;the block size {len(iv) * 8} is not an even multiple of the segment &#39;
                F&#39;size {segment_size * 8}; this is currently not supported.&#39;)
        self.segment_size = segment_size
        self.iv = iv

    def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        s = self.segment_size
        S = bytearray(self.iv)
        E = self.encrypt_block
        C = bytearray(len(self.iv))
        if s == 1:
            while True:
                M = yield C
                for k, m in enumerate(M):
                    C[k] = c = m ^ E(S)[0]
                    S[:-1], S[-1] = memoryview(S)[1:], c
        else:
            segments = [slice(i, i + s) for i in range(0, len(S), s)]
            while True:
                M = yield C
                for k in segments:
                    m = M[k]
                    C[k] = c = strxor(m, E(S)[:s])
                    S[:-s], S[-s:] = memoryview(S)[s:], c

    def decrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        s = self.segment_size
        S = bytearray(self.iv)
        E = self.encrypt_block
        M = bytearray(len(self.iv))
        if s == 1:
            while True:
                C = yield M
                for k, c in enumerate(C):
                    M[k] = c ^ E(S)[0]
                    S[:-1], S[-1] = memoryview(S)[1:], c
        else:
            segments = [slice(i, i + s) for i in range(0, len(S), s)]
            while True:
                C = yield M
                for k in segments:
                    c = C[k]
                    M[k] = strxor(c, E(S)[:s])
                    S[:-s], S[-s:] = memoryview(S)[s:], c</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.CFB.iv"><code class="name">var <span class="ident">iv</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CFB.segment_size"><code class="name">var <span class="ident">segment_size</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CFB.aligned"><code class="name">var <span class="ident">aligned</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.CipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.decrypt" href="#refinery.lib.crypto.CipherMode.decrypt">decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.OFB"><code class="flex name class">
<span>class <span class="ident">OFB</span></span>
<span>(</span><span>iv)</span>
</code></dt>
<dd>
<section class="desc"><p>An implementation of Output Feedback Mode.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L440-L457" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_register_cipher_mode
class OFB(StatefulCipherMode):
    &#34;&#34;&#34;
    An implementation of Output Feedback Mode.
    &#34;&#34;&#34;

    aligned = False

    def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        S = self.iv
        C = B&#39;&#39;
        E = self.encrypt_block
        while True:
            M = yield C
            S = E(S)
            C = strxor(M, S)

    decrypt = encrypt</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></li>
<li><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.OFB.aligned"><code class="name">var <span class="ident">aligned</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.crypto.OFB.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements data encryption according to the current cipher mode and underlying cipher.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L448-L455" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
    S = self.iv
    C = B&#39;&#39;
    E = self.encrypt_block
    while True:
        M = yield C
        S = E(S)
        C = strxor(M, S)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.StatefulCipherMode.iv" href="#refinery.lib.crypto.StatefulCipherMode.iv">iv</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.CTR"><code class="flex name class">
<span>class <span class="ident">CTR</span></span>
<span>(</span><span>block_size=None, counter=None, nonce=None, initial_value=0, little_endian=False)</span>
</code></dt>
<dd>
<section class="desc"><p>An implementation of Counter mode.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L460-L533" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_register_cipher_mode
class CTR(CipherMode):
    &#34;&#34;&#34;
    An implementation of Counter mode.
    &#34;&#34;&#34;

    counter_len: int
    prefix: BufferType
    suffix: BufferType
    initial_value: int
    little_endian: bool
    block_size: int

    aligned = False

    @property
    def byte_order(self):
        return &#39;little&#39; if self.little_endian else &#39;big&#39;

    def __init__(
        self,
        block_size: int | None = None,
        counter: dict | None = None,
        nonce: BufferType | None = None,
        initial_value: int | None = 0,
        little_endian: bool = False
    ):
        if counter is not None:
            self.initial_value = counter.get(&#39;initial_value&#39;, initial_value)
            self.little_endian = counter.get(&#39;little_endian&#39;, little_endian)
            self.prefix = counter[&#39;prefix&#39;]
            self.suffix = counter[&#39;suffix&#39;]
            self.counter_len = counter[&#39;counter_len&#39;]
            self.block_size = self.counter_len + len(self.prefix) + len(self.suffix)
            if block_size not in {None, self.block_size}:
                raise ValueError(&#39;Information in counter object does not align with block size.&#39;)
            return
        if block_size is None:
            raise ValueError(&#39;Unable to construct CTR mode object without block_size or counter argument.&#39;)

        self.initial_value = initial_value or 0
        self.little_endian = little_endian
        self.suffix = B&#39;&#39;
        self.block_size = block_size

        if nonce is not None:
            if len(nonce) &gt; block_size:
                raise ValueError(&#39;Nonce length exceeds block length.&#39;)
            self.counter_len = block_size - len(nonce)
            self.prefix = nonce
        else:
            self.counter_len = block_size // 2
            self.prefix = B&#39;\0&#39; * (block_size - self.counter_len)

    def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
        S = bytearray(self.block_size)
        J = slice(len(self.prefix), self.block_size - len(self.suffix))
        K = self.initial_value
        if self.prefix:
            S[:+len(self.prefix)] = self.prefix
        if self.suffix:
            S[-len(self.suffix):] = self.suffix
        C = B&#39;&#39;
        E = self.encrypt_block
        order = self.byte_order
        csize = self.counter_len
        mask = (1 &lt;&lt; (csize * 8)) - 1
        while True:
            M = yield C
            S[J] = K.to_bytes(csize, order)
            K = K + 1 &amp; mask
            C = strxor(E(S), M)

    decrypt = encrypt</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.CTR.counter_len"><code class="name">var <span class="ident">counter_len</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CTR.prefix"><code class="name">var <span class="ident">prefix</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CTR.suffix"><code class="name">var <span class="ident">suffix</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CTR.initial_value"><code class="name">var <span class="ident">initial_value</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CTR.little_endian"><code class="name">var <span class="ident">little_endian</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CTR.block_size"><code class="name">var <span class="ident">block_size</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CTR.aligned"><code class="name">var <span class="ident">aligned</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.crypto.CTR.byte_order"><code class="name">var <span class="ident">byte_order</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L475-L477" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def byte_order(self):
    return &#39;little&#39; if self.little_endian else &#39;big&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.crypto.CTR.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements data encryption according to the current cipher mode and underlying cipher.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L514-L531" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encrypt(self) -&gt; Generator[BufferType, memoryview, None]:
    S = bytearray(self.block_size)
    J = slice(len(self.prefix), self.block_size - len(self.suffix))
    K = self.initial_value
    if self.prefix:
        S[:+len(self.prefix)] = self.prefix
    if self.suffix:
        S[-len(self.suffix):] = self.suffix
    C = B&#39;&#39;
    E = self.encrypt_block
    order = self.byte_order
    csize = self.counter_len
    mask = (1 &lt;&lt; (csize * 8)) - 1
    while True:
        M = yield C
        S[J] = K.to_bytes(csize, order)
        K = K + 1 &amp; mask
        C = strxor(E(S), M)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.CipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.CipherInterface"><code class="flex name class">
<span>class <span class="ident">CipherInterface</span></span>
</code></dt>
<dd>
<section class="desc"><p>Abstract base class for refinery's block cipher interface.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L536-L580" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CipherInterface(ABC):
    &#34;&#34;&#34;
    Abstract base class for refinery&#39;s block cipher interface.
    &#34;&#34;&#34;

    key_size: Collection[int]
    &#34;&#34;&#34;
    A sequence containing all valid key sizes for this cipher.
    &#34;&#34;&#34;

    block_size: int
    &#34;&#34;&#34;
    The block size of this cipher.
    &#34;&#34;&#34;

    @abstractmethod
    def encrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Data encryption according to this cipher interface.
        &#34;&#34;&#34;

    @abstractmethod
    def decrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Data decryption according to this cipher interface.
        &#34;&#34;&#34;

    def update(self, D: BufferType) -&gt; None:
        &#34;&#34;&#34;
        Provide additional authenticated data to a cipher that supports authentication. This method
        must be called before decryption.
        &#34;&#34;&#34;
        return

    def verify(self, T: BufferType) -&gt; bool:
        &#34;&#34;&#34;
        Verify that the decrypted message is authentic given the input tag.
        &#34;&#34;&#34;
        raise NotImplementedError

    def digest(self) -&gt; BufferType:
        &#34;&#34;&#34;
        Compute the binary authentication tag (MAC).
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.BlockCipher" href="#refinery.lib.crypto.BlockCipher">BlockCipher</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.CipherInterface.key_size"><code class="name">var <span class="ident">key_size</span></code></dt>
<dd>
<section class="desc"><p>A sequence containing all valid key sizes for this cipher.</p></section>
</dd>
<dt id="refinery.lib.crypto.CipherInterface.block_size"><code class="name">var <span class="ident">block_size</span></code></dt>
<dd>
<section class="desc"><p>The block size of this cipher.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.crypto.CipherInterface.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Data encryption according to this cipher interface.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L551-L555" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def encrypt(self, data: BufferType) -&gt; BufferType:
    &#34;&#34;&#34;
    Data encryption according to this cipher interface.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.CipherInterface.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Data decryption according to this cipher interface.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L557-L561" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def decrypt(self, data: BufferType) -&gt; BufferType:
    &#34;&#34;&#34;
    Data decryption according to this cipher interface.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.CipherInterface.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, D)</span>
</code></dt>
<dd>
<section class="desc"><p>Provide additional authenticated data to a cipher that supports authentication. This method
must be called before decryption.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L563-L568" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def update(self, D: BufferType) -&gt; None:
    &#34;&#34;&#34;
    Provide additional authenticated data to a cipher that supports authentication. This method
    must be called before decryption.
    &#34;&#34;&#34;
    return</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.CipherInterface.verify"><code class="name flex">
<span>def <span class="ident">verify</span></span>(<span>self, T)</span>
</code></dt>
<dd>
<section class="desc"><p>Verify that the decrypted message is authentic given the input tag.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L570-L574" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def verify(self, T: BufferType) -&gt; bool:
    &#34;&#34;&#34;
    Verify that the decrypted message is authentic given the input tag.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.CipherInterface.digest"><code class="name flex">
<span>def <span class="ident">digest</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the binary authentication tag (MAC).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L576-L580" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def digest(self) -&gt; BufferType:
    &#34;&#34;&#34;
    Compute the binary authentication tag (MAC).
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.crypto.CipherObjectFactory"><code class="flex name class">
<span>class <span class="ident">CipherObjectFactory</span></span>
</code></dt>
<dd>
<section class="desc"><p>An abstract class to build <code><a title="refinery.lib.crypto.CipherInterface" href="#refinery.lib.crypto.CipherInterface">CipherInterface</a></code>s from an asortment of
cryptographic secrets and parameters.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L583-L612" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CipherObjectFactory(ABC):
    &#34;&#34;&#34;
    An abstract class to build `refinery.lib.crypto.CipherInterface`s from an asortment of
    cryptographic secrets and parameters.
    &#34;&#34;&#34;

    name: str
    key_size: Collection[int] | None = None
    block_size: int | None = None

    @abstractmethod
    def new(
        self,
        key: BufferType,
        *,
        iv: BufferType | None = None,
        counter: int | None = None,
        initial_value: int | None = 0,
        nonce: BufferType | None = None,
        mode: str | None = None,
        segment_size: int | None = None,
        block_size: int | None = None,
        **cipher_args
    ) -&gt; CipherInterface:
        &#34;&#34;&#34;
        Build the actual `refinery.lib.crypto.CipherInterface` from the given input parameters.
        This mimics the PyCrypto interface for new ciphers in order to make the refinery factory
        cross-compatible with that library.
        &#34;&#34;&#34;
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.BlockCipherFactory" href="#refinery.lib.crypto.BlockCipherFactory">BlockCipherFactory</a></li>
<li><a title="refinery.lib.crypto.PyCryptoFactoryWrapper" href="#refinery.lib.crypto.PyCryptoFactoryWrapper">PyCryptoFactoryWrapper</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.CipherObjectFactory.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CipherObjectFactory.key_size"><code class="name">var <span class="ident">key_size</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.CipherObjectFactory.block_size"><code class="name">var <span class="ident">block_size</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.crypto.CipherObjectFactory.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>self, key, *, iv=None, counter=None, initial_value=0, nonce=None, mode=None, segment_size=None, block_size=None, **cipher_args)</span>
</code></dt>
<dd>
<section class="desc"><p>Build the actual <code><a title="refinery.lib.crypto.CipherInterface" href="#refinery.lib.crypto.CipherInterface">CipherInterface</a></code> from the given input parameters.
This mimics the PyCrypto interface for new ciphers in order to make the refinery factory
cross-compatible with that library.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L593-L612" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def new(
    self,
    key: BufferType,
    *,
    iv: BufferType | None = None,
    counter: int | None = None,
    initial_value: int | None = 0,
    nonce: BufferType | None = None,
    mode: str | None = None,
    segment_size: int | None = None,
    block_size: int | None = None,
    **cipher_args
) -&gt; CipherInterface:
    &#34;&#34;&#34;
    Build the actual `refinery.lib.crypto.CipherInterface` from the given input parameters.
    This mimics the PyCrypto interface for new ciphers in order to make the refinery factory
    cross-compatible with that library.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.crypto.PyCryptoFactoryWrapper"><code class="flex name class">
<span>class <span class="ident">PyCryptoFactoryWrapper</span></span>
<span>(</span><span>module)</span>
</code></dt>
<dd>
<section class="desc"><p>Wraps a PyCrypto module as a <code><a title="refinery.lib.crypto.CipherObjectFactory" href="#refinery.lib.crypto.CipherObjectFactory">CipherObjectFactory</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L615-L651" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PyCryptoFactoryWrapper(CipherObjectFactory):
    &#34;&#34;&#34;
    Wraps a PyCrypto module as a `refinery.lib.crypto.CipherObjectFactory`.
    &#34;&#34;&#34;

    def __init__(self, module):
        self.module = module

    def new(self, *a, **k) -&gt; CipherInterface:
        return self.module.new(*a, **k)

    @property
    def key_size(self):
        try:
            value = self.module.key_size
        except AttributeError:
            return None
        if isinstance(value, int):
            return {value}
        return value

    @property
    def block_size(self):
        try:
            value = self.module.block_size
        except AttributeError:
            return None
        return value

    def __repr__(self):
        return repr(self.module)

    def __dir__(self):
        return dir(self.module)

    def __getattr__(self, key):
        return getattr(self.module, key)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CipherObjectFactory" href="#refinery.lib.crypto.CipherObjectFactory">CipherObjectFactory</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.crypto.PyCryptoFactoryWrapper.key_size"><code class="name">var <span class="ident">key_size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L626-L634" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def key_size(self):
    try:
        value = self.module.key_size
    except AttributeError:
        return None
    if isinstance(value, int):
        return {value}
    return value</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.PyCryptoFactoryWrapper.block_size"><code class="name">var <span class="ident">block_size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L636-L642" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def block_size(self):
    try:
        value = self.module.block_size
    except AttributeError:
        return None
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.CipherObjectFactory" href="#refinery.lib.crypto.CipherObjectFactory">CipherObjectFactory</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.CipherObjectFactory.new" href="#refinery.lib.crypto.CipherObjectFactory.new">new</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.BlockCipherFactory"><code class="flex name class">
<span>class <span class="ident">BlockCipherFactory</span></span>
<span>(</span><span>cipher)</span>
</code></dt>
<dd>
<section class="desc"><p>A <code><a title="refinery.lib.crypto.CipherObjectFactory" href="#refinery.lib.crypto.CipherObjectFactory">CipherObjectFactory</a></code> for custom block ciphers.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L654-L714" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BlockCipherFactory(CipherObjectFactory):
    &#34;&#34;&#34;
    A `refinery.lib.crypto.CipherObjectFactory` for custom block ciphers.
    &#34;&#34;&#34;

    cipher: type[BlockCipher]

    def __init__(self, cipher: type[BlockCipher]):
        self.cipher = cipher
        self._modes = []
        for name, mode in CIPHER_MODES.items():
            setattr(self, F&#39;MODE_{name}&#39;, mode._identifier)
            self._modes.append(mode)

    def new(self, key, mode=None, **args) -&gt; CipherInterface:
        if mode is not None:
            mode = self._modes[mode]
        mode_arguments = {}
        cipher = self.cipher
        for arg in (&#39;iv&#39;, &#39;counter&#39;, &#39;initial_value&#39;, &#39;nonce&#39;, &#39;mode&#39;, &#39;segment_size&#39;):
            try:
                mode_arguments[arg] = args.pop(arg)
            except KeyError:
                pass
        if mode is CTR:
            block_size = self.block_size
            if block_size is None:
                # This happens for ciphers that do not have a fixed block size, i.e. the
                # block size is truly an instance attribute and not a class property.
                # In this case, we create a temporary cipher object and use it to obtain
                # the true block size.
                block_size = cipher(key, ECB(), **args).block_size
            mode_arguments.update(block_size=block_size)
        if mode is None:
            mode = ECB
        mode = mode(**mode_arguments)
        return cipher(key, mode, **args)

    @property
    def name(self):
        return self.cipher.__name__

    @property
    def key_size(self):
        try:
            value = self.cipher.key_size
        except AttributeError:
            return None
        if isinstance(value, property):
            return None
        return value

    @property
    def block_size(self):
        try:
            value = self.cipher.block_size
        except AttributeError:
            return None
        if not isinstance(value, int):
            return None
        return value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CipherObjectFactory" href="#refinery.lib.crypto.CipherObjectFactory">CipherObjectFactory</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.BlockCipherFactory.cipher"><code class="name">var <span class="ident">cipher</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.crypto.BlockCipherFactory.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L692-L694" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def name(self):
    return self.cipher.__name__</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.BlockCipherFactory.key_size"><code class="name">var <span class="ident">key_size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L696-L704" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def key_size(self):
    try:
        value = self.cipher.key_size
    except AttributeError:
        return None
    if isinstance(value, property):
        return None
    return value</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.BlockCipherFactory.block_size"><code class="name">var <span class="ident">block_size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L706-L714" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def block_size(self):
    try:
        value = self.cipher.block_size
    except AttributeError:
        return None
    if not isinstance(value, int):
        return None
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.CipherObjectFactory" href="#refinery.lib.crypto.CipherObjectFactory">CipherObjectFactory</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.CipherObjectFactory.new" href="#refinery.lib.crypto.CipherObjectFactory.new">new</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.crypto.BlockCipher"><code class="flex name class">
<span>class <span class="ident">BlockCipher</span></span>
<span>(</span><span>key, mode)</span>
</code></dt>
<dd>
<section class="desc"><p>Abstract base class for refinery's block cipher interface.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L717-L770" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BlockCipher(CipherInterface, ABC):
    block_size: int
    key: BufferType
    mode: CipherMode
    key_size: Collection[int]

    def __init__(self, key: BufferType, mode: CipherMode | None):
        if len(key) not in self.key_size:
            raise ValueError(F&#39;The key size {len(key)} is not supported by {self.__class__.__name__.lower()}.&#39;)
        self.key = key
        self.mode = mode or ECB()

    @abstractmethod
    def block_encrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Encryption of a single block of data.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abstractmethod
    def block_decrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Decryption of a single block of data.
        &#34;&#34;&#34;
        raise NotImplementedError

    def _apply_blockwise(self, operation: Operation, data: BufferType) -&gt; BufferType:
        block_size = self.block_size
        mode = self.mode
        if (k := -len(data) % block_size) and mode.aligned:
            raise DataUnaligned(block_size, k)
        dst = src = memoryview(data)
        if dst.readonly:
            dst = memoryview(bytearray(src))
        return mode.apply(
            operation,
            dst,
            src,
            self.block_encrypt,
            self.block_decrypt,
            block_size
        )

    def encrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Encrypt the input data.
        &#34;&#34;&#34;
        return self._apply_blockwise(Operation.Encrypt, data)

    def decrypt(self, data: BufferType) -&gt; BufferType:
        &#34;&#34;&#34;
        Decrypt the input data.
        &#34;&#34;&#34;
        return self._apply_blockwise(Operation.Decrypt, data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.crypto.CipherInterface" href="#refinery.lib.crypto.CipherInterface">CipherInterface</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.crypto.cipher.camellia.Camellia" href="../units/crypto/cipher/camellia.html#refinery.units.crypto.cipher.camellia.Camellia">Camellia</a></li>
<li><a title="refinery.units.crypto.cipher.chaskey.Chaskey" href="../units/crypto/cipher/chaskey.html#refinery.units.crypto.cipher.chaskey.Chaskey">Chaskey</a></li>
<li><a title="refinery.units.crypto.cipher.gost.GOST" href="../units/crypto/cipher/gost.html#refinery.units.crypto.cipher.gost.GOST">GOST</a></li>
<li><a title="refinery.units.crypto.cipher.rc5.RC5" href="../units/crypto/cipher/rc5.html#refinery.units.crypto.cipher.rc5.RC5">RC5</a></li>
<li><a title="refinery.units.crypto.cipher.rc6.RC6" href="../units/crypto/cipher/rc6.html#refinery.units.crypto.cipher.rc6.RC6">RC6</a></li>
<li><a title="refinery.units.crypto.cipher.rijndael.Rijndael" href="../units/crypto/cipher/rijndael.html#refinery.units.crypto.cipher.rijndael.Rijndael">Rijndael</a></li>
<li><a title="refinery.units.crypto.cipher.serpent.Serpent" href="../units/crypto/cipher/serpent.html#refinery.units.crypto.cipher.serpent.Serpent">Serpent</a></li>
<li><a title="refinery.units.crypto.cipher.sm4.SM4" href="../units/crypto/cipher/sm4.html#refinery.units.crypto.cipher.sm4.SM4">SM4</a></li>
<li><a title="refinery.units.crypto.cipher.speck.Speck" href="../units/crypto/cipher/speck.html#refinery.units.crypto.cipher.speck.Speck">Speck</a></li>
<li><a title="refinery.units.crypto.cipher.tea.TEABase" href="../units/crypto/cipher/tea.html#refinery.units.crypto.cipher.tea.TEABase">TEABase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.crypto.BlockCipher.key"><code class="name">var <span class="ident">key</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.crypto.BlockCipher.mode"><code class="name">var <span class="ident">mode</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.crypto.BlockCipher.block_encrypt"><code class="name flex">
<span>def <span class="ident">block_encrypt</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Encryption of a single block of data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L729-L734" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def block_encrypt(self, data: BufferType) -&gt; BufferType:
    &#34;&#34;&#34;
    Encryption of a single block of data.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.BlockCipher.block_decrypt"><code class="name flex">
<span>def <span class="ident">block_decrypt</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Decryption of a single block of data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L736-L741" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def block_decrypt(self, data: BufferType) -&gt; BufferType:
    &#34;&#34;&#34;
    Decryption of a single block of data.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.BlockCipher.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Encrypt the input data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L760-L764" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encrypt(self, data: BufferType) -&gt; BufferType:
    &#34;&#34;&#34;
    Encrypt the input data.
    &#34;&#34;&#34;
    return self._apply_blockwise(Operation.Encrypt, data)</code></pre>
</details>
</dd>
<dt id="refinery.lib.crypto.BlockCipher.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Decrypt the input data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/crypto.py#L766-L770" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decrypt(self, data: BufferType) -&gt; BufferType:
    &#34;&#34;&#34;
    Decrypt the input data.
    &#34;&#34;&#34;
    return self._apply_blockwise(Operation.Decrypt, data)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.crypto.CipherInterface" href="#refinery.lib.crypto.CipherInterface">CipherInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.crypto.CipherInterface.block_size" href="#refinery.lib.crypto.CipherInterface.block_size">block_size</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherInterface.digest" href="#refinery.lib.crypto.CipherInterface.digest">digest</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherInterface.key_size" href="#refinery.lib.crypto.CipherInterface.key_size">key_size</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherInterface.update" href="#refinery.lib.crypto.CipherInterface.update">update</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherInterface.verify" href="#refinery.lib.crypto.CipherInterface.verify">verify</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="refinery.lib.crypto.strxor" href="#refinery.lib.crypto.strxor">strxor</a></code></li>
<li><code><a title="refinery.lib.crypto.rotl128" href="#refinery.lib.crypto.rotl128">rotl128</a></code></li>
<li><code><a title="refinery.lib.crypto.rotl64" href="#refinery.lib.crypto.rotl64">rotl64</a></code></li>
<li><code><a title="refinery.lib.crypto.rotl32" href="#refinery.lib.crypto.rotl32">rotl32</a></code></li>
<li><code><a title="refinery.lib.crypto.rotl16" href="#refinery.lib.crypto.rotl16">rotl16</a></code></li>
<li><code><a title="refinery.lib.crypto.rotl8" href="#refinery.lib.crypto.rotl8">rotl8</a></code></li>
<li><code><a title="refinery.lib.crypto.rotr128" href="#refinery.lib.crypto.rotr128">rotr128</a></code></li>
<li><code><a title="refinery.lib.crypto.rotr64" href="#refinery.lib.crypto.rotr64">rotr64</a></code></li>
<li><code><a title="refinery.lib.crypto.rotr32" href="#refinery.lib.crypto.rotr32">rotr32</a></code></li>
<li><code><a title="refinery.lib.crypto.rotr16" href="#refinery.lib.crypto.rotr16">rotr16</a></code></li>
<li><code><a title="refinery.lib.crypto.rotr8" href="#refinery.lib.crypto.rotr8">rotr8</a></code></li>
<li><code><a title="refinery.lib.crypto.rotr" href="#refinery.lib.crypto.rotr">rotr</a></code></li>
<li><code><a title="refinery.lib.crypto.rotl" href="#refinery.lib.crypto.rotl">rotl</a></code></li>
<li><code><a title="refinery.lib.crypto.pad_pkcs7" href="#refinery.lib.crypto.pad_pkcs7">pad_pkcs7</a></code></li>
<li><code><a title="refinery.lib.crypto.pad_x923" href="#refinery.lib.crypto.pad_x923">pad_x923</a></code></li>
<li><code><a title="refinery.lib.crypto.pad_iso7816" href="#refinery.lib.crypto.pad_iso7816">pad_iso7816</a></code></li>
<li><code><a title="refinery.lib.crypto.unpad_pkcs7" href="#refinery.lib.crypto.unpad_pkcs7">unpad_pkcs7</a></code></li>
<li><code><a title="refinery.lib.crypto.unpad_x923" href="#refinery.lib.crypto.unpad_x923">unpad_x923</a></code></li>
<li><code><a title="refinery.lib.crypto.unpad_iso7816" href="#refinery.lib.crypto.unpad_iso7816">unpad_iso7816</a></code></li>
<li><code><a title="refinery.lib.crypto.unpad" href="#refinery.lib.crypto.unpad">unpad</a></code></li>
<li><code><a title="refinery.lib.crypto.pad" href="#refinery.lib.crypto.pad">pad</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.crypto.Padding" href="#refinery.lib.crypto.Padding">Padding</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.Operation" href="#refinery.lib.crypto.Operation">Operation</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.CipherMode" href="#refinery.lib.crypto.CipherMode">CipherMode</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.crypto.CipherMode.encrypt" href="#refinery.lib.crypto.CipherMode.encrypt">encrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.decrypt" href="#refinery.lib.crypto.CipherMode.decrypt">decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherMode.apply" href="#refinery.lib.crypto.CipherMode.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.ECB" href="#refinery.lib.crypto.ECB">ECB</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.DataUnaligned" href="#refinery.lib.crypto.DataUnaligned">DataUnaligned</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.StatefulCipherMode" href="#refinery.lib.crypto.StatefulCipherMode">StatefulCipherMode</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.CBC" href="#refinery.lib.crypto.CBC">CBC</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.PCBC" href="#refinery.lib.crypto.PCBC">PCBC</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.CFB" href="#refinery.lib.crypto.CFB">CFB</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.OFB" href="#refinery.lib.crypto.OFB">OFB</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.crypto.OFB.decrypt" href="#refinery.lib.crypto.OFB.decrypt">decrypt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.CTR" href="#refinery.lib.crypto.CTR">CTR</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.crypto.CTR.decrypt" href="#refinery.lib.crypto.CTR.decrypt">decrypt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.CipherInterface" href="#refinery.lib.crypto.CipherInterface">CipherInterface</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.crypto.CipherInterface.encrypt" href="#refinery.lib.crypto.CipherInterface.encrypt">encrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherInterface.decrypt" href="#refinery.lib.crypto.CipherInterface.decrypt">decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherInterface.update" href="#refinery.lib.crypto.CipherInterface.update">update</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherInterface.verify" href="#refinery.lib.crypto.CipherInterface.verify">verify</a></code></li>
<li><code><a title="refinery.lib.crypto.CipherInterface.digest" href="#refinery.lib.crypto.CipherInterface.digest">digest</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.CipherObjectFactory" href="#refinery.lib.crypto.CipherObjectFactory">CipherObjectFactory</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.crypto.CipherObjectFactory.new" href="#refinery.lib.crypto.CipherObjectFactory.new">new</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.PyCryptoFactoryWrapper" href="#refinery.lib.crypto.PyCryptoFactoryWrapper">PyCryptoFactoryWrapper</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.BlockCipherFactory" href="#refinery.lib.crypto.BlockCipherFactory">BlockCipherFactory</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.crypto.BlockCipher" href="#refinery.lib.crypto.BlockCipher">BlockCipher</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.crypto.BlockCipher.block_encrypt" href="#refinery.lib.crypto.BlockCipher.block_encrypt">block_encrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.BlockCipher.block_decrypt" href="#refinery.lib.crypto.BlockCipher.block_decrypt">block_decrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.BlockCipher.encrypt" href="#refinery.lib.crypto.BlockCipher.encrypt">encrypt</a></code></li>
<li><code><a title="refinery.lib.crypto.BlockCipher.decrypt" href="#refinery.lib.crypto.BlockCipher.decrypt">decrypt</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
