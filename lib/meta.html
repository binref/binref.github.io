<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.meta documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.meta</code></h1>
</header>
<section id="section-intro">
<p>Inside a frame (see <code><a title="refinery.lib.frame" href="frame.html">refinery.lib.frame</a></code>), all chunks that are processed by refinery units have a
dictionary of metadata attached to them. This dictionary implements chunk-local variables which can
be accessed in various ways by the refinery argument parser (see <code><a title="refinery.lib.argformats" href="argformats.html">refinery.lib.argformats</a></code>).</p>
<h3 id="storing-meta-variables">Storing Meta Variables</h3>
<p>There are several units that are specifically designed to store meta variables:</p>
<ul>
<li>The <code><a title="refinery.put" href="../index.html#refinery.put">put</a></code> unit can store any multibin expression into a variable.</li>
<li>The <code><a title="refinery.push" href="../index.html#refinery.push">push</a></code> and <code><a title="refinery.pop" href="../index.html#refinery.pop">pop</a></code> units can be used to store the result of a more complex
sub-pipeline inside a meta variable; more on this later.</li>
<li>The <code><a title="refinery.cm" href="../index.html#refinery.cm">cm</a></code> unit is a catch-all helper to generate common metadata such as size, frame
index, hashes, entropy, etcetera.</li>
<li>The unit <code><a title="refinery.rmv" href="../index.html#refinery.rmv">rmv</a></code> (short for "remove variable") can be used to clear local variables.</li>
<li>By default, variables exist only throughout the <code><a title="refinery.lib.frame" href="frame.html">refinery.lib.frame</a></code> that they are defined in.
The unit <code><a title="refinery.mvg" href="../index.html#refinery.mvg">mvg</a></code> (short for "make variable global") can be used to propagate variables
to parent frames.</li>
<li>The <code><a title="refinery.struct" href="../index.html#refinery.struct">struct</a></code> parses structured data from the beginning of a chunk into meta variables.</li>
<li>You can use named capture groups in regular expressions when using the <code><a title="refinery.rex" href="../index.html#refinery.rex">rex</a></code> unit, and
these matches will be stored under their name as a meta variable in each output chunk.</li>
<li>There are units that extract data from archive-like formats. Some examples are <code><a title="refinery.xtzip" href="../index.html#refinery.xtzip">xtzip</a></code>,
<code><a title="refinery.xtmail" href="../index.html#refinery.xtmail">xtmail</a></code>, <code><a title="refinery.winreg" href="../index.html#refinery.winreg">winreg</a></code>, and <code><a title="refinery.perc" href="../index.html#refinery.perc">perc</a></code>. These units will enrich their output
chunks with a metadata variable indicating the (virtual) path of the extracted item.</li>
</ul>
<h3 id="variable-reference-handlers">Variable Reference Handlers</h3>
<p>There are a number of ways in which meta variables can be used. The most straightforward way is to
use the <code><a title="refinery.lib.argformats.DelayedArgument.var" href="argformats.html#refinery.lib.argformats.DelayedArgument.var">DelayedArgument.var()</a></code> handler to read the contents of a variable
and use it as part of a multibin expression. The <code><a title="refinery.lib.argformats.DelayedArgument.eat" href="argformats.html#refinery.lib.argformats.DelayedArgument.eat">DelayedArgument.eat()</a></code>
handler works in the same way, except that the variable is removed from the meta dictionary after
it has been used. Example:</p>
<pre><code>$ emit FOO [| put x BAR | cca var:x ]]
FOOBAR
</code></pre>
<p>We attach a variable named <code>x</code> with value <code>BAR</code> to the chunk containing the string <code>FOO</code> and then
use <code><a title="refinery.cca" href="../index.html#refinery.cca">cca</a></code> to append the contents of the variable to the chunk, giving us <code>FOOBAR</code>. Had we
used <code><a title="refinery.ccp" href="../index.html#refinery.ccp">ccp</a></code>, the result would have been <code>BARFOO</code>.</p>
<h3 id="integer-and-slice-expressions">Integer and Slice Expressions</h3>
<p>Whenever a multibin argument supports Python expressions, be it integers, sequences of integers,
or slice expressions (see also the <code><a title="refinery.lib.argformats.DelayedArgument.eval" href="argformats.html#refinery.lib.argformats.DelayedArgument.eval">DelayedArgument.eval()</a></code> handler), then
meta variables can freely be used in that expression. Examples:</p>
<pre><code>$ emit BAR-FOO [| put i 4 | snip i: ]]
FOO
$ emit range:4 [| put t a | add t ]]
abcd
</code></pre>
<h3 id="format-string-expressions">Format String Expressions</h3>
<p>The units <code><a title="refinery.pf" href="../index.html#refinery.pf">pf</a></code>, <code><a title="refinery.dump" href="../index.html#refinery.dump">dump</a></code>, and <code><a title="refinery.run" href="../index.html#refinery.run">run</a></code> support format string expressions that
can contain meta variables. For example, the following command will print a recursive listing of
the current directory with human-readable file sizes, entropy in percent, and the md5 hash of each
file:</p>
<pre><code>ef ** [| pf {size!r} {entropy!r} {md5} {path} ]]
</code></pre>
<p>Another example would be the following command, which dumps the base64 encoded buffer of length at
least 200 from the input to incrementally numbered files:</p>
<pre><code>emit sample | carve --min=200 b64 [| dump buffer{index}.b64 ]
</code></pre>
<h3 id="magic-meta-variables">Magic Meta Variables</h3>
<p>As alluded to in the previous section, there are several meta variables that are available on every
chunk, such as <code>size</code>, <code>entropy</code>, and <code>md5</code>. These values are computed as soon as they are accessed.
Some of them are formatted differently when using the <code>r</code>-transformation; for example, the <code>size</code>
variable will be printed as a human-readable expression when formatted as <code>{size!r}</code>, but it will be
a decimal string when formatted as <code>{size}</code> or <code>{size!s}</code>.</p>
<ul>
<li><code>index</code>: The index of the chunk in the current frame (see <code><a title="refinery.lib.frame" href="frame.html">refinery.lib.frame</a></code>).</li>
<li><code>magic</code>: Human-readable file magic string.</li>
<li><code>mime</code>: MIME type of the chunk according to file magic information.</li>
<li><code>ext</code>: A guessed file extension based on file magic information.</li>
<li><code>size</code>: The number of bytes in this chunk of data. The default formatting of this value is a
decimal integer, but its r-format is a human-readable size expression.</li>
<li><code>entropy</code>: Information entropy value of the data. Its computation can be expensive for large
chunks. The r-format of this value is a percentage.</li>
<li><code>ic</code>: The index of coincidence of the data. Its computation can be expensive for large chunks.
The r-format of this value is a percentage.</li>
<li><code>crc32</code>: The hexadecimal representation of the CRC32-hash of the data.</li>
<li><code>sha1</code>: The hexadecimal representation of the SHA1-hash of the data.</li>
<li><code>sha256</code>: The hexadecimal representation of the SHA256-hash of the data.</li>
<li><code>sha512</code>: The hexadecimal representation of the SHA512-hash of the data.</li>
<li><code>md5</code>: The hexadecimal representation of the MD5-hash of the data.</li>
</ul>
<h3 id="using-push-and-pop">Using Push And Pop</h3>
<p>The <code><a title="refinery.push" href="../index.html#refinery.push">push</a></code> and <code><a title="refinery.pop" href="../index.html#refinery.pop">pop</a></code> units can be used to extract sub-pipelines as variables. For
example, the following command extracts the files from a password-protected attachment of an email
message by first extracting the password from the email message body:</p>
<pre><code>$ emit phish.eml [                      |
&gt;     push [                            |
&gt;         xtmail body.txt               |
&gt;         rex -I password:\s*(\w+) {1}  |
&gt;         pop password ]                |
&gt;       xt *.zip                        |
&gt;       xt *.exe -p var:password        |
&gt;       dump extracted/{path} ]
</code></pre>
<p>The <code><a title="refinery.push" href="../index.html#refinery.push">push</a></code> unit emits two copies of the input data, and the second copy has been moved out
of scope (it is not visible). The first <code><a title="refinery.xtmail" href="../index.html#refinery.xtmail">xtmail</a></code> unit extracts the <code>body.txt</code> part and we
obtain the password using <code><a title="refinery.rex" href="../index.html#refinery.rex">rex</a></code>. The <code><a title="refinery.pop" href="../index.html#refinery.pop">pop</a></code> unit consumes the first input and will
populate the meta variable dictionaries of all subsequent chunks with a variable named <code>password</code>
which contains the data from that first chunk. Note that <code><a title="refinery.pop" href="../index.html#refinery.pop">pop</a></code> can also be used in other
ways to merge down the metadata from chunks inside sub-pipelines.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L1-L1055" class="git-link">Browse git</a>
</summary>
<pre><code class="python">R&#34;&#34;&#34;
Inside a frame (see `refinery.lib.frame`), all chunks that are processed by refinery units have a
dictionary of metadata attached to them. This dictionary implements chunk-local variables which can
be accessed in various ways by the refinery argument parser (see `refinery.lib.argformats`).

### Storing Meta Variables

There are several units that are specifically designed to store meta variables:

- The `refinery.put` unit can store any multibin expression into a variable.
- The `refinery.push` and `refinery.pop` units can be used to store the result of a more complex
  sub-pipeline inside a meta variable; more on this later.
- The `refinery.cm` unit is a catch-all helper to generate common metadata such as size, frame
  index, hashes, entropy, etcetera.
- The unit `refinery.rmv` (short for &#34;remove variable&#34;) can be used to clear local variables.
- By default, variables exist only throughout the `refinery.lib.frame` that they are defined in.
  The unit `refinery.mvg` (short for &#34;make variable global&#34;) can be used to propagate variables
  to parent frames.
- The `refinery.struct` parses structured data from the beginning of a chunk into meta variables.
- You can use named capture groups in regular expressions when using the `refinery.rex` unit, and
  these matches will be stored under their name as a meta variable in each output chunk.
- There are units that extract data from archive-like formats. Some examples are `refinery.xtzip`,
  `refinery.xtmail`, `refinery.winreg`, and `refinery.perc`. These units will enrich their output
  chunks with a metadata variable indicating the (virtual) path of the extracted item.

### Variable Reference Handlers

There are a number of ways in which meta variables can be used. The most straightforward way is to
use the `refinery.lib.argformats.DelayedArgument.var` handler to read the contents of a variable
and use it as part of a multibin expression. The `refinery.lib.argformats.DelayedArgument.eat`
handler works in the same way, except that the variable is removed from the meta dictionary after
it has been used. Example:

    $ emit FOO [| put x BAR | cca var:x ]]
    FOOBAR

We attach a variable named `x` with value `BAR` to the chunk containing the string `FOO` and then
use `refinery.cca` to append the contents of the variable to the chunk, giving us `FOOBAR`. Had we
used `refinery.ccp`, the result would have been `BARFOO`.

### Integer and Slice Expressions

Whenever a multibin argument supports Python expressions, be it integers, sequences of integers,
or slice expressions (see also the `refinery.lib.argformats.DelayedArgument.eval` handler), then
meta variables can freely be used in that expression. Examples:

    $ emit BAR-FOO [| put i 4 | snip i: ]]
    FOO
    $ emit range:4 [| put t a | add t ]]
    abcd

### Format String Expressions

The units `refinery.pf`, `refinery.dump`, and `refinery.run` support format string expressions that
can contain meta variables. For example, the following command will print a recursive listing of
the current directory with human-readable file sizes, entropy in percent, and the md5 hash of each
file:

    ef ** [| pf {size!r} {entropy!r} {md5} {path} ]]

Another example would be the following command, which dumps the base64 encoded buffer of length at
least 200 from the input to incrementally numbered files:

    emit sample | carve --min=200 b64 [| dump buffer{index}.b64 ]

### Magic Meta Variables

As alluded to in the previous section, there are several meta variables that are available on every
chunk, such as `size`, `entropy`, and `md5`. These values are computed as soon as they are accessed.
Some of them are formatted differently when using the `r`-transformation; for example, the `size`
variable will be printed as a human-readable expression when formatted as `{size!r}`, but it will be
a decimal string when formatted as `{size}` or `{size!s}`.

- `index`: The index of the chunk in the current frame (see `refinery.lib.frame`).
- `magic`: Human-readable file magic string.
- `mime`: MIME type of the chunk according to file magic information.
- `ext`: A guessed file extension based on file magic information.
- `size`: The number of bytes in this chunk of data. The default formatting of this value is a
   decimal integer, but its r-format is a human-readable size expression.
- `entropy`: Information entropy value of the data. Its computation can be expensive for large
   chunks. The r-format of this value is a percentage.
- `ic`: The index of coincidence of the data. Its computation can be expensive for large chunks.
   The r-format of this value is a percentage.
- `crc32`: The hexadecimal representation of the CRC32-hash of the data.
- `sha1`: The hexadecimal representation of the SHA1-hash of the data.
- `sha256`: The hexadecimal representation of the SHA256-hash of the data.
- `sha512`: The hexadecimal representation of the SHA512-hash of the data.
- `md5`: The hexadecimal representation of the MD5-hash of the data.

### Using Push And Pop

The `refinery.push` and `refinery.pop` units can be used to extract sub-pipelines as variables. For
example, the following command extracts the files from a password-protected attachment of an email
message by first extracting the password from the email message body:

    $ emit phish.eml [                      |
    &gt;     push [                            |
    &gt;         xtmail body.txt               |
    &gt;         rex -I password:\s*(\w+) {1}  |
    &gt;         pop password ]                |
    &gt;       xt *.zip                        |
    &gt;       xt *.exe -p var:password        |
    &gt;       dump extracted/{path} ]

The `refinery.push` unit emits two copies of the input data, and the second copy has been moved out
of scope (it is not visible). The first `refinery.xtmail` unit extracts the `body.txt` part and we
obtain the password using `refinery.rex`. The `refinery.pop` unit consumes the first input and will
populate the meta variable dictionaries of all subsequent chunks with a variable named `password`
which contains the data from that first chunk. Note that `refinery.pop` can also be used in other
ways to merge down the metadata from chunks inside sub-pipelines.
&#34;&#34;&#34;
from __future__ import annotations

import abc
import codecs
import contextlib
import itertools
import os
import re
import string

from io import StringIO
from typing import TYPE_CHECKING, Any, Callable
from urllib.parse import unquote_to_bytes

from refinery.lib.environment import environment
from refinery.lib.mime import get_cached_file_magic_info
from refinery.lib.structures import MemoryFile
from refinery.lib.tools import entropy, index_of_coincidence
from refinery.lib.types import buf, isbuffer, typename

if TYPE_CHECKING:
    from typing import Protocol

    from refinery.lib.frame import Chunk

    class _Derivation(Protocol):
        costly: bool
        name: str
        wrap: type

        def __call__(self, object: LazyMetaOracle) -&gt; str | int | float:
            ...


class CustomStringRepresentation(abc.ABC):
    &#34;&#34;&#34;
    This abstract class defines an interface for wrapper classes used in `refinery.lib.meta.LazyMetaOracleFactory`.
    These classes have to implement a `str` and `repr` typecast that can be used for the conversion part of a
    format string expression.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def __str__(self) -&gt; str:
        ...

    @abc.abstractmethod
    def __repr__(self) -&gt; str:
        ...


_INDEX = &#39;index&#39;
_BIGINT = &#39;__bi__&#39;

_HIGH_ASCII = &#39;¹²³«»¡¿¼½¾¢£¥§©®±µ·÷øÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõöùúûüýþÿ&#39;
_8BIT_ASCII = string.printable + _HIGH_ASCII
_PRINT_SAFE = set(_8BIT_ASCII.encode(&#39;latin1&#39;)) - set(b&#39;|&lt;&gt;\t\n\r\v&#39;)
if os.name == &#39;nt&#39;:
    _PRINT_SAFE -= set(b&#39;^&#34;&#39;)
else:
    _PRINT_SAFE -= set(b&#39;&amp;*?\&#39;&#34;&#39;)

_PT = bytearray(256)
for p in _PRINT_SAFE:
    _PT[p] = 1


def is_print_safe(string: str):
    return string.isprintable() or not any(
        (code := ord(letter)) &lt; len(_PT) and not _PT[code] for letter in string
    )


class ByteStringWrapper(bytearray, CustomStringRepresentation):
    &#34;&#34;&#34;
    Represents a binary string and a preferred codec in case it is printable. Casting this wrapper class
    will decode the string using the given codec, using backslash escape sequences to handle decoding
    errors. The `repr` case returns a hexadecimal representation of the binary data. Finally, the object
    proxies attribute access to the wrapped binary string.
    &#34;&#34;&#34;
    _CODECS = {
        codecs.lookup(c).name: p
        for c, p in [(&#39;utf8&#39;, &#39;s&#39;), (&#39;latin1&#39;, &#39;a&#39;), (&#39;utf-16le&#39;, &#39;u&#39;)]
    }

    @classmethod
    def Wrap(cls, string: str | buf | ByteStringWrapper, codec: str | None = None):
        if isinstance(string, cls):
            return string
        return cls(string, codec=codec)

    def __init__(self, string: str | buf, codec: str | None = None):
        if isinstance(string, str):
            self._string = string
            codec = codec or &#39;utf8&#39;
            string = string.encode(codec)
        elif isbuffer(string):
            self._string = None
        else:
            raise TypeError(F&#39;The argument {string!r} is not a buffer or string.&#39;)

        super().__init__(string)

        if codec is not None:
            nc = codecs.lookup(codec).name
            if nc not in self._CODECS:
                raise ValueError(F&#39;The codec {nc} is not a supported codec.&#39;)
            codec = nc

        self.codec = codec

    def __fspath__(self):
        return self.string

    def requires_prefix(self, string) -&gt; bool:
        try:
            from refinery.lib.argformats import DelayedArgument
            return bool(DelayedArgument(string).modifiers)
        except Exception:
            return True

    @property
    def string(self):
        value = self._string
        if value is None:
            _codec = self.codec
            _error = None
            codecs = self._CODECS if _codec is None else [_codec, &#39;latin1&#39;]
            for codec in codecs:
                try:
                    self._string = value = self.decode(codec)
                except UnicodeError as e:
                    _error = _error or e
                else:
                    self.codec = codec
                    break
            else:
                raise AttributeError(F&#39;Codec unknown: {_error!s}&#39;)
        return value

    def __eq__(self, other):
        if isinstance(other, str):
            return self.string == other
        return super().__eq__(other)

    def __hash__(self):
        return hash(self.string)

    def __repr__(self):
        try:
            return self._pretty
        except AttributeError:
            pass
        try:
            if not self or any(self[1::2]):
                prefix = None
            else:
                try:
                    pretty = self.decode(&#39;utf-16le&#39;)
                    prefix = &#39;u&#39;
                except UnicodeDecodeError:
                    prefix = None
            if prefix is None:
                pretty = self.string
                prefix = self._CODECS[self.codec]
        except AttributeError:
            pretty = None
        else:
            if not is_print_safe(pretty):
                pretty = None
            elif prefix != &#39;s&#39; or self.requires_prefix(pretty):
                pretty = F&#39;{prefix}:{pretty}&#39;
        if pretty is None:
            pretty = F&#39;h:{self.hex()}&#39;
        self._pretty = pretty
        return pretty

    def __str__(self):
        return self.string

    def __format__(self, spec):
        return self.string.__format__(spec)


def is_valid_variable_name(name: str, allow_wildcards: bool = False) -&gt; bool:
    &#34;&#34;&#34;
    All single-letter, uppercase variable names are reserved.
    &#34;&#34;&#34;
    if allow_wildcards:
        parts = re.split(r&#39;([\*\?\[\]])&#39;, name)
        brackets = 0
        for p in itertools.islice(parts, 1, None, 2):
            if p == &#39;[&#39;:
                brackets += 1
            if p == &#39;]&#39;:
                brackets -= 1
            if brackets &lt; 0:
                return False
        if brackets != 0:
            return False
        parts = parts[0::2]
    else:
        parts = [name]
    try:
        for part in parts:
            check_variable_name(part, allow_derivations=True)
    except ValueError:
        return False
    else:
        return True


def check_variable_name(name: str | None, allow_derivations=False) -&gt; str | None:
    &#34;&#34;&#34;
    All single-letter, uppercase variable names are reserved. Additionally, derived
    property names should not be overwritten.
    &#34;&#34;&#34;
    error = None
    if name is None:
        return None
    elif len(name) == 1 and name.upper() == name:
        error = &#39;a capitalzed single letter, which are reserved for state machines.&#39;
    elif not name.isidentifier():
        error = &#39;not an identifier.&#39;
    elif not allow_derivations:
        if name == _INDEX or name in LazyMetaOracle.derivations:
            error = &#39;reserved for a derived property.&#39;
    if error:
        raise ValueError(F&#39;The variable name &#34;{name}&#34; is invalid; it is {error}&#39;)
    return name


class SizeInt(int, CustomStringRepresentation):
    &#34;&#34;&#34;
    The string representation of this int class is a human-readable expression of size, using
    common units such as kB and MB.
    &#34;&#34;&#34;
    width = 9
    align = True

    def __str__(self):
        return str(int(self))

    if environment.disable_size_format.value:
        __repr__ = __str__
    else:
        def __repr__(self):
            step = 1000.0
            unit = None
            result = self
            for unit in [None, &#39;kB&#39;, &#39;MB&#39;, &#39;GB&#39;, &#39;TB&#39;, &#39;PB&#39;, &#39;EB&#39;, &#39;ZB&#39;, &#39;YB&#39;]:
                if unit and result / step &lt;= 0.1:
                    break
                result /= step
            if unit is None:
                width = 3 if self.align else 1
                return F&#39;{result:{width}} BYTES&#39;
            else:
                width = 6 if self.align else 1
                comma = 3 if self.align else 1
                return F&#39;{result:0{width}.{comma}f} {unit}&#39;


class TerseSizeInt(SizeInt):
    &#34;&#34;&#34;
    Similar to `refinery.lib.meta.SizeInt`, but the representation does not pad with zeros to
    ensure having the same width for every input.
    &#34;&#34;&#34;
    align = False


class Percentage(float, CustomStringRepresentation):
    &#34;&#34;&#34;
    The string representation of this floating point class is a human-readable expression of a
    percentage. The string representation is a common decimal with 4 digits precision, but casting
    the object using `repr` will yield a percentage.
    &#34;&#34;&#34;
    def __str__(self):
        return F&#39;{self:.4f}&#39;

    def __repr__(self):
        return F&#39;{self * 100:05.2f}%&#39;


class _NoDerivationAvailable(Exception):
    pass


class _LazyMetaMeta(type):
    def __new__(cls, name: str, bases, namespace: dict):
        derivations: dict = namespace[&#39;derivations&#39;]
        for obj in namespace.values():
            try:
                obj: _Derivation
                derivations[obj.name] = obj
            except AttributeError:
                pass
        return type.__new__(cls, name, bases, namespace)


def _derivation(name, costly: bool = False, wrap: type = ByteStringWrapper) -&gt; Callable[[_Derivation], _Derivation]:
    def decorator(method: _Derivation) -&gt; _Derivation:
        method.name = name
        method.costly = costly
        method.wrap = wrap
        return method
    return decorator


class LazyMetaOracle(metaclass=_LazyMetaMeta):
    &#34;&#34;&#34;
    A dictionary that can be queried lazily for all potential options of the common meta variable
    unit. For example, a SHA-256 hash is computed only as soon as the oracle is accessed at the
    key `&#39;sha256&#39;`.
    &#34;&#34;&#34;

    IndexKey = _INDEX

    derivations: dict[str, _Derivation] = {}
    &#34;&#34;&#34;
    A dictionary mapping the names of common properties to anonymous functions that compute their
    corresponding value on a chunk of binary input data.
    &#34;&#34;&#34;

    ghost: bool
    chunk: buf
    cache: dict[str, str | int | float]
    index: int | None

    history: dict[str, list[tuple[bool, Any]]]
    current: dict[str, Any]
    updated: dict[str, bool]

    def __init__(self, chunk: buf, scope: int = 1, seed: dict[str, list[tuple[bool, Any]]] | None = None):
        self.ghost = False
        self.chunk = chunk
        self.cache = {}
        self.index = None
        self.scope = scope
        self.tempval = {}
        self.current = {}
        self.updated = {}
        self.rescope = {}
        if seed is not None:
            for key, stack in seed.items():
                if not isinstance(stack, list):
                    raise TypeError(F&#39;Encountered history item of type {typename(stack)}, this should be a list.&#39;)
                if len(stack) != scope:
                    raise ValueError(F&#39;History item had length {len(stack)}, but scope was specified as {scope}.&#39;)
                for k, v in enumerate(stack):
                    stack[k] = tuple(v)
                for is_link, value in reversed(stack):
                    while is_link:
                        is_link, value = stack[value]
                    try:
                        bigint: bytes = value[_BIGINT]
                    except Exception:
                        pass
                    else:
                        value = int.from_bytes(bigint)
                    if value is not None:
                        self.current[key] = self.autowrap(key, value)
                        self.updated[key] = False
                    break
                else:
                    raise ValueError(R&#39;History item was all None.&#39;)
            self.history = seed
        else:
            self.history = {}

    def update(self, other: dict | LazyMetaOracle):
        if isinstance(other, LazyMetaOracle):
            self.current.update(other.current)
            self.updated.update(other.updated)
            self.tempval.update(other.tempval)
            self.rescope.update(other.rescope)
            self.history = other.history
            return
        for key, value in other.items():
            self[key] = value

    def inherit(self, parent: LazyMetaOracle):
        &#34;&#34;&#34;
        This method is called to inherit variables from a parent meta variable dictionary.
        &#34;&#34;&#34;
        if not self.history:
            self.history = parent.history
        elif self.history is not parent.history:
            for key in parent.current.keys():
                if key not in self.current:
                    self.current[key] = parent.current[key]
                    self.history[key] = parent.history[key]
        self.scope = parent.scope
        for key in parent.keys():
            try:
                derivation = self.derivations[key]
            except KeyError:
                try:
                    self.updated.setdefault(key, False)
                    self.current.setdefault(key, parent.current[key])
                except KeyError:
                    pass
            else:
                if derivation.costly and len(self.chunk) &gt;= 0x1000:
                    continue
                self[key] = derivation.wrap(derivation(self))

    def set_scope(self, key: str, scope: int):
        current = self.scope
        scope = max(1, scope)
        if key not in self.current:
            raise KeyError(key)
        if scope &gt; current:
            raise ValueError(F&#39;Attempt to increase scope level of variable {key} to {scope}, it is currently at {self.scope}.&#39;)
        if scope == current:
            return
        self.rescope[key] = scope

    def get_scope(self, key: str):
        value = self.current[key]
        scope = self.scope
        try:
            stack = self.history[key]
        except KeyError:
            return scope
        for k, (is_link, v) in enumerate(reversed(stack)):
            while is_link:
                is_link, v = stack[v]
            if v == value:
                continue
            return scope - k + 1
        return scope

    def serialize(self, target_scope: int) -&gt; dict[str, list[tuple[bool, Any]]]:
        if not target_scope:
            return {}
        current_scope = self.scope
        if current_scope == 0:
            padding = [(True, 0)] * (target_scope - 1)
            return {key: [(False, value)] + padding for key, value in self.current.items()}
        serializable = {key: list(stack) for key, stack in self.history.items()}
        if target_scope &gt; current_scope:
            padding = target_scope - current_scope
            for key, stack in serializable.items():
                stack.extend(itertools.repeat((True, (current_scope - 1)), padding))
        for key, stack in serializable.items():
            if key not in self.current:
                stack[~0] = (False, None)
        if target_scope &lt; current_scope:
            for key, stack in serializable.items():
                del stack[target_scope:]
        for key, value in self.current.items():
            if value is None:
                raise RuntimeError(F&#39;Meta variable &#34;{key}&#34; was set to None.&#39;)
            elif isinstance(value, int) and value &gt; 0xFFFFFFFFFFFFFFFF:
                q, r = divmod(value.bit_length(), 8)
                q += int(bool(r))
                value = {_BIGINT: value.to_bytes(q)}
            try:
                item_scope = self.rescope[key]
            except KeyError:
                item_scope = current_scope
            if item_scope == current_scope and not self.updated[key]:
                continue
            if item_scope &gt; target_scope:
                continue
            link = index = item_scope - 1
            if index &lt; 0:
                raise RuntimeError(&#39;computed a negative index for variable placement&#39;)
            try:
                stack = serializable[key]
            except KeyError:
                serializable[key] = stack = [(False, None)] * target_scope
            else:
                for k, (is_link, v) in enumerate(stack):
                    if k &gt; index:
                        break
                    while is_link:
                        k, is_link, v = v, *stack[v]
                    if v == value:
                        link = k
                        break
            if link &lt; index:
                stack[index] = (True, link)
            else:
                stack[index] = (False, value)
            for k in range(index + 1, target_scope):
                stack[k] = (True, index)
        vanishing_variables = []
        for key, stack in serializable.items():
            if all(v is None for lnk, v in stack if not lnk):
                vanishing_variables.append(key)
        for key in vanishing_variables:
            del serializable[key]
        return serializable

    def items(self):
        yield (_INDEX, self.index)
        yield from self.tempval.items()
        yield from self.current.items()

    def keys(self):
        yield _INDEX
        yield from self.tempval.keys()
        yield from self.current.keys()

    def variable_names(self):
        yield _INDEX
        yield from self.current.keys()

    def values(self):
        yield self.index
        yield from (v for _, v in self.items())

    __iter__ = keys

    def format_str(
        self,
        spec: str,
        codec: str,
        args: list | tuple = (),
        symb: dict | None = None,
        used: set | None = None,
        escaped: bool = False,
    ) -&gt; str:
        &#34;&#34;&#34;
        Formats the input expression like a normal Python format string expression. Certain refinery
        metadata objects have special formatters for the `r`-transformation, as defined by wrapping
        of type `refinery.lib.meta.CustomStringRepresentation`. The following representations are
        defined:

        - `entropy` and `ic` are formatted as a percentage.
        - `sha1`, `sha256`, `sha512`, and `md5` are formatted as hex strings.
        - `size` is formatted as a human-readable size with unit.
        &#34;&#34;&#34;
        ret = self.format(spec, codec, args, symb, binary=False, used=used, escaped=escaped)
        assert isinstance(ret, str)
        return ret

    def format_bin(
        self,
        spec: str,
        codec: str,
        args: list | tuple = (),
        symb: dict | None = None,
        used: set | None = None,
        escaped: bool = False,
    ) -&gt; buf:
        &#34;&#34;&#34;
        Formats the input expression using a Python F-string like expression. These strings contain
        fields in the format `{expression!T:pipeline}`, where `T` is a transformation character and
        the `pipeline` part is a sequence of `refinery.lib.argformats.multibin` handlers which are
        parsed in reverse. For example, the expression `{v:b64:hex}` will first decode the contents
        of `v` using `refinery.b64`, and then decode the result using `refinery.hex`.

        The transformation character is only required when `expression` is a literal; it specifies
        how to convert the literal to a binary string. The following transformations can be applied:

        - `a`: literal is to be encoded using latin1
        - `u`: literal is to be encoded using utf16
        - `s`: literal is to be encoded using the default codec
        - `q`: literal is a URL-encoded binary string
        - `h`: literal is a hex-encoded binary string
        - `e`: literal is an escaped ASCII string
        &#34;&#34;&#34;
        ret = self.format(spec, codec, args, symb, binary=True, used=used, escaped=escaped)
        assert not isinstance(ret, str)
        return ret

    def format(
        self,
        spec    : str,
        codec   : str,
        args    : list | tuple,
        symb    : dict | None,
        binary  : bool,
        fixup   : bool = True,
        used    : set | None = None,
        escaped : bool = False
    ) -&gt; str | buf:
        &#34;&#34;&#34;
        Formats a string using Python-like string fomatting syntax. The formatter for `binary`
        mode is different; each formatting is documented in one of the following two proxy methods:

        - `refinery.lib.meta.LazyMetaOracle.format_str`
        - `refinery.lib.meta.LazyMetaOracle.format_bin`
        &#34;&#34;&#34;
        # prevents circular import:
        from refinery.lib.argformats import (
            Chunk,
            DelayedNumSeqArgument,
            ParserError,
            PythonExpression,
        )

        symb = symb or {}

        if used is None:
            class dummy:
                def add(self, _):
                    pass
            used = dummy()

        if args is None:
            args = ()
        elif not isinstance(args, (list, tuple)):
            args = list(args)

        if fixup:
            for (store, it) in (
                (args, enumerate(args)),
                (symb, symb.items()),
            ):
                for key, value in it:
                    with contextlib.suppress(TypeError):
                        if isinstance(value, CustomStringRepresentation):
                            continue
                        store[key] = ByteStringWrapper.Wrap(value, codec)

        formatter = string.Formatter()
        autoindex = 0

        def putstr(s: str):
            if isinstance(stream, MemoryFile):
                stream.write(s.encode(codec))
            else:
                stream.write(s)

        if binary:
            stream = MemoryFile()
        else:
            stream = StringIO()

        with stream:
            for prefix, field, modifier, conversion in formatter.parse(spec):
                def recover_placeholder():
                    recovery = F&#39;{{{field}&#39;
                    if conversion:
                        recovery = F&#39;{recovery}!{conversion}&#39;
                    if modifier:
                        recovery = F&#39;{recovery}:{modifier}&#39;
                    return F&#39;{recovery}}}&#39;

                value = None

                if conversion == &#39;a&#39;:
                    converter = ascii
                elif conversion == &#39;s&#39;:
                    converter = str
                elif conversion == &#39;r&#39;:
                    converter = repr
                else:
                    converter = None

                if prefix:
                    if escaped:
                        prefix = prefix.encode(&#39;latin1&#39;).decode(&#39;unicode-escape&#39;)
                    putstr(prefix)

                if field is None:
                    continue

                if not field:
                    if not args:
                        ph = recover_placeholder()
                        if self.ghost:
                            putstr(ph)
                            continue
                        raise LookupError(F&#39;Spec contains placeholder {ph} but no positional arguments were given.&#39;)
                    value = args[autoindex]
                    used.add(autoindex)
                    if autoindex &lt; len(args) - 1:
                        autoindex += 1

                if conversion:
                    conversion = conversion.lower()
                    if conversion == &#39;h&#39;:
                        value = bytes.fromhex(field)
                    elif conversion == &#39;q&#39;:
                        value = unquote_to_bytes(field)
                    elif conversion == &#39;u&#39;:
                        value = field.encode(&#39;utf-16le&#39;)
                    elif conversion == &#39;n&#39;:
                        value = field.encode(codec).decode(&#39;unicode-escape&#39;).encode(&#39;latin1&#39;)
                elif field in symb:
                    value = symb[field]
                    used.add(field)

                if value is None:
                    with contextlib.suppress(ValueError, IndexError):
                        index = int(field, 0)
                        value = args[index]
                        used.add(index)

                if value is None:
                    with contextlib.suppress(KeyError):
                        value = self[field]
                        used.add(field)

                if value is None:
                    try:
                        field = self.format(field, codec, args, symb, False, False, used)
                    except Exception:
                        pass
                    try:
                        expression = PythonExpression(field, *self, *symb)
                        value = expression(self, **symb)
                    except ParserError:
                        if self.ghost:
                            putstr(recover_placeholder())
                            continue
                        if modifier:
                            value = field
                        else:
                            raise KeyError
                    except Exception:
                        value = B&#39;&#39;

                try:
                    converted = ByteStringWrapper.Wrap(value, codec)
                except TypeError:
                    if converter:
                        converted = converter(value)
                    elif isinstance(value, CustomStringRepresentation):
                        converted = str(value)
                    else:
                        converted = value

                if binary and isbuffer(converted):
                    output = None
                else:
                    try:
                        output = converted.__format__(modifier)
                    except Exception:
                        if not modifier:
                            raise
                        output = None

                if modifier and output is None:
                    modifier = modifier.strip()
                    expression = self.format(modifier, codec, args, symb, True, False, used)
                    output = DelayedNumSeqArgument(
                        expression.decode(codec), reverse=True, seed=converted)
                    output = output(Chunk(converted, meta=self))

                if output is None:
                    output = converted

                if not binary:
                    if isinstance(output, (bytes, bytearray)):
                        output = output.decode()
                    elif not isinstance(output, str):
                        output = str(output)
                elif isinstance(output, str):
                    output = output.encode()

                stream.write(output)
            return stream.getvalue()

    def knows(self, key):
        return (
            key in self.current or # noqa
            key in self.tempval or # noqa
            key in self.cache
        )

    def __contains__(self, key):
        return (
            key == _INDEX
            or key in self.current
            or key in self.tempval
            or key in self.derivations
        )

    def clear(self):
        self.current.clear()
        self.tempval.clear()

    def __len__(self):
        return len(self.current) + len(self.tempval)

    def autowrap(self, key, value):
        try:
            wrap = self.derivations[key].wrap
        except KeyError:
            wrap = ByteStringWrapper
        if not isinstance(value, wrap):
            with contextlib.suppress(TypeError):
                value = wrap(value)
        return value

    def __setitem__(self, key, value):
        new = self.autowrap(key, value)
        if not is_valid_variable_name(key):
            self.tempval[key] = new
            return
        self.current[key] = new
        try:
            stack = self.history[key]
            lnk, old = stack[-1]
        except KeyError:
            self.updated[key] = True
        else:
            while lnk:
                lnk, old = stack[old]
            self.updated[key] = (old != new)

    class nodefault:
        pass

    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default

    def pop(self, key, default=nodefault):
        try:
            value = self[key]
        except KeyError:
            if default is self.nodefault:
                raise
            return default
        else:
            self.discard(key)
            return value

    def __getitem__(self, key):
        if key == _INDEX:
            return self.index
        try:
            value = self.current[key]
        except KeyError:
            try:
                return self.tempval[key]
            except KeyError:
                pass
            return self.__missing__(key)
        if isinstance(value, str):
            value = value.encode(&#39;utf8&#39;)
        return value

    def discard(self, key):
        try:
            del self.current[key]
        except KeyError:
            try:
                del self.tempval[key]
            except KeyError:
                pass

    __delitem__ = discard

    def __getattr__(self, key):
        if key not in self.current:
            deduction = self.derivations.get(key)
            if deduction is None:
                raise AttributeError(key)
            return deduction.wrap(deduction(self))
        else:
            return self[key]

    def __missing__(self, key):
        try:
            return self.cache[key]
        except KeyError:
            pass
        deduction = self.derivations.get(key)
        if deduction is None:
            raise KeyError(F&#39;The meta variable {key} is unknown.&#39;)
        try:
            value = deduction.wrap(deduction(self))
        except _NoDerivationAvailable:
            raise KeyError(F&#39;unable to derive the {key} property here, you have to use the cm unit.&#39;)
        else:
            self.cache[key] = value
            return value

    def derive(self, key):
        self[key] = self[key]

    @_derivation(&#39;mime&#39;)
    def _derive_mime(self):
        return get_cached_file_magic_info(self.chunk).mime

    @_derivation(&#39;ext&#39;)
    def _derive_ext(self):
        return get_cached_file_magic_info(self.chunk).extension

    @_derivation(&#39;magic&#39;)
    def _derive_magic(self):
        return get_cached_file_magic_info(self.chunk).description

    @_derivation(&#39;size&#39;, wrap=SizeInt)
    def _derive_size(self):
        return len(self.chunk)

    @_derivation(&#39;entropy&#39;, True, Percentage)
    def _derive_entropy(self):
        return entropy(self.chunk)

    @_derivation(&#39;ic&#39;, True, Percentage)
    def _derive_ic(self):
        return index_of_coincidence(self.chunk)

    @_derivation(&#39;crc32&#39;)
    def _derive_crc32(self):
        import zlib
        return (zlib.crc32(self.chunk) &amp; 0xFFFFFFFF).to_bytes(4, &#39;big&#39;).hex()

    @_derivation(&#39;sha1&#39;, True)
    def _derive_sha1(self):
        import hashlib
        return hashlib.sha1(self.chunk).hexdigest()

    @_derivation(&#39;sha256&#39;, True)
    def _derive_sha256(self):
        import hashlib
        return hashlib.sha256(self.chunk).hexdigest()

    @_derivation(&#39;sha512&#39;, True)
    def _derive_sha512(self):
        import hashlib
        return hashlib.sha512(self.chunk).hexdigest()

    @_derivation(&#39;md5&#39;, True)
    def _derive_md5(self):
        import hashlib
        return hashlib.md5(self.chunk).hexdigest()


def metavars(chunk: Chunk | buf) -&gt; LazyMetaOracle:
    &#34;&#34;&#34;
    This method is the main function used by refinery units to get the meta variable dictionary
    of an input chunk. This dictionary is wrapped using the `refinery.lib.meta.LazyMetaOracleFactory`
    so that access to common variables is always possible.
    &#34;&#34;&#34;
    try:
        meta = chunk.meta
    except AttributeError:
        meta = LazyMetaOracle(chunk)
    else:
        if not isinstance(meta, LazyMetaOracle):
            raise TypeError(F&#39;Invalid meta variable dictionary on chunk: {meta!r}&#39;)
    return meta</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.meta.is_print_safe"><code class="name flex">
<span>def <span class="ident">is_print_safe</span></span>(<span>string)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L178-L181" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_print_safe(string: str):
    return string.isprintable() or not any(
        (code := ord(letter)) &lt; len(_PT) and not _PT[code] for letter in string
    )</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.is_valid_variable_name"><code class="name flex">
<span>def <span class="ident">is_valid_variable_name</span></span>(<span>name, allow_wildcards=False)</span>
</code></dt>
<dd>
<section class="desc"><p>All single-letter, uppercase variable names are reserved.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L295-L320" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_valid_variable_name(name: str, allow_wildcards: bool = False) -&gt; bool:
    &#34;&#34;&#34;
    All single-letter, uppercase variable names are reserved.
    &#34;&#34;&#34;
    if allow_wildcards:
        parts = re.split(r&#39;([\*\?\[\]])&#39;, name)
        brackets = 0
        for p in itertools.islice(parts, 1, None, 2):
            if p == &#39;[&#39;:
                brackets += 1
            if p == &#39;]&#39;:
                brackets -= 1
            if brackets &lt; 0:
                return False
        if brackets != 0:
            return False
        parts = parts[0::2]
    else:
        parts = [name]
    try:
        for part in parts:
            check_variable_name(part, allow_derivations=True)
    except ValueError:
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.check_variable_name"><code class="name flex">
<span>def <span class="ident">check_variable_name</span></span>(<span>name, allow_derivations=False)</span>
</code></dt>
<dd>
<section class="desc"><p>All single-letter, uppercase variable names are reserved. Additionally, derived
property names should not be overwritten.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L323-L340" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check_variable_name(name: str | None, allow_derivations=False) -&gt; str | None:
    &#34;&#34;&#34;
    All single-letter, uppercase variable names are reserved. Additionally, derived
    property names should not be overwritten.
    &#34;&#34;&#34;
    error = None
    if name is None:
        return None
    elif len(name) == 1 and name.upper() == name:
        error = &#39;a capitalzed single letter, which are reserved for state machines.&#39;
    elif not name.isidentifier():
        error = &#39;not an identifier.&#39;
    elif not allow_derivations:
        if name == _INDEX or name in LazyMetaOracle.derivations:
            error = &#39;reserved for a derived property.&#39;
    if error:
        raise ValueError(F&#39;The variable name &#34;{name}&#34; is invalid; it is {error}&#39;)
    return name</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.metavars"><code class="name flex">
<span>def <span class="ident">metavars</span></span>(<span>chunk)</span>
</code></dt>
<dd>
<section class="desc"><p>This method is the main function used by refinery units to get the meta variable dictionary
of an input chunk. This dictionary is wrapped using the <code>refinery.lib.meta.LazyMetaOracleFactory</code>
so that access to common variables is always possible.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L1042-L1055" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def metavars(chunk: Chunk | buf) -&gt; LazyMetaOracle:
    &#34;&#34;&#34;
    This method is the main function used by refinery units to get the meta variable dictionary
    of an input chunk. This dictionary is wrapped using the `refinery.lib.meta.LazyMetaOracleFactory`
    so that access to common variables is always possible.
    &#34;&#34;&#34;
    try:
        meta = chunk.meta
    except AttributeError:
        meta = LazyMetaOracle(chunk)
    else:
        if not isinstance(meta, LazyMetaOracle):
            raise TypeError(F&#39;Invalid meta variable dictionary on chunk: {meta!r}&#39;)
    return meta</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.meta.CustomStringRepresentation"><code class="flex name class">
<span>class <span class="ident">CustomStringRepresentation</span></span>
</code></dt>
<dd>
<section class="desc"><p>This abstract class defines an interface for wrapper classes used in <code>refinery.lib.meta.LazyMetaOracleFactory</code>.
These classes have to implement a <code>str</code> and <code>repr</code> typecast that can be used for the conversion part of a
format string expression.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L146-L159" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CustomStringRepresentation(abc.ABC):
    &#34;&#34;&#34;
    This abstract class defines an interface for wrapper classes used in `refinery.lib.meta.LazyMetaOracleFactory`.
    These classes have to implement a `str` and `repr` typecast that can be used for the conversion part of a
    format string expression.
    &#34;&#34;&#34;

    @abc.abstractmethod
    def __str__(self) -&gt; str:
        ...

    @abc.abstractmethod
    def __repr__(self) -&gt; str:
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.meta.ByteStringWrapper" href="#refinery.lib.meta.ByteStringWrapper">ByteStringWrapper</a></li>
<li><a title="refinery.lib.meta.Percentage" href="#refinery.lib.meta.Percentage">Percentage</a></li>
<li><a title="refinery.lib.meta.SizeInt" href="#refinery.lib.meta.SizeInt">SizeInt</a></li>
</ul>
</dd>
<dt id="refinery.lib.meta.ByteStringWrapper"><code class="flex name class">
<span>class <span class="ident">ByteStringWrapper</span></span>
<span>(</span><span>string, codec=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Represents a binary string and a preferred codec in case it is printable. Casting this wrapper class
will decode the string using the given codec, using backslash escape sequences to handle decoding
errors. The <code>repr</code> case returns a hexadecimal representation of the binary data. Finally, the object
proxies attribute access to the wrapped binary string.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L184-L292" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ByteStringWrapper(bytearray, CustomStringRepresentation):
    &#34;&#34;&#34;
    Represents a binary string and a preferred codec in case it is printable. Casting this wrapper class
    will decode the string using the given codec, using backslash escape sequences to handle decoding
    errors. The `repr` case returns a hexadecimal representation of the binary data. Finally, the object
    proxies attribute access to the wrapped binary string.
    &#34;&#34;&#34;
    _CODECS = {
        codecs.lookup(c).name: p
        for c, p in [(&#39;utf8&#39;, &#39;s&#39;), (&#39;latin1&#39;, &#39;a&#39;), (&#39;utf-16le&#39;, &#39;u&#39;)]
    }

    @classmethod
    def Wrap(cls, string: str | buf | ByteStringWrapper, codec: str | None = None):
        if isinstance(string, cls):
            return string
        return cls(string, codec=codec)

    def __init__(self, string: str | buf, codec: str | None = None):
        if isinstance(string, str):
            self._string = string
            codec = codec or &#39;utf8&#39;
            string = string.encode(codec)
        elif isbuffer(string):
            self._string = None
        else:
            raise TypeError(F&#39;The argument {string!r} is not a buffer or string.&#39;)

        super().__init__(string)

        if codec is not None:
            nc = codecs.lookup(codec).name
            if nc not in self._CODECS:
                raise ValueError(F&#39;The codec {nc} is not a supported codec.&#39;)
            codec = nc

        self.codec = codec

    def __fspath__(self):
        return self.string

    def requires_prefix(self, string) -&gt; bool:
        try:
            from refinery.lib.argformats import DelayedArgument
            return bool(DelayedArgument(string).modifiers)
        except Exception:
            return True

    @property
    def string(self):
        value = self._string
        if value is None:
            _codec = self.codec
            _error = None
            codecs = self._CODECS if _codec is None else [_codec, &#39;latin1&#39;]
            for codec in codecs:
                try:
                    self._string = value = self.decode(codec)
                except UnicodeError as e:
                    _error = _error or e
                else:
                    self.codec = codec
                    break
            else:
                raise AttributeError(F&#39;Codec unknown: {_error!s}&#39;)
        return value

    def __eq__(self, other):
        if isinstance(other, str):
            return self.string == other
        return super().__eq__(other)

    def __hash__(self):
        return hash(self.string)

    def __repr__(self):
        try:
            return self._pretty
        except AttributeError:
            pass
        try:
            if not self or any(self[1::2]):
                prefix = None
            else:
                try:
                    pretty = self.decode(&#39;utf-16le&#39;)
                    prefix = &#39;u&#39;
                except UnicodeDecodeError:
                    prefix = None
            if prefix is None:
                pretty = self.string
                prefix = self._CODECS[self.codec]
        except AttributeError:
            pretty = None
        else:
            if not is_print_safe(pretty):
                pretty = None
            elif prefix != &#39;s&#39; or self.requires_prefix(pretty):
                pretty = F&#39;{prefix}:{pretty}&#39;
        if pretty is None:
            pretty = F&#39;h:{self.hex()}&#39;
        self._pretty = pretty
        return pretty

    def __str__(self):
        return self.string

    def __format__(self, spec):
        return self.string.__format__(spec)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.bytearray</li>
<li><a title="refinery.lib.meta.CustomStringRepresentation" href="#refinery.lib.meta.CustomStringRepresentation">CustomStringRepresentation</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.meta.ByteStringWrapper.Wrap"><code class="name flex">
<span>def <span class="ident">Wrap</span></span>(<span>string, codec=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.meta.ByteStringWrapper.string"><code class="name">var <span class="ident">string</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L232-L249" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def string(self):
    value = self._string
    if value is None:
        _codec = self.codec
        _error = None
        codecs = self._CODECS if _codec is None else [_codec, &#39;latin1&#39;]
        for codec in codecs:
            try:
                self._string = value = self.decode(codec)
            except UnicodeError as e:
                _error = _error or e
            else:
                self.codec = codec
                break
        else:
            raise AttributeError(F&#39;Codec unknown: {_error!s}&#39;)
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.meta.ByteStringWrapper.requires_prefix"><code class="name flex">
<span>def <span class="ident">requires_prefix</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L225-L230" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def requires_prefix(self, string) -&gt; bool:
    try:
        from refinery.lib.argformats import DelayedArgument
        return bool(DelayedArgument(string).modifiers)
    except Exception:
        return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.meta.SizeInt"><code class="flex name class">
<span>class <span class="ident">SizeInt</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>The string representation of this int class is a human-readable expression of size, using
common units such as kB and MB.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L343-L371" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SizeInt(int, CustomStringRepresentation):
    &#34;&#34;&#34;
    The string representation of this int class is a human-readable expression of size, using
    common units such as kB and MB.
    &#34;&#34;&#34;
    width = 9
    align = True

    def __str__(self):
        return str(int(self))

    if environment.disable_size_format.value:
        __repr__ = __str__
    else:
        def __repr__(self):
            step = 1000.0
            unit = None
            result = self
            for unit in [None, &#39;kB&#39;, &#39;MB&#39;, &#39;GB&#39;, &#39;TB&#39;, &#39;PB&#39;, &#39;EB&#39;, &#39;ZB&#39;, &#39;YB&#39;]:
                if unit and result / step &lt;= 0.1:
                    break
                result /= step
            if unit is None:
                width = 3 if self.align else 1
                return F&#39;{result:{width}} BYTES&#39;
            else:
                width = 6 if self.align else 1
                comma = 3 if self.align else 1
                return F&#39;{result:0{width}.{comma}f} {unit}&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.int</li>
<li><a title="refinery.lib.meta.CustomStringRepresentation" href="#refinery.lib.meta.CustomStringRepresentation">CustomStringRepresentation</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.meta.TerseSizeInt" href="#refinery.lib.meta.TerseSizeInt">TerseSizeInt</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.meta.SizeInt.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.meta.SizeInt.align"><code class="name">var <span class="ident">align</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.meta.TerseSizeInt"><code class="flex name class">
<span>class <span class="ident">TerseSizeInt</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Similar to <code><a title="refinery.lib.meta.SizeInt" href="#refinery.lib.meta.SizeInt">SizeInt</a></code>, but the representation does not pad with zeros to
ensure having the same width for every input.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L374-L379" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TerseSizeInt(SizeInt):
    &#34;&#34;&#34;
    Similar to `refinery.lib.meta.SizeInt`, but the representation does not pad with zeros to
    ensure having the same width for every input.
    &#34;&#34;&#34;
    align = False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.meta.SizeInt" href="#refinery.lib.meta.SizeInt">SizeInt</a></li>
<li>builtins.int</li>
<li><a title="refinery.lib.meta.CustomStringRepresentation" href="#refinery.lib.meta.CustomStringRepresentation">CustomStringRepresentation</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.meta.SizeInt" href="#refinery.lib.meta.SizeInt">SizeInt</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.meta.SizeInt.align" href="#refinery.lib.meta.SizeInt.align">align</a></code></li>
<li><code><a title="refinery.lib.meta.SizeInt.width" href="#refinery.lib.meta.SizeInt.width">width</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.meta.Percentage"><code class="flex name class">
<span>class <span class="ident">Percentage</span></span>
<span>(</span><span>x=0, /)</span>
</code></dt>
<dd>
<section class="desc"><p>The string representation of this floating point class is a human-readable expression of a
percentage. The string representation is a common decimal with 4 digits precision, but casting
the object using <code>repr</code> will yield a percentage.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L382-L392" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Percentage(float, CustomStringRepresentation):
    &#34;&#34;&#34;
    The string representation of this floating point class is a human-readable expression of a
    percentage. The string representation is a common decimal with 4 digits precision, but casting
    the object using `repr` will yield a percentage.
    &#34;&#34;&#34;
    def __str__(self):
        return F&#39;{self:.4f}&#39;

    def __repr__(self):
        return F&#39;{self * 100:05.2f}%&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.float</li>
<li><a title="refinery.lib.meta.CustomStringRepresentation" href="#refinery.lib.meta.CustomStringRepresentation">CustomStringRepresentation</a></li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle"><code class="flex name class">
<span>class <span class="ident">LazyMetaOracle</span></span>
<span>(</span><span>chunk, scope=1, seed=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A dictionary that can be queried lazily for all potential options of the common meta variable
unit. For example, a SHA-256 hash is computed only as soon as the oracle is accessed at the
key <code>'sha256'</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L420-L1039" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LazyMetaOracle(metaclass=_LazyMetaMeta):
    &#34;&#34;&#34;
    A dictionary that can be queried lazily for all potential options of the common meta variable
    unit. For example, a SHA-256 hash is computed only as soon as the oracle is accessed at the
    key `&#39;sha256&#39;`.
    &#34;&#34;&#34;

    IndexKey = _INDEX

    derivations: dict[str, _Derivation] = {}
    &#34;&#34;&#34;
    A dictionary mapping the names of common properties to anonymous functions that compute their
    corresponding value on a chunk of binary input data.
    &#34;&#34;&#34;

    ghost: bool
    chunk: buf
    cache: dict[str, str | int | float]
    index: int | None

    history: dict[str, list[tuple[bool, Any]]]
    current: dict[str, Any]
    updated: dict[str, bool]

    def __init__(self, chunk: buf, scope: int = 1, seed: dict[str, list[tuple[bool, Any]]] | None = None):
        self.ghost = False
        self.chunk = chunk
        self.cache = {}
        self.index = None
        self.scope = scope
        self.tempval = {}
        self.current = {}
        self.updated = {}
        self.rescope = {}
        if seed is not None:
            for key, stack in seed.items():
                if not isinstance(stack, list):
                    raise TypeError(F&#39;Encountered history item of type {typename(stack)}, this should be a list.&#39;)
                if len(stack) != scope:
                    raise ValueError(F&#39;History item had length {len(stack)}, but scope was specified as {scope}.&#39;)
                for k, v in enumerate(stack):
                    stack[k] = tuple(v)
                for is_link, value in reversed(stack):
                    while is_link:
                        is_link, value = stack[value]
                    try:
                        bigint: bytes = value[_BIGINT]
                    except Exception:
                        pass
                    else:
                        value = int.from_bytes(bigint)
                    if value is not None:
                        self.current[key] = self.autowrap(key, value)
                        self.updated[key] = False
                    break
                else:
                    raise ValueError(R&#39;History item was all None.&#39;)
            self.history = seed
        else:
            self.history = {}

    def update(self, other: dict | LazyMetaOracle):
        if isinstance(other, LazyMetaOracle):
            self.current.update(other.current)
            self.updated.update(other.updated)
            self.tempval.update(other.tempval)
            self.rescope.update(other.rescope)
            self.history = other.history
            return
        for key, value in other.items():
            self[key] = value

    def inherit(self, parent: LazyMetaOracle):
        &#34;&#34;&#34;
        This method is called to inherit variables from a parent meta variable dictionary.
        &#34;&#34;&#34;
        if not self.history:
            self.history = parent.history
        elif self.history is not parent.history:
            for key in parent.current.keys():
                if key not in self.current:
                    self.current[key] = parent.current[key]
                    self.history[key] = parent.history[key]
        self.scope = parent.scope
        for key in parent.keys():
            try:
                derivation = self.derivations[key]
            except KeyError:
                try:
                    self.updated.setdefault(key, False)
                    self.current.setdefault(key, parent.current[key])
                except KeyError:
                    pass
            else:
                if derivation.costly and len(self.chunk) &gt;= 0x1000:
                    continue
                self[key] = derivation.wrap(derivation(self))

    def set_scope(self, key: str, scope: int):
        current = self.scope
        scope = max(1, scope)
        if key not in self.current:
            raise KeyError(key)
        if scope &gt; current:
            raise ValueError(F&#39;Attempt to increase scope level of variable {key} to {scope}, it is currently at {self.scope}.&#39;)
        if scope == current:
            return
        self.rescope[key] = scope

    def get_scope(self, key: str):
        value = self.current[key]
        scope = self.scope
        try:
            stack = self.history[key]
        except KeyError:
            return scope
        for k, (is_link, v) in enumerate(reversed(stack)):
            while is_link:
                is_link, v = stack[v]
            if v == value:
                continue
            return scope - k + 1
        return scope

    def serialize(self, target_scope: int) -&gt; dict[str, list[tuple[bool, Any]]]:
        if not target_scope:
            return {}
        current_scope = self.scope
        if current_scope == 0:
            padding = [(True, 0)] * (target_scope - 1)
            return {key: [(False, value)] + padding for key, value in self.current.items()}
        serializable = {key: list(stack) for key, stack in self.history.items()}
        if target_scope &gt; current_scope:
            padding = target_scope - current_scope
            for key, stack in serializable.items():
                stack.extend(itertools.repeat((True, (current_scope - 1)), padding))
        for key, stack in serializable.items():
            if key not in self.current:
                stack[~0] = (False, None)
        if target_scope &lt; current_scope:
            for key, stack in serializable.items():
                del stack[target_scope:]
        for key, value in self.current.items():
            if value is None:
                raise RuntimeError(F&#39;Meta variable &#34;{key}&#34; was set to None.&#39;)
            elif isinstance(value, int) and value &gt; 0xFFFFFFFFFFFFFFFF:
                q, r = divmod(value.bit_length(), 8)
                q += int(bool(r))
                value = {_BIGINT: value.to_bytes(q)}
            try:
                item_scope = self.rescope[key]
            except KeyError:
                item_scope = current_scope
            if item_scope == current_scope and not self.updated[key]:
                continue
            if item_scope &gt; target_scope:
                continue
            link = index = item_scope - 1
            if index &lt; 0:
                raise RuntimeError(&#39;computed a negative index for variable placement&#39;)
            try:
                stack = serializable[key]
            except KeyError:
                serializable[key] = stack = [(False, None)] * target_scope
            else:
                for k, (is_link, v) in enumerate(stack):
                    if k &gt; index:
                        break
                    while is_link:
                        k, is_link, v = v, *stack[v]
                    if v == value:
                        link = k
                        break
            if link &lt; index:
                stack[index] = (True, link)
            else:
                stack[index] = (False, value)
            for k in range(index + 1, target_scope):
                stack[k] = (True, index)
        vanishing_variables = []
        for key, stack in serializable.items():
            if all(v is None for lnk, v in stack if not lnk):
                vanishing_variables.append(key)
        for key in vanishing_variables:
            del serializable[key]
        return serializable

    def items(self):
        yield (_INDEX, self.index)
        yield from self.tempval.items()
        yield from self.current.items()

    def keys(self):
        yield _INDEX
        yield from self.tempval.keys()
        yield from self.current.keys()

    def variable_names(self):
        yield _INDEX
        yield from self.current.keys()

    def values(self):
        yield self.index
        yield from (v for _, v in self.items())

    __iter__ = keys

    def format_str(
        self,
        spec: str,
        codec: str,
        args: list | tuple = (),
        symb: dict | None = None,
        used: set | None = None,
        escaped: bool = False,
    ) -&gt; str:
        &#34;&#34;&#34;
        Formats the input expression like a normal Python format string expression. Certain refinery
        metadata objects have special formatters for the `r`-transformation, as defined by wrapping
        of type `refinery.lib.meta.CustomStringRepresentation`. The following representations are
        defined:

        - `entropy` and `ic` are formatted as a percentage.
        - `sha1`, `sha256`, `sha512`, and `md5` are formatted as hex strings.
        - `size` is formatted as a human-readable size with unit.
        &#34;&#34;&#34;
        ret = self.format(spec, codec, args, symb, binary=False, used=used, escaped=escaped)
        assert isinstance(ret, str)
        return ret

    def format_bin(
        self,
        spec: str,
        codec: str,
        args: list | tuple = (),
        symb: dict | None = None,
        used: set | None = None,
        escaped: bool = False,
    ) -&gt; buf:
        &#34;&#34;&#34;
        Formats the input expression using a Python F-string like expression. These strings contain
        fields in the format `{expression!T:pipeline}`, where `T` is a transformation character and
        the `pipeline` part is a sequence of `refinery.lib.argformats.multibin` handlers which are
        parsed in reverse. For example, the expression `{v:b64:hex}` will first decode the contents
        of `v` using `refinery.b64`, and then decode the result using `refinery.hex`.

        The transformation character is only required when `expression` is a literal; it specifies
        how to convert the literal to a binary string. The following transformations can be applied:

        - `a`: literal is to be encoded using latin1
        - `u`: literal is to be encoded using utf16
        - `s`: literal is to be encoded using the default codec
        - `q`: literal is a URL-encoded binary string
        - `h`: literal is a hex-encoded binary string
        - `e`: literal is an escaped ASCII string
        &#34;&#34;&#34;
        ret = self.format(spec, codec, args, symb, binary=True, used=used, escaped=escaped)
        assert not isinstance(ret, str)
        return ret

    def format(
        self,
        spec    : str,
        codec   : str,
        args    : list | tuple,
        symb    : dict | None,
        binary  : bool,
        fixup   : bool = True,
        used    : set | None = None,
        escaped : bool = False
    ) -&gt; str | buf:
        &#34;&#34;&#34;
        Formats a string using Python-like string fomatting syntax. The formatter for `binary`
        mode is different; each formatting is documented in one of the following two proxy methods:

        - `refinery.lib.meta.LazyMetaOracle.format_str`
        - `refinery.lib.meta.LazyMetaOracle.format_bin`
        &#34;&#34;&#34;
        # prevents circular import:
        from refinery.lib.argformats import (
            Chunk,
            DelayedNumSeqArgument,
            ParserError,
            PythonExpression,
        )

        symb = symb or {}

        if used is None:
            class dummy:
                def add(self, _):
                    pass
            used = dummy()

        if args is None:
            args = ()
        elif not isinstance(args, (list, tuple)):
            args = list(args)

        if fixup:
            for (store, it) in (
                (args, enumerate(args)),
                (symb, symb.items()),
            ):
                for key, value in it:
                    with contextlib.suppress(TypeError):
                        if isinstance(value, CustomStringRepresentation):
                            continue
                        store[key] = ByteStringWrapper.Wrap(value, codec)

        formatter = string.Formatter()
        autoindex = 0

        def putstr(s: str):
            if isinstance(stream, MemoryFile):
                stream.write(s.encode(codec))
            else:
                stream.write(s)

        if binary:
            stream = MemoryFile()
        else:
            stream = StringIO()

        with stream:
            for prefix, field, modifier, conversion in formatter.parse(spec):
                def recover_placeholder():
                    recovery = F&#39;{{{field}&#39;
                    if conversion:
                        recovery = F&#39;{recovery}!{conversion}&#39;
                    if modifier:
                        recovery = F&#39;{recovery}:{modifier}&#39;
                    return F&#39;{recovery}}}&#39;

                value = None

                if conversion == &#39;a&#39;:
                    converter = ascii
                elif conversion == &#39;s&#39;:
                    converter = str
                elif conversion == &#39;r&#39;:
                    converter = repr
                else:
                    converter = None

                if prefix:
                    if escaped:
                        prefix = prefix.encode(&#39;latin1&#39;).decode(&#39;unicode-escape&#39;)
                    putstr(prefix)

                if field is None:
                    continue

                if not field:
                    if not args:
                        ph = recover_placeholder()
                        if self.ghost:
                            putstr(ph)
                            continue
                        raise LookupError(F&#39;Spec contains placeholder {ph} but no positional arguments were given.&#39;)
                    value = args[autoindex]
                    used.add(autoindex)
                    if autoindex &lt; len(args) - 1:
                        autoindex += 1

                if conversion:
                    conversion = conversion.lower()
                    if conversion == &#39;h&#39;:
                        value = bytes.fromhex(field)
                    elif conversion == &#39;q&#39;:
                        value = unquote_to_bytes(field)
                    elif conversion == &#39;u&#39;:
                        value = field.encode(&#39;utf-16le&#39;)
                    elif conversion == &#39;n&#39;:
                        value = field.encode(codec).decode(&#39;unicode-escape&#39;).encode(&#39;latin1&#39;)
                elif field in symb:
                    value = symb[field]
                    used.add(field)

                if value is None:
                    with contextlib.suppress(ValueError, IndexError):
                        index = int(field, 0)
                        value = args[index]
                        used.add(index)

                if value is None:
                    with contextlib.suppress(KeyError):
                        value = self[field]
                        used.add(field)

                if value is None:
                    try:
                        field = self.format(field, codec, args, symb, False, False, used)
                    except Exception:
                        pass
                    try:
                        expression = PythonExpression(field, *self, *symb)
                        value = expression(self, **symb)
                    except ParserError:
                        if self.ghost:
                            putstr(recover_placeholder())
                            continue
                        if modifier:
                            value = field
                        else:
                            raise KeyError
                    except Exception:
                        value = B&#39;&#39;

                try:
                    converted = ByteStringWrapper.Wrap(value, codec)
                except TypeError:
                    if converter:
                        converted = converter(value)
                    elif isinstance(value, CustomStringRepresentation):
                        converted = str(value)
                    else:
                        converted = value

                if binary and isbuffer(converted):
                    output = None
                else:
                    try:
                        output = converted.__format__(modifier)
                    except Exception:
                        if not modifier:
                            raise
                        output = None

                if modifier and output is None:
                    modifier = modifier.strip()
                    expression = self.format(modifier, codec, args, symb, True, False, used)
                    output = DelayedNumSeqArgument(
                        expression.decode(codec), reverse=True, seed=converted)
                    output = output(Chunk(converted, meta=self))

                if output is None:
                    output = converted

                if not binary:
                    if isinstance(output, (bytes, bytearray)):
                        output = output.decode()
                    elif not isinstance(output, str):
                        output = str(output)
                elif isinstance(output, str):
                    output = output.encode()

                stream.write(output)
            return stream.getvalue()

    def knows(self, key):
        return (
            key in self.current or # noqa
            key in self.tempval or # noqa
            key in self.cache
        )

    def __contains__(self, key):
        return (
            key == _INDEX
            or key in self.current
            or key in self.tempval
            or key in self.derivations
        )

    def clear(self):
        self.current.clear()
        self.tempval.clear()

    def __len__(self):
        return len(self.current) + len(self.tempval)

    def autowrap(self, key, value):
        try:
            wrap = self.derivations[key].wrap
        except KeyError:
            wrap = ByteStringWrapper
        if not isinstance(value, wrap):
            with contextlib.suppress(TypeError):
                value = wrap(value)
        return value

    def __setitem__(self, key, value):
        new = self.autowrap(key, value)
        if not is_valid_variable_name(key):
            self.tempval[key] = new
            return
        self.current[key] = new
        try:
            stack = self.history[key]
            lnk, old = stack[-1]
        except KeyError:
            self.updated[key] = True
        else:
            while lnk:
                lnk, old = stack[old]
            self.updated[key] = (old != new)

    class nodefault:
        pass

    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default

    def pop(self, key, default=nodefault):
        try:
            value = self[key]
        except KeyError:
            if default is self.nodefault:
                raise
            return default
        else:
            self.discard(key)
            return value

    def __getitem__(self, key):
        if key == _INDEX:
            return self.index
        try:
            value = self.current[key]
        except KeyError:
            try:
                return self.tempval[key]
            except KeyError:
                pass
            return self.__missing__(key)
        if isinstance(value, str):
            value = value.encode(&#39;utf8&#39;)
        return value

    def discard(self, key):
        try:
            del self.current[key]
        except KeyError:
            try:
                del self.tempval[key]
            except KeyError:
                pass

    __delitem__ = discard

    def __getattr__(self, key):
        if key not in self.current:
            deduction = self.derivations.get(key)
            if deduction is None:
                raise AttributeError(key)
            return deduction.wrap(deduction(self))
        else:
            return self[key]

    def __missing__(self, key):
        try:
            return self.cache[key]
        except KeyError:
            pass
        deduction = self.derivations.get(key)
        if deduction is None:
            raise KeyError(F&#39;The meta variable {key} is unknown.&#39;)
        try:
            value = deduction.wrap(deduction(self))
        except _NoDerivationAvailable:
            raise KeyError(F&#39;unable to derive the {key} property here, you have to use the cm unit.&#39;)
        else:
            self.cache[key] = value
            return value

    def derive(self, key):
        self[key] = self[key]

    @_derivation(&#39;mime&#39;)
    def _derive_mime(self):
        return get_cached_file_magic_info(self.chunk).mime

    @_derivation(&#39;ext&#39;)
    def _derive_ext(self):
        return get_cached_file_magic_info(self.chunk).extension

    @_derivation(&#39;magic&#39;)
    def _derive_magic(self):
        return get_cached_file_magic_info(self.chunk).description

    @_derivation(&#39;size&#39;, wrap=SizeInt)
    def _derive_size(self):
        return len(self.chunk)

    @_derivation(&#39;entropy&#39;, True, Percentage)
    def _derive_entropy(self):
        return entropy(self.chunk)

    @_derivation(&#39;ic&#39;, True, Percentage)
    def _derive_ic(self):
        return index_of_coincidence(self.chunk)

    @_derivation(&#39;crc32&#39;)
    def _derive_crc32(self):
        import zlib
        return (zlib.crc32(self.chunk) &amp; 0xFFFFFFFF).to_bytes(4, &#39;big&#39;).hex()

    @_derivation(&#39;sha1&#39;, True)
    def _derive_sha1(self):
        import hashlib
        return hashlib.sha1(self.chunk).hexdigest()

    @_derivation(&#39;sha256&#39;, True)
    def _derive_sha256(self):
        import hashlib
        return hashlib.sha256(self.chunk).hexdigest()

    @_derivation(&#39;sha512&#39;, True)
    def _derive_sha512(self):
        import hashlib
        return hashlib.sha512(self.chunk).hexdigest()

    @_derivation(&#39;md5&#39;, True)
    def _derive_md5(self):
        import hashlib
        return hashlib.md5(self.chunk).hexdigest()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.meta.LazyMetaOracle.ghost"><code class="name">var <span class="ident">ghost</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.chunk"><code class="name">var <span class="ident">chunk</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.cache"><code class="name">var <span class="ident">cache</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.history"><code class="name">var <span class="ident">history</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.current"><code class="name">var <span class="ident">current</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.updated"><code class="name">var <span class="ident">updated</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.IndexKey"><code class="name">var <span class="ident">IndexKey</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.derivations"><code class="name">var <span class="ident">derivations</span></code></dt>
<dd>
<section class="desc"><p>A dictionary mapping the names of common properties to anonymous functions that compute their
corresponding value on a chunk of binary input data.</p></section>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.nodefault"><code class="name">var <span class="ident">nodefault</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.meta.LazyMetaOracle.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L481-L490" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def update(self, other: dict | LazyMetaOracle):
    if isinstance(other, LazyMetaOracle):
        self.current.update(other.current)
        self.updated.update(other.updated)
        self.tempval.update(other.tempval)
        self.rescope.update(other.rescope)
        self.history = other.history
        return
    for key, value in other.items():
        self[key] = value</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.inherit"><code class="name flex">
<span>def <span class="ident">inherit</span></span>(<span>self, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>This method is called to inherit variables from a parent meta variable dictionary.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L492-L516" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def inherit(self, parent: LazyMetaOracle):
    &#34;&#34;&#34;
    This method is called to inherit variables from a parent meta variable dictionary.
    &#34;&#34;&#34;
    if not self.history:
        self.history = parent.history
    elif self.history is not parent.history:
        for key in parent.current.keys():
            if key not in self.current:
                self.current[key] = parent.current[key]
                self.history[key] = parent.history[key]
    self.scope = parent.scope
    for key in parent.keys():
        try:
            derivation = self.derivations[key]
        except KeyError:
            try:
                self.updated.setdefault(key, False)
                self.current.setdefault(key, parent.current[key])
            except KeyError:
                pass
        else:
            if derivation.costly and len(self.chunk) &gt;= 0x1000:
                continue
            self[key] = derivation.wrap(derivation(self))</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.set_scope"><code class="name flex">
<span>def <span class="ident">set_scope</span></span>(<span>self, key, scope)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L518-L527" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_scope(self, key: str, scope: int):
    current = self.scope
    scope = max(1, scope)
    if key not in self.current:
        raise KeyError(key)
    if scope &gt; current:
        raise ValueError(F&#39;Attempt to increase scope level of variable {key} to {scope}, it is currently at {self.scope}.&#39;)
    if scope == current:
        return
    self.rescope[key] = scope</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.get_scope"><code class="name flex">
<span>def <span class="ident">get_scope</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L529-L542" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_scope(self, key: str):
    value = self.current[key]
    scope = self.scope
    try:
        stack = self.history[key]
    except KeyError:
        return scope
    for k, (is_link, v) in enumerate(reversed(stack)):
        while is_link:
            is_link, v = stack[v]
        if v == value:
            continue
        return scope - k + 1
    return scope</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, target_scope)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L544-L605" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def serialize(self, target_scope: int) -&gt; dict[str, list[tuple[bool, Any]]]:
    if not target_scope:
        return {}
    current_scope = self.scope
    if current_scope == 0:
        padding = [(True, 0)] * (target_scope - 1)
        return {key: [(False, value)] + padding for key, value in self.current.items()}
    serializable = {key: list(stack) for key, stack in self.history.items()}
    if target_scope &gt; current_scope:
        padding = target_scope - current_scope
        for key, stack in serializable.items():
            stack.extend(itertools.repeat((True, (current_scope - 1)), padding))
    for key, stack in serializable.items():
        if key not in self.current:
            stack[~0] = (False, None)
    if target_scope &lt; current_scope:
        for key, stack in serializable.items():
            del stack[target_scope:]
    for key, value in self.current.items():
        if value is None:
            raise RuntimeError(F&#39;Meta variable &#34;{key}&#34; was set to None.&#39;)
        elif isinstance(value, int) and value &gt; 0xFFFFFFFFFFFFFFFF:
            q, r = divmod(value.bit_length(), 8)
            q += int(bool(r))
            value = {_BIGINT: value.to_bytes(q)}
        try:
            item_scope = self.rescope[key]
        except KeyError:
            item_scope = current_scope
        if item_scope == current_scope and not self.updated[key]:
            continue
        if item_scope &gt; target_scope:
            continue
        link = index = item_scope - 1
        if index &lt; 0:
            raise RuntimeError(&#39;computed a negative index for variable placement&#39;)
        try:
            stack = serializable[key]
        except KeyError:
            serializable[key] = stack = [(False, None)] * target_scope
        else:
            for k, (is_link, v) in enumerate(stack):
                if k &gt; index:
                    break
                while is_link:
                    k, is_link, v = v, *stack[v]
                if v == value:
                    link = k
                    break
        if link &lt; index:
            stack[index] = (True, link)
        else:
            stack[index] = (False, value)
        for k in range(index + 1, target_scope):
            stack[k] = (True, index)
    vanishing_variables = []
    for key, stack in serializable.items():
        if all(v is None for lnk, v in stack if not lnk):
            vanishing_variables.append(key)
    for key in vanishing_variables:
        del serializable[key]
    return serializable</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L607-L610" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def items(self):
    yield (_INDEX, self.index)
    yield from self.tempval.items()
    yield from self.current.items()</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L612-L615" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def keys(self):
    yield _INDEX
    yield from self.tempval.keys()
    yield from self.current.keys()</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.variable_names"><code class="name flex">
<span>def <span class="ident">variable_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L617-L619" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def variable_names(self):
    yield _INDEX
    yield from self.current.keys()</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L621-L623" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def values(self):
    yield self.index
    yield from (v for _, v in self.items())</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.format_str"><code class="name flex">
<span>def <span class="ident">format_str</span></span>(<span>self, spec, codec, args=(), symb=None, used=None, escaped=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Formats the input expression like a normal Python format string expression. Certain refinery
metadata objects have special formatters for the <code>r</code>-transformation, as defined by wrapping
of type <code><a title="refinery.lib.meta.CustomStringRepresentation" href="#refinery.lib.meta.CustomStringRepresentation">CustomStringRepresentation</a></code>. The following representations are
defined:</p>
<ul>
<li><code>entropy</code> and <code>ic</code> are formatted as a percentage.</li>
<li><code>sha1</code>, <code>sha256</code>, <code>sha512</code>, and <code>md5</code> are formatted as hex strings.</li>
<li><code>size</code> is formatted as a human-readable size with unit.</li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L627-L648" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def format_str(
    self,
    spec: str,
    codec: str,
    args: list | tuple = (),
    symb: dict | None = None,
    used: set | None = None,
    escaped: bool = False,
) -&gt; str:
    &#34;&#34;&#34;
    Formats the input expression like a normal Python format string expression. Certain refinery
    metadata objects have special formatters for the `r`-transformation, as defined by wrapping
    of type `refinery.lib.meta.CustomStringRepresentation`. The following representations are
    defined:

    - `entropy` and `ic` are formatted as a percentage.
    - `sha1`, `sha256`, `sha512`, and `md5` are formatted as hex strings.
    - `size` is formatted as a human-readable size with unit.
    &#34;&#34;&#34;
    ret = self.format(spec, codec, args, symb, binary=False, used=used, escaped=escaped)
    assert isinstance(ret, str)
    return ret</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.format_bin"><code class="name flex">
<span>def <span class="ident">format_bin</span></span>(<span>self, spec, codec, args=(), symb=None, used=None, escaped=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Formats the input expression using a Python F-string like expression. These strings contain
fields in the format <code>{expression!T:pipeline}</code>, where <code>T</code> is a transformation character and
the <code>pipeline</code> part is a sequence of <code><a title="refinery.lib.argformats.multibin" href="argformats.html#refinery.lib.argformats.multibin">multibin()</a></code> handlers which are
parsed in reverse. For example, the expression <code>{v:b64:hex}</code> will first decode the contents
of <code>v</code> using <code><a title="refinery.b64" href="../index.html#refinery.b64">b64</a></code>, and then decode the result using <code><a title="refinery.hex" href="../index.html#refinery.hex">hex</a></code>.</p>
<p>The transformation character is only required when <code>expression</code> is a literal; it specifies
how to convert the literal to a binary string. The following transformations can be applied:</p>
<ul>
<li><code>a</code>: literal is to be encoded using latin1</li>
<li><code>u</code>: literal is to be encoded using utf16</li>
<li><code>s</code>: literal is to be encoded using the default codec</li>
<li><code>q</code>: literal is a URL-encoded binary string</li>
<li><code>h</code>: literal is a hex-encoded binary string</li>
<li><code>e</code>: literal is an escaped ASCII string</li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L650-L678" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def format_bin(
    self,
    spec: str,
    codec: str,
    args: list | tuple = (),
    symb: dict | None = None,
    used: set | None = None,
    escaped: bool = False,
) -&gt; buf:
    &#34;&#34;&#34;
    Formats the input expression using a Python F-string like expression. These strings contain
    fields in the format `{expression!T:pipeline}`, where `T` is a transformation character and
    the `pipeline` part is a sequence of `refinery.lib.argformats.multibin` handlers which are
    parsed in reverse. For example, the expression `{v:b64:hex}` will first decode the contents
    of `v` using `refinery.b64`, and then decode the result using `refinery.hex`.

    The transformation character is only required when `expression` is a literal; it specifies
    how to convert the literal to a binary string. The following transformations can be applied:

    - `a`: literal is to be encoded using latin1
    - `u`: literal is to be encoded using utf16
    - `s`: literal is to be encoded using the default codec
    - `q`: literal is a URL-encoded binary string
    - `h`: literal is a hex-encoded binary string
    - `e`: literal is an escaped ASCII string
    &#34;&#34;&#34;
    ret = self.format(spec, codec, args, symb, binary=True, used=used, escaped=escaped)
    assert not isinstance(ret, str)
    return ret</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, spec, codec, args, symb, binary, fixup=True, used=None, escaped=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Formats a string using Python-like string fomatting syntax. The formatter for <code>binary</code>
mode is different; each formatting is documented in one of the following two proxy methods:</p>
<ul>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.format_str" href="#refinery.lib.meta.LazyMetaOracle.format_str">LazyMetaOracle.format_str()</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.format_bin" href="#refinery.lib.meta.LazyMetaOracle.format_bin">LazyMetaOracle.format_bin()</a></code></li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L680-L868" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def format(
    self,
    spec    : str,
    codec   : str,
    args    : list | tuple,
    symb    : dict | None,
    binary  : bool,
    fixup   : bool = True,
    used    : set | None = None,
    escaped : bool = False
) -&gt; str | buf:
    &#34;&#34;&#34;
    Formats a string using Python-like string fomatting syntax. The formatter for `binary`
    mode is different; each formatting is documented in one of the following two proxy methods:

    - `refinery.lib.meta.LazyMetaOracle.format_str`
    - `refinery.lib.meta.LazyMetaOracle.format_bin`
    &#34;&#34;&#34;
    # prevents circular import:
    from refinery.lib.argformats import (
        Chunk,
        DelayedNumSeqArgument,
        ParserError,
        PythonExpression,
    )

    symb = symb or {}

    if used is None:
        class dummy:
            def add(self, _):
                pass
        used = dummy()

    if args is None:
        args = ()
    elif not isinstance(args, (list, tuple)):
        args = list(args)

    if fixup:
        for (store, it) in (
            (args, enumerate(args)),
            (symb, symb.items()),
        ):
            for key, value in it:
                with contextlib.suppress(TypeError):
                    if isinstance(value, CustomStringRepresentation):
                        continue
                    store[key] = ByteStringWrapper.Wrap(value, codec)

    formatter = string.Formatter()
    autoindex = 0

    def putstr(s: str):
        if isinstance(stream, MemoryFile):
            stream.write(s.encode(codec))
        else:
            stream.write(s)

    if binary:
        stream = MemoryFile()
    else:
        stream = StringIO()

    with stream:
        for prefix, field, modifier, conversion in formatter.parse(spec):
            def recover_placeholder():
                recovery = F&#39;{{{field}&#39;
                if conversion:
                    recovery = F&#39;{recovery}!{conversion}&#39;
                if modifier:
                    recovery = F&#39;{recovery}:{modifier}&#39;
                return F&#39;{recovery}}}&#39;

            value = None

            if conversion == &#39;a&#39;:
                converter = ascii
            elif conversion == &#39;s&#39;:
                converter = str
            elif conversion == &#39;r&#39;:
                converter = repr
            else:
                converter = None

            if prefix:
                if escaped:
                    prefix = prefix.encode(&#39;latin1&#39;).decode(&#39;unicode-escape&#39;)
                putstr(prefix)

            if field is None:
                continue

            if not field:
                if not args:
                    ph = recover_placeholder()
                    if self.ghost:
                        putstr(ph)
                        continue
                    raise LookupError(F&#39;Spec contains placeholder {ph} but no positional arguments were given.&#39;)
                value = args[autoindex]
                used.add(autoindex)
                if autoindex &lt; len(args) - 1:
                    autoindex += 1

            if conversion:
                conversion = conversion.lower()
                if conversion == &#39;h&#39;:
                    value = bytes.fromhex(field)
                elif conversion == &#39;q&#39;:
                    value = unquote_to_bytes(field)
                elif conversion == &#39;u&#39;:
                    value = field.encode(&#39;utf-16le&#39;)
                elif conversion == &#39;n&#39;:
                    value = field.encode(codec).decode(&#39;unicode-escape&#39;).encode(&#39;latin1&#39;)
            elif field in symb:
                value = symb[field]
                used.add(field)

            if value is None:
                with contextlib.suppress(ValueError, IndexError):
                    index = int(field, 0)
                    value = args[index]
                    used.add(index)

            if value is None:
                with contextlib.suppress(KeyError):
                    value = self[field]
                    used.add(field)

            if value is None:
                try:
                    field = self.format(field, codec, args, symb, False, False, used)
                except Exception:
                    pass
                try:
                    expression = PythonExpression(field, *self, *symb)
                    value = expression(self, **symb)
                except ParserError:
                    if self.ghost:
                        putstr(recover_placeholder())
                        continue
                    if modifier:
                        value = field
                    else:
                        raise KeyError
                except Exception:
                    value = B&#39;&#39;

            try:
                converted = ByteStringWrapper.Wrap(value, codec)
            except TypeError:
                if converter:
                    converted = converter(value)
                elif isinstance(value, CustomStringRepresentation):
                    converted = str(value)
                else:
                    converted = value

            if binary and isbuffer(converted):
                output = None
            else:
                try:
                    output = converted.__format__(modifier)
                except Exception:
                    if not modifier:
                        raise
                    output = None

            if modifier and output is None:
                modifier = modifier.strip()
                expression = self.format(modifier, codec, args, symb, True, False, used)
                output = DelayedNumSeqArgument(
                    expression.decode(codec), reverse=True, seed=converted)
                output = output(Chunk(converted, meta=self))

            if output is None:
                output = converted

            if not binary:
                if isinstance(output, (bytes, bytearray)):
                    output = output.decode()
                elif not isinstance(output, str):
                    output = str(output)
            elif isinstance(output, str):
                output = output.encode()

            stream.write(output)
        return stream.getvalue()</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.knows"><code class="name flex">
<span>def <span class="ident">knows</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L870-L875" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def knows(self, key):
    return (
        key in self.current or # noqa
        key in self.tempval or # noqa
        key in self.cache
    )</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L885-L887" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clear(self):
    self.current.clear()
    self.tempval.clear()</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.autowrap"><code class="name flex">
<span>def <span class="ident">autowrap</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L892-L900" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def autowrap(self, key, value):
    try:
        wrap = self.derivations[key].wrap
    except KeyError:
        wrap = ByteStringWrapper
    if not isinstance(value, wrap):
        with contextlib.suppress(TypeError):
            value = wrap(value)
    return value</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, key, default=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L921-L925" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get(self, key, default=None):
    try:
        return self[key]
    except KeyError:
        return default</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, key, default=refinery.lib.meta.LazyMetaOracle.nodefault)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L927-L936" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pop(self, key, default=nodefault):
    try:
        value = self[key]
    except KeyError:
        if default is self.nodefault:
            raise
        return default
    else:
        self.discard(key)
        return value</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.discard"><code class="name flex">
<span>def <span class="ident">discard</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L953-L960" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def discard(self, key):
    try:
        del self.current[key]
    except KeyError:
        try:
            del self.tempval[key]
        except KeyError:
            pass</code></pre>
</details>
</dd>
<dt id="refinery.lib.meta.LazyMetaOracle.derive"><code class="name flex">
<span>def <span class="ident">derive</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/meta.py#L989-L990" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def derive(self, key):
    self[key] = self[key]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#storing-meta-variables">Storing Meta Variables</a></li>
<li><a href="#variable-reference-handlers">Variable Reference Handlers</a></li>
<li><a href="#integer-and-slice-expressions">Integer and Slice Expressions</a></li>
<li><a href="#format-string-expressions">Format String Expressions</a></li>
<li><a href="#magic-meta-variables">Magic Meta Variables</a></li>
<li><a href="#using-push-and-pop">Using Push And Pop</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.meta.is_print_safe" href="#refinery.lib.meta.is_print_safe">is_print_safe</a></code></li>
<li><code><a title="refinery.lib.meta.is_valid_variable_name" href="#refinery.lib.meta.is_valid_variable_name">is_valid_variable_name</a></code></li>
<li><code><a title="refinery.lib.meta.check_variable_name" href="#refinery.lib.meta.check_variable_name">check_variable_name</a></code></li>
<li><code><a title="refinery.lib.meta.metavars" href="#refinery.lib.meta.metavars">metavars</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.meta.CustomStringRepresentation" href="#refinery.lib.meta.CustomStringRepresentation">CustomStringRepresentation</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.meta.ByteStringWrapper" href="#refinery.lib.meta.ByteStringWrapper">ByteStringWrapper</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.meta.ByteStringWrapper.Wrap" href="#refinery.lib.meta.ByteStringWrapper.Wrap">Wrap</a></code></li>
<li><code><a title="refinery.lib.meta.ByteStringWrapper.requires_prefix" href="#refinery.lib.meta.ByteStringWrapper.requires_prefix">requires_prefix</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.meta.SizeInt" href="#refinery.lib.meta.SizeInt">SizeInt</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.meta.TerseSizeInt" href="#refinery.lib.meta.TerseSizeInt">TerseSizeInt</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.meta.Percentage" href="#refinery.lib.meta.Percentage">Percentage</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.meta.LazyMetaOracle" href="#refinery.lib.meta.LazyMetaOracle">LazyMetaOracle</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.lib.meta.LazyMetaOracle.update" href="#refinery.lib.meta.LazyMetaOracle.update">update</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.inherit" href="#refinery.lib.meta.LazyMetaOracle.inherit">inherit</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.set_scope" href="#refinery.lib.meta.LazyMetaOracle.set_scope">set_scope</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.get_scope" href="#refinery.lib.meta.LazyMetaOracle.get_scope">get_scope</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.serialize" href="#refinery.lib.meta.LazyMetaOracle.serialize">serialize</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.items" href="#refinery.lib.meta.LazyMetaOracle.items">items</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.keys" href="#refinery.lib.meta.LazyMetaOracle.keys">keys</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.variable_names" href="#refinery.lib.meta.LazyMetaOracle.variable_names">variable_names</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.values" href="#refinery.lib.meta.LazyMetaOracle.values">values</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.format_str" href="#refinery.lib.meta.LazyMetaOracle.format_str">format_str</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.format_bin" href="#refinery.lib.meta.LazyMetaOracle.format_bin">format_bin</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.format" href="#refinery.lib.meta.LazyMetaOracle.format">format</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.knows" href="#refinery.lib.meta.LazyMetaOracle.knows">knows</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.clear" href="#refinery.lib.meta.LazyMetaOracle.clear">clear</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.autowrap" href="#refinery.lib.meta.LazyMetaOracle.autowrap">autowrap</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.get" href="#refinery.lib.meta.LazyMetaOracle.get">get</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.pop" href="#refinery.lib.meta.LazyMetaOracle.pop">pop</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.discard" href="#refinery.lib.meta.LazyMetaOracle.discard">discard</a></code></li>
<li><code><a title="refinery.lib.meta.LazyMetaOracle.derive" href="#refinery.lib.meta.LazyMetaOracle.derive">derive</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
