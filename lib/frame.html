<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.frame documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.frame</code></h1>
</header>
<section id="section-intro">
<p>Some refinery units produce more than one output when applied to an input. For example,
<code><a title="refinery.chop" href="../index.html#refinery.chop">chop</a></code> will chop the input data into evenly sized blocks and emit each of them
as a single output. By default, if no framing syntax is used, multiple outputs are
separated by line breaks, which is often desirable when text data is extracted. However,
for processing binary data, this is equally often more than useless. To process the list
of results generated by any refinery unit, end the command for this unit with the
special argument <code>[</code>. This argument has to be the last argument to be recognized as a
framing initialization. If this syntax is used, the list of results is emitted in an
internal format which allows arbitrarily nested lists of binary chunks to be processed.</p>
<h3 id="simple-frame-example">Simple Frame Example</h3>
<pre><code>$ emit OOOOOOOO | chop 2 [| ccp F | cca . ]
FOO.FOO.FOO.FOO.
</code></pre>
<p>Here, the string <code>OOOOOOOO</code> is first chopped into blocks of 2, yielding the <strong>frame</strong>
<code>[OO, OO, OO, OO]</code> which is then forwarded to the next command. If a <code><a title="refinery.units.Unit" href="../units/index.html#refinery.units.Unit">Unit</a></code>
receives input in framed format, each chunk of the frame is processed individually and
emitted as one output chunk. In this case, <code><a title="refinery.ccp" href="../index.html#refinery.ccp">ccp</a></code> simply prepends <code>F</code> to every
input, producing the frame <code>[FOO, FOO, FOO, FOO]</code>. Finally, <code><a title="refinery.cca" href="../index.html#refinery.cca">cca</a></code> appends a period
to each chunk. When a unit is given the closing bracket as the last argument, this
concludes processing of one frame which results in concatenation of all binary chunks in
the frame.</p>
<h3 id="frame-layers">Frame Layers</h3>
<p>Frames can be nested arbitrarily, and <code><a title="refinery.sep" href="../index.html#refinery.sep">sep</a></code> can be used to insert a separator
(the default is line break) between all chunks in the frame:</p>
<pre><code>$ emit OOOOOOOO | chop 4 [| chop 2 [| ccp F | cca . ]| sep ]
FOO.FOO.
FOO.FOO.
</code></pre>
<p>Here, we first produce the two-layered <strong>frame tree</strong> <code>[[OO,OO], [OO,OO]]</code> by using two
<code><a title="refinery.chop" href="../index.html#refinery.chop">chop</a></code> invocations. We refer to this data as a tree because, well, it is one:</p>
<pre><code>LAYER 1:      [[..],[..]]
                /     \
LAYER 2:    [OO,OO] [OO,OO]
</code></pre>
<p>The bottom layer is processed as before, yielding <code>[FOO.FOO., FOO.FOO.]</code>. Next, the unit
<code><a title="refinery.sep" href="../index.html#refinery.sep">sep</a></code> inserts a line break character between the two chunks in this frame.</p>
<h3 id="adding-line-breaks-easily">Adding Line Breaks Easily</h3>
<p>Since separating data with line breaks is a common requirement, it is also possible to use
one more closing bracket than necessary at the end of a frame to separate all chunks by line
breaks:</p>
<pre><code>$ emit OOOOOOOO | chop 4 [| chop 2 [| ccp F | cca . ]]]
FOO.FOO.
FOO.FOO.
</code></pre>
<h3 id="squeezing">Squeezing</h3>
<p>Inside a frame, application of a <code><a title="refinery.units.Unit" href="../units/index.html#refinery.units.Unit">Unit</a></code> with multiple outputs will substitute the
input by the corresponding list of outputs. For example,</p>
<pre><code>$ emit OOOOOOOO | chop 4 [| chop 2 | ccp F ]]
</code></pre>
<p>has the exact same output as the following command:</p>
<pre><code>$ emit 00000000 | chop 2 [| ccp F ]]
</code></pre>
<p>In the first case, we create the frame <code>[OOOO, OOOO]</code> and then apply <code>chop 2</code> to each chunk,
which results in the frame <code>[OO, OO, OO, OO]</code>. Now, consider the example</p>
<pre><code>$ emit OOCLOOCL | chop 4 [| snip 2::-1 3: ]]
COO
L
COO
L
</code></pre>
<p>With what we have learned so far, if we wanted it to spell <code>COOL</code> twice instead,we would have
to use the following and slightly awkward syntax:</p>
<pre><code>$ emit OOCLOOCL | chop 4 [| snip 2::-1 3 [| nop ]| sep ]
COOL
COOL
</code></pre>
<p>This is because the <code>snip</code> command, by default, will simply insert the list <code>[COO, L]</code> into
the complete frame, creating the output sequence <code>[COO, L, COO, L]</code> and all of these chunks
will be separated by line breaks. For this reason, the squeeze syntax exists. If the brackets
at the end of a refinery command are prefixed by the sequence <code>[]</code>, i.e. an opening bracket
followed directly by a closing one, then all outputs of the unit are fused into a single
output chunk by concatenating them. In our example:</p>
<pre><code>$ emit OOCLOOCL | chop 4 [| snip 2::-1 3 []]]
COOL
COOL
</code></pre>
<h3 id="scoping">Scoping</h3>
<p>It is possible to alter the <strong>visibility</strong> of <code><a title="refinery.lib.frame.Chunk" href="#refinery.lib.frame.Chunk">Chunk</a></code>, primarily by
using <code><a title="refinery.scope" href="../index.html#refinery.scope">scope</a></code>. The unit accepts a slice argument which defines the indices of
the current frame that remain visible. All subsequent units will only process visible
chunks and simply forward the ones that are not visible. <code><a title="refinery.lib.frame.Chunk" href="#refinery.lib.frame.Chunk">Chunk</a></code>s
remain invisible when a new frame layer opens:</p>
<pre><code>$ emit BINARY REFINERY [| scope 0 | clower | sep - ]
binary-REFINERY
</code></pre>
<p>Here, the scope was limited to the first chunk <code>BINARY</code> which was transformed to lower
case, but the second chunk <code>REFINERY</code> was left untouched. A somewhat more complex example:</p>
<pre><code>$ emit aaaaaaaa namtaB [| scope 0 | rex . [| ccp N ]| scope 1 | rev | sep - ]
NaNaNaNaNaNaNaNa-Batman
</code></pre>
<p>Note that <code><a title="refinery.sep" href="../index.html#refinery.sep">sep</a></code> makes all chunks in the frame visible by default, because it is
intended to sit at the end of a frame. Otherwise, <code>NaNaNaNaNaNaNaNa</code> and <code>Batman</code> in the
above example would not be separated by a dash.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L1-L802" class="git-link">Browse git</a>
</summary>
<pre><code class="python">R&#34;&#34;&#34;
Some refinery units produce more than one output when applied to an input. For example,
`refinery.chop` will chop the input data into evenly sized blocks and emit each of them
as a single output. By default, if no framing syntax is used, multiple outputs are
separated by line breaks, which is often desirable when text data is extracted. However,
for processing binary data, this is equally often more than useless. To process the list
of results generated by any refinery unit, end the command for this unit with the
special argument `[`. This argument has to be the last argument to be recognized as a
framing initialization. If this syntax is used, the list of results is emitted in an
internal format which allows arbitrarily nested lists of binary chunks to be processed.

### Simple Frame Example

    $ emit OOOOOOOO | chop 2 [| ccp F | cca . ]
    FOO.FOO.FOO.FOO.

Here, the string `OOOOOOOO` is first chopped into blocks of 2, yielding the **frame**
`[OO, OO, OO, OO]` which is then forwarded to the next command. If a `refinery.units.Unit`
receives input in framed format, each chunk of the frame is processed individually and
emitted as one output chunk. In this case, `refinery.ccp` simply prepends `F` to every
input, producing the frame `[FOO, FOO, FOO, FOO]`. Finally, `refinery.cca` appends a period
to each chunk. When a unit is given the closing bracket as the last argument, this
concludes processing of one frame which results in concatenation of all binary chunks in
the frame.

### Frame Layers

Frames can be nested arbitrarily, and `refinery.sep` can be used to insert a separator
(the default is line break) between all chunks in the frame:

    $ emit OOOOOOOO | chop 4 [| chop 2 [| ccp F | cca . ]| sep ]
    FOO.FOO.
    FOO.FOO.

Here, we first produce the two-layered **frame tree** `[[OO,OO], [OO,OO]]` by using two
`refinery.chop` invocations. We refer to this data as a tree because, well, it is one:

    LAYER 1:      [[..],[..]]
                    /     \
    LAYER 2:    [OO,OO] [OO,OO]

The bottom layer is processed as before, yielding `[FOO.FOO., FOO.FOO.]`. Next, the unit
`refinery.sep` inserts a line break character between the two chunks in this frame.

### Adding Line Breaks Easily

Since separating data with line breaks is a common requirement, it is also possible to use
one more closing bracket than necessary at the end of a frame to separate all chunks by line
breaks:

    $ emit OOOOOOOO | chop 4 [| chop 2 [| ccp F | cca . ]]]
    FOO.FOO.
    FOO.FOO.

### Squeezing

Inside a frame, application of a `refinery.units.Unit` with multiple outputs will substitute the
input by the corresponding list of outputs. For example,

    $ emit OOOOOOOO | chop 4 [| chop 2 | ccp F ]]

has the exact same output as the following command:

    $ emit 00000000 | chop 2 [| ccp F ]]

In the first case, we create the frame `[OOOO, OOOO]` and then apply `chop 2` to each chunk,
which results in the frame `[OO, OO, OO, OO]`. Now, consider the example

    $ emit OOCLOOCL | chop 4 [| snip 2::-1 3: ]]
    COO
    L
    COO
    L

With what we have learned so far, if we wanted it to spell `COOL` twice instead,we would have
to use the following and slightly awkward syntax:

    $ emit OOCLOOCL | chop 4 [| snip 2::-1 3 [| nop ]| sep ]
    COOL
    COOL

This is because the `snip` command, by default, will simply insert the list `[COO, L]` into
the complete frame, creating the output sequence `[COO, L, COO, L]` and all of these chunks
will be separated by line breaks. For this reason, the squeeze syntax exists. If the brackets
at the end of a refinery command are prefixed by the sequence `[]`, i.e. an opening bracket
followed directly by a closing one, then all outputs of the unit are fused into a single
output chunk by concatenating them. In our example:

    $ emit OOCLOOCL | chop 4 [| snip 2::-1 3 []]]
    COOL
    COOL


### Scoping

It is possible to alter the **visibility** of `refinery.lib.frame.Chunk`, primarily by
using `refinery.scope`. The unit accepts a slice argument which defines the indices of
the current frame that remain visible. All subsequent units will only process visible
chunks and simply forward the ones that are not visible. `refinery.lib.frame.Chunk`s
remain invisible when a new frame layer opens:

    $ emit BINARY REFINERY [| scope 0 | clower | sep - ]
    binary-REFINERY

Here, the scope was limited to the first chunk `BINARY` which was transformed to lower
case, but the second chunk `REFINERY` was left untouched. A somewhat more complex example:

    $ emit aaaaaaaa namtaB [| scope 0 | rex . [| ccp N ]| scope 1 | rev | sep - ]
    NaNaNaNaNaNaNaNa-Batman

Note that `refinery.sep` makes all chunks in the frame visible by default, because it is
intended to sit at the end of a frame. Otherwise, `NaNaNaNaNaNaNaNa` and `Batman` in the
above example would not be separated by a dash.
&#34;&#34;&#34;
from __future__ import annotations

import itertools
import uuid
import zlib

from typing import (
    TYPE_CHECKING,
    Any,
    BinaryIO,
    Callable,
    Generator,
    Iterable,
    SupportsIndex,
    overload,
)

from refinery.lib.meta import LazyMetaOracle
from refinery.lib.structures import MemoryFile
from refinery.lib.types import buf

if TYPE_CHECKING:
    from msgpack.fallback import Unpacker

try:
    import msgpack
except ModuleNotFoundError:
    msgpack = None

__all__ = [
    &#39;Chunk&#39;,
    &#39;Framed&#39;,
    &#39;FrameUnpacker&#39;,
    &#39;MAGIC&#39;,
    &#39;MSIZE&#39;,
    &#39;generate_frame_header&#39;
]


MAGIC = bytes.fromhex(&#39;FEED1985C0CAC01AC0DE&#39;)
&#34;&#34;&#34;
This is the magic signature that is used by refinery to prefix serialized frame data. If a unit
reads data from STDIN that is prefixed with these bytes, it assumes that serialized frame data
follows. Otherwise, the input is treated as a single unframed chunk.
&#34;&#34;&#34;
MSIZE = len(MAGIC) + 1
&#34;&#34;&#34;
This is the length of the data returned by `refinery.lib.frame.generate_frame_header`.
&#34;&#34;&#34;


def generate_frame_header(scope: int):
    &#34;&#34;&#34;
    This function generates a frame header for a frame tree of depth equal to `scope`. The depth
    is encoded as a single byte following `refinery.lib.frame.MAGIC`. This implies a depth limit
    of 255 for frame trees in refinery, and I dearly hope that noone is insane enough to build a
    refinery pipeline that would be affected.
    &#34;&#34;&#34;
    if scope &gt; 0xFF:
        raise ValueError(&#39;Maximum frame depth exceeded.&#39;)
    return B&#39;%s%c&#39; % (MAGIC, scope)


class Chunk(bytearray):
    &#34;&#34;&#34;
    Represents the individual chunks in a frame. The `refinery.units.Unit.filter` method receives
    an iterable of `refinery.lib.frame.Chunk`s.
    &#34;&#34;&#34;
    temp: Any
    &#34;&#34;&#34;
    Units can use this field to transport temporary data between different callbacks. For example,
    a unit might want to transport information from `refinery.units.Unit.filter` to:

    - `refinery.units.Unit.reverse`
    - `refinery.units.Unit.process`

    These methods, in turn, might want to transport information to `refinery.units.Unit.finish`.
    &#34;&#34;&#34;
    uuid: uuid.UUID
    &#34;&#34;&#34;
    Each chunk object carries a unique identifier. The `refinery.units.DelayedArgumentProxy` uses
    this property to check whether `refinery.units.Unit` command-line arguments were previously
    evaluated against this chunk. Otherwise `refinery.lib.argformats.DelayedArgument`s that alter
    the input data could produce unexpected results when the argument proxy is mapped against the
    same chunk twice.
    &#34;&#34;&#34;

    __slots__ = (
        &#39;_meta&#39;,
        &#39;_view&#39;,
        &#39;_path&#39;,
        &#39;_fill_scope&#39;,
        &#39;_fill_batch&#39;,
        &#39;temp&#39;,
        &#39;uuid&#39;,
    )

    def __init__(
        self,
        data: buf | None = None,
        path: list[int] | None = None,
        view: list[bool] | None = None,
        meta: dict[str, Any] | None = None,
        seed: dict[str, list] | None = None,
        fill_scope: bool | None = None,
        fill_batch: int | None = None,
        ignore_chunk_properties: bool = False,
    ):
        if data is None:
            bytearray.__init__(self)
        else:
            bytearray.__init__(self, data)

        self.uuid = uuid.uuid4()
        self.temp = None

        if path is None:
            path = []
        if view is None:
            view = [False] * len(path)
        elif len(view) != len(path):
            raise ValueError(&#39;view must have the same length as path&#39;)

        if not ignore_chunk_properties and isinstance(data, Chunk):
            path = path or list(data.path)
            view = view or list(data.view)
            meta = meta or data.meta
            fill_scope = fill_scope or data._fill_scope
            fill_batch = fill_batch or data._fill_batch

        self._view: list[bool] = view
        self._path: list[int] = path
        self._fill_scope: bool | None = fill_scope
        self._fill_batch: bool | None = fill_batch

        self._meta = m = LazyMetaOracle(self, scope=self.scope, seed=seed)
        if meta is not None:
            m.update(meta)

    @classmethod
    def Wrap(cls, data):
        if isinstance(data, cls):
            return data
        return cls(data)

    def set_next_scope(self, visible: bool) -&gt; None:
        self._fill_scope = visible

    def set_next_batch(self, batch: int) -&gt; None:
        &#34;&#34;&#34;
        This function allows units to emit trees of depth one rather than lists. When a unit emits
        a chunk at index `a`, sets the next batch to `b`, and when a double frame opens after this
        unit&#39;s invocation, then said chunk will have `a/b` added to its path. By default, `b` would
        always be `0`. For example, the `refinery.rex` unit uses this feature. As a result:

            $ emit #1yellow-#3red-#2orange | rex #(.)([a-z]+) {1} {2} [[| pop x:e ]| rep v:x ]]
            yellow
            red
            red
            red
            orange
            orange

        The double frame after `refinery.rex` looks like this:

            [[1,yellow],[2,red],[3,orange]]

        By default, the frame would simply look like this:

            [[1,yellow,2,red,3,orange]]

        This feature is useful for `refinery.units.Unit`s that produce multiple outputs for each of
        a number of intermediate results - in the case of `refinery.rex`, that intermediate result
        is a regular expression match, and `refinery.rex` allows to produce different outputs for
        each of those.
        &#34;&#34;&#34;
        self._fill_batch = batch

    @property
    def scope(self) -&gt; int:
        &#34;&#34;&#34;
        This value is the length of `refinery.lib.frame.Chunk.path` and therefore corresponds to
        the depth of the frame tree. It is called &#34;scope&#34; because it is equally the scope at which
        new metadata variables for this chunk will be created.
        &#34;&#34;&#34;
        return len(self._path)

    @property
    def view(self) -&gt; list[bool]:
        &#34;&#34;&#34;
        This tuple of boolean values indicates the visibility of this chunk at each layer of
        the frame tree. The `refinery.scope` unit can be used to change visibility of chunks
        within a frame.
        &#34;&#34;&#34;
        return self._view

    @property
    def path(self) -&gt; list[int]:
        &#34;&#34;&#34;
        The vertices in each frame tree layer are sequentially numbered by their order of
        appearance in the stream. The `refinery.lib.frame.Chunk.path` contains the numbers of
        the vertices (in each layer) which define the path from the root of the frame tree
        to the leaf vertex representing this `refinery.lib.frame.Chunk`
        &#34;&#34;&#34;
        return self._path

    @property
    def meta(self) -&gt; LazyMetaOracle:
        &#34;&#34;&#34;
        Every chunk can contain a dictionary of arbitrary metadata. Further details about this data
        are available in the module-level documetnation of `refinery.lib.meta`.
        &#34;&#34;&#34;
        if self._meta.chunk is not self:
            raise RuntimeError(&#39;meta dictionary carries invalid parent reference&#39;)
        return self._meta

    @property
    def visible(self):
        &#34;&#34;&#34;
        This property defines whether the chunk is currently visible. It defaults to true if the
        chunk is not part of a frame and is otherwise the same as the last element of the tuple
        `refinery.lib.frame.Chunk.view`. Setting this property will correspondingly alter the last
        entry of `refinery.lib.frame.Chunk.view`.
        Setting this property on an unframed `refinery.lib.frame.Chunk` raises an `AttributeError`.
        &#34;&#34;&#34;
        return not self._view or self._view[~0]

    @property
    def scopable(self):
        &#34;&#34;&#34;
        This property defines whether the chunk can be made visible in the current frame.
        &#34;&#34;&#34;
        return len(self._view) &lt;= 1 or self._view[~1]

    @visible.setter
    def visible(self, value: bool):
        view = self._view
        if not view:
            if not value:
                raise AttributeError(&#39;cannot make chunk invisible outside frame&#39;)
        else:
            view[~0] = value

    @classmethod
    def unpack(cls, stream):
        &#34;&#34;&#34;
        Classmethod to read a serialized chunk from an unpacker stream.
        &#34;&#34;&#34;
        item = next(stream)
        path, view, meta, fs, data = item
        return cls(data, path=path, view=view, seed=meta, fill_scope=fs)

    def pack(self, nest: int = 0, position: int = 0, serialize: bool = True):
        &#34;&#34;&#34;
        This function is equivalent to `refinery.lib.frame.Chunk.pack` if `serialize` is `True`.
        Otherwise, the function creates a copy of the chunk whose location in the frame tree has
        been adjusted based on the given nesting and position. With the default arguments, the
        value of all the following expressions is the same:

        - `chunk.pack(nesting, position)`
        - `chunk.gift(nesting, position, True)`
        - `chunk.gift(nesting, position).pack()`

        The difference, however, is that the first two options require one less copy operation
        than the latter.
        &#34;&#34;&#34;
        scope = self.scope + nest
        fs = self._fill_scope
        fb = self._fill_batch
        if nest &gt; 0:
            view = list(self._view)
            path = list(self._path)
            if nest &gt; 0:
                if fs is not None:
                    view.extend(itertools.repeat(self.visible, nest - 1))
                    view.append(fs)
                    fs = None
                else:
                    view.extend(itertools.repeat(self.visible, nest))
                if fb is not None and nest &gt; 1:
                    path.append(position)
                    path.append(fb)
                    path.extend(itertools.repeat(0, nest - 2))
                else:
                    path.append(position)
                    path.extend(itertools.repeat(0, nest - 1))
        elif nest &lt; 0:
            view = self._view[:nest]
            path = self._path[:nest]
        else:
            view = self._view
            path = self._path
            if not serialize:
                view = list(view)
                path = list(path)

        assert len(path) == scope
        assert len(view) == scope

        meta = self._meta.serialize(self.scope + nest)

        if serialize:
            assert msgpack
            item = (path, view, meta, fs, self)
            item = msgpack.packb(item)
            assert isinstance(item, bytes)
            return item
        else:
            return Chunk(self, path, view, None, meta, fs, fb,
                ignore_chunk_properties=True)

    def __repr__(self) -&gt; str:
        layer = &#39;/&#39;.join(str(p) if s else F&#39;!{p}&#39; for p, s in zip(self._path, self._view))
        layer = layer and &#39;/&#39; + layer
        return F&#39;&lt;chunk{layer}:{bytes(self)!r}&gt;&#39;

    def intersect(self, other: Chunk):
        &#34;&#34;&#34;
        Removes all meta variables from this chunk whose value differs from those of the `other`
        inut chunk.
        &#34;&#34;&#34;
        other_meta = other._meta
        meta = self._meta
        for key, value in list(meta.items()):
            if other_meta.get(key) != value:
                meta.discard(key)
        return self

    def __str__(self):
        try:
            return self.decode(&#39;UTF8&#39;)
        except UnicodeDecodeError:
            return self.hex()

    def __hash__(self):
        return hash(zlib.adler32(self))

    @overload
    def __getitem__(self, k: str) -&gt; int | str | float | bytes | None:
        ...

    @overload
    def __getitem__(self, key: SupportsIndex, /) -&gt; int:
        ...

    @overload
    def __getitem__(self, key: slice, /) -&gt; bytearray:
        ...

    def __getitem__(self, k):
        if not isinstance(k, str):
            return bytearray.__getitem__(self, k)
        return self._meta.__getitem__(k)

    def __setitem__(self, bounds, value):
        if isinstance(bounds, str):
            self._meta[bounds] = value
        else:
            bytearray.__setitem__(self, bounds, value)

    def truncate(self, scope: int = 0):
        &#34;&#34;&#34;
        Truncate the `refinery.lib.frame.Chunk.path` and `refinery.lib.frame.Chunk.view` lists
        to the given length, setting the `refinery.lib.frame.Chunk.scope` to the given value.
        &#34;&#34;&#34;
        del self._path[scope:]
        del self._view[scope:]
        return self

    def copy(self, meta=True, data=True) -&gt; Chunk:
        &#34;&#34;&#34;
        Produce a copy of this chunk. The metadata is copied if the `meta` argument is `True`,
        otherwise the copy has no metadata. The body of the chunk is copied only if the `data`
        argument is `True`.
        &#34;&#34;&#34;
        data = data and self or None
        copy = Chunk(
            data,
            path=list(self._path),
            view=list(self._view),
            fill_scope=self._fill_scope,
            fill_batch=self._fill_batch,
            ignore_chunk_properties=True,
        )
        if meta:
            copy.meta.update(self.meta)
        if copy.meta.scope != copy.scope:
            raise RuntimeError
        return copy

    def __copy__(self):
        return self.copy()

    def __deepcopy__(self, memo):
        raise NotImplementedError


class FrameUnpacker(Iterable[Chunk]):
    &#34;&#34;&#34;
    Provides a unified interface to read both framed and raw input data from a stream. After
    loading a framed input stream, the object provides an iterator over the first **frame** in
    the bottom **layer** of the frame tree. Consider this doubly layered frame tree:

        [[FOO, BAR], [BOO, BAZ]]

    The `refinery.lib.frame.FrameUnpacker` object will first be an iterator over the first frame
    `[FOO, BAR]`. After consuming this iterator, the `refinery.lib.frame.FrameUnpacker.nextframe`
    method can be called to load the next frame, at which point the object will become an
    iterator over `[BOO, BAZ]`.
    &#34;&#34;&#34;
    next_chunk: Chunk | None
    depth: int
    trunk: tuple[int, ...]
    check: tuple[int, ...]
    stream: BinaryIO | None
    finished: bool
    framed: bool
    unpacker: Unpacker | None

    def __init__(self, stream: BinaryIO | None):
        self.finished = False
        self.trunk = ()
        self.check = ()
        self.stream = None
        self.depth = 0
        self.next_chunk = None
        buffer = stream and stream.read(len(MAGIC)) or None
        if buffer == MAGIC:
            self.depth, = stream.read(1)
            self.framed = True
            self.stream = stream
            self.unpacker = msgpack.Unpacker(max_buffer_size=0xFFFFFFFF, use_list=True)
            self._advance()
        else:
            self.unpacker = None
            self.framed = False
            self.depth = 0
            self.next_chunk = Chunk()
            while buffer:
                self.next_chunk.extend(buffer)
                buffer = stream.read()

    def _advance(self) -&gt; bool:
        while not self.finished:
            try:
                self.next_chunk = chunk = Chunk.unpack(self.unpacker)
                self.check = tuple(chunk.path)
                if chunk.scope != self.depth:
                    raise RuntimeError(F&#39;Frame of depth {self.depth} contained chunk of scope {chunk.scope}.&#39;)
                return True
            except StopIteration:
                pass
            try:
                recv = self.stream.read1()
            except TypeError:
                raise
            recv = recv or self.stream.read()
            if not recv:
                break
            self.unpacker.feed(recv)
        self.finished = True
        return False

    def nextframe(self) -&gt; bool:
        &#34;&#34;&#34;
        Once the iterator is consumed, calling this function will return `True` if
        and only if another frame with input data has been loaded, in which case
        the object will provide an iterator over the freshly loaded frame. If this
        function returns `False`, all input data has been consumed.
        &#34;&#34;&#34;
        if self.finished:
            return False
        self.trunk = self.check
        return True

    def abort(self):
        &#34;&#34;&#34;
        Abort unpacking chunks from the frame.
        &#34;&#34;&#34;
        if self.depth &gt; 1:
            while not self.finished and self.trunk == self.check:
                self._advance()
        else:
            self.unpacker = None
            self.finished = True

    @property
    def eol(self) -&gt; bool:
        &#34;&#34;&#34;
        Specifies whether the current frame was fully consumed.
        &#34;&#34;&#34;
        return self.trunk != self.peek

    @property
    def peek(self) -&gt; tuple[int, ...]:
        &#34;&#34;&#34;
        Contains the identifier of the next frame.
        &#34;&#34;&#34;
        return self.check

    def __iter__(self) -&gt; Generator[Chunk]:
        if self.finished:
            return
        if not self.framed:
            yield self.next_chunk
            self.finished = True
            return
        while not self.finished and self.trunk == self.check:
            yield self.next_chunk
            self._advance()


class Framed:
    &#34;&#34;&#34;
    A proxy interface to ingest and output framed data. It is given an `action` to be
    performed for each elementary chunk of data, a `stream` of input data, and an integer
    argument `nested` which specifies the relative amount of nesting to be performed
    by the interface. This parameter should either be `1` if the interface should output
    the results at an additional layer, `0` if the nesting depth of the data should
    remain unchanged, and a negative amount if frame layers are to be collapsed. After
    initialization, the `refinery.lib.frame.Framed` object is an iterator that yields
    bytestrings which can be forwarded as the output of the operation with all framing
    already taken care of.
    &#34;&#34;&#34;
    def __init__(
        self,
        action : Callable[[Chunk], Iterable[Chunk]],
        stream : BinaryIO | None,
        filter : Callable[[Iterable[Chunk]], Iterable[Chunk]],
        finish : Callable[[], Iterable[Chunk]],
        nesting: int = 0,
        squeeze: bool = False,
        serialized: bool = True,
        filter_all: bool = False,
    ):
        self.unpack = FrameUnpacker(stream)
        self.action = action
        self.filter = filter
        self.finish = finish
        self.serialized = serialized
        self.filter_all = filter_all
        self.nesting = nesting
        self.squeeze = squeeze

    def _apply_filter(self) -&gt; Iterable[Chunk]:

        def autoindex(it: Iterable[Chunk]):
            for k, chunk in enumerate(it):
                chunk.meta.index = k
                yield chunk

        chunks = iter(self.unpack)
        header = list(itertools.islice(chunks, 0, 2))
        if not header:
            return
        elif len(header) &gt; 1:
            chunks = itertools.chain(header, chunks)
            chunks = autoindex(chunks)
        else:
            header[0].meta.index = 0
            chunks = iter(header)
        if header[0].scopable or self.filter_all:
            chunks = self.filter(chunks)
        yield from chunks

        if not self.unpack.eol:  # filter did not consume the iterable
            self.unpack.abort()

        if self.unpack.finished and self.finish:
            yield from self.finish()

    @property
    def unframed(self) -&gt; bool:
        &#34;&#34;&#34;
        This property is true if the output data is not framed.
        &#34;&#34;&#34;
        return self.nesting + self.unpack.depth &lt; 1

    @property
    def framebreak(self) -&gt; bool:
        &#34;&#34;&#34;
        This property will be true if the data generated by this framing interface should
        be separated by linebreaks. This happens when one of the following is true:
        - The requested nesting was smaller than required to close all existing frames.
        - The input data was not framed and the nesting did not increase in this unit
        &#34;&#34;&#34;
        if not self.unpack.framed:
            return self.nesting &lt; 1
        return self.nesting + self.unpack.depth &lt; 0

    def _generate_chunks(self, parent: Chunk):
        path = list(parent.path)
        view = list(parent.view)
        meta = parent.meta
        scope = parent.scope

        def inherit(chunk: Chunk):
            if chunk is parent:
                return chunk
            if path:
                chunk._path[:] = path
            if view and not chunk._view:
                chunk._view[:] = view
            chunk._meta.inherit(meta)
            return chunk.truncate(scope)

        if not self.squeeze:
            for chunk in self.action(parent):
                yield inherit(chunk)
        else:
            it = self.action(parent)
            for header in it:
                buffer = MemoryFile(header)
                buffer.seek(len(header))
                break
            else:
                return
            for item in it:
                header.intersect(item)
                buffer.write(item)
            inherit(header)
            yield header

    def _generate_bytes(self, data: Chunk):
        if not self.squeeze:
            yield from self.action(data)
            return
        buffer = MemoryFile(bytearray())
        for item in self.action(data):
            buffer.write(item)
        yield buffer.getvalue()

    def __iter__(self):
        nesting = self.nesting
        serialized = self.serialized
        scope = max(self.unpack.depth + nesting, 0)
        if self.unpack.finished:
            if scope:
                yield generate_frame_header(scope)
            return
        if nesting &gt; 0:
            assert scope
            yield generate_frame_header(scope)
            while self.unpack.nextframe():
                for k, chunk in enumerate(self._apply_filter()):
                    if not chunk.visible:
                        yield chunk.pack(nesting, k, serialized)
                        continue
                    for result in self._generate_chunks(chunk):
                        yield result.pack(nesting, k, serialized)
        elif not self.unpack.framed:
            for chunk in self._apply_filter():
                yield from self._generate_bytes(chunk)
        elif nesting == 0:
            assert scope
            yield generate_frame_header(scope)
            while self.unpack.nextframe():
                for chunk in self._apply_filter():
                    if not chunk.visible:
                        yield chunk.pack(0, 0, serialized)
                        continue
                    for result in self._generate_chunks(chunk):
                        yield result.pack(0, 0, serialized)
        else:
            trunk = None
            check = scope + 1
            if scope:
                yield generate_frame_header(scope)
            while self.unpack.nextframe():
                for chunk in self._apply_filter():
                    results = self._generate_chunks(chunk) if chunk.visible else (chunk,)
                    if not scope:
                        for chunk in results:
                            yield chunk.truncate()
                        continue
                    for result in results:
                        if trunk is None:
                            trunk = result
                        elif result.path[:check] == trunk.path[:check]:
                            trunk.intersect(result)
                            trunk.extend(result)
                        else:
                            yield trunk.pack(nesting, 0, serialized)
                            trunk = result
                if not scope or trunk is None:
                    continue
            if trunk is not None:
                yield trunk.pack(nesting, 0, serialized)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="refinery.lib.frame.MAGIC"><code class="name">var <span class="ident">MAGIC</span></code></dt>
<dd>
<section class="desc"><p>This is the magic signature that is used by refinery to prefix serialized frame data. If a unit
reads data from STDIN that is prefixed with these bytes, it assumes that serialized frame data
follows. Otherwise, the input is treated as a single unframed chunk.</p></section>
</dd>
<dt id="refinery.lib.frame.MSIZE"><code class="name">var <span class="ident">MSIZE</span></code></dt>
<dd>
<section class="desc"><p>This is the length of the data returned by <code><a title="refinery.lib.frame.generate_frame_header" href="#refinery.lib.frame.generate_frame_header">generate_frame_header()</a></code>.</p></section>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.frame.generate_frame_header"><code class="name flex">
<span>def <span class="ident">generate_frame_header</span></span>(<span>scope)</span>
</code></dt>
<dd>
<section class="desc"><p>This function generates a frame header for a frame tree of depth equal to <code>scope</code>. The depth
is encoded as a single byte following <code><a title="refinery.lib.frame.MAGIC" href="#refinery.lib.frame.MAGIC">MAGIC</a></code>. This implies a depth limit
of 255 for frame trees in refinery, and I dearly hope that noone is insane enough to build a
refinery pipeline that would be affected.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L166-L175" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def generate_frame_header(scope: int):
    &#34;&#34;&#34;
    This function generates a frame header for a frame tree of depth equal to `scope`. The depth
    is encoded as a single byte following `refinery.lib.frame.MAGIC`. This implies a depth limit
    of 255 for frame trees in refinery, and I dearly hope that noone is insane enough to build a
    refinery pipeline that would be affected.
    &#34;&#34;&#34;
    if scope &gt; 0xFF:
        raise ValueError(&#39;Maximum frame depth exceeded.&#39;)
    return B&#39;%s%c&#39; % (MAGIC, scope)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.frame.Chunk"><code class="flex name class">
<span>class <span class="ident">Chunk</span></span>
<span>(</span><span>data=None, path=None, view=None, meta=None, seed=None, fill_scope=None, fill_batch=None, ignore_chunk_properties=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Represents the individual chunks in a frame. The <code><a title="refinery.units.Unit.filter" href="../units/index.html#refinery.units.UnitBase.filter">Unit.filter()</a></code> method receives
an iterable of <code><a title="refinery.lib.frame.Chunk" href="#refinery.lib.frame.Chunk">Chunk</a></code>s.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L178-L509" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Chunk(bytearray):
    &#34;&#34;&#34;
    Represents the individual chunks in a frame. The `refinery.units.Unit.filter` method receives
    an iterable of `refinery.lib.frame.Chunk`s.
    &#34;&#34;&#34;
    temp: Any
    &#34;&#34;&#34;
    Units can use this field to transport temporary data between different callbacks. For example,
    a unit might want to transport information from `refinery.units.Unit.filter` to:

    - `refinery.units.Unit.reverse`
    - `refinery.units.Unit.process`

    These methods, in turn, might want to transport information to `refinery.units.Unit.finish`.
    &#34;&#34;&#34;
    uuid: uuid.UUID
    &#34;&#34;&#34;
    Each chunk object carries a unique identifier. The `refinery.units.DelayedArgumentProxy` uses
    this property to check whether `refinery.units.Unit` command-line arguments were previously
    evaluated against this chunk. Otherwise `refinery.lib.argformats.DelayedArgument`s that alter
    the input data could produce unexpected results when the argument proxy is mapped against the
    same chunk twice.
    &#34;&#34;&#34;

    __slots__ = (
        &#39;_meta&#39;,
        &#39;_view&#39;,
        &#39;_path&#39;,
        &#39;_fill_scope&#39;,
        &#39;_fill_batch&#39;,
        &#39;temp&#39;,
        &#39;uuid&#39;,
    )

    def __init__(
        self,
        data: buf | None = None,
        path: list[int] | None = None,
        view: list[bool] | None = None,
        meta: dict[str, Any] | None = None,
        seed: dict[str, list] | None = None,
        fill_scope: bool | None = None,
        fill_batch: int | None = None,
        ignore_chunk_properties: bool = False,
    ):
        if data is None:
            bytearray.__init__(self)
        else:
            bytearray.__init__(self, data)

        self.uuid = uuid.uuid4()
        self.temp = None

        if path is None:
            path = []
        if view is None:
            view = [False] * len(path)
        elif len(view) != len(path):
            raise ValueError(&#39;view must have the same length as path&#39;)

        if not ignore_chunk_properties and isinstance(data, Chunk):
            path = path or list(data.path)
            view = view or list(data.view)
            meta = meta or data.meta
            fill_scope = fill_scope or data._fill_scope
            fill_batch = fill_batch or data._fill_batch

        self._view: list[bool] = view
        self._path: list[int] = path
        self._fill_scope: bool | None = fill_scope
        self._fill_batch: bool | None = fill_batch

        self._meta = m = LazyMetaOracle(self, scope=self.scope, seed=seed)
        if meta is not None:
            m.update(meta)

    @classmethod
    def Wrap(cls, data):
        if isinstance(data, cls):
            return data
        return cls(data)

    def set_next_scope(self, visible: bool) -&gt; None:
        self._fill_scope = visible

    def set_next_batch(self, batch: int) -&gt; None:
        &#34;&#34;&#34;
        This function allows units to emit trees of depth one rather than lists. When a unit emits
        a chunk at index `a`, sets the next batch to `b`, and when a double frame opens after this
        unit&#39;s invocation, then said chunk will have `a/b` added to its path. By default, `b` would
        always be `0`. For example, the `refinery.rex` unit uses this feature. As a result:

            $ emit #1yellow-#3red-#2orange | rex #(.)([a-z]+) {1} {2} [[| pop x:e ]| rep v:x ]]
            yellow
            red
            red
            red
            orange
            orange

        The double frame after `refinery.rex` looks like this:

            [[1,yellow],[2,red],[3,orange]]

        By default, the frame would simply look like this:

            [[1,yellow,2,red,3,orange]]

        This feature is useful for `refinery.units.Unit`s that produce multiple outputs for each of
        a number of intermediate results - in the case of `refinery.rex`, that intermediate result
        is a regular expression match, and `refinery.rex` allows to produce different outputs for
        each of those.
        &#34;&#34;&#34;
        self._fill_batch = batch

    @property
    def scope(self) -&gt; int:
        &#34;&#34;&#34;
        This value is the length of `refinery.lib.frame.Chunk.path` and therefore corresponds to
        the depth of the frame tree. It is called &#34;scope&#34; because it is equally the scope at which
        new metadata variables for this chunk will be created.
        &#34;&#34;&#34;
        return len(self._path)

    @property
    def view(self) -&gt; list[bool]:
        &#34;&#34;&#34;
        This tuple of boolean values indicates the visibility of this chunk at each layer of
        the frame tree. The `refinery.scope` unit can be used to change visibility of chunks
        within a frame.
        &#34;&#34;&#34;
        return self._view

    @property
    def path(self) -&gt; list[int]:
        &#34;&#34;&#34;
        The vertices in each frame tree layer are sequentially numbered by their order of
        appearance in the stream. The `refinery.lib.frame.Chunk.path` contains the numbers of
        the vertices (in each layer) which define the path from the root of the frame tree
        to the leaf vertex representing this `refinery.lib.frame.Chunk`
        &#34;&#34;&#34;
        return self._path

    @property
    def meta(self) -&gt; LazyMetaOracle:
        &#34;&#34;&#34;
        Every chunk can contain a dictionary of arbitrary metadata. Further details about this data
        are available in the module-level documetnation of `refinery.lib.meta`.
        &#34;&#34;&#34;
        if self._meta.chunk is not self:
            raise RuntimeError(&#39;meta dictionary carries invalid parent reference&#39;)
        return self._meta

    @property
    def visible(self):
        &#34;&#34;&#34;
        This property defines whether the chunk is currently visible. It defaults to true if the
        chunk is not part of a frame and is otherwise the same as the last element of the tuple
        `refinery.lib.frame.Chunk.view`. Setting this property will correspondingly alter the last
        entry of `refinery.lib.frame.Chunk.view`.
        Setting this property on an unframed `refinery.lib.frame.Chunk` raises an `AttributeError`.
        &#34;&#34;&#34;
        return not self._view or self._view[~0]

    @property
    def scopable(self):
        &#34;&#34;&#34;
        This property defines whether the chunk can be made visible in the current frame.
        &#34;&#34;&#34;
        return len(self._view) &lt;= 1 or self._view[~1]

    @visible.setter
    def visible(self, value: bool):
        view = self._view
        if not view:
            if not value:
                raise AttributeError(&#39;cannot make chunk invisible outside frame&#39;)
        else:
            view[~0] = value

    @classmethod
    def unpack(cls, stream):
        &#34;&#34;&#34;
        Classmethod to read a serialized chunk from an unpacker stream.
        &#34;&#34;&#34;
        item = next(stream)
        path, view, meta, fs, data = item
        return cls(data, path=path, view=view, seed=meta, fill_scope=fs)

    def pack(self, nest: int = 0, position: int = 0, serialize: bool = True):
        &#34;&#34;&#34;
        This function is equivalent to `refinery.lib.frame.Chunk.pack` if `serialize` is `True`.
        Otherwise, the function creates a copy of the chunk whose location in the frame tree has
        been adjusted based on the given nesting and position. With the default arguments, the
        value of all the following expressions is the same:

        - `chunk.pack(nesting, position)`
        - `chunk.gift(nesting, position, True)`
        - `chunk.gift(nesting, position).pack()`

        The difference, however, is that the first two options require one less copy operation
        than the latter.
        &#34;&#34;&#34;
        scope = self.scope + nest
        fs = self._fill_scope
        fb = self._fill_batch
        if nest &gt; 0:
            view = list(self._view)
            path = list(self._path)
            if nest &gt; 0:
                if fs is not None:
                    view.extend(itertools.repeat(self.visible, nest - 1))
                    view.append(fs)
                    fs = None
                else:
                    view.extend(itertools.repeat(self.visible, nest))
                if fb is not None and nest &gt; 1:
                    path.append(position)
                    path.append(fb)
                    path.extend(itertools.repeat(0, nest - 2))
                else:
                    path.append(position)
                    path.extend(itertools.repeat(0, nest - 1))
        elif nest &lt; 0:
            view = self._view[:nest]
            path = self._path[:nest]
        else:
            view = self._view
            path = self._path
            if not serialize:
                view = list(view)
                path = list(path)

        assert len(path) == scope
        assert len(view) == scope

        meta = self._meta.serialize(self.scope + nest)

        if serialize:
            assert msgpack
            item = (path, view, meta, fs, self)
            item = msgpack.packb(item)
            assert isinstance(item, bytes)
            return item
        else:
            return Chunk(self, path, view, None, meta, fs, fb,
                ignore_chunk_properties=True)

    def __repr__(self) -&gt; str:
        layer = &#39;/&#39;.join(str(p) if s else F&#39;!{p}&#39; for p, s in zip(self._path, self._view))
        layer = layer and &#39;/&#39; + layer
        return F&#39;&lt;chunk{layer}:{bytes(self)!r}&gt;&#39;

    def intersect(self, other: Chunk):
        &#34;&#34;&#34;
        Removes all meta variables from this chunk whose value differs from those of the `other`
        inut chunk.
        &#34;&#34;&#34;
        other_meta = other._meta
        meta = self._meta
        for key, value in list(meta.items()):
            if other_meta.get(key) != value:
                meta.discard(key)
        return self

    def __str__(self):
        try:
            return self.decode(&#39;UTF8&#39;)
        except UnicodeDecodeError:
            return self.hex()

    def __hash__(self):
        return hash(zlib.adler32(self))

    @overload
    def __getitem__(self, k: str) -&gt; int | str | float | bytes | None:
        ...

    @overload
    def __getitem__(self, key: SupportsIndex, /) -&gt; int:
        ...

    @overload
    def __getitem__(self, key: slice, /) -&gt; bytearray:
        ...

    def __getitem__(self, k):
        if not isinstance(k, str):
            return bytearray.__getitem__(self, k)
        return self._meta.__getitem__(k)

    def __setitem__(self, bounds, value):
        if isinstance(bounds, str):
            self._meta[bounds] = value
        else:
            bytearray.__setitem__(self, bounds, value)

    def truncate(self, scope: int = 0):
        &#34;&#34;&#34;
        Truncate the `refinery.lib.frame.Chunk.path` and `refinery.lib.frame.Chunk.view` lists
        to the given length, setting the `refinery.lib.frame.Chunk.scope` to the given value.
        &#34;&#34;&#34;
        del self._path[scope:]
        del self._view[scope:]
        return self

    def copy(self, meta=True, data=True) -&gt; Chunk:
        &#34;&#34;&#34;
        Produce a copy of this chunk. The metadata is copied if the `meta` argument is `True`,
        otherwise the copy has no metadata. The body of the chunk is copied only if the `data`
        argument is `True`.
        &#34;&#34;&#34;
        data = data and self or None
        copy = Chunk(
            data,
            path=list(self._path),
            view=list(self._view),
            fill_scope=self._fill_scope,
            fill_batch=self._fill_batch,
            ignore_chunk_properties=True,
        )
        if meta:
            copy.meta.update(self.meta)
        if copy.meta.scope != copy.scope:
            raise RuntimeError
        return copy

    def __copy__(self):
        return self.copy()

    def __deepcopy__(self, memo):
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.bytearray</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.frame.Chunk.Wrap"><code class="name flex">
<span>def <span class="ident">Wrap</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.frame.Chunk.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>stream)</span>
</code></dt>
<dd>
<section class="desc"><p>Classmethod to read a serialized chunk from an unpacker stream.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.frame.Chunk.scope"><code class="name">var <span class="ident">scope</span></code></dt>
<dd>
<section class="desc"><p>This value is the length of <code><a title="refinery.lib.frame.Chunk.path" href="#refinery.lib.frame.Chunk.path">Chunk.path</a></code> and therefore corresponds to
the depth of the frame tree. It is called "scope" because it is equally the scope at which
new metadata variables for this chunk will be created.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L293-L300" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def scope(self) -&gt; int:
    &#34;&#34;&#34;
    This value is the length of `refinery.lib.frame.Chunk.path` and therefore corresponds to
    the depth of the frame tree. It is called &#34;scope&#34; because it is equally the scope at which
    new metadata variables for this chunk will be created.
    &#34;&#34;&#34;
    return len(self._path)</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.view"><code class="name">var <span class="ident">view</span></code></dt>
<dd>
<section class="desc"><p>This tuple of boolean values indicates the visibility of this chunk at each layer of
the frame tree. The <code><a title="refinery.scope" href="../index.html#refinery.scope">scope</a></code> unit can be used to change visibility of chunks
within a frame.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L302-L309" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def view(self) -&gt; list[bool]:
    &#34;&#34;&#34;
    This tuple of boolean values indicates the visibility of this chunk at each layer of
    the frame tree. The `refinery.scope` unit can be used to change visibility of chunks
    within a frame.
    &#34;&#34;&#34;
    return self._view</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<section class="desc"><p>The vertices in each frame tree layer are sequentially numbered by their order of
appearance in the stream. The <code><a title="refinery.lib.frame.Chunk.path" href="#refinery.lib.frame.Chunk.path">Chunk.path</a></code> contains the numbers of
the vertices (in each layer) which define the path from the root of the frame tree
to the leaf vertex representing this <code><a title="refinery.lib.frame.Chunk" href="#refinery.lib.frame.Chunk">Chunk</a></code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L311-L319" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def path(self) -&gt; list[int]:
    &#34;&#34;&#34;
    The vertices in each frame tree layer are sequentially numbered by their order of
    appearance in the stream. The `refinery.lib.frame.Chunk.path` contains the numbers of
    the vertices (in each layer) which define the path from the root of the frame tree
    to the leaf vertex representing this `refinery.lib.frame.Chunk`
    &#34;&#34;&#34;
    return self._path</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.meta"><code class="name">var <span class="ident">meta</span></code></dt>
<dd>
<section class="desc"><p>Every chunk can contain a dictionary of arbitrary metadata. Further details about this data
are available in the module-level documetnation of <code><a title="refinery.lib.meta" href="meta.html">refinery.lib.meta</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L321-L329" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def meta(self) -&gt; LazyMetaOracle:
    &#34;&#34;&#34;
    Every chunk can contain a dictionary of arbitrary metadata. Further details about this data
    are available in the module-level documetnation of `refinery.lib.meta`.
    &#34;&#34;&#34;
    if self._meta.chunk is not self:
        raise RuntimeError(&#39;meta dictionary carries invalid parent reference&#39;)
    return self._meta</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.visible"><code class="name">var <span class="ident">visible</span></code></dt>
<dd>
<section class="desc"><p>This property defines whether the chunk is currently visible. It defaults to true if the
chunk is not part of a frame and is otherwise the same as the last element of the tuple
<code><a title="refinery.lib.frame.Chunk.view" href="#refinery.lib.frame.Chunk.view">Chunk.view</a></code>. Setting this property will correspondingly alter the last
entry of <code><a title="refinery.lib.frame.Chunk.view" href="#refinery.lib.frame.Chunk.view">Chunk.view</a></code>.
Setting this property on an unframed <code><a title="refinery.lib.frame.Chunk" href="#refinery.lib.frame.Chunk">Chunk</a></code> raises an <code>AttributeError</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L331-L340" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def visible(self):
    &#34;&#34;&#34;
    This property defines whether the chunk is currently visible. It defaults to true if the
    chunk is not part of a frame and is otherwise the same as the last element of the tuple
    `refinery.lib.frame.Chunk.view`. Setting this property will correspondingly alter the last
    entry of `refinery.lib.frame.Chunk.view`.
    Setting this property on an unframed `refinery.lib.frame.Chunk` raises an `AttributeError`.
    &#34;&#34;&#34;
    return not self._view or self._view[~0]</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.scopable"><code class="name">var <span class="ident">scopable</span></code></dt>
<dd>
<section class="desc"><p>This property defines whether the chunk can be made visible in the current frame.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L342-L347" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def scopable(self):
    &#34;&#34;&#34;
    This property defines whether the chunk can be made visible in the current frame.
    &#34;&#34;&#34;
    return len(self._view) &lt;= 1 or self._view[~1]</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.temp"><code class="name">var <span class="ident">temp</span></code></dt>
<dd>
<section class="desc"><p>Units can use this field to transport temporary data between different callbacks. For example,
a unit might want to transport information from <code><a title="refinery.units.Unit.filter" href="../units/index.html#refinery.units.UnitBase.filter">Unit.filter()</a></code> to:</p>
<ul>
<li><code><a title="refinery.units.Unit.reverse" href="../units/index.html#refinery.units.UnitBase.reverse">UnitBase.reverse()</a></code></li>
<li><code><a title="refinery.units.Unit.process" href="../units/index.html#refinery.units.UnitBase.process">Unit.process()</a></code></li>
</ul>
<p>These methods, in turn, might want to transport information to <code><a title="refinery.units.Unit.finish" href="../units/index.html#refinery.units.UnitBase.finish">Unit.finish()</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L178-L509" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Chunk(bytearray):
    &#34;&#34;&#34;
    Represents the individual chunks in a frame. The `refinery.units.Unit.filter` method receives
    an iterable of `refinery.lib.frame.Chunk`s.
    &#34;&#34;&#34;
    temp: Any
    &#34;&#34;&#34;
    Units can use this field to transport temporary data between different callbacks. For example,
    a unit might want to transport information from `refinery.units.Unit.filter` to:

    - `refinery.units.Unit.reverse`
    - `refinery.units.Unit.process`

    These methods, in turn, might want to transport information to `refinery.units.Unit.finish`.
    &#34;&#34;&#34;
    uuid: uuid.UUID
    &#34;&#34;&#34;
    Each chunk object carries a unique identifier. The `refinery.units.DelayedArgumentProxy` uses
    this property to check whether `refinery.units.Unit` command-line arguments were previously
    evaluated against this chunk. Otherwise `refinery.lib.argformats.DelayedArgument`s that alter
    the input data could produce unexpected results when the argument proxy is mapped against the
    same chunk twice.
    &#34;&#34;&#34;

    __slots__ = (
        &#39;_meta&#39;,
        &#39;_view&#39;,
        &#39;_path&#39;,
        &#39;_fill_scope&#39;,
        &#39;_fill_batch&#39;,
        &#39;temp&#39;,
        &#39;uuid&#39;,
    )

    def __init__(
        self,
        data: buf | None = None,
        path: list[int] | None = None,
        view: list[bool] | None = None,
        meta: dict[str, Any] | None = None,
        seed: dict[str, list] | None = None,
        fill_scope: bool | None = None,
        fill_batch: int | None = None,
        ignore_chunk_properties: bool = False,
    ):
        if data is None:
            bytearray.__init__(self)
        else:
            bytearray.__init__(self, data)

        self.uuid = uuid.uuid4()
        self.temp = None

        if path is None:
            path = []
        if view is None:
            view = [False] * len(path)
        elif len(view) != len(path):
            raise ValueError(&#39;view must have the same length as path&#39;)

        if not ignore_chunk_properties and isinstance(data, Chunk):
            path = path or list(data.path)
            view = view or list(data.view)
            meta = meta or data.meta
            fill_scope = fill_scope or data._fill_scope
            fill_batch = fill_batch or data._fill_batch

        self._view: list[bool] = view
        self._path: list[int] = path
        self._fill_scope: bool | None = fill_scope
        self._fill_batch: bool | None = fill_batch

        self._meta = m = LazyMetaOracle(self, scope=self.scope, seed=seed)
        if meta is not None:
            m.update(meta)

    @classmethod
    def Wrap(cls, data):
        if isinstance(data, cls):
            return data
        return cls(data)

    def set_next_scope(self, visible: bool) -&gt; None:
        self._fill_scope = visible

    def set_next_batch(self, batch: int) -&gt; None:
        &#34;&#34;&#34;
        This function allows units to emit trees of depth one rather than lists. When a unit emits
        a chunk at index `a`, sets the next batch to `b`, and when a double frame opens after this
        unit&#39;s invocation, then said chunk will have `a/b` added to its path. By default, `b` would
        always be `0`. For example, the `refinery.rex` unit uses this feature. As a result:

            $ emit #1yellow-#3red-#2orange | rex #(.)([a-z]+) {1} {2} [[| pop x:e ]| rep v:x ]]
            yellow
            red
            red
            red
            orange
            orange

        The double frame after `refinery.rex` looks like this:

            [[1,yellow],[2,red],[3,orange]]

        By default, the frame would simply look like this:

            [[1,yellow,2,red,3,orange]]

        This feature is useful for `refinery.units.Unit`s that produce multiple outputs for each of
        a number of intermediate results - in the case of `refinery.rex`, that intermediate result
        is a regular expression match, and `refinery.rex` allows to produce different outputs for
        each of those.
        &#34;&#34;&#34;
        self._fill_batch = batch

    @property
    def scope(self) -&gt; int:
        &#34;&#34;&#34;
        This value is the length of `refinery.lib.frame.Chunk.path` and therefore corresponds to
        the depth of the frame tree. It is called &#34;scope&#34; because it is equally the scope at which
        new metadata variables for this chunk will be created.
        &#34;&#34;&#34;
        return len(self._path)

    @property
    def view(self) -&gt; list[bool]:
        &#34;&#34;&#34;
        This tuple of boolean values indicates the visibility of this chunk at each layer of
        the frame tree. The `refinery.scope` unit can be used to change visibility of chunks
        within a frame.
        &#34;&#34;&#34;
        return self._view

    @property
    def path(self) -&gt; list[int]:
        &#34;&#34;&#34;
        The vertices in each frame tree layer are sequentially numbered by their order of
        appearance in the stream. The `refinery.lib.frame.Chunk.path` contains the numbers of
        the vertices (in each layer) which define the path from the root of the frame tree
        to the leaf vertex representing this `refinery.lib.frame.Chunk`
        &#34;&#34;&#34;
        return self._path

    @property
    def meta(self) -&gt; LazyMetaOracle:
        &#34;&#34;&#34;
        Every chunk can contain a dictionary of arbitrary metadata. Further details about this data
        are available in the module-level documetnation of `refinery.lib.meta`.
        &#34;&#34;&#34;
        if self._meta.chunk is not self:
            raise RuntimeError(&#39;meta dictionary carries invalid parent reference&#39;)
        return self._meta

    @property
    def visible(self):
        &#34;&#34;&#34;
        This property defines whether the chunk is currently visible. It defaults to true if the
        chunk is not part of a frame and is otherwise the same as the last element of the tuple
        `refinery.lib.frame.Chunk.view`. Setting this property will correspondingly alter the last
        entry of `refinery.lib.frame.Chunk.view`.
        Setting this property on an unframed `refinery.lib.frame.Chunk` raises an `AttributeError`.
        &#34;&#34;&#34;
        return not self._view or self._view[~0]

    @property
    def scopable(self):
        &#34;&#34;&#34;
        This property defines whether the chunk can be made visible in the current frame.
        &#34;&#34;&#34;
        return len(self._view) &lt;= 1 or self._view[~1]

    @visible.setter
    def visible(self, value: bool):
        view = self._view
        if not view:
            if not value:
                raise AttributeError(&#39;cannot make chunk invisible outside frame&#39;)
        else:
            view[~0] = value

    @classmethod
    def unpack(cls, stream):
        &#34;&#34;&#34;
        Classmethod to read a serialized chunk from an unpacker stream.
        &#34;&#34;&#34;
        item = next(stream)
        path, view, meta, fs, data = item
        return cls(data, path=path, view=view, seed=meta, fill_scope=fs)

    def pack(self, nest: int = 0, position: int = 0, serialize: bool = True):
        &#34;&#34;&#34;
        This function is equivalent to `refinery.lib.frame.Chunk.pack` if `serialize` is `True`.
        Otherwise, the function creates a copy of the chunk whose location in the frame tree has
        been adjusted based on the given nesting and position. With the default arguments, the
        value of all the following expressions is the same:

        - `chunk.pack(nesting, position)`
        - `chunk.gift(nesting, position, True)`
        - `chunk.gift(nesting, position).pack()`

        The difference, however, is that the first two options require one less copy operation
        than the latter.
        &#34;&#34;&#34;
        scope = self.scope + nest
        fs = self._fill_scope
        fb = self._fill_batch
        if nest &gt; 0:
            view = list(self._view)
            path = list(self._path)
            if nest &gt; 0:
                if fs is not None:
                    view.extend(itertools.repeat(self.visible, nest - 1))
                    view.append(fs)
                    fs = None
                else:
                    view.extend(itertools.repeat(self.visible, nest))
                if fb is not None and nest &gt; 1:
                    path.append(position)
                    path.append(fb)
                    path.extend(itertools.repeat(0, nest - 2))
                else:
                    path.append(position)
                    path.extend(itertools.repeat(0, nest - 1))
        elif nest &lt; 0:
            view = self._view[:nest]
            path = self._path[:nest]
        else:
            view = self._view
            path = self._path
            if not serialize:
                view = list(view)
                path = list(path)

        assert len(path) == scope
        assert len(view) == scope

        meta = self._meta.serialize(self.scope + nest)

        if serialize:
            assert msgpack
            item = (path, view, meta, fs, self)
            item = msgpack.packb(item)
            assert isinstance(item, bytes)
            return item
        else:
            return Chunk(self, path, view, None, meta, fs, fb,
                ignore_chunk_properties=True)

    def __repr__(self) -&gt; str:
        layer = &#39;/&#39;.join(str(p) if s else F&#39;!{p}&#39; for p, s in zip(self._path, self._view))
        layer = layer and &#39;/&#39; + layer
        return F&#39;&lt;chunk{layer}:{bytes(self)!r}&gt;&#39;

    def intersect(self, other: Chunk):
        &#34;&#34;&#34;
        Removes all meta variables from this chunk whose value differs from those of the `other`
        inut chunk.
        &#34;&#34;&#34;
        other_meta = other._meta
        meta = self._meta
        for key, value in list(meta.items()):
            if other_meta.get(key) != value:
                meta.discard(key)
        return self

    def __str__(self):
        try:
            return self.decode(&#39;UTF8&#39;)
        except UnicodeDecodeError:
            return self.hex()

    def __hash__(self):
        return hash(zlib.adler32(self))

    @overload
    def __getitem__(self, k: str) -&gt; int | str | float | bytes | None:
        ...

    @overload
    def __getitem__(self, key: SupportsIndex, /) -&gt; int:
        ...

    @overload
    def __getitem__(self, key: slice, /) -&gt; bytearray:
        ...

    def __getitem__(self, k):
        if not isinstance(k, str):
            return bytearray.__getitem__(self, k)
        return self._meta.__getitem__(k)

    def __setitem__(self, bounds, value):
        if isinstance(bounds, str):
            self._meta[bounds] = value
        else:
            bytearray.__setitem__(self, bounds, value)

    def truncate(self, scope: int = 0):
        &#34;&#34;&#34;
        Truncate the `refinery.lib.frame.Chunk.path` and `refinery.lib.frame.Chunk.view` lists
        to the given length, setting the `refinery.lib.frame.Chunk.scope` to the given value.
        &#34;&#34;&#34;
        del self._path[scope:]
        del self._view[scope:]
        return self

    def copy(self, meta=True, data=True) -&gt; Chunk:
        &#34;&#34;&#34;
        Produce a copy of this chunk. The metadata is copied if the `meta` argument is `True`,
        otherwise the copy has no metadata. The body of the chunk is copied only if the `data`
        argument is `True`.
        &#34;&#34;&#34;
        data = data and self or None
        copy = Chunk(
            data,
            path=list(self._path),
            view=list(self._view),
            fill_scope=self._fill_scope,
            fill_batch=self._fill_batch,
            ignore_chunk_properties=True,
        )
        if meta:
            copy.meta.update(self.meta)
        if copy.meta.scope != copy.scope:
            raise RuntimeError
        return copy

    def __copy__(self):
        return self.copy()

    def __deepcopy__(self, memo):
        raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.uuid"><code class="name">var <span class="ident">uuid</span></code></dt>
<dd>
<section class="desc"><p>Each chunk object carries a unique identifier. The <code><a title="refinery.units.DelayedArgumentProxy" href="../units/index.html#refinery.units.DelayedArgumentProxy">DelayedArgumentProxy</a></code> uses
this property to check whether <code><a title="refinery.units.Unit" href="../units/index.html#refinery.units.Unit">Unit</a></code> command-line arguments were previously
evaluated against this chunk. Otherwise <code><a title="refinery.lib.argformats.DelayedArgument" href="argformats.html#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></code>s that alter
the input data could produce unexpected results when the argument proxy is mapped against the
same chunk twice.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L178-L509" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Chunk(bytearray):
    &#34;&#34;&#34;
    Represents the individual chunks in a frame. The `refinery.units.Unit.filter` method receives
    an iterable of `refinery.lib.frame.Chunk`s.
    &#34;&#34;&#34;
    temp: Any
    &#34;&#34;&#34;
    Units can use this field to transport temporary data between different callbacks. For example,
    a unit might want to transport information from `refinery.units.Unit.filter` to:

    - `refinery.units.Unit.reverse`
    - `refinery.units.Unit.process`

    These methods, in turn, might want to transport information to `refinery.units.Unit.finish`.
    &#34;&#34;&#34;
    uuid: uuid.UUID
    &#34;&#34;&#34;
    Each chunk object carries a unique identifier. The `refinery.units.DelayedArgumentProxy` uses
    this property to check whether `refinery.units.Unit` command-line arguments were previously
    evaluated against this chunk. Otherwise `refinery.lib.argformats.DelayedArgument`s that alter
    the input data could produce unexpected results when the argument proxy is mapped against the
    same chunk twice.
    &#34;&#34;&#34;

    __slots__ = (
        &#39;_meta&#39;,
        &#39;_view&#39;,
        &#39;_path&#39;,
        &#39;_fill_scope&#39;,
        &#39;_fill_batch&#39;,
        &#39;temp&#39;,
        &#39;uuid&#39;,
    )

    def __init__(
        self,
        data: buf | None = None,
        path: list[int] | None = None,
        view: list[bool] | None = None,
        meta: dict[str, Any] | None = None,
        seed: dict[str, list] | None = None,
        fill_scope: bool | None = None,
        fill_batch: int | None = None,
        ignore_chunk_properties: bool = False,
    ):
        if data is None:
            bytearray.__init__(self)
        else:
            bytearray.__init__(self, data)

        self.uuid = uuid.uuid4()
        self.temp = None

        if path is None:
            path = []
        if view is None:
            view = [False] * len(path)
        elif len(view) != len(path):
            raise ValueError(&#39;view must have the same length as path&#39;)

        if not ignore_chunk_properties and isinstance(data, Chunk):
            path = path or list(data.path)
            view = view or list(data.view)
            meta = meta or data.meta
            fill_scope = fill_scope or data._fill_scope
            fill_batch = fill_batch or data._fill_batch

        self._view: list[bool] = view
        self._path: list[int] = path
        self._fill_scope: bool | None = fill_scope
        self._fill_batch: bool | None = fill_batch

        self._meta = m = LazyMetaOracle(self, scope=self.scope, seed=seed)
        if meta is not None:
            m.update(meta)

    @classmethod
    def Wrap(cls, data):
        if isinstance(data, cls):
            return data
        return cls(data)

    def set_next_scope(self, visible: bool) -&gt; None:
        self._fill_scope = visible

    def set_next_batch(self, batch: int) -&gt; None:
        &#34;&#34;&#34;
        This function allows units to emit trees of depth one rather than lists. When a unit emits
        a chunk at index `a`, sets the next batch to `b`, and when a double frame opens after this
        unit&#39;s invocation, then said chunk will have `a/b` added to its path. By default, `b` would
        always be `0`. For example, the `refinery.rex` unit uses this feature. As a result:

            $ emit #1yellow-#3red-#2orange | rex #(.)([a-z]+) {1} {2} [[| pop x:e ]| rep v:x ]]
            yellow
            red
            red
            red
            orange
            orange

        The double frame after `refinery.rex` looks like this:

            [[1,yellow],[2,red],[3,orange]]

        By default, the frame would simply look like this:

            [[1,yellow,2,red,3,orange]]

        This feature is useful for `refinery.units.Unit`s that produce multiple outputs for each of
        a number of intermediate results - in the case of `refinery.rex`, that intermediate result
        is a regular expression match, and `refinery.rex` allows to produce different outputs for
        each of those.
        &#34;&#34;&#34;
        self._fill_batch = batch

    @property
    def scope(self) -&gt; int:
        &#34;&#34;&#34;
        This value is the length of `refinery.lib.frame.Chunk.path` and therefore corresponds to
        the depth of the frame tree. It is called &#34;scope&#34; because it is equally the scope at which
        new metadata variables for this chunk will be created.
        &#34;&#34;&#34;
        return len(self._path)

    @property
    def view(self) -&gt; list[bool]:
        &#34;&#34;&#34;
        This tuple of boolean values indicates the visibility of this chunk at each layer of
        the frame tree. The `refinery.scope` unit can be used to change visibility of chunks
        within a frame.
        &#34;&#34;&#34;
        return self._view

    @property
    def path(self) -&gt; list[int]:
        &#34;&#34;&#34;
        The vertices in each frame tree layer are sequentially numbered by their order of
        appearance in the stream. The `refinery.lib.frame.Chunk.path` contains the numbers of
        the vertices (in each layer) which define the path from the root of the frame tree
        to the leaf vertex representing this `refinery.lib.frame.Chunk`
        &#34;&#34;&#34;
        return self._path

    @property
    def meta(self) -&gt; LazyMetaOracle:
        &#34;&#34;&#34;
        Every chunk can contain a dictionary of arbitrary metadata. Further details about this data
        are available in the module-level documetnation of `refinery.lib.meta`.
        &#34;&#34;&#34;
        if self._meta.chunk is not self:
            raise RuntimeError(&#39;meta dictionary carries invalid parent reference&#39;)
        return self._meta

    @property
    def visible(self):
        &#34;&#34;&#34;
        This property defines whether the chunk is currently visible. It defaults to true if the
        chunk is not part of a frame and is otherwise the same as the last element of the tuple
        `refinery.lib.frame.Chunk.view`. Setting this property will correspondingly alter the last
        entry of `refinery.lib.frame.Chunk.view`.
        Setting this property on an unframed `refinery.lib.frame.Chunk` raises an `AttributeError`.
        &#34;&#34;&#34;
        return not self._view or self._view[~0]

    @property
    def scopable(self):
        &#34;&#34;&#34;
        This property defines whether the chunk can be made visible in the current frame.
        &#34;&#34;&#34;
        return len(self._view) &lt;= 1 or self._view[~1]

    @visible.setter
    def visible(self, value: bool):
        view = self._view
        if not view:
            if not value:
                raise AttributeError(&#39;cannot make chunk invisible outside frame&#39;)
        else:
            view[~0] = value

    @classmethod
    def unpack(cls, stream):
        &#34;&#34;&#34;
        Classmethod to read a serialized chunk from an unpacker stream.
        &#34;&#34;&#34;
        item = next(stream)
        path, view, meta, fs, data = item
        return cls(data, path=path, view=view, seed=meta, fill_scope=fs)

    def pack(self, nest: int = 0, position: int = 0, serialize: bool = True):
        &#34;&#34;&#34;
        This function is equivalent to `refinery.lib.frame.Chunk.pack` if `serialize` is `True`.
        Otherwise, the function creates a copy of the chunk whose location in the frame tree has
        been adjusted based on the given nesting and position. With the default arguments, the
        value of all the following expressions is the same:

        - `chunk.pack(nesting, position)`
        - `chunk.gift(nesting, position, True)`
        - `chunk.gift(nesting, position).pack()`

        The difference, however, is that the first two options require one less copy operation
        than the latter.
        &#34;&#34;&#34;
        scope = self.scope + nest
        fs = self._fill_scope
        fb = self._fill_batch
        if nest &gt; 0:
            view = list(self._view)
            path = list(self._path)
            if nest &gt; 0:
                if fs is not None:
                    view.extend(itertools.repeat(self.visible, nest - 1))
                    view.append(fs)
                    fs = None
                else:
                    view.extend(itertools.repeat(self.visible, nest))
                if fb is not None and nest &gt; 1:
                    path.append(position)
                    path.append(fb)
                    path.extend(itertools.repeat(0, nest - 2))
                else:
                    path.append(position)
                    path.extend(itertools.repeat(0, nest - 1))
        elif nest &lt; 0:
            view = self._view[:nest]
            path = self._path[:nest]
        else:
            view = self._view
            path = self._path
            if not serialize:
                view = list(view)
                path = list(path)

        assert len(path) == scope
        assert len(view) == scope

        meta = self._meta.serialize(self.scope + nest)

        if serialize:
            assert msgpack
            item = (path, view, meta, fs, self)
            item = msgpack.packb(item)
            assert isinstance(item, bytes)
            return item
        else:
            return Chunk(self, path, view, None, meta, fs, fb,
                ignore_chunk_properties=True)

    def __repr__(self) -&gt; str:
        layer = &#39;/&#39;.join(str(p) if s else F&#39;!{p}&#39; for p, s in zip(self._path, self._view))
        layer = layer and &#39;/&#39; + layer
        return F&#39;&lt;chunk{layer}:{bytes(self)!r}&gt;&#39;

    def intersect(self, other: Chunk):
        &#34;&#34;&#34;
        Removes all meta variables from this chunk whose value differs from those of the `other`
        inut chunk.
        &#34;&#34;&#34;
        other_meta = other._meta
        meta = self._meta
        for key, value in list(meta.items()):
            if other_meta.get(key) != value:
                meta.discard(key)
        return self

    def __str__(self):
        try:
            return self.decode(&#39;UTF8&#39;)
        except UnicodeDecodeError:
            return self.hex()

    def __hash__(self):
        return hash(zlib.adler32(self))

    @overload
    def __getitem__(self, k: str) -&gt; int | str | float | bytes | None:
        ...

    @overload
    def __getitem__(self, key: SupportsIndex, /) -&gt; int:
        ...

    @overload
    def __getitem__(self, key: slice, /) -&gt; bytearray:
        ...

    def __getitem__(self, k):
        if not isinstance(k, str):
            return bytearray.__getitem__(self, k)
        return self._meta.__getitem__(k)

    def __setitem__(self, bounds, value):
        if isinstance(bounds, str):
            self._meta[bounds] = value
        else:
            bytearray.__setitem__(self, bounds, value)

    def truncate(self, scope: int = 0):
        &#34;&#34;&#34;
        Truncate the `refinery.lib.frame.Chunk.path` and `refinery.lib.frame.Chunk.view` lists
        to the given length, setting the `refinery.lib.frame.Chunk.scope` to the given value.
        &#34;&#34;&#34;
        del self._path[scope:]
        del self._view[scope:]
        return self

    def copy(self, meta=True, data=True) -&gt; Chunk:
        &#34;&#34;&#34;
        Produce a copy of this chunk. The metadata is copied if the `meta` argument is `True`,
        otherwise the copy has no metadata. The body of the chunk is copied only if the `data`
        argument is `True`.
        &#34;&#34;&#34;
        data = data and self or None
        copy = Chunk(
            data,
            path=list(self._path),
            view=list(self._view),
            fill_scope=self._fill_scope,
            fill_batch=self._fill_batch,
            ignore_chunk_properties=True,
        )
        if meta:
            copy.meta.update(self.meta)
        if copy.meta.scope != copy.scope:
            raise RuntimeError
        return copy

    def __copy__(self):
        return self.copy()

    def __deepcopy__(self, memo):
        raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.frame.Chunk.set_next_scope"><code class="name flex">
<span>def <span class="ident">set_next_scope</span></span>(<span>self, visible)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L260-L261" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_next_scope(self, visible: bool) -&gt; None:
    self._fill_scope = visible</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.set_next_batch"><code class="name flex">
<span>def <span class="ident">set_next_batch</span></span>(<span>self, batch)</span>
</code></dt>
<dd>
<section class="desc"><p>This function allows units to emit trees of depth one rather than lists. When a unit emits
a chunk at index <code>a</code>, sets the next batch to <code>b</code>, and when a double frame opens after this
unit's invocation, then said chunk will have <code>a/b</code> added to its path. By default, <code>b</code> would
always be <code>0</code>. For example, the <code><a title="refinery.rex" href="../index.html#refinery.rex">rex</a></code> unit uses this feature. As a result:</p>
<pre><code>$ emit #1yellow-#3red-#2orange | rex #(.)([a-z]+) {1} {2} [[| pop x:e ]| rep v:x ]]
yellow
red
red
red
orange
orange
</code></pre>
<p>The double frame after <code><a title="refinery.rex" href="../index.html#refinery.rex">rex</a></code> looks like this:</p>
<pre><code>[[1,yellow],[2,red],[3,orange]]
</code></pre>
<p>By default, the frame would simply look like this:</p>
<pre><code>[[1,yellow,2,red,3,orange]]
</code></pre>
<p>This feature is useful for <code><a title="refinery.units.Unit" href="../units/index.html#refinery.units.Unit">Unit</a></code>s that produce multiple outputs for each of
a number of intermediate results - in the case of <code><a title="refinery.rex" href="../index.html#refinery.rex">rex</a></code>, that intermediate result
is a regular expression match, and <code><a title="refinery.rex" href="../index.html#refinery.rex">rex</a></code> allows to produce different outputs for
each of those.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L263-L291" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_next_batch(self, batch: int) -&gt; None:
    &#34;&#34;&#34;
    This function allows units to emit trees of depth one rather than lists. When a unit emits
    a chunk at index `a`, sets the next batch to `b`, and when a double frame opens after this
    unit&#39;s invocation, then said chunk will have `a/b` added to its path. By default, `b` would
    always be `0`. For example, the `refinery.rex` unit uses this feature. As a result:

        $ emit #1yellow-#3red-#2orange | rex #(.)([a-z]+) {1} {2} [[| pop x:e ]| rep v:x ]]
        yellow
        red
        red
        red
        orange
        orange

    The double frame after `refinery.rex` looks like this:

        [[1,yellow],[2,red],[3,orange]]

    By default, the frame would simply look like this:

        [[1,yellow,2,red,3,orange]]

    This feature is useful for `refinery.units.Unit`s that produce multiple outputs for each of
    a number of intermediate results - in the case of `refinery.rex`, that intermediate result
    is a regular expression match, and `refinery.rex` allows to produce different outputs for
    each of those.
    &#34;&#34;&#34;
    self._fill_batch = batch</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.pack"><code class="name flex">
<span>def <span class="ident">pack</span></span>(<span>self, nest=0, position=0, serialize=True)</span>
</code></dt>
<dd>
<section class="desc"><p>This function is equivalent to <code><a title="refinery.lib.frame.Chunk.pack" href="#refinery.lib.frame.Chunk.pack">Chunk.pack()</a></code> if <code>serialize</code> is <code>True</code>.
Otherwise, the function creates a copy of the chunk whose location in the frame tree has
been adjusted based on the given nesting and position. With the default arguments, the
value of all the following expressions is the same:</p>
<ul>
<li><code>chunk.pack(nesting, position)</code></li>
<li><code>chunk.gift(nesting, position, True)</code></li>
<li><code>chunk.gift(nesting, position).pack()</code></li>
</ul>
<p>The difference, however, is that the first two options require one less copy operation
than the latter.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L367-L424" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pack(self, nest: int = 0, position: int = 0, serialize: bool = True):
    &#34;&#34;&#34;
    This function is equivalent to `refinery.lib.frame.Chunk.pack` if `serialize` is `True`.
    Otherwise, the function creates a copy of the chunk whose location in the frame tree has
    been adjusted based on the given nesting and position. With the default arguments, the
    value of all the following expressions is the same:

    - `chunk.pack(nesting, position)`
    - `chunk.gift(nesting, position, True)`
    - `chunk.gift(nesting, position).pack()`

    The difference, however, is that the first two options require one less copy operation
    than the latter.
    &#34;&#34;&#34;
    scope = self.scope + nest
    fs = self._fill_scope
    fb = self._fill_batch
    if nest &gt; 0:
        view = list(self._view)
        path = list(self._path)
        if nest &gt; 0:
            if fs is not None:
                view.extend(itertools.repeat(self.visible, nest - 1))
                view.append(fs)
                fs = None
            else:
                view.extend(itertools.repeat(self.visible, nest))
            if fb is not None and nest &gt; 1:
                path.append(position)
                path.append(fb)
                path.extend(itertools.repeat(0, nest - 2))
            else:
                path.append(position)
                path.extend(itertools.repeat(0, nest - 1))
    elif nest &lt; 0:
        view = self._view[:nest]
        path = self._path[:nest]
    else:
        view = self._view
        path = self._path
        if not serialize:
            view = list(view)
            path = list(path)

    assert len(path) == scope
    assert len(view) == scope

    meta = self._meta.serialize(self.scope + nest)

    if serialize:
        assert msgpack
        item = (path, view, meta, fs, self)
        item = msgpack.packb(item)
        assert isinstance(item, bytes)
        return item
    else:
        return Chunk(self, path, view, None, meta, fs, fb,
            ignore_chunk_properties=True)</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.intersect"><code class="name flex">
<span>def <span class="ident">intersect</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<section class="desc"><p>Removes all meta variables from this chunk whose value differs from those of the <code>other</code>
inut chunk.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L431-L441" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def intersect(self, other: Chunk):
    &#34;&#34;&#34;
    Removes all meta variables from this chunk whose value differs from those of the `other`
    inut chunk.
    &#34;&#34;&#34;
    other_meta = other._meta
    meta = self._meta
    for key, value in list(meta.items()):
        if other_meta.get(key) != value:
            meta.discard(key)
    return self</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, scope=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Truncate the <code><a title="refinery.lib.frame.Chunk.path" href="#refinery.lib.frame.Chunk.path">Chunk.path</a></code> and <code><a title="refinery.lib.frame.Chunk.view" href="#refinery.lib.frame.Chunk.view">Chunk.view</a></code> lists
to the given length, setting the <code><a title="refinery.lib.frame.Chunk.scope" href="#refinery.lib.frame.Chunk.scope">Chunk.scope</a></code> to the given value.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L475-L482" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def truncate(self, scope: int = 0):
    &#34;&#34;&#34;
    Truncate the `refinery.lib.frame.Chunk.path` and `refinery.lib.frame.Chunk.view` lists
    to the given length, setting the `refinery.lib.frame.Chunk.scope` to the given value.
    &#34;&#34;&#34;
    del self._path[scope:]
    del self._view[scope:]
    return self</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Chunk.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, meta=True, data=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Produce a copy of this chunk. The metadata is copied if the <code>meta</code> argument is <code>True</code>,
otherwise the copy has no metadata. The body of the chunk is copied only if the <code>data</code>
argument is <code>True</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L484-L503" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def copy(self, meta=True, data=True) -&gt; Chunk:
    &#34;&#34;&#34;
    Produce a copy of this chunk. The metadata is copied if the `meta` argument is `True`,
    otherwise the copy has no metadata. The body of the chunk is copied only if the `data`
    argument is `True`.
    &#34;&#34;&#34;
    data = data and self or None
    copy = Chunk(
        data,
        path=list(self._path),
        view=list(self._view),
        fill_scope=self._fill_scope,
        fill_batch=self._fill_batch,
        ignore_chunk_properties=True,
    )
    if meta:
        copy.meta.update(self.meta)
    if copy.meta.scope != copy.scope:
        raise RuntimeError
    return copy</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.frame.Framed"><code class="flex name class">
<span>class <span class="ident">Framed</span></span>
<span>(</span><span>action, stream, filter, finish, nesting=0, squeeze=False, serialized=True, filter_all=False)</span>
</code></dt>
<dd>
<section class="desc"><p>A proxy interface to ingest and output framed data. It is given an <code>action</code> to be
performed for each elementary chunk of data, a <code>stream</code> of input data, and an integer
argument <code>nested</code> which specifies the relative amount of nesting to be performed
by the interface. This parameter should either be <code>1</code> if the interface should output
the results at an additional layer, <code>0</code> if the nesting depth of the data should
remain unchanged, and a negative amount if frame layers are to be collapsed. After
initialization, the <code><a title="refinery.lib.frame.Framed" href="#refinery.lib.frame.Framed">Framed</a></code> object is an iterator that yields
bytestrings which can be forwarded as the output of the operation with all framing
already taken care of.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L627-L802" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Framed:
    &#34;&#34;&#34;
    A proxy interface to ingest and output framed data. It is given an `action` to be
    performed for each elementary chunk of data, a `stream` of input data, and an integer
    argument `nested` which specifies the relative amount of nesting to be performed
    by the interface. This parameter should either be `1` if the interface should output
    the results at an additional layer, `0` if the nesting depth of the data should
    remain unchanged, and a negative amount if frame layers are to be collapsed. After
    initialization, the `refinery.lib.frame.Framed` object is an iterator that yields
    bytestrings which can be forwarded as the output of the operation with all framing
    already taken care of.
    &#34;&#34;&#34;
    def __init__(
        self,
        action : Callable[[Chunk], Iterable[Chunk]],
        stream : BinaryIO | None,
        filter : Callable[[Iterable[Chunk]], Iterable[Chunk]],
        finish : Callable[[], Iterable[Chunk]],
        nesting: int = 0,
        squeeze: bool = False,
        serialized: bool = True,
        filter_all: bool = False,
    ):
        self.unpack = FrameUnpacker(stream)
        self.action = action
        self.filter = filter
        self.finish = finish
        self.serialized = serialized
        self.filter_all = filter_all
        self.nesting = nesting
        self.squeeze = squeeze

    def _apply_filter(self) -&gt; Iterable[Chunk]:

        def autoindex(it: Iterable[Chunk]):
            for k, chunk in enumerate(it):
                chunk.meta.index = k
                yield chunk

        chunks = iter(self.unpack)
        header = list(itertools.islice(chunks, 0, 2))
        if not header:
            return
        elif len(header) &gt; 1:
            chunks = itertools.chain(header, chunks)
            chunks = autoindex(chunks)
        else:
            header[0].meta.index = 0
            chunks = iter(header)
        if header[0].scopable or self.filter_all:
            chunks = self.filter(chunks)
        yield from chunks

        if not self.unpack.eol:  # filter did not consume the iterable
            self.unpack.abort()

        if self.unpack.finished and self.finish:
            yield from self.finish()

    @property
    def unframed(self) -&gt; bool:
        &#34;&#34;&#34;
        This property is true if the output data is not framed.
        &#34;&#34;&#34;
        return self.nesting + self.unpack.depth &lt; 1

    @property
    def framebreak(self) -&gt; bool:
        &#34;&#34;&#34;
        This property will be true if the data generated by this framing interface should
        be separated by linebreaks. This happens when one of the following is true:
        - The requested nesting was smaller than required to close all existing frames.
        - The input data was not framed and the nesting did not increase in this unit
        &#34;&#34;&#34;
        if not self.unpack.framed:
            return self.nesting &lt; 1
        return self.nesting + self.unpack.depth &lt; 0

    def _generate_chunks(self, parent: Chunk):
        path = list(parent.path)
        view = list(parent.view)
        meta = parent.meta
        scope = parent.scope

        def inherit(chunk: Chunk):
            if chunk is parent:
                return chunk
            if path:
                chunk._path[:] = path
            if view and not chunk._view:
                chunk._view[:] = view
            chunk._meta.inherit(meta)
            return chunk.truncate(scope)

        if not self.squeeze:
            for chunk in self.action(parent):
                yield inherit(chunk)
        else:
            it = self.action(parent)
            for header in it:
                buffer = MemoryFile(header)
                buffer.seek(len(header))
                break
            else:
                return
            for item in it:
                header.intersect(item)
                buffer.write(item)
            inherit(header)
            yield header

    def _generate_bytes(self, data: Chunk):
        if not self.squeeze:
            yield from self.action(data)
            return
        buffer = MemoryFile(bytearray())
        for item in self.action(data):
            buffer.write(item)
        yield buffer.getvalue()

    def __iter__(self):
        nesting = self.nesting
        serialized = self.serialized
        scope = max(self.unpack.depth + nesting, 0)
        if self.unpack.finished:
            if scope:
                yield generate_frame_header(scope)
            return
        if nesting &gt; 0:
            assert scope
            yield generate_frame_header(scope)
            while self.unpack.nextframe():
                for k, chunk in enumerate(self._apply_filter()):
                    if not chunk.visible:
                        yield chunk.pack(nesting, k, serialized)
                        continue
                    for result in self._generate_chunks(chunk):
                        yield result.pack(nesting, k, serialized)
        elif not self.unpack.framed:
            for chunk in self._apply_filter():
                yield from self._generate_bytes(chunk)
        elif nesting == 0:
            assert scope
            yield generate_frame_header(scope)
            while self.unpack.nextframe():
                for chunk in self._apply_filter():
                    if not chunk.visible:
                        yield chunk.pack(0, 0, serialized)
                        continue
                    for result in self._generate_chunks(chunk):
                        yield result.pack(0, 0, serialized)
        else:
            trunk = None
            check = scope + 1
            if scope:
                yield generate_frame_header(scope)
            while self.unpack.nextframe():
                for chunk in self._apply_filter():
                    results = self._generate_chunks(chunk) if chunk.visible else (chunk,)
                    if not scope:
                        for chunk in results:
                            yield chunk.truncate()
                        continue
                    for result in results:
                        if trunk is None:
                            trunk = result
                        elif result.path[:check] == trunk.path[:check]:
                            trunk.intersect(result)
                            trunk.extend(result)
                        else:
                            yield trunk.pack(nesting, 0, serialized)
                            trunk = result
                if not scope or trunk is None:
                    continue
            if trunk is not None:
                yield trunk.pack(nesting, 0, serialized)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.frame.Framed.unframed"><code class="name">var <span class="ident">unframed</span></code></dt>
<dd>
<section class="desc"><p>This property is true if the output data is not framed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L686-L691" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def unframed(self) -&gt; bool:
    &#34;&#34;&#34;
    This property is true if the output data is not framed.
    &#34;&#34;&#34;
    return self.nesting + self.unpack.depth &lt; 1</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.Framed.framebreak"><code class="name">var <span class="ident">framebreak</span></code></dt>
<dd>
<section class="desc"><p>This property will be true if the data generated by this framing interface should
be separated by linebreaks. This happens when one of the following is true:
- The requested nesting was smaller than required to close all existing frames.
- The input data was not framed and the nesting did not increase in this unit</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L693-L703" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def framebreak(self) -&gt; bool:
    &#34;&#34;&#34;
    This property will be true if the data generated by this framing interface should
    be separated by linebreaks. This happens when one of the following is true:
    - The requested nesting was smaller than required to close all existing frames.
    - The input data was not framed and the nesting did not increase in this unit
    &#34;&#34;&#34;
    if not self.unpack.framed:
        return self.nesting &lt; 1
    return self.nesting + self.unpack.depth &lt; 0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.frame.FrameUnpacker"><code class="flex name class">
<span>class <span class="ident">FrameUnpacker</span></span>
<span>(</span><span>stream)</span>
</code></dt>
<dd>
<section class="desc"><p>Provides a unified interface to read both framed and raw input data from a stream. After
loading a framed input stream, the object provides an iterator over the first <strong>frame</strong> in
the bottom <strong>layer</strong> of the frame tree. Consider this doubly layered frame tree:</p>
<pre><code>[[FOO, BAR], [BOO, BAZ]]
</code></pre>
<p>The <code><a title="refinery.lib.frame.FrameUnpacker" href="#refinery.lib.frame.FrameUnpacker">FrameUnpacker</a></code> object will first be an iterator over the first frame
<code>[FOO, BAR]</code>. After consuming this iterator, the <code><a title="refinery.lib.frame.FrameUnpacker.nextframe" href="#refinery.lib.frame.FrameUnpacker.nextframe">FrameUnpacker.nextframe()</a></code>
method can be called to load the next frame, at which point the object will become an
iterator over <code>[BOO, BAZ]</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L512-L624" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class FrameUnpacker(Iterable[Chunk]):
    &#34;&#34;&#34;
    Provides a unified interface to read both framed and raw input data from a stream. After
    loading a framed input stream, the object provides an iterator over the first **frame** in
    the bottom **layer** of the frame tree. Consider this doubly layered frame tree:

        [[FOO, BAR], [BOO, BAZ]]

    The `refinery.lib.frame.FrameUnpacker` object will first be an iterator over the first frame
    `[FOO, BAR]`. After consuming this iterator, the `refinery.lib.frame.FrameUnpacker.nextframe`
    method can be called to load the next frame, at which point the object will become an
    iterator over `[BOO, BAZ]`.
    &#34;&#34;&#34;
    next_chunk: Chunk | None
    depth: int
    trunk: tuple[int, ...]
    check: tuple[int, ...]
    stream: BinaryIO | None
    finished: bool
    framed: bool
    unpacker: Unpacker | None

    def __init__(self, stream: BinaryIO | None):
        self.finished = False
        self.trunk = ()
        self.check = ()
        self.stream = None
        self.depth = 0
        self.next_chunk = None
        buffer = stream and stream.read(len(MAGIC)) or None
        if buffer == MAGIC:
            self.depth, = stream.read(1)
            self.framed = True
            self.stream = stream
            self.unpacker = msgpack.Unpacker(max_buffer_size=0xFFFFFFFF, use_list=True)
            self._advance()
        else:
            self.unpacker = None
            self.framed = False
            self.depth = 0
            self.next_chunk = Chunk()
            while buffer:
                self.next_chunk.extend(buffer)
                buffer = stream.read()

    def _advance(self) -&gt; bool:
        while not self.finished:
            try:
                self.next_chunk = chunk = Chunk.unpack(self.unpacker)
                self.check = tuple(chunk.path)
                if chunk.scope != self.depth:
                    raise RuntimeError(F&#39;Frame of depth {self.depth} contained chunk of scope {chunk.scope}.&#39;)
                return True
            except StopIteration:
                pass
            try:
                recv = self.stream.read1()
            except TypeError:
                raise
            recv = recv or self.stream.read()
            if not recv:
                break
            self.unpacker.feed(recv)
        self.finished = True
        return False

    def nextframe(self) -&gt; bool:
        &#34;&#34;&#34;
        Once the iterator is consumed, calling this function will return `True` if
        and only if another frame with input data has been loaded, in which case
        the object will provide an iterator over the freshly loaded frame. If this
        function returns `False`, all input data has been consumed.
        &#34;&#34;&#34;
        if self.finished:
            return False
        self.trunk = self.check
        return True

    def abort(self):
        &#34;&#34;&#34;
        Abort unpacking chunks from the frame.
        &#34;&#34;&#34;
        if self.depth &gt; 1:
            while not self.finished and self.trunk == self.check:
                self._advance()
        else:
            self.unpacker = None
            self.finished = True

    @property
    def eol(self) -&gt; bool:
        &#34;&#34;&#34;
        Specifies whether the current frame was fully consumed.
        &#34;&#34;&#34;
        return self.trunk != self.peek

    @property
    def peek(self) -&gt; tuple[int, ...]:
        &#34;&#34;&#34;
        Contains the identifier of the next frame.
        &#34;&#34;&#34;
        return self.check

    def __iter__(self) -&gt; Generator[Chunk]:
        if self.finished:
            return
        if not self.framed:
            yield self.next_chunk
            self.finished = True
            return
        while not self.finished and self.trunk == self.check:
            yield self.next_chunk
            self._advance()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Iterable</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.frame.FrameUnpacker.next_chunk"><code class="name">var <span class="ident">next_chunk</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.frame.FrameUnpacker.depth"><code class="name">var <span class="ident">depth</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.frame.FrameUnpacker.trunk"><code class="name">var <span class="ident">trunk</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.frame.FrameUnpacker.check"><code class="name">var <span class="ident">check</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.frame.FrameUnpacker.stream"><code class="name">var <span class="ident">stream</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.frame.FrameUnpacker.finished"><code class="name">var <span class="ident">finished</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.frame.FrameUnpacker.framed"><code class="name">var <span class="ident">framed</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.frame.FrameUnpacker.unpacker"><code class="name">var <span class="ident">unpacker</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.frame.FrameUnpacker.eol"><code class="name">var <span class="ident">eol</span></code></dt>
<dd>
<section class="desc"><p>Specifies whether the current frame was fully consumed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L601-L606" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eol(self) -&gt; bool:
    &#34;&#34;&#34;
    Specifies whether the current frame was fully consumed.
    &#34;&#34;&#34;
    return self.trunk != self.peek</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.FrameUnpacker.peek"><code class="name">var <span class="ident">peek</span></code></dt>
<dd>
<section class="desc"><p>Contains the identifier of the next frame.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L608-L613" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def peek(self) -&gt; tuple[int, ...]:
    &#34;&#34;&#34;
    Contains the identifier of the next frame.
    &#34;&#34;&#34;
    return self.check</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.frame.FrameUnpacker.nextframe"><code class="name flex">
<span>def <span class="ident">nextframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Once the iterator is consumed, calling this function will return <code>True</code> if
and only if another frame with input data has been loaded, in which case
the object will provide an iterator over the freshly loaded frame. If this
function returns <code>False</code>, all input data has been consumed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L578-L588" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nextframe(self) -&gt; bool:
    &#34;&#34;&#34;
    Once the iterator is consumed, calling this function will return `True` if
    and only if another frame with input data has been loaded, in which case
    the object will provide an iterator over the freshly loaded frame. If this
    function returns `False`, all input data has been consumed.
    &#34;&#34;&#34;
    if self.finished:
        return False
    self.trunk = self.check
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.frame.FrameUnpacker.abort"><code class="name flex">
<span>def <span class="ident">abort</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Abort unpacking chunks from the frame.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/frame.py#L590-L599" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def abort(self):
    &#34;&#34;&#34;
    Abort unpacking chunks from the frame.
    &#34;&#34;&#34;
    if self.depth &gt; 1:
        while not self.finished and self.trunk == self.check:
            self._advance()
    else:
        self.unpacker = None
        self.finished = True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#simple-frame-example">Simple Frame Example</a></li>
<li><a href="#frame-layers">Frame Layers</a></li>
<li><a href="#adding-line-breaks-easily">Adding Line Breaks Easily</a></li>
<li><a href="#squeezing">Squeezing</a></li>
<li><a href="#scoping">Scoping</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="refinery.lib.frame.MAGIC" href="#refinery.lib.frame.MAGIC">MAGIC</a></code></li>
<li><code><a title="refinery.lib.frame.MSIZE" href="#refinery.lib.frame.MSIZE">MSIZE</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.frame.generate_frame_header" href="#refinery.lib.frame.generate_frame_header">generate_frame_header</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.frame.Chunk" href="#refinery.lib.frame.Chunk">Chunk</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.lib.frame.Chunk.Wrap" href="#refinery.lib.frame.Chunk.Wrap">Wrap</a></code></li>
<li><code><a title="refinery.lib.frame.Chunk.unpack" href="#refinery.lib.frame.Chunk.unpack">unpack</a></code></li>
<li><code><a title="refinery.lib.frame.Chunk.set_next_scope" href="#refinery.lib.frame.Chunk.set_next_scope">set_next_scope</a></code></li>
<li><code><a title="refinery.lib.frame.Chunk.set_next_batch" href="#refinery.lib.frame.Chunk.set_next_batch">set_next_batch</a></code></li>
<li><code><a title="refinery.lib.frame.Chunk.pack" href="#refinery.lib.frame.Chunk.pack">pack</a></code></li>
<li><code><a title="refinery.lib.frame.Chunk.intersect" href="#refinery.lib.frame.Chunk.intersect">intersect</a></code></li>
<li><code><a title="refinery.lib.frame.Chunk.truncate" href="#refinery.lib.frame.Chunk.truncate">truncate</a></code></li>
<li><code><a title="refinery.lib.frame.Chunk.copy" href="#refinery.lib.frame.Chunk.copy">copy</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.frame.Framed" href="#refinery.lib.frame.Framed">Framed</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.frame.FrameUnpacker" href="#refinery.lib.frame.FrameUnpacker">FrameUnpacker</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.frame.FrameUnpacker.nextframe" href="#refinery.lib.frame.FrameUnpacker.nextframe">nextframe</a></code></li>
<li><code><a title="refinery.lib.frame.FrameUnpacker.abort" href="#refinery.lib.frame.FrameUnpacker.abort">abort</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
