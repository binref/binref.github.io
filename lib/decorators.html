<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.decorators documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.decorators</code></h1>
</header>
<section id="section-intro">
<p>A selection of refinery-specific decorators.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/decorators.py#L1-L190" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
A selection of refinery-specific decorators.
&#34;&#34;&#34;
from __future__ import annotations

import codecs
import copy
import itertools
import re

from functools import WRAPPER_ASSIGNMENTS, wraps
from typing import TYPE_CHECKING, Any, Callable, TypeVar, cast, overload

if TYPE_CHECKING:
    from refinery.units import Chunk, Unit


_F = TypeVar(&#39;_F&#39;, bound=Callable)


def wraps_without_annotations(method: Callable) -&gt; Callable[[_F], _F]:
    &#34;&#34;&#34;
    This decorator works simila to `wraps` from `functools` but does not update the
    type annotations of the wrapped function. This is used in the other decorators
    in this module because they change the function signature.
    &#34;&#34;&#34;
    assignments: set[str] = set(WRAPPER_ASSIGNMENTS)
    assignments.discard(&#39;__annotations__&#39;)
    wrap = wraps(method, assigned=assignments)
    if TYPE_CHECKING:
        wrap = cast(&#39;Callable[[_F], _F]&#39;, wrap)
    return wrap


@overload
def unicoded(method: Callable[[Any, str], str]) -&gt; Callable[[Any, Chunk], bytes]:
    ...


@overload
def unicoded(method: Callable[[Any, str], str | None]) -&gt; Callable[[Any, Chunk], bytes | None]:
    ...


def unicoded(method: Callable[[Any, str], str | None]) -&gt; Callable[[Any, Chunk], bytes | None]:
    &#34;&#34;&#34;
    Can be used to decorate a `refinery.units.Unit.process` routine that takes a
    string argument and also returns one. The resulting routine takes a binary buffer
    as input and attempts to decode it as unicode text. If certain characters cannot
    be decoded, then these ranges are skipped and the decorated routine is called
    once for each string patch that was successfully decoded.
    &#34;&#34;&#34;
    @wraps_without_annotations(method)
    def method_wrapper(self: Unit, data: Chunk) -&gt; bytes | None:
        input_codec = self.codec if any(data[::2]) else &#39;UTF-16LE&#39;
        partial = re.split(R&#39;([\uDC80-\uDCFF]+)&#39;,  # surrogate escape range
            codecs.decode(data, input_codec, errors=&#39;surrogateescape&#39;))
        partial[::2] = (method(self, p) or &#39;&#39; if p else &#39;&#39; for p in itertools.islice(iter(partial), 0, None, 2))
        nones = sum(1 for p in partial if p is None)
        if nones == len(partial):
            return None
        if nones &gt;= 1:
            for k, p in enumerate(partial):
                if p is None:
                    partial[k] = &#39;&#39;
        return codecs.encode(&#39;&#39;.join(partial), self.codec, errors=&#39;surrogateescape&#39;)
    return method_wrapper


def masked(mask: int, mod: bool = False):
    &#34;&#34;&#34;
    Convert arithmetic operations that occur within the decorated function body in such a way that
    the result is reduced with the given bit mask. All additions, subtractions, multiplications,
    left shifts, and taking powers are augmented by introducing a binary AND. If the mod parameter
    is enabled, a modulo operation is introduced instead.
    &#34;&#34;&#34;
    import ast
    import inspect

    if mod:
        op = ast.Mod
    else:
        op = ast.BitAnd

    def decorator(function):
        code = inspect.getsource(function)
        code = inspect.cleandoc(code)
        tree = ast.parse(code)

        class Postprocessor(ast.NodeTransformer):
            name = None

            def visit_UnaryOp(self, node: ast.UnaryOp) -&gt; Any:
                self.generic_visit(node)
                if not isinstance(node.op, (ast.USub, ast.Invert)):
                    return node
                return ast.BinOp(node, op(), ast.Constant(mask))

            def visit_AugAssign(self, node: ast.AugAssign) -&gt; Any:
                self.generic_visit(node)
                if not isinstance(node.op, (ast.Add, ast.Mult, ast.Sub, ast.LShift, ast.Pow)):
                    return node
                target_load = copy.deepcopy(node.target)
                target_load.ctx = ast.Load()
                computation = ast.BinOp(left=target_load, op=node.op, right=node.value)
                reduced = ast.BinOp(left=computation, op=op(), right=ast.Constant(mask))
                return ast.Assign(targets=[node.target], value=reduced)

            def visit_BinOp(self, node: ast.BinOp):
                self.generic_visit(node)
                if not isinstance(node.op, (ast.Add, ast.Mult, ast.Sub, ast.LShift, ast.Pow)):
                    return node
                return ast.BinOp(node, op(), ast.Constant(mask))

            def visit_FunctionDef(self, node: ast.FunctionDef):
                self.generic_visit(node)
                if self.name is None:
                    node.name = self.name = F&#39;__wrapped_{node.name}&#39;
                    for k in range(len(node.decorator_list)):
                        if not isinstance(decorator := node.decorator_list[k], ast.Call):
                            continue
                        if not isinstance(decorator := decorator.func, ast.Name):
                            continue
                        if decorator.id == masked.__name__:
                            del node.decorator_list[:k + 1]
                            break
                return node

        pp = Postprocessor()
        fixed = ast.fix_missing_locations(pp.visit(tree))
        if (name := pp.name) is None:
            raise RuntimeError

        import types

        freevars = function.__code__.co_freevars
        closure = function.__closure__
        namespace = {**function.__globals__}

        if freevars and closure:
            # Wrap the rewritten function definition inside a factory function that takes the free
            # variables as parameters, recreating the closure binding. The factory is needed so
            # that the inner function has the correct co_freevars, allowing us to reconstruct it
            # with the original closure cells to preserve late binding.
            factory_name = &#39;__closure_factory&#39;
            factory_args = ast.arguments(
                posonlyargs=[],
                args=[ast.arg(arg=v) for v in freevars],
                vararg=None,
                kwonlyargs=[],
                kw_defaults=[],
                kwarg=None,
                defaults=[],
            )
            factory_body: list[ast.stmt] = fixed.body + [
                ast.Return(value=ast.Name(id=name, ctx=ast.Load()))]
            no_decorators: list[ast.expr] = []
            factory_def = ast.FunctionDef(
                name=factory_name,
                args=factory_args,
                body=factory_body,
                decorator_list=no_decorators,
                returns=None,
                type_comment=None,
                type_params=[],
            )
            fixed = ast.Module(body=[factory_def], type_ignores=[])
            fixed = ast.fix_missing_locations(fixed)
            exec(compile(fixed, function.__code__.co_filename, &#39;exec&#39;), namespace)
            # We can&#39;t call the factory directly because the closure cells may not
            # have been assigned yet (late binding). Instead, we extract the inner
            # function&#39;s code object from the factory and reconstruct the function
            # with the original closure cells and the real globals dict.
            factory_fn = namespace[factory_name]
            inner_code = None
            for const in factory_fn.__code__.co_consts:
                if isinstance(const, types.CodeType) and const.co_name == name:
                    inner_code = const
                    break
            if inner_code is None:
                raise RuntimeError(F&#39;Could not find inner code object {name!r} in factory&#39;)
            result = types.FunctionType(inner_code, function.__globals__, name, closure=closure)
        else:
            exec(compile(fixed, function.__code__.co_filename, &#39;exec&#39;), namespace)
            result = types.FunctionType(
                namespace[name].__code__, function.__globals__, name)

        return wraps(function)(result)

    return decorator</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.decorators.wraps_without_annotations"><code class="name flex">
<span>def <span class="ident">wraps_without_annotations</span></span>(<span>method)</span>
</code></dt>
<dd>
<section class="desc"><p>This decorator works simila to <code>wraps</code> from <code>functools</code> but does not update the
type annotations of the wrapped function. This is used in the other decorators
in this module because they change the function signature.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/decorators.py#L21-L32" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wraps_without_annotations(method: Callable) -&gt; Callable[[_F], _F]:
    &#34;&#34;&#34;
    This decorator works simila to `wraps` from `functools` but does not update the
    type annotations of the wrapped function. This is used in the other decorators
    in this module because they change the function signature.
    &#34;&#34;&#34;
    assignments: set[str] = set(WRAPPER_ASSIGNMENTS)
    assignments.discard(&#39;__annotations__&#39;)
    wrap = wraps(method, assigned=assignments)
    if TYPE_CHECKING:
        wrap = cast(&#39;Callable[[_F], _F]&#39;, wrap)
    return wrap</code></pre>
</details>
</dd>
<dt id="refinery.lib.decorators.unicoded"><code class="name flex">
<span>def <span class="ident">unicoded</span></span>(<span>method)</span>
</code></dt>
<dd>
<section class="desc"><p>Can be used to decorate a <code><a title="refinery.units.Unit.process" href="../units/index.html#refinery.units.UnitBase.process">Unit.process()</a></code> routine that takes a
string argument and also returns one. The resulting routine takes a binary buffer
as input and attempts to decode it as unicode text. If certain characters cannot
be decoded, then these ranges are skipped and the decorated routine is called
once for each string patch that was successfully decoded.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/decorators.py#L45-L67" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unicoded(method: Callable[[Any, str], str | None]) -&gt; Callable[[Any, Chunk], bytes | None]:
    &#34;&#34;&#34;
    Can be used to decorate a `refinery.units.Unit.process` routine that takes a
    string argument and also returns one. The resulting routine takes a binary buffer
    as input and attempts to decode it as unicode text. If certain characters cannot
    be decoded, then these ranges are skipped and the decorated routine is called
    once for each string patch that was successfully decoded.
    &#34;&#34;&#34;
    @wraps_without_annotations(method)
    def method_wrapper(self: Unit, data: Chunk) -&gt; bytes | None:
        input_codec = self.codec if any(data[::2]) else &#39;UTF-16LE&#39;
        partial = re.split(R&#39;([\uDC80-\uDCFF]+)&#39;,  # surrogate escape range
            codecs.decode(data, input_codec, errors=&#39;surrogateescape&#39;))
        partial[::2] = (method(self, p) or &#39;&#39; if p else &#39;&#39; for p in itertools.islice(iter(partial), 0, None, 2))
        nones = sum(1 for p in partial if p is None)
        if nones == len(partial):
            return None
        if nones &gt;= 1:
            for k, p in enumerate(partial):
                if p is None:
                    partial[k] = &#39;&#39;
        return codecs.encode(&#39;&#39;.join(partial), self.codec, errors=&#39;surrogateescape&#39;)
    return method_wrapper</code></pre>
</details>
</dd>
<dt id="refinery.lib.decorators.masked"><code class="name flex">
<span>def <span class="ident">masked</span></span>(<span>mask, mod=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert arithmetic operations that occur within the decorated function body in such a way that
the result is reduced with the given bit mask. All additions, subtractions, multiplications,
left shifts, and taking powers are augmented by introducing a binary AND. If the mod parameter
is enabled, a modulo operation is introduced instead.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/decorators.py#L70-L190" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def masked(mask: int, mod: bool = False):
    &#34;&#34;&#34;
    Convert arithmetic operations that occur within the decorated function body in such a way that
    the result is reduced with the given bit mask. All additions, subtractions, multiplications,
    left shifts, and taking powers are augmented by introducing a binary AND. If the mod parameter
    is enabled, a modulo operation is introduced instead.
    &#34;&#34;&#34;
    import ast
    import inspect

    if mod:
        op = ast.Mod
    else:
        op = ast.BitAnd

    def decorator(function):
        code = inspect.getsource(function)
        code = inspect.cleandoc(code)
        tree = ast.parse(code)

        class Postprocessor(ast.NodeTransformer):
            name = None

            def visit_UnaryOp(self, node: ast.UnaryOp) -&gt; Any:
                self.generic_visit(node)
                if not isinstance(node.op, (ast.USub, ast.Invert)):
                    return node
                return ast.BinOp(node, op(), ast.Constant(mask))

            def visit_AugAssign(self, node: ast.AugAssign) -&gt; Any:
                self.generic_visit(node)
                if not isinstance(node.op, (ast.Add, ast.Mult, ast.Sub, ast.LShift, ast.Pow)):
                    return node
                target_load = copy.deepcopy(node.target)
                target_load.ctx = ast.Load()
                computation = ast.BinOp(left=target_load, op=node.op, right=node.value)
                reduced = ast.BinOp(left=computation, op=op(), right=ast.Constant(mask))
                return ast.Assign(targets=[node.target], value=reduced)

            def visit_BinOp(self, node: ast.BinOp):
                self.generic_visit(node)
                if not isinstance(node.op, (ast.Add, ast.Mult, ast.Sub, ast.LShift, ast.Pow)):
                    return node
                return ast.BinOp(node, op(), ast.Constant(mask))

            def visit_FunctionDef(self, node: ast.FunctionDef):
                self.generic_visit(node)
                if self.name is None:
                    node.name = self.name = F&#39;__wrapped_{node.name}&#39;
                    for k in range(len(node.decorator_list)):
                        if not isinstance(decorator := node.decorator_list[k], ast.Call):
                            continue
                        if not isinstance(decorator := decorator.func, ast.Name):
                            continue
                        if decorator.id == masked.__name__:
                            del node.decorator_list[:k + 1]
                            break
                return node

        pp = Postprocessor()
        fixed = ast.fix_missing_locations(pp.visit(tree))
        if (name := pp.name) is None:
            raise RuntimeError

        import types

        freevars = function.__code__.co_freevars
        closure = function.__closure__
        namespace = {**function.__globals__}

        if freevars and closure:
            # Wrap the rewritten function definition inside a factory function that takes the free
            # variables as parameters, recreating the closure binding. The factory is needed so
            # that the inner function has the correct co_freevars, allowing us to reconstruct it
            # with the original closure cells to preserve late binding.
            factory_name = &#39;__closure_factory&#39;
            factory_args = ast.arguments(
                posonlyargs=[],
                args=[ast.arg(arg=v) for v in freevars],
                vararg=None,
                kwonlyargs=[],
                kw_defaults=[],
                kwarg=None,
                defaults=[],
            )
            factory_body: list[ast.stmt] = fixed.body + [
                ast.Return(value=ast.Name(id=name, ctx=ast.Load()))]
            no_decorators: list[ast.expr] = []
            factory_def = ast.FunctionDef(
                name=factory_name,
                args=factory_args,
                body=factory_body,
                decorator_list=no_decorators,
                returns=None,
                type_comment=None,
                type_params=[],
            )
            fixed = ast.Module(body=[factory_def], type_ignores=[])
            fixed = ast.fix_missing_locations(fixed)
            exec(compile(fixed, function.__code__.co_filename, &#39;exec&#39;), namespace)
            # We can&#39;t call the factory directly because the closure cells may not
            # have been assigned yet (late binding). Instead, we extract the inner
            # function&#39;s code object from the factory and reconstruct the function
            # with the original closure cells and the real globals dict.
            factory_fn = namespace[factory_name]
            inner_code = None
            for const in factory_fn.__code__.co_consts:
                if isinstance(const, types.CodeType) and const.co_name == name:
                    inner_code = const
                    break
            if inner_code is None:
                raise RuntimeError(F&#39;Could not find inner code object {name!r} in factory&#39;)
            result = types.FunctionType(inner_code, function.__globals__, name, closure=closure)
        else:
            exec(compile(fixed, function.__code__.co_filename, &#39;exec&#39;), namespace)
            result = types.FunctionType(
                namespace[name].__code__, function.__globals__, name)

        return wraps(function)(result)

    return decorator</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.decorators.wraps_without_annotations" href="#refinery.lib.decorators.wraps_without_annotations">wraps_without_annotations</a></code></li>
<li><code><a title="refinery.lib.decorators.unicoded" href="#refinery.lib.decorators.unicoded">unicoded</a></code></li>
<li><code><a title="refinery.lib.decorators.masked" href="#refinery.lib.decorators.masked">masked</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
