<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.lief documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.lief</code></h1>
</header>
<section id="section-intro">
<p>A wrapper around the LIEF library.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/lief.py#L1-L186" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
A wrapper around the LIEF library.
&#34;&#34;&#34;
from __future__ import annotations

import io

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import lief.COFF as COFF
    import lief.ELF as ELF
    import lief.MachO as MachO
    import lief.PE as PE

    from lief import Binary as AbstractBinary
    from lief import Header, Relocation, Section, Symbol

    from refinery.lib.types import buf

__all__ = [
    &#39;ELF&#39;,
    &#39;MachO&#39;,
    &#39;PE&#39;,
    &#39;COFF&#39;,
    &#39;AbstractBinary&#39;,
    &#39;Relocation&#39;,
    &#39;Header&#39;,
    &#39;Symbol&#39;,
    &#39;Section&#39;,
    &#39;load_pe&#39;,
    &#39;load_pe_fast&#39;,
    &#39;load_macho&#39;,
    &#39;load&#39;,
    &#39;string&#39;,
]

__pdoc__ = {_forward: False for _forward in __all__[:9]}

_lib = None


def _init():
    global _lib
    if _lib is not None:
        return _lib
    import lief as lib
    lib.disable_leak_warning()
    lib.logging.disable()
    _lib = lib
    return lib


def __getattr__(name):
    lib = _init()
    if name == &#39;lib&#39;:
        return lib
    if name == &#39;ELF&#39;:
        import lief.ELF as ELF
        return ELF
    if name == &#39;MachO&#39;:
        import lief.MachO as MachO
        return MachO
    if name == &#39;PE&#39;:
        import lief.PE as PE
        return PE
    if name == &#39;COFF&#39;:
        import lief.COFF as COFF
        return COFF
    if name == &#39;AbstractBinary&#39;:
        return lib.Binary
    if name == &#39;Relocation&#39;:
        return lib.Relocation
    if name == &#39;Header&#39;:
        return lib.Header
    if name == &#39;Symbol&#39;:
        return lib.Symbol
    if name == &#39;Section&#39;:
        return lib.Section
    raise AttributeError(F&#39;module {__name__!r} has no attribute {name!r}&#39;)


def load_pe(
    data: buf,
    parse_exports: bool = True,
    parse_imports: bool = True,
    parse_reloc: bool = True,
    parse_rsrc: bool = True,
    parse_signature: bool = True,
):
    &#34;&#34;&#34;
    Load a PE file using LIEF. This is an ease-of-use function which forwards the keyworda rguments
    to a config object and then invokes the LIEF parser. Everything is parsed by default. For speed
    over completeness, see `refinery.lib.lief.load_pe_fast`.
    &#34;&#34;&#34;
    import lief.PE as PE
    with io.BytesIO(data) as stream:
        cfg = PE.ParserConfig()
        cfg.parse_exports = bool(parse_exports)
        cfg.parse_imports = bool(parse_imports)
        cfg.parse_reloc = bool(parse_reloc)
        cfg.parse_rsrc = bool(parse_rsrc)
        cfg.parse_signature = bool(parse_signature)
        if parsed := PE.parse(stream, cfg):
            return parsed
        raise ValueError


def load_pe_fast(
    data: buf,
    parse_exports: bool = False,
    parse_imports: bool = False,
    parse_reloc: bool = False,
    parse_rsrc: bool = False,
    parse_signature: bool = False,
):
    &#34;&#34;&#34;
    This is equivalent to `refinery.lib.lief.load_pe` with the sole exception that the parser
    settings are optimized for speed rather than for parsing as many components as possible.
    &#34;&#34;&#34;
    return load_pe(
        data,
        parse_exports=parse_exports,
        parse_imports=parse_imports,
        parse_reloc=parse_reloc,
        parse_rsrc=parse_rsrc,
        parse_signature=parse_signature,
    )


def load_macho(data: buf):
    &#34;&#34;&#34;
    Load a MachO file using LIEF.
    &#34;&#34;&#34;
    import lief.MachO as MachO
    with io.BytesIO(data) as stream:
        config = MachO.ParserConfig()
        config.parse_dyld_bindings = True
        config.parse_dyld_rebases = True
        config.parse_dyld_exports = True
        if parsed := MachO.parse(stream, config):
            return parsed
        raise ValueError


def load_elf(data: buf):
    &#34;&#34;&#34;
    Load an ELF file using LIEF.
    &#34;&#34;&#34;
    import lief.ELF as ELF
    with io.BytesIO(data) as stream:
        config = ELF.ParserConfig()
        config.parse_dyn_symbols = True
        config.parse_relocations = True
        config.parse_symtab_symbols = True
        if parsed := ELF.parse(stream):
            return parsed
        raise ValueError


def load(data: buf):
    &#34;&#34;&#34;
    Load a PE, ELF, or MachO executable using LIEF. The function first attempts to parse the file
    based on its first 4 bytes using a specific LIEF parser and reverts to LIEF&#39;s general purpose
    loader if these fail.
    &#34;&#34;&#34;
    if data[:2] == B&#39;MZ&#39;:
        return load_pe(data)
    if data[:4] == B&#39;\x7FELF&#39;:
        return load_elf(data)
    if set(data[:4]) &lt;= {0xFE, 0xED, 0xFA, 0xCE, 0xCF}:
        return load_macho(data)
    raise ValueError


def string(value: str | buf) -&gt; str:
    &#34;&#34;&#34;
    A function to convert LIEF values to a string, regardless of whether it is exposed as bytes
    or string by the foreign interface.
    &#34;&#34;&#34;
    if not isinstance(value, str):
        if isinstance(value, memoryview):
            value = bytes(value)
        value, _, _ = value.partition(B&#39;\0&#39;)
        value = value.decode(&#39;utf8&#39;)
    return value</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.lief.load_pe"><code class="name flex">
<span>def <span class="ident">load_pe</span></span>(<span>data, parse_exports=True, parse_imports=True, parse_reloc=True, parse_rsrc=True, parse_signature=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Load a PE file using LIEF. This is an ease-of-use function which forwards the keyworda rguments
to a config object and then invokes the LIEF parser. Everything is parsed by default. For speed
over completeness, see <code><a title="refinery.lib.lief.load_pe_fast" href="#refinery.lib.lief.load_pe_fast">load_pe_fast()</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/lief.py#L83-L106" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def load_pe(
    data: buf,
    parse_exports: bool = True,
    parse_imports: bool = True,
    parse_reloc: bool = True,
    parse_rsrc: bool = True,
    parse_signature: bool = True,
):
    &#34;&#34;&#34;
    Load a PE file using LIEF. This is an ease-of-use function which forwards the keyworda rguments
    to a config object and then invokes the LIEF parser. Everything is parsed by default. For speed
    over completeness, see `refinery.lib.lief.load_pe_fast`.
    &#34;&#34;&#34;
    import lief.PE as PE
    with io.BytesIO(data) as stream:
        cfg = PE.ParserConfig()
        cfg.parse_exports = bool(parse_exports)
        cfg.parse_imports = bool(parse_imports)
        cfg.parse_reloc = bool(parse_reloc)
        cfg.parse_rsrc = bool(parse_rsrc)
        cfg.parse_signature = bool(parse_signature)
        if parsed := PE.parse(stream, cfg):
            return parsed
        raise ValueError</code></pre>
</details>
</dd>
<dt id="refinery.lib.lief.load_pe_fast"><code class="name flex">
<span>def <span class="ident">load_pe_fast</span></span>(<span>data, parse_exports=False, parse_imports=False, parse_reloc=False, parse_rsrc=False, parse_signature=False)</span>
</code></dt>
<dd>
<section class="desc"><p>This is equivalent to <code><a title="refinery.lib.lief.load_pe" href="#refinery.lib.lief.load_pe">load_pe()</a></code> with the sole exception that the parser
settings are optimized for speed rather than for parsing as many components as possible.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/lief.py#L109-L128" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def load_pe_fast(
    data: buf,
    parse_exports: bool = False,
    parse_imports: bool = False,
    parse_reloc: bool = False,
    parse_rsrc: bool = False,
    parse_signature: bool = False,
):
    &#34;&#34;&#34;
    This is equivalent to `refinery.lib.lief.load_pe` with the sole exception that the parser
    settings are optimized for speed rather than for parsing as many components as possible.
    &#34;&#34;&#34;
    return load_pe(
        data,
        parse_exports=parse_exports,
        parse_imports=parse_imports,
        parse_reloc=parse_reloc,
        parse_rsrc=parse_rsrc,
        parse_signature=parse_signature,
    )</code></pre>
</details>
</dd>
<dt id="refinery.lib.lief.load_macho"><code class="name flex">
<span>def <span class="ident">load_macho</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Load a MachO file using LIEF.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/lief.py#L131-L143" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def load_macho(data: buf):
    &#34;&#34;&#34;
    Load a MachO file using LIEF.
    &#34;&#34;&#34;
    import lief.MachO as MachO
    with io.BytesIO(data) as stream:
        config = MachO.ParserConfig()
        config.parse_dyld_bindings = True
        config.parse_dyld_rebases = True
        config.parse_dyld_exports = True
        if parsed := MachO.parse(stream, config):
            return parsed
        raise ValueError</code></pre>
</details>
</dd>
<dt id="refinery.lib.lief.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Load a PE, ELF, or MachO executable using LIEF. The function first attempts to parse the file
based on its first 4 bytes using a specific LIEF parser and reverts to LIEF's general purpose
loader if these fail.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/lief.py#L161-L173" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def load(data: buf):
    &#34;&#34;&#34;
    Load a PE, ELF, or MachO executable using LIEF. The function first attempts to parse the file
    based on its first 4 bytes using a specific LIEF parser and reverts to LIEF&#39;s general purpose
    loader if these fail.
    &#34;&#34;&#34;
    if data[:2] == B&#39;MZ&#39;:
        return load_pe(data)
    if data[:4] == B&#39;\x7FELF&#39;:
        return load_elf(data)
    if set(data[:4]) &lt;= {0xFE, 0xED, 0xFA, 0xCE, 0xCF}:
        return load_macho(data)
    raise ValueError</code></pre>
</details>
</dd>
<dt id="refinery.lib.lief.string"><code class="name flex">
<span>def <span class="ident">string</span></span>(<span>value)</span>
</code></dt>
<dd>
<section class="desc"><p>A function to convert LIEF values to a string, regardless of whether it is exposed as bytes
or string by the foreign interface.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/lief.py#L176-L186" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def string(value: str | buf) -&gt; str:
    &#34;&#34;&#34;
    A function to convert LIEF values to a string, regardless of whether it is exposed as bytes
    or string by the foreign interface.
    &#34;&#34;&#34;
    if not isinstance(value, str):
        if isinstance(value, memoryview):
            value = bytes(value)
        value, _, _ = value.partition(B&#39;\0&#39;)
        value = value.decode(&#39;utf8&#39;)
    return value</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.lief.load_pe" href="#refinery.lib.lief.load_pe">load_pe</a></code></li>
<li><code><a title="refinery.lib.lief.load_pe_fast" href="#refinery.lib.lief.load_pe_fast">load_pe_fast</a></code></li>
<li><code><a title="refinery.lib.lief.load_macho" href="#refinery.lib.lief.load_macho">load_macho</a></code></li>
<li><code><a title="refinery.lib.lief.load" href="#refinery.lib.lief.load">load</a></code></li>
<li><code><a title="refinery.lib.lief.string" href="#refinery.lib.lief.string">string</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
