<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.zip documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.zip</code></h1>
</header>
<section id="section-intro">
<p>Structures for unpacking ZIP archives. This can cover a lot more than the built-in zipfile module,
but it is incapable of creating ZIP archives.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L1-L1239" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Structures for unpacking ZIP archives. This can cover a lot more than the built-in zipfile module,
but it is incapable of creating ZIP archives.
&#34;&#34;&#34;
from __future__ import annotations

import bisect
import codecs
import enum
import re
import zlib

from datetime import datetime
from typing import TYPE_CHECKING, NamedTuple

from refinery.lib.decompression import parse_lzma_properties
from refinery.lib.dt import dostime
from refinery.lib.fast import zipcrypto
from refinery.lib.id import buffer_offset
from refinery.lib.intervals import IntIntervalUnion
from refinery.lib.structures import FlagAccessMixin, Struct, StructReader, StructReaderBits
from refinery.lib.types import buf

if TYPE_CHECKING:
    from typing import Self


class PasswordRequired(Exception):
    pass


class InvalidPassword(ValueError):
    pass


class InvalidChecksum(ValueError):
    def __init__(self, record: ZipFileRecord, data: buf, expected: int, computed: int) -&gt; None:
        self.record = record
        self.data = data
        self.expected = expected
        self.computed = computed

    def __str__(self):
        return (
            F&#39;Invalid checksum for {self.record.name};&#39;
            F&#39; computed {self.computed:08X},&#39;
            F&#39; expected {self.expected:08X}.&#39;)


class DataIntegrityError(ValueError):
    pass


class ZipAnomalies(enum.IntFlag):
    Normal = 0
    DataDescriptorWithoutHeader = 1


class ZipFlags(FlagAccessMixin, enum.IntFlag):
    Encrypted           = 0x0001 # noqa
    CompressOption1     = 0x0002 # noqa
    CompressOption2     = 0x0004 # noqa
    DataDescriptor      = 0x0008 # noqa
    EnhancedDeflate     = 0x0010 # noqa
    CompressedPatched   = 0x0020 # noqa
    StrongEncryption    = 0x0040 # noqa
    UseUTF8             = 0x0800 # noqa
    EncryptedCD         = 0x2000 # noqa


class ZipEncryptionAlgorithm(enum.IntEnum):
    DES             = 0x6601 # noqa
    BuggyRC2        = 0x6602 # noqa (version needed to extract &lt; 5.2)
    TrippleDES168   = 0x6603 # noqa
    TrippleDES112   = 0x6609 # noqa
    AES128          = 0x660E # noqa
    AES192          = 0x660F # noqa
    AES256          = 0x6610 # noqa
    RC2             = 0x6702 # noqa (version needed to extract &gt;= 5.2)
    Blowfish        = 0x6720 # noqa
    Twofish         = 0x6721 # noqa
    RC4             = 0x6801 # noqa
    Unknown         = 0xFFFF # noqa


class ZipEncryptionFlags(FlagAccessMixin, enum.IntFlag):
    DecryptWithPassword = 1
    DecryptWithCertificate = 2


class ZipCompressionMethod(enum.IntEnum):
    STORE           = 0x00 # noqa
    SHRINK          = 0x01 # noqa
    REDUCED1        = 0x02 # noqa
    REDUCED2        = 0x03 # noqa
    REDUCED3        = 0x04 # noqa
    REDUCED4        = 0x05 # noqa
    IMPLODE         = 0x06 # noqa
    TOKENIZE        = 0x07 # noqa
    DEFLATE         = 0x08 # noqa
    DEFLATE64       = 0x09 # noqa
    PKWARE_IMPLODE  = 0x0A # noqa
    BZIP2           = 0x0C # noqa
    LZMA            = 0x0E # noqa
    IBM_CMPSC       = 0x10 # noqa
    IBM_TERSE       = 0x12 # noqa
    IBM_LZ77        = 0x13 # noqa
    ZSTD_DEPRECATED = 0x14 # noqa
    ZSTD            = 0x5D # noqa
    MP3             = 0x5E # noqa
    XZ              = 0x5F # noqa
    JPEG            = 0x60 # noqa
    WAVPACK         = 0x61 # noqa
    PPMD            = 0x62 # noqa
    AExENCRYPTION   = 0x63 # noqa
    RESERVED11      = 0x0B # noqa
    RESERVED13      = 0x0D # noqa
    RESERVED15      = 0x0F # noqa
    RESERVED17      = 0x11 # noqa


class ZipCrypto(Struct):
    CRC32Table: list[int] = []

    def __init__(self, reader: StructReader, crc: int):
        if not (ct := self.CRC32Table):
            for c in range(256):
                for _ in range(8):
                    c, x = divmod(c, 2)
                    c ^= x * 0xEDB88320
                ct.append(c)
        self.header = reader.read(12)
        self.crc = crc
        self._restart()

    def __buffer__(self, flags: int, /):
        return memoryview(self.header)

    def _restart(self):
        self.state = (0x12345678, 0x23456789, 0x34567890)

    def _decrypt(self, password: bytes, data: buf):
        result, *self.state = zipcrypto.decrypt(password, data, *self.state)
        return result

    def checkpwd(self, password: str | None):
        if password is None:
            return False
        self._restart()
        head = self._decrypt(password.encode(&#39;latin1&#39;), self.header)
        return head[11] == (self.crc &gt;&gt; 24) &amp; 0xFF

    def decrypt(self, password: str, data: buf):
        if not self.checkpwd(password):
            raise InvalidPassword
        return self._decrypt(b&#39;&#39;, data)


class ZipInternalFileAttributes(FlagAccessMixin, enum.IntFlag):
    ApparentText = 0x0001
    RecordLengthControl = 0x0002


class SigningBlock42Entry(Struct):
    def __init__(self, reader: StructReader[memoryview]):
        length = reader.u64()
        self.id = reader.u32()
        self.value = reader.read_exactly(length - 4)


class PkgSigningBlock(Struct):
    Signature = None
    SeekDelta = 0

    @classmethod
    def FromCentralDir(cls, reader: StructReader[memoryview]) -&gt; Self | None:
        cd = reader.tell()
        sd = cls.SeekDelta
        sb = cls.Signature
        if sb is None:
            raise NotImplementedError
        if (seek := cd - len(sb) - 8) &gt;= 0:
            reader.seekset(seek)
            size = reader.u64()
            if reader.read(len(sb)) != sb:
                return None
            if (seek := reader.tell() - size - sd) &gt;= 0:
                reader.seekset(seek)
                try:
                    apksig = cls(reader, size)
                except (ValueError, EOFError):
                    reader.seekset(cd)
                    return None
                if (m := len(apksig)) != (n := size + sd):
                    raise ValueError(F&#39;Size mismatch: {m} != {n}.&#39;)
                return apksig


class ApkSigningBlock42(PkgSigningBlock):
    &#34;&#34;&#34;
    The standard APK signing block.
    &#34;&#34;&#34;
    Signature = B&#39;APK Sig Block 42&#39;
    SeekDelta = 8

    def __init__(self, reader: StructReader[memoryview], size: int):
        self.offset = reader.tell()
        n = reader.u64()
        if n != size or n &lt; 0x18:
            raise ValueError(F&#39;Invalid length {n} for {self.__class__.__name__}.&#39;)
        self.data = reader.read_exactly(n - 0x18)
        body = StructReader(self.data)
        if (m := reader.u64()) != n:
            raise ValueError(F&#39;Size mismatch: {m} != {n}.&#39;)
        if reader.read(0x10) != self.Signature:
            raise ValueError(&#39;Invalid signature.&#39;)
        fields: list[SigningBlock42Entry] = []
        try:
            while not body.eof:
                fields.append(SigningBlock42Entry(body))
        except (ValueError, EOFError):
            self.fields = None
        else:
            self.fields = fields


class RpkSigningBlock42(ApkSigningBlock42):
    &#34;&#34;&#34;
    Rapid Package variant of the signing block. Also known as MiniApp.
    &#34;&#34;&#34;
    Signature = B&#39;RPK Sig Block 42&#39;


class ApkSigningBlock42_VariantWithAt(ApkSigningBlock42):
    &#34;&#34;&#34;
    An unknown variant of the APK signing block with an @ symbol instead of A. Seen in:
    e85f49b2234cc84d222e57a24c905cd37ceaf460a55e38956389e759f2ffd0a8
    &#34;&#34;&#34;
    Signature = B&#39;@PK Sig Block 42&#39;


class UnknownSigningBlockPK57(PkgSigningBlock):
    &#34;&#34;&#34;
    Unknown block of what appears to be a custom signature, seen in:
    fc5a13755bc0a744ea2c0807eee83823a03cdb28bf99c5d40419719a2b159cb4
    &#34;&#34;&#34;
    Signature = B&#39;PK\x05\x07&#39;
    SeekDelta = 12

    def __init__(self, reader: StructReader[memoryview], size: int):
        self.offset = reader.tell()
        self.unknown = reader.u32()
        self.signature = reader.read(size - 4)
        self.size = reader.u64()
        if self.size != size:
            raise ValueError
        if reader.read(4) != self.Signature:
            raise ValueError


class ZipEncryptionHeader(Struct):
    def __init__(self, reader: StructReader[memoryview]):
        self.iv = bytes(reader.read_exactly(reader.u16()))
        self.header_size = reader.u32()
        self.format = reader.u16()
        if self.format != 3:
            raise ValueError(F&#39;Invalid format {self.format:#x} in {self.__class__.__name__}.&#39;)
        self.algorithm = ZipEncryptionAlgorithm(reader.u16())
        self.bitlen = reader.u16()
        self.flags = ZipEncryptionFlags(reader.u16())
        self.erd = reader.read_exactly(reader.u16())
        self.reserved1 = r1 = reader.u32()
        self.reserved2 = reader.read_exactly(reader.u16()) if r1 else None
        if (vn := reader.u16()) &lt;= 4:
            raise ValueError(F&#39;Invalid size {vn} for validation data in {self.__class__.__name__}.&#39;)
        self.validation = reader.read_exactly(vn - 4)
        self.crc32 = reader.u32()
        self._derivations = {}

    def derive_key(self, password: str):
        def _cipher(key):
            if block_cipher is None:
                return ARC4.new(key)
            iv = self.iv[:block_cipher.block_size]
            return block_cipher.new(key, getattr(block_cipher, &#39;MODE_CBC&#39;), iv=iv)
        try:
            derived = self._derivations[password]
        except KeyError:
            from Cryptodome.Cipher import AES, ARC2, ARC4, DES, DES3, Blowfish
            from Cryptodome.Hash import SHA1
            from Cryptodome.Protocol.KDF import PBKDF2

            algorithm = self.algorithm
            key_size = 16

            if algorithm == ZipEncryptionAlgorithm.AES128:
                block_cipher = AES
            elif algorithm == ZipEncryptionAlgorithm.AES192:
                key_size = 24
                block_cipher = AES
            elif algorithm == ZipEncryptionAlgorithm.AES256:
                key_size = 32
                block_cipher = AES
            elif algorithm == ZipEncryptionAlgorithm.DES:
                key_size = 8
                block_cipher = DES
            elif algorithm == ZipEncryptionAlgorithm.TrippleDES168:
                key_size = 24
                block_cipher = DES3
            elif algorithm == ZipEncryptionAlgorithm.TrippleDES112:
                block_cipher = DES3
            elif algorithm == ZipEncryptionAlgorithm.RC2:
                block_cipher = ARC2
            elif algorithm == ZipEncryptionAlgorithm.RC4:
                block_cipher = None
            elif algorithm == ZipEncryptionAlgorithm.Blowfish:
                block_cipher = Blowfish
            elif algorithm == ZipEncryptionAlgorithm.BuggyRC2:
                raise NotImplementedError(
                    F&#39;This ZIP uses a buggy and unsupported RC2 implementation, indicated by the legacy identifier {algorithm:#x}.&#39;)
            elif algorithm == ZipEncryptionAlgorithm.Twofish:
                raise NotImplementedError(
                    &#39;This ZIP uses the unsupported Twofish encryption mode.&#39;)
            else:
                raise ValueError(
                    F&#39;Unsupported encryption algorithm {algorithm:#x}.&#39;)

            password_hash = SHA1.new(password.encode(&#39;utf-8&#39;)).digest()
            master_key_material = PBKDF2(
                password_hash.decode(&#39;latin1&#39;),
                password_hash,
                dkLen=key_size * 2 + 2,
                count=1000,
                hmac_hash_module=SHA1
            )
            master_key = master_key_material[:key_size]

            rd = _cipher(master_key).decrypt(self.erd)
            iv = SHA1.new(self.iv + rd).digest()
            key_material = PBKDF2(
                iv.decode(&#39;latin1&#39;),
                iv,
                dkLen=key_size * 2 + 2,
                count=1000,
                hmac_hash_module=SHA1
            )

            data_key = key_material[:key_size]
            auth_key = key_material[key_size:key_size * 2]
            password_verify = key_material[key_size * 2:key_size * 2 + 2]

            if password_verify != self.validation[:2]:
                self._derivations[password] = None
                raise InvalidPassword
            else:
                self._derivations[password] = block_cipher, data_key, auth_key
        else:
            if derived is None:
                raise InvalidPassword
            block_cipher, data_key, auth_key = derived

        return _cipher(data_key), auth_key

    def checkpwd(self, password: str | None):
        if password is None:
            return False
        try:
            self.derive_key(password)
        except InvalidPassword:
            return False
        else:
            return True

    def decrypt(self, password: str, data: bytes):
        from Cryptodome.Hash import HMAC, SHA1
        cipher, hmk = self.derive_key(password)

        if len(self.validation) &gt; 2:
            computed_hmac = HMAC.new(hmk, data, SHA1).digest()
            expected_hmac = self.validation[2:12] if len(self.validation) &gt;= 12 else self.validation[2:]
            if computed_hmac[:len(expected_hmac)] != expected_hmac:
                raise DataIntegrityError

        return cipher.decrypt(data)


class ZipArchiveExtraDataRecord(Struct):
    Signature = B&#39;PK\x06\x08&#39;

    def __init__(self, reader: StructReader[memoryview]):
        if reader.read(4) != self.Signature:
            raise ValueError
        self.extra_field_data = reader.read_exactly(reader.u32())
        self.extra_fields = ZipExtraField.ParseBuffer(self.extra_field_data)


class ZipDigitalSignature(Struct):
    Signature = B&#39;PK\x05\x05&#39;

    def __init__(self, reader: StructReader[memoryview]):
        if reader.read(4) != self.Signature:
            raise ValueError
        self.size_of_data = reader.u16()
        self.signature_data = reader.read_exactly(self.size_of_data)


class ZipDataDescriptorRaw(NamedTuple):
    crc32: int
    csize: int
    usize: int


class ZipDataDescriptor(Struct):
    Signature = B&#39;PK\x07\x08&#39;

    def __init__(
        self,
        reader: StructReader[memoryview],
        is64bit: bool = False,
        expected_size: int = -1,
    ):
        if reader.read(4) != self.Signature:
            raise ValueError
        self.crc32 = reader.u32()
        if expected_size &gt;= 0:
            u64value = reader.u64(peek=True)
            u32value = reader.u32(peek=True)
            if expected_size == u32value:
                if expected_size != u64value:
                    is64bit = False
            elif expected_size == u64value:
                if expected_size != u32value:
                    is64bit = True
        size = reader.u64 if is64bit else reader.u32
        self.csize = size()
        self.usize = size()
        if not is64bit and self.usize == 0 and self.csize &gt; 0x100:
            # This is likely a 64-bit descriptor despite what we thought.
            self.usize = reader.u64()
            is64bit = True
        self.is64bit = is64bit


class ZipFileRecord(Struct):
    Signature = B&#39;PK\x03\x04&#39;

    def __init__(
        self,
        reader: StructReader[memoryview],
        is64bit: bool = False,
        ddirs: list[int] | None = None,
        read_data: bool = True,
        dir: ZipDirEntry | None = None,
    ):
        self._unpacked = None
        self._decrypted = None
        self.offset = reader.tell()
        self.dir = dir

        self.anomalies = ZipAnomalies.Normal

        if reader.read(4) != self.Signature:
            raise ValueError
        self.version = reader.u16()
        self.flags = ZipFlags(reader.u16())
        self.method_value = reader.u16()
        try:
            self.method = ZipCompressionMethod(self.method_value)
        except ValueError:
            self.method = None
        try:
            self.date = dostime(reader.u32(peek=True))
        except Exception:
            self.date = None
        self.mtime = reader.u16()
        self.mdate = reader.u16()

        self.crc32_ignored = False

        descriptor = reader.peek(12)
        self.crc32 = reader.u32()
        self.csize = reader.u32()
        self.usize = reader.u32()

        nl = reader.u16()
        xl = reader.u16()
        self.name_bytes = reader.read_exactly(nl)
        self.xtra_data = reader.read_exactly(xl)
        self.xtra = ZipExtraField.ParseBuffer(self.xtra_data)

        self.ae = None
        self.ux = None
        self.up = None
        self.ts = None

        codec = &#39;utf8&#39; if self.flags.UseUTF8 else &#39;latin1&#39;
        self.name = codecs.decode(self.name_bytes, codec)

        for x in self.xtra:
            if z64 := ZipExtInfo64.TryParse(x, self.usize, self.csize):
                self.usize = z64.usize
                self.csize = z64.csize
                is64bit = True
            elif ae := ZipExtAES.TryParse(x):
                if (m := self.method) != ZipCompressionMethod.AExENCRYPTION:
                    if m is not None:
                        m = m.name
                    raise ValueError(F&#39;AES extension found, but compression method was {m}.&#39;)
                self.ae = ae
                self.method = ae.method
            elif up := ZipExtUnicodePath.TryParse(x):
                self.up = up
                if up.crc == zlib.crc32(self.name_bytes) &amp; 0xFFFFFFFF:
                    self.name = up.name
            elif ux := ZipExtUnixIDs.TryParse(x):
                self.ux = ux
            elif ts := ZipExtTimestamp.TryParse(x):
                self.ts = ts

        self.data_offset = start = reader.tell()
        self.data_descriptor = None

        if not self.flags.Encrypted:
            self.encryption = NoCrypto()
        elif self.flags.StrongEncryption:
            self.encryption = ZipEncryptionHeader(reader)
        else:
            if ae := (dir.ae if dir else None) or self.ae:
                self.encryption = AExCrypto(reader, ae)
            else:
                self.encryption = ZipCrypto(reader, self.crc32)

        skipped = len(self.encryption)

        if not read_data:
            self.data = None
            return

        if 0 &lt; self.csize:
            rest = self.csize - skipped
            if rest &lt; 0:
                raise DataIntegrityError
            self.data = reader.read_exactly(rest)
        else:
            self.data = B&#39;&#39;

        if ddirs and not self.csize:
            k = bisect.bisect_left(ddirs, start)
            for k in range(k, len(ddirs)):
                ddpos = ddirs[k]
                csize = ddpos - self.data_offset
                self.data = reader.read_exactly(csize - skipped)
                self.data_descriptor = info = ZipDataDescriptor(reader, is64bit, csize)
                if info.csize == csize:
                    self.crc32 = info.crc32
                    self.csize = info.csize
                    self.usize = info.usize
                    is64bit = info.is64bit
                    break
                try:
                    u = self.unpack()
                except Exception:
                    pass
                else:
                    self.csize = csize
                    self.usize = len(u)
                    break
                reader.seekset(self.data_offset)
                start += 4
        elif self.flags.DataDescriptor or reader.peek(4) == ZipDataDescriptor.Signature:
            self.data_descriptor = info = ZipDataDescriptor(reader, is64bit)
            is64bit = info.is64bit
            self.crc32 = self.crc32 or info.crc32
            self.csize = self.csize or info.csize
            self.usize = self.usize or info.usize
        elif reader.peek(12) == descriptor:
            self.data_descriptor = ZipDataDescriptorRaw(reader.u32(), reader.u32(), reader.u32())
            self.anomalies |= ZipAnomalies.DataDescriptorWithoutHeader

        if self.name == &#39;AndroidManifest.xml&#39;:
            checkpoint = reader.tell()
            axml_magic = B&#39;\x03\x00\x08\x00&#39;
            reader.seekset(self.data_offset)
            if reader.peek(4) == axml_magic and (usize := self.usize) and (reader.remaining_bytes &gt;= usize):
                self.data = reader.read_exactly(usize)
                self.method = ZipCompressionMethod.STORE
                self.crc32_ignored = True
                self.encryption = NoCrypto()
            else:
                reader.seekset(checkpoint)

        self.is64bit = is64bit

    def get_mtime(self):
        ts = None
        if dir := self.dir:
            if (ts := dir.ts) is None and (dt := dir.date):
                return dt
        if ts and (t := ts.mtime) or self.ts and (t := self.ts.mtime):
            return datetime.fromtimestamp(t)
        return self.date

    def get_ctime(self):
        if self.dir and (ts := self.dir.ts) and (t := ts.ctime) or (ts := self.ts) and (t := ts.ctime):
            return datetime.fromtimestamp(t)

    def get_atime(self):
        if self.dir and (ts := self.dir.ts) and (t := ts.atime) or (ts := self.ts) and (t := ts.atime):
            return datetime.fromtimestamp(t)

    def get_name(self):
        if (dir := self.dir) and (name := dir.name):
            return name
        return self.name

    def get_gid(self):
        if ux := (d.ux if (d := self.dir) else None) or self.ux:
            return ux.gid

    def get_uid(self):
        if ux := (d.ux if (d := self.dir) else None) or self.ux:
            return ux.uid

    def is_dir(self):
        return self.get_name().endswith((&#39;/&#39;, &#39;\\&#39;))

    def is_password_ok(self, password: str | None = None):
        return self.encryption.checkpwd(password)

    def unpack(self, password: str | None = None, check: bool = True):
        if not check or self.crc32_ignored:
            def _nocheck(x):
                return x
            _checked = _nocheck
        else:
            def _checker(unpacked: buf):
                crc32loc = self.crc32
                crc32dir = 0 if (dir := self.dir) is None else dir.crc32
                if crc32loc == 0 and crc32dir == 0:
                    return unpacked
                crc32 = zlib.crc32(unpacked)
                if crc32 == crc32loc or crc32 == crc32dir:
                    return unpacked
                raise InvalidChecksum(self, unpacked, crc32dir or crc32loc, crc32)
            _checked = _checker

        if (d := self.data) is None:
            raise ValueError(F&#39;The data for this {self.__class__.__name__} was not read.&#39;)
        if (u := self._unpacked) is not None:
            return _checked(u)

        if e := self.encryption:
            if password is None:
                raise PasswordRequired
            compressed = e.decrypt(password, d)
        else:
            compressed = d

        if (m := self.method) == ZipCompressionMethod.STORE:
            u = compressed
        elif m == ZipCompressionMethod.DEFLATE:
            u = zlib.decompress(compressed, -15)
        elif m == ZipCompressionMethod.DEFLATE64:
            from refinery.lib.seven.deflate import Deflate
            u = bytearray()
            deflate = Deflate(u, StructReader(memoryview(compressed)), df64=True)
            deflate.decode()
        elif m == ZipCompressionMethod.BZIP2:
            import bz2
            u = bz2.decompress(compressed)
        elif m == ZipCompressionMethod.LZMA:
            import lzma
            cv = memoryview(compressed)
            cr = StructReader(cv)
            _ = cr.u8() # major version
            _ = cr.u8() # minor version
            n = cr.u16()
            properties_data = cr.read_exactly(n)
            compressed_data = cr.read()
            decompressor = lzma.LZMADecompressor(
                lzma.FORMAT_RAW, filters=[parse_lzma_properties(properties_data, 1)])
            u = decompressor.decompress(compressed_data)
        elif m == ZipCompressionMethod.PPMD:
            from refinery.lib.shared.pyppmd import pyppmd
            cv = memoryview(compressed)
            cr = StructReaderBits(cv)
            order = 1 + cr.read_nibble()
            msize = 1 + cr.read_byte() &lt;&lt; 20
            rm = cr.read_nibble()
            ppmd = pyppmd.PpmdDecompressor(order, msize, restore_method=rm)
            u = ppmd.decompress(bytes(cr.read()))
        elif m == ZipCompressionMethod.ZSTD:
            from refinery.lib.shared.pyzstd import pyzstd
            dctx = pyzstd.ZstdDecompressor()
            u = dctx.decompress(compressed)
        elif m == ZipCompressionMethod.XZ:
            import lzma
            u = lzma.decompress(compressed, format=lzma.FORMAT_XZ)
        else:
            if m is not None:
                m = m.name
            raise NotImplementedError(F&#39;Compression method {m} is not implemented.&#39;)

        self._unpacked = u
        return _checked(u)


class ZipEndOfCentralDirectory(Struct):
    Signature = B&#39;PK\x05\x06&#39;

    def __init__(self, reader: StructReader[memoryview]):
        self.offset = reader.tell()
        if reader.read(4) != self.Signature:
            raise ValueError
        self.disk_number = reader.u16()
        self.start_disk_number = reader.u16()
        self.entries_on_disk = reader.u16()
        self.entries_in_directory = reader.u16()
        self.directory_size = reader.u32()
        self.directory_offset = reader.u32()
        self.comment_length = reader.u16()


class ZipEocdLocator64(Struct):
    Signature = B&#39;PK\x06\x07&#39;

    def __init__(self, reader: StructReader[memoryview]):
        if reader.read(4) != self.Signature:
            raise ValueError
        self.disk_with_eocd64 = reader.u32()
        self.offset = reader.u64()
        self.total_disks = reader.u32()


class ZipEndOfCentralDirectory64(Struct):
    Signature = B&#39;PK\x06\x06&#39;

    def __init__(self, reader: StructReader[memoryview]):
        self.offset = reader.tell()
        if reader.read(4) != self.Signature:
            raise ValueError
        self.eocd64_size = reader.u64()
        self.version_made_by = reader.u16()
        self.version_to_extract = reader.u16()
        self.disk_number = reader.u32()
        self.start_disk_number = reader.u32()
        self.entries_on_disk = reader.u64()
        self.entries_in_directory = reader.u64()
        self.directory_size = reader.u64()
        self.directory_offset = reader.u64()
        self.locator = ZipEocdLocator64(reader)
        self.eocd32 = ZipEndOfCentralDirectory(reader)


class ZipExtraField(Struct):
    def __init__(self, reader: StructReader[memoryview]):
        self.header_id = reader.u16()
        self.data_size = reader.u16()
        self.data = reader.read_exactly(self.data_size)

    @classmethod
    def ParseBuffer(cls, data: buf | None) -&gt; list[ZipExtraField]:
        if data is None:
            return []
        reader = StructReader(memoryview(data))
        extras = []
        while not reader.eof:
            try:
                extras.append(cls(reader))
            except EOFError:
                break
        return extras


class ZipExt(Struct):
    HeaderID: int

    @classmethod
    def TryParse(cls, extra: ZipExtraField, *args, **kwargs):
        if extra.header_id != cls.HeaderID:
            return None
        return cls.Parse(extra.data, *args, **kwargs)


class NoCrypto:
    def __len__(self):
        return 0

    def __buffer__(self, flags: int, /):
        return memoryview(B&#39;&#39;)

    def decrypt(self, password: str, data: buf):
        return data

    def checkpwd(self, password: str | None):
        return not password


class AExCrypto(Struct):
    def __init__(self, cr: StructReader[memoryview], ae: ZipExtAES):
        self.version = ae.version
        self.strength = ae.strength

        self.salt = cr.read((ae.strength + 1) &lt;&lt; 2)
        self.pvv = cr.read(2)
        if ae.version == 3:
            self.nonce = cr.read(12)
            self.auth_size = 16
        else:
            self.nonce = None
            self.auth_size = 10
        self.keylen = (ae.strength + 1) &lt;&lt; 3

    def _derive(self, password: str, salt: buf):
        from Cryptodome.Hash import SHA1
        from Cryptodome.Protocol.KDF import PBKDF2
        ks = self.keylen
        dk = ks + 2
        if self.version &lt; 3:
            dk += ks
        derived = PBKDF2(password, salt, dkLen=dk, count=1000, hmac_hash_module=SHA1)
        cr = StructReader(derived)
        key = cr.read(ks)
        mac = cr.read(ks) if self.version &lt; 3 else B&#39;&#39;
        pvv = cr.read()
        return key, mac, pvv

    def checkpwd(self, password: str | None):
        if password is None:
            return False
        _, _, dp = self._derive(password, self.salt)
        return dp == self.pvv

    def decrypt(self, password: str, data: buf):
        from Cryptodome.Cipher import AES
        from Cryptodome.Hash import HMAC, SHA1
        from Cryptodome.Util import Counter
        dk, dm, dp = self._derive(password, self.salt)
        if dp != self.pvv:
            raise InvalidPassword
        view = memoryview(data)
        ciphertext = view[:-self.auth_size]
        auth = view[-self.auth_size:]
        if self.version &lt; 3:
            hmac = HMAC.new(dm, ciphertext, SHA1).digest()
            if hmac[:10] != auth:
                raise DataIntegrityError
            ctr = Counter.new(128, initial_value=1, little_endian=True)
            cipher = AES.new(dk, AES.MODE_CTR, counter=ctr)
            result = cipher.decrypt(ciphertext)
        else:
            cipher = AES.new(dk, AES.MODE_GCM, nonce=self.nonce)
            result = cipher.decrypt(ciphertext)
            try:
                cipher.verify(auth)
            except ValueError as V:
                raise DataIntegrityError from V
        return result


class ZipExtAES(ZipExt):
    HeaderID = 0x9901

    def __init__(self, reader: StructReader[memoryview]):
        self.version = reader.u16()
        self.vendor = reader.u16()
        self.strength = reader.u8()
        if not 1 &lt;= self.strength &lt;= 3:
            raise ValueError(F&#39;Invalid AES strength {self.strength}.&#39;)
        self.method_value = reader.u16()
        try:
            self.method = ZipCompressionMethod(self.method_value)
        except ValueError:
            self.method = None


class ZipExtInfo64(ZipExt):
    HeaderID = 0x0001

    def __init__(
        self,
        reader: StructReader[memoryview],
        usize: int,
        csize: int,
        header_offset: int = 0,
        disk_nr_start: int = 0,
    ):
        self.usize = usize
        self.csize = csize
        self.header_offset = header_offset
        self.disk_nr_start = disk_nr_start

        if usize == 0xFFFFFFFF:
            self.usize = reader.u64()
        if csize == 0xFFFFFFFF:
            self.csize = reader.u64()
        if header_offset == 0xFFFFFFFF:
            self.header_offset = reader.u64()
        if disk_nr_start == 0xFFFF:
            self.disk_nr_start = reader.u32()


class ZipExtUnixIDs(ZipExt):
    HeaderID = 0x7875

    def __init__(self, reader: StructReader[memoryview]):
        self.version = reader.u8()
        self.uid = reader.read_integer(reader.u8() * 8)
        self.gid = reader.read_integer(reader.u8() * 8)


class ZipExtTimestampFlags(FlagAccessMixin, enum.IntFlag):
    Modification = 1
    Access = 2
    Creation = 4


class ZipExtTimestamp(ZipExt):
    HeaderID = 0x5455

    def __init__(self, reader: StructReader[memoryview]):
        self.flags = ZipExtTimestampFlags(reader.u8())
        self.mtime = None
        self.atime = None
        self.ctime = None
        if reader.remaining_bytes &gt;= 4 and self.flags.Modification:
            self.mtime = reader.u32()
        if reader.remaining_bytes &gt;= 4 and self.flags.Access:
            self.atime = reader.u32()
        if reader.remaining_bytes &gt;= 4 and self.flags.Creation:
            self.ctime = reader.u32()


class ZipExtUnicodePath(ZipExt):
    HeaderID = 0x7075

    def __init__(self, reader: StructReader[memoryview]):
        self.version = reader.u8()
        self.crc = reader.u32()
        self.name = codecs.decode(reader.read(), &#39;utf8&#39;)


class ZipDirEntry(Struct):
    Signature = B&#39;PK\x01\x02&#39;

    def is_dir(self):
        return self.name.endswith((&#39;/&#39;, &#39;\\&#39;))

    def __init__(self, reader: StructReader[memoryview]):
        if reader.read(4) != self.Signature:
            raise ValueError
        self.version_made_by = reader.u16()
        self.version_to_extract = reader.u16()
        self.flags = ZipFlags(reader.u16())
        self.method_value = reader.u16()
        try:
            self.compression = ZipCompressionMethod(self.method_value)
        except ValueError:
            self.compression = None
        try:
            self.date = dostime(reader.u32(peek=True))
        except Exception:
            self.date = None
        self.mtime = reader.u16()
        self.mdate = reader.u16()
        self.crc32 = reader.u32()
        self.csize = reader.u32()
        self.usize = reader.u32()
        nl = reader.u16()
        xl = reader.u16()
        cl = reader.u16()
        self.disk_nr_start = reader.u16()
        self.internal_attributes = ZipInternalFileAttributes(reader.u16())
        self.external_attributes = reader.u32()
        self.header_offset = reader.u32()
        self.name_bytes = reader.read_exactly(nl)
        extras = reader.read_exactly(xl)
        self.comment = reader.read_exactly(cl)
        self.xtra = ZipExtraField.ParseBuffer(extras)

        codec = &#39;utf8&#39; if self.flags.UseUTF8 else &#39;latin1&#39;
        self.name = codecs.decode(self.name_bytes, codec)

        self.ae = None
        self.up = None
        self.ux = None
        self.ts = None

        for x in self.xtra:
            if z64 := ZipExtInfo64.TryParse(x, self.usize, self.csize, self.header_offset, self.disk_nr_start):
                self.usize = z64.usize
                self.csize = z64.csize
                self.header_offset = z64.header_offset
                self.disk_nr_start = z64.disk_nr_start
            elif ae := ZipExtAES.TryParse(x):
                self.ae = ae
            elif up := ZipExtUnicodePath.TryParse(x):
                self.up = up
                if up.crc == zlib.crc32(self.name_bytes) &amp; 0xFFFFFFFF:
                    self.name = up.name
            elif ux := ZipExtUnixIDs.TryParse(x):
                self.ux = ux
            elif ts := ZipExtTimestamp.TryParse(x):
                self.ts = ts


class Zip:

    def parse_record(self, offset: int | None = None, read_data: bool = True, dir: ZipDirEntry | None = None):
        if offset is not None:
            self.reader.seekset(offset)
        return ZipFileRecord(
            self.reader,
            is64bit=self.is64bit,
            ddirs=self.ddirs,
            read_data=read_data,
            dir=dir,
        )

    def read(self, entry: str | int | ZipDirEntry):
        if isinstance(entry, str):
            entries = self.by_name[entry]
            if (c := len(entries)) &gt; 1:
                raise RuntimeError(F&#39;There are {c} central directory entries for: {entry}&#39;)
            entry = entries[0]
        if isinstance(entry, ZipDirEntry):
            start = entry.header_offset + self.shift
            dir = entry
        else:
            start = entry
            dir = None
        if start &lt; 0:
            raise EOFError(F&#39;Record referenced at {-start} bytes before start of file.&#39;)
        if (x := start - len(self.reader)) &gt;= 0:
            raise EOFError(F&#39;Record referenced at offset {x} from EOF.&#39;)
        try:
            return self.records[start]
        except KeyError:
            pass
        self.reader.seekset(start)
        self.records[start] = r = self.parse_record(dir=dir)
        self.coverage.addi(start, len(r))
        self.unreferenced_records.pop(start, None)
        return r

    def sub_archive_count(self):
        return sum(sub.sub_archive_count() + 1 for sub in self.sub_archives.values())

    def __init__(
        self,
        data: buf,
        password: str | None = None,
        read_records: bool = True,
        read_unreferenced_records: bool = True,
        sub_archives_covered: bool = True,
    ):
        self.reader = reader = StructReader(view := memoryview(data))
        self.is64bit = True
        self.coverage = coverage = IntIntervalUnion()
        self.password = password

        self.has_pk00_header = (data[:4] == B&#39;PK00&#39;)
        if self.has_pk00_header:
            self.coverage.addi(0, 4)

        for EOCD in (
            ZipEndOfCentralDirectory64,
            ZipEndOfCentralDirectory,
        ):
            if (end := buffer_offset(view, EOCD.Signature, back2front=True)) &gt;= 0:
                reader.seekset(end)
                self.offset_eocd = end
                self.eocd = eocd = EOCD(reader)
                coverage.addi(end, len(eocd))
                break
            else:
                self.is64bit = False
        else:
            raise ValueError(&#39;No EOCD.&#39;)

        start = eocd.directory_offset
        self.shift = end - eocd.directory_size - start
        if self.shift:
            start = end - eocd.directory_size
        if start &lt; 0:
            raise ValueError(&#39;Invalid end of central directory size&#39;)
        self.offset_directory = start
        reader.seekset(start)
        apksig = None

        for sb in (
            ApkSigningBlock42,
            RpkSigningBlock42,
            ApkSigningBlock42_VariantWithAt,
            UnknownSigningBlockPK57,
        ):
            self.apksig = sb.FromCentralDir(reader)
            if (apksig := self.apksig):
                coverage.addi(apksig.offset, len(apksig))
                break

        if reader.peek(4) == ZipArchiveExtraDataRecord.Signature:
            self.archive_extra_data = ZipArchiveExtraDataRecord(reader)
            coverage.addi(start, len(self.archive_extra_data))
            start = reader.tell()
        else:
            self.archive_extra_data = None

        if reader.peek(4) != ZipDirEntry.Signature:
            self.encryption = ZipEncryptionHeader(reader)
            coverage.addi(start, len(self.encryption))
            start = reader.tell()
            size = eocd.directory_size - (start - self.offset_directory)
            self.encrypted_directory = reader.read_exactly(size)
            coverage.addi(start, size)
            if password is None:
                raise PasswordRequired
            decrypted_cd = self.encryption.decrypt(password, self.encrypted_directory)
            cd = StructReader(memoryview(decrypted_cd))
            self.directory = [
                ZipDirEntry(cd) for _ in range(eocd.entries_in_directory)
            ]
        else:
            self.encryption = None
            self.encrypted_directory = None
            self.directory = [
                ZipDirEntry(reader) for _ in range(eocd.entries_in_directory)
            ]
            coverage.addi(start, sum(len(d) for d in self.directory))

        by_name: dict[str, list[ZipDirEntry]] = {}
        self.by_name = by_name

        for entry in self.directory:
            by_name.setdefault(entry.name, []).append(entry)

        records: dict[int, ZipFileRecord] = {}
        unreferenced_records: dict[int, ZipFileRecord] = {}
        unreferenced_dirents: dict[int, ZipDirEntry] = {}
        self.records = records
        self.unreferenced_records = unreferenced_records
        self.unreferenced_dirents = unreferenced_dirents
        start = reader.tell()

        if reader.peek(4) == ZipDigitalSignature.Signature:
            self.digital_signature = ZipDigitalSignature(reader)
            coverage.addi(start, len(self.digital_signature))
            start = reader.tell()
        else:
            self.digital_signature = None

        self.ddirs = [match.start()
            for match in re.finditer(re.escape(ZipDataDescriptor.Signature), view)]

        if not read_records:
            return

        verdicts64bit = {self.is64bit}

        for entry in self.directory:
            try:
                record = self.read(entry)
            except Exception:
                pass
            else:
                verdicts64bit.add(record.is64bit)

        if len(verdicts64bit) == 2:
            # For at least one record, a data descriptor indicated that our 64-bit assumption
            # was incorrect. We try to re-parse with the opposite assumption and use whatever
            # produces more correctly parsed records.
            backup_records = self.records
            self.records.clear()
            self.is64bit = not self.is64bit
            for entry in self.directory:
                try:
                    record = self.read(entry)
                except Exception:
                    pass
            self.is64bit = not self.is64bit
            if len(self.records) &lt; len(backup_records):
                self.records = backup_records

        sub_archives: dict[int, Zip] = {}
        end = self.eocd.offset

        while True:
            try:
                sub = Zip(view[:end], read_unreferenced_records=False)
            except Exception:
                break
            if (sub_eocd := sub.eocd.offset) in self.coverage:
                end = sub_eocd
                continue
            sub_archives[sub_eocd] = sub
            if sub_archives_covered:
                for i in sub.coverage:
                    self.coverage.addi(*i)
            end = sub.eocd.offset

        self.sub_archives = sub_archives

        if not read_unreferenced_records:
            return

        for start, end in list(coverage.gaps(0, len(view))):
            gap = view[start:end]
            if apksig and end == apksig.offset and not any(gap):
                coverage.addi(start, len(gap))
                continue
            while gap[:2] == B&#39;PK&#39;:
                reader.seekset(start)
                if gap[:4] == ZipDirEntry.Signature:
                    try:
                        r = ZipDirEntry(reader)
                        n = len(r)
                    except Exception:
                        break
                    unreferenced_dirents[start] = r
                elif gap[:4] == ZipFileRecord.Signature:
                    try:
                        r = self.parse_record(read_data=False)
                        n = len(r)
                    except Exception:
                        break
                    if gap[n:n + 4] != ZipFileRecord.Signature and len(gap) &gt;= n + r.csize:
                        reader.seekset(start)
                        try:
                            r = self.parse_record()
                        except Exception:
                            pass
                        else:
                            n = len(r)
                    unreferenced_records[start] = r
                else:
                    break
                gap = gap[n:]
                coverage.addi(start, n)
                start += n</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.zip.PasswordRequired"><code class="flex name class">
<span>class <span class="ident">PasswordRequired</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Common base class for all non-exit exceptions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L28-L29" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PasswordRequired(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.zip.InvalidPassword"><code class="flex name class">
<span>class <span class="ident">InvalidPassword</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Inappropriate argument value (of correct type).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L32-L33" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InvalidPassword(ValueError):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.zip.InvalidChecksum"><code class="flex name class">
<span>class <span class="ident">InvalidChecksum</span></span>
<span>(</span><span>record, data, expected, computed)</span>
</code></dt>
<dd>
<section class="desc"><p>Inappropriate argument value (of correct type).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L36-L47" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InvalidChecksum(ValueError):
    def __init__(self, record: ZipFileRecord, data: buf, expected: int, computed: int) -&gt; None:
        self.record = record
        self.data = data
        self.expected = expected
        self.computed = computed

    def __str__(self):
        return (
            F&#39;Invalid checksum for {self.record.name};&#39;
            F&#39; computed {self.computed:08X},&#39;
            F&#39; expected {self.expected:08X}.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.zip.DataIntegrityError"><code class="flex name class">
<span>class <span class="ident">DataIntegrityError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Inappropriate argument value (of correct type).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L50-L51" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DataIntegrityError(ValueError):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.zip.ZipAnomalies"><code class="flex name class">
<span>class <span class="ident">ZipAnomalies</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L54-L56" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipAnomalies(enum.IntFlag):
    Normal = 0
    DataDescriptorWithoutHeader = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipAnomalies.Normal"><code class="name">var <span class="ident">Normal</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipAnomalies.DataDescriptorWithoutHeader"><code class="name">var <span class="ident">DataDescriptorWithoutHeader</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipFlags"><code class="flex name class">
<span>class <span class="ident">ZipFlags</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>This class can be mixed into an <code>enum.IntFlag</code> for some quality of life improvements. Firstly,
you can now access flags as follows:</p>
<pre><code>class Flags(FlagAccessMixin, enum.IntFlag):
    IsBinary = 1
    IsCompressed = 2

flag = Flags(3)

if flag.IsCompressed:
    decompress()
</code></pre>
<p>Furthermore, flag values can be enumerated:</p>
<pre><code>&gt;&gt;&gt; list(flag)
[IsBinary, IsCompressed]
&gt;&gt;&gt; flag
IsBinary|IsCompressed
</code></pre>
<p>And finally, as visible from the above output, flag values are represented by their name by
default.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L59-L68" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipFlags(FlagAccessMixin, enum.IntFlag):
    Encrypted           = 0x0001 # noqa
    CompressOption1     = 0x0002 # noqa
    CompressOption2     = 0x0004 # noqa
    DataDescriptor      = 0x0008 # noqa
    EnhancedDeflate     = 0x0010 # noqa
    CompressedPatched   = 0x0020 # noqa
    StrongEncryption    = 0x0040 # noqa
    UseUTF8             = 0x0800 # noqa
    EncryptedCD         = 0x2000 # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.FlagAccessMixin" href="structures.html#refinery.lib.structures.FlagAccessMixin">FlagAccessMixin</a></li>
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipFlags.Encrypted"><code class="name">var <span class="ident">Encrypted</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipFlags.CompressOption1"><code class="name">var <span class="ident">CompressOption1</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipFlags.CompressOption2"><code class="name">var <span class="ident">CompressOption2</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipFlags.DataDescriptor"><code class="name">var <span class="ident">DataDescriptor</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipFlags.EnhancedDeflate"><code class="name">var <span class="ident">EnhancedDeflate</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipFlags.CompressedPatched"><code class="name">var <span class="ident">CompressedPatched</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipFlags.StrongEncryption"><code class="name">var <span class="ident">StrongEncryption</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipFlags.UseUTF8"><code class="name">var <span class="ident">UseUTF8</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipFlags.EncryptedCD"><code class="name">var <span class="ident">EncryptedCD</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionAlgorithm"><code class="flex name class">
<span>class <span class="ident">ZipEncryptionAlgorithm</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L71-L83" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipEncryptionAlgorithm(enum.IntEnum):
    DES             = 0x6601 # noqa
    BuggyRC2        = 0x6602 # noqa (version needed to extract &lt; 5.2)
    TrippleDES168   = 0x6603 # noqa
    TrippleDES112   = 0x6609 # noqa
    AES128          = 0x660E # noqa
    AES192          = 0x660F # noqa
    AES256          = 0x6610 # noqa
    RC2             = 0x6702 # noqa (version needed to extract &gt;= 5.2)
    Blowfish        = 0x6720 # noqa
    Twofish         = 0x6721 # noqa
    RC4             = 0x6801 # noqa
    Unknown         = 0xFFFF # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipEncryptionAlgorithm.DES"><code class="name">var <span class="ident">DES</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionAlgorithm.BuggyRC2"><code class="name">var <span class="ident">BuggyRC2</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionAlgorithm.TrippleDES168"><code class="name">var <span class="ident">TrippleDES168</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionAlgorithm.TrippleDES112"><code class="name">var <span class="ident">TrippleDES112</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionAlgorithm.AES128"><code class="name">var <span class="ident">AES128</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionAlgorithm.AES192"><code class="name">var <span class="ident">AES192</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionAlgorithm.AES256"><code class="name">var <span class="ident">AES256</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionAlgorithm.RC2"><code class="name">var <span class="ident">RC2</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionAlgorithm.Blowfish"><code class="name">var <span class="ident">Blowfish</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionAlgorithm.Twofish"><code class="name">var <span class="ident">Twofish</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionAlgorithm.RC4"><code class="name">var <span class="ident">RC4</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionAlgorithm.Unknown"><code class="name">var <span class="ident">Unknown</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionFlags"><code class="flex name class">
<span>class <span class="ident">ZipEncryptionFlags</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>This class can be mixed into an <code>enum.IntFlag</code> for some quality of life improvements. Firstly,
you can now access flags as follows:</p>
<pre><code>class Flags(FlagAccessMixin, enum.IntFlag):
    IsBinary = 1
    IsCompressed = 2

flag = Flags(3)

if flag.IsCompressed:
    decompress()
</code></pre>
<p>Furthermore, flag values can be enumerated:</p>
<pre><code>&gt;&gt;&gt; list(flag)
[IsBinary, IsCompressed]
&gt;&gt;&gt; flag
IsBinary|IsCompressed
</code></pre>
<p>And finally, as visible from the above output, flag values are represented by their name by
default.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L86-L88" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipEncryptionFlags(FlagAccessMixin, enum.IntFlag):
    DecryptWithPassword = 1
    DecryptWithCertificate = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.FlagAccessMixin" href="structures.html#refinery.lib.structures.FlagAccessMixin">FlagAccessMixin</a></li>
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipEncryptionFlags.DecryptWithPassword"><code class="name">var <span class="ident">DecryptWithPassword</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionFlags.DecryptWithCertificate"><code class="name">var <span class="ident">DecryptWithCertificate</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod"><code class="flex name class">
<span>class <span class="ident">ZipCompressionMethod</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L91-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipCompressionMethod(enum.IntEnum):
    STORE           = 0x00 # noqa
    SHRINK          = 0x01 # noqa
    REDUCED1        = 0x02 # noqa
    REDUCED2        = 0x03 # noqa
    REDUCED3        = 0x04 # noqa
    REDUCED4        = 0x05 # noqa
    IMPLODE         = 0x06 # noqa
    TOKENIZE        = 0x07 # noqa
    DEFLATE         = 0x08 # noqa
    DEFLATE64       = 0x09 # noqa
    PKWARE_IMPLODE  = 0x0A # noqa
    BZIP2           = 0x0C # noqa
    LZMA            = 0x0E # noqa
    IBM_CMPSC       = 0x10 # noqa
    IBM_TERSE       = 0x12 # noqa
    IBM_LZ77        = 0x13 # noqa
    ZSTD_DEPRECATED = 0x14 # noqa
    ZSTD            = 0x5D # noqa
    MP3             = 0x5E # noqa
    XZ              = 0x5F # noqa
    JPEG            = 0x60 # noqa
    WAVPACK         = 0x61 # noqa
    PPMD            = 0x62 # noqa
    AExENCRYPTION   = 0x63 # noqa
    RESERVED11      = 0x0B # noqa
    RESERVED13      = 0x0D # noqa
    RESERVED15      = 0x0F # noqa
    RESERVED17      = 0x11 # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipCompressionMethod.STORE"><code class="name">var <span class="ident">STORE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.SHRINK"><code class="name">var <span class="ident">SHRINK</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.REDUCED1"><code class="name">var <span class="ident">REDUCED1</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.REDUCED2"><code class="name">var <span class="ident">REDUCED2</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.REDUCED3"><code class="name">var <span class="ident">REDUCED3</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.REDUCED4"><code class="name">var <span class="ident">REDUCED4</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.IMPLODE"><code class="name">var <span class="ident">IMPLODE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.TOKENIZE"><code class="name">var <span class="ident">TOKENIZE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.DEFLATE"><code class="name">var <span class="ident">DEFLATE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.DEFLATE64"><code class="name">var <span class="ident">DEFLATE64</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.PKWARE_IMPLODE"><code class="name">var <span class="ident">PKWARE_IMPLODE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.BZIP2"><code class="name">var <span class="ident">BZIP2</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.LZMA"><code class="name">var <span class="ident">LZMA</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.IBM_CMPSC"><code class="name">var <span class="ident">IBM_CMPSC</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.IBM_TERSE"><code class="name">var <span class="ident">IBM_TERSE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.IBM_LZ77"><code class="name">var <span class="ident">IBM_LZ77</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.ZSTD_DEPRECATED"><code class="name">var <span class="ident">ZSTD_DEPRECATED</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.ZSTD"><code class="name">var <span class="ident">ZSTD</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.MP3"><code class="name">var <span class="ident">MP3</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.XZ"><code class="name">var <span class="ident">XZ</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.JPEG"><code class="name">var <span class="ident">JPEG</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.WAVPACK"><code class="name">var <span class="ident">WAVPACK</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.PPMD"><code class="name">var <span class="ident">PPMD</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.AExENCRYPTION"><code class="name">var <span class="ident">AExENCRYPTION</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.RESERVED11"><code class="name">var <span class="ident">RESERVED11</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.RESERVED13"><code class="name">var <span class="ident">RESERVED13</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.RESERVED15"><code class="name">var <span class="ident">RESERVED15</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipCompressionMethod.RESERVED17"><code class="name">var <span class="ident">RESERVED17</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipCrypto"><code class="flex name class">
<span>class <span class="ident">ZipCrypto</span></span>
<span>(</span><span>reader, crc)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L122-L156" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipCrypto(Struct):
    CRC32Table: list[int] = []

    def __init__(self, reader: StructReader, crc: int):
        if not (ct := self.CRC32Table):
            for c in range(256):
                for _ in range(8):
                    c, x = divmod(c, 2)
                    c ^= x * 0xEDB88320
                ct.append(c)
        self.header = reader.read(12)
        self.crc = crc
        self._restart()

    def __buffer__(self, flags: int, /):
        return memoryview(self.header)

    def _restart(self):
        self.state = (0x12345678, 0x23456789, 0x34567890)

    def _decrypt(self, password: bytes, data: buf):
        result, *self.state = zipcrypto.decrypt(password, data, *self.state)
        return result

    def checkpwd(self, password: str | None):
        if password is None:
            return False
        self._restart()
        head = self._decrypt(password.encode(&#39;latin1&#39;), self.header)
        return head[11] == (self.crc &gt;&gt; 24) &amp; 0xFF

    def decrypt(self, password: str, data: buf):
        if not self.checkpwd(password):
            raise InvalidPassword
        return self._decrypt(b&#39;&#39;, data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipCrypto.CRC32Table"><code class="name">var <span class="ident">CRC32Table</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipCrypto.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipCrypto.checkpwd"><code class="name flex">
<span>def <span class="ident">checkpwd</span></span>(<span>self, password)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L146-L151" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkpwd(self, password: str | None):
    if password is None:
        return False
    self._restart()
    head = self._decrypt(password.encode(&#39;latin1&#39;), self.header)
    return head[11] == (self.crc &gt;&gt; 24) &amp; 0xFF</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.ZipCrypto.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self, password, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L153-L156" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decrypt(self, password: str, data: buf):
    if not self.checkpwd(password):
        raise InvalidPassword
    return self._decrypt(b&#39;&#39;, data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipInternalFileAttributes"><code class="flex name class">
<span>class <span class="ident">ZipInternalFileAttributes</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>This class can be mixed into an <code>enum.IntFlag</code> for some quality of life improvements. Firstly,
you can now access flags as follows:</p>
<pre><code>class Flags(FlagAccessMixin, enum.IntFlag):
    IsBinary = 1
    IsCompressed = 2

flag = Flags(3)

if flag.IsCompressed:
    decompress()
</code></pre>
<p>Furthermore, flag values can be enumerated:</p>
<pre><code>&gt;&gt;&gt; list(flag)
[IsBinary, IsCompressed]
&gt;&gt;&gt; flag
IsBinary|IsCompressed
</code></pre>
<p>And finally, as visible from the above output, flag values are represented by their name by
default.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L159-L161" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipInternalFileAttributes(FlagAccessMixin, enum.IntFlag):
    ApparentText = 0x0001
    RecordLengthControl = 0x0002</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.FlagAccessMixin" href="structures.html#refinery.lib.structures.FlagAccessMixin">FlagAccessMixin</a></li>
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipInternalFileAttributes.ApparentText"><code class="name">var <span class="ident">ApparentText</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipInternalFileAttributes.RecordLengthControl"><code class="name">var <span class="ident">RecordLengthControl</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.SigningBlock42Entry"><code class="flex name class">
<span>class <span class="ident">SigningBlock42Entry</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L164-L168" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SigningBlock42Entry(Struct):
    def __init__(self, reader: StructReader[memoryview]):
        length = reader.u64()
        self.id = reader.u32()
        self.value = reader.read_exactly(length - 4)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.SigningBlock42Entry.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.PkgSigningBlock"><code class="flex name class">
<span>class <span class="ident">PkgSigningBlock</span></span>
<span>(</span><span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L171-L196" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PkgSigningBlock(Struct):
    Signature = None
    SeekDelta = 0

    @classmethod
    def FromCentralDir(cls, reader: StructReader[memoryview]) -&gt; Self | None:
        cd = reader.tell()
        sd = cls.SeekDelta
        sb = cls.Signature
        if sb is None:
            raise NotImplementedError
        if (seek := cd - len(sb) - 8) &gt;= 0:
            reader.seekset(seek)
            size = reader.u64()
            if reader.read(len(sb)) != sb:
                return None
            if (seek := reader.tell() - size - sd) &gt;= 0:
                reader.seekset(seek)
                try:
                    apksig = cls(reader, size)
                except (ValueError, EOFError):
                    reader.seekset(cd)
                    return None
                if (m := len(apksig)) != (n := size + sd):
                    raise ValueError(F&#39;Size mismatch: {m} != {n}.&#39;)
                return apksig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.zip.ApkSigningBlock42" href="#refinery.lib.zip.ApkSigningBlock42">ApkSigningBlock42</a></li>
<li><a title="refinery.lib.zip.UnknownSigningBlockPK57" href="#refinery.lib.zip.UnknownSigningBlockPK57">UnknownSigningBlockPK57</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.PkgSigningBlock.Signature"><code class="name">var <span class="ident">Signature</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.PkgSigningBlock.SeekDelta"><code class="name">var <span class="ident">SeekDelta</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.PkgSigningBlock.FromCentralDir"><code class="name flex">
<span>def <span class="ident">FromCentralDir</span></span>(<span>reader)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.zip.PkgSigningBlock.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ApkSigningBlock42"><code class="flex name class">
<span>class <span class="ident">ApkSigningBlock42</span></span>
<span>(</span><span>reader, size)</span>
</code></dt>
<dd>
<section class="desc"><p>The standard APK signing block.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L199-L224" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ApkSigningBlock42(PkgSigningBlock):
    &#34;&#34;&#34;
    The standard APK signing block.
    &#34;&#34;&#34;
    Signature = B&#39;APK Sig Block 42&#39;
    SeekDelta = 8

    def __init__(self, reader: StructReader[memoryview], size: int):
        self.offset = reader.tell()
        n = reader.u64()
        if n != size or n &lt; 0x18:
            raise ValueError(F&#39;Invalid length {n} for {self.__class__.__name__}.&#39;)
        self.data = reader.read_exactly(n - 0x18)
        body = StructReader(self.data)
        if (m := reader.u64()) != n:
            raise ValueError(F&#39;Size mismatch: {m} != {n}.&#39;)
        if reader.read(0x10) != self.Signature:
            raise ValueError(&#39;Invalid signature.&#39;)
        fields: list[SigningBlock42Entry] = []
        try:
            while not body.eof:
                fields.append(SigningBlock42Entry(body))
        except (ValueError, EOFError):
            self.fields = None
        else:
            self.fields = fields</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.zip.PkgSigningBlock" href="#refinery.lib.zip.PkgSigningBlock">PkgSigningBlock</a></li>
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.zip.ApkSigningBlock42_VariantWithAt" href="#refinery.lib.zip.ApkSigningBlock42_VariantWithAt">ApkSigningBlock42_VariantWithAt</a></li>
<li><a title="refinery.lib.zip.RpkSigningBlock42" href="#refinery.lib.zip.RpkSigningBlock42">RpkSigningBlock42</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ApkSigningBlock42.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.zip.PkgSigningBlock" href="#refinery.lib.zip.PkgSigningBlock">PkgSigningBlock</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.zip.PkgSigningBlock.SeekDelta" href="#refinery.lib.zip.PkgSigningBlock.SeekDelta">SeekDelta</a></code></li>
<li><code><a title="refinery.lib.zip.PkgSigningBlock.Signature" href="#refinery.lib.zip.PkgSigningBlock.Signature">Signature</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.zip.RpkSigningBlock42"><code class="flex name class">
<span>class <span class="ident">RpkSigningBlock42</span></span>
<span>(</span><span>reader, size)</span>
</code></dt>
<dd>
<section class="desc"><p>Rapid Package variant of the signing block. Also known as MiniApp.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L227-L231" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RpkSigningBlock42(ApkSigningBlock42):
    &#34;&#34;&#34;
    Rapid Package variant of the signing block. Also known as MiniApp.
    &#34;&#34;&#34;
    Signature = B&#39;RPK Sig Block 42&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.zip.ApkSigningBlock42" href="#refinery.lib.zip.ApkSigningBlock42">ApkSigningBlock42</a></li>
<li><a title="refinery.lib.zip.PkgSigningBlock" href="#refinery.lib.zip.PkgSigningBlock">PkgSigningBlock</a></li>
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.RpkSigningBlock42.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.zip.ApkSigningBlock42" href="#refinery.lib.zip.ApkSigningBlock42">ApkSigningBlock42</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.zip.ApkSigningBlock42.SeekDelta" href="#refinery.lib.zip.PkgSigningBlock.SeekDelta">SeekDelta</a></code></li>
<li><code><a title="refinery.lib.zip.ApkSigningBlock42.Signature" href="#refinery.lib.zip.PkgSigningBlock.Signature">Signature</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.zip.ApkSigningBlock42_VariantWithAt"><code class="flex name class">
<span>class <span class="ident">ApkSigningBlock42_VariantWithAt</span></span>
<span>(</span><span>reader, size)</span>
</code></dt>
<dd>
<section class="desc"><p>An unknown variant of the APK signing block with an @ symbol instead of A. Seen in:
e85f49b2234cc84d222e57a24c905cd37ceaf460a55e38956389e759f2ffd0a8</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L234-L239" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ApkSigningBlock42_VariantWithAt(ApkSigningBlock42):
    &#34;&#34;&#34;
    An unknown variant of the APK signing block with an @ symbol instead of A. Seen in:
    e85f49b2234cc84d222e57a24c905cd37ceaf460a55e38956389e759f2ffd0a8
    &#34;&#34;&#34;
    Signature = B&#39;@PK Sig Block 42&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.zip.ApkSigningBlock42" href="#refinery.lib.zip.ApkSigningBlock42">ApkSigningBlock42</a></li>
<li><a title="refinery.lib.zip.PkgSigningBlock" href="#refinery.lib.zip.PkgSigningBlock">PkgSigningBlock</a></li>
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ApkSigningBlock42_VariantWithAt.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.zip.ApkSigningBlock42" href="#refinery.lib.zip.ApkSigningBlock42">ApkSigningBlock42</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.zip.ApkSigningBlock42.SeekDelta" href="#refinery.lib.zip.PkgSigningBlock.SeekDelta">SeekDelta</a></code></li>
<li><code><a title="refinery.lib.zip.ApkSigningBlock42.Signature" href="#refinery.lib.zip.PkgSigningBlock.Signature">Signature</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.zip.UnknownSigningBlockPK57"><code class="flex name class">
<span>class <span class="ident">UnknownSigningBlockPK57</span></span>
<span>(</span><span>reader, size)</span>
</code></dt>
<dd>
<section class="desc"><p>Unknown block of what appears to be a custom signature, seen in:
fc5a13755bc0a744ea2c0807eee83823a03cdb28bf99c5d40419719a2b159cb4</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L242-L258" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class UnknownSigningBlockPK57(PkgSigningBlock):
    &#34;&#34;&#34;
    Unknown block of what appears to be a custom signature, seen in:
    fc5a13755bc0a744ea2c0807eee83823a03cdb28bf99c5d40419719a2b159cb4
    &#34;&#34;&#34;
    Signature = B&#39;PK\x05\x07&#39;
    SeekDelta = 12

    def __init__(self, reader: StructReader[memoryview], size: int):
        self.offset = reader.tell()
        self.unknown = reader.u32()
        self.signature = reader.read(size - 4)
        self.size = reader.u64()
        if self.size != size:
            raise ValueError
        if reader.read(4) != self.Signature:
            raise ValueError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.zip.PkgSigningBlock" href="#refinery.lib.zip.PkgSigningBlock">PkgSigningBlock</a></li>
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.UnknownSigningBlockPK57.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.zip.PkgSigningBlock" href="#refinery.lib.zip.PkgSigningBlock">PkgSigningBlock</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.zip.PkgSigningBlock.SeekDelta" href="#refinery.lib.zip.PkgSigningBlock.SeekDelta">SeekDelta</a></code></li>
<li><code><a title="refinery.lib.zip.PkgSigningBlock.Signature" href="#refinery.lib.zip.PkgSigningBlock.Signature">Signature</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionHeader"><code class="flex name class">
<span>class <span class="ident">ZipEncryptionHeader</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L261-L384" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipEncryptionHeader(Struct):
    def __init__(self, reader: StructReader[memoryview]):
        self.iv = bytes(reader.read_exactly(reader.u16()))
        self.header_size = reader.u32()
        self.format = reader.u16()
        if self.format != 3:
            raise ValueError(F&#39;Invalid format {self.format:#x} in {self.__class__.__name__}.&#39;)
        self.algorithm = ZipEncryptionAlgorithm(reader.u16())
        self.bitlen = reader.u16()
        self.flags = ZipEncryptionFlags(reader.u16())
        self.erd = reader.read_exactly(reader.u16())
        self.reserved1 = r1 = reader.u32()
        self.reserved2 = reader.read_exactly(reader.u16()) if r1 else None
        if (vn := reader.u16()) &lt;= 4:
            raise ValueError(F&#39;Invalid size {vn} for validation data in {self.__class__.__name__}.&#39;)
        self.validation = reader.read_exactly(vn - 4)
        self.crc32 = reader.u32()
        self._derivations = {}

    def derive_key(self, password: str):
        def _cipher(key):
            if block_cipher is None:
                return ARC4.new(key)
            iv = self.iv[:block_cipher.block_size]
            return block_cipher.new(key, getattr(block_cipher, &#39;MODE_CBC&#39;), iv=iv)
        try:
            derived = self._derivations[password]
        except KeyError:
            from Cryptodome.Cipher import AES, ARC2, ARC4, DES, DES3, Blowfish
            from Cryptodome.Hash import SHA1
            from Cryptodome.Protocol.KDF import PBKDF2

            algorithm = self.algorithm
            key_size = 16

            if algorithm == ZipEncryptionAlgorithm.AES128:
                block_cipher = AES
            elif algorithm == ZipEncryptionAlgorithm.AES192:
                key_size = 24
                block_cipher = AES
            elif algorithm == ZipEncryptionAlgorithm.AES256:
                key_size = 32
                block_cipher = AES
            elif algorithm == ZipEncryptionAlgorithm.DES:
                key_size = 8
                block_cipher = DES
            elif algorithm == ZipEncryptionAlgorithm.TrippleDES168:
                key_size = 24
                block_cipher = DES3
            elif algorithm == ZipEncryptionAlgorithm.TrippleDES112:
                block_cipher = DES3
            elif algorithm == ZipEncryptionAlgorithm.RC2:
                block_cipher = ARC2
            elif algorithm == ZipEncryptionAlgorithm.RC4:
                block_cipher = None
            elif algorithm == ZipEncryptionAlgorithm.Blowfish:
                block_cipher = Blowfish
            elif algorithm == ZipEncryptionAlgorithm.BuggyRC2:
                raise NotImplementedError(
                    F&#39;This ZIP uses a buggy and unsupported RC2 implementation, indicated by the legacy identifier {algorithm:#x}.&#39;)
            elif algorithm == ZipEncryptionAlgorithm.Twofish:
                raise NotImplementedError(
                    &#39;This ZIP uses the unsupported Twofish encryption mode.&#39;)
            else:
                raise ValueError(
                    F&#39;Unsupported encryption algorithm {algorithm:#x}.&#39;)

            password_hash = SHA1.new(password.encode(&#39;utf-8&#39;)).digest()
            master_key_material = PBKDF2(
                password_hash.decode(&#39;latin1&#39;),
                password_hash,
                dkLen=key_size * 2 + 2,
                count=1000,
                hmac_hash_module=SHA1
            )
            master_key = master_key_material[:key_size]

            rd = _cipher(master_key).decrypt(self.erd)
            iv = SHA1.new(self.iv + rd).digest()
            key_material = PBKDF2(
                iv.decode(&#39;latin1&#39;),
                iv,
                dkLen=key_size * 2 + 2,
                count=1000,
                hmac_hash_module=SHA1
            )

            data_key = key_material[:key_size]
            auth_key = key_material[key_size:key_size * 2]
            password_verify = key_material[key_size * 2:key_size * 2 + 2]

            if password_verify != self.validation[:2]:
                self._derivations[password] = None
                raise InvalidPassword
            else:
                self._derivations[password] = block_cipher, data_key, auth_key
        else:
            if derived is None:
                raise InvalidPassword
            block_cipher, data_key, auth_key = derived

        return _cipher(data_key), auth_key

    def checkpwd(self, password: str | None):
        if password is None:
            return False
        try:
            self.derive_key(password)
        except InvalidPassword:
            return False
        else:
            return True

    def decrypt(self, password: str, data: bytes):
        from Cryptodome.Hash import HMAC, SHA1
        cipher, hmk = self.derive_key(password)

        if len(self.validation) &gt; 2:
            computed_hmac = HMAC.new(hmk, data, SHA1).digest()
            expected_hmac = self.validation[2:12] if len(self.validation) &gt;= 12 else self.validation[2:]
            if computed_hmac[:len(expected_hmac)] != expected_hmac:
                raise DataIntegrityError

        return cipher.decrypt(data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipEncryptionHeader.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipEncryptionHeader.derive_key"><code class="name flex">
<span>def <span class="ident">derive_key</span></span>(<span>self, password)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L280-L362" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def derive_key(self, password: str):
    def _cipher(key):
        if block_cipher is None:
            return ARC4.new(key)
        iv = self.iv[:block_cipher.block_size]
        return block_cipher.new(key, getattr(block_cipher, &#39;MODE_CBC&#39;), iv=iv)
    try:
        derived = self._derivations[password]
    except KeyError:
        from Cryptodome.Cipher import AES, ARC2, ARC4, DES, DES3, Blowfish
        from Cryptodome.Hash import SHA1
        from Cryptodome.Protocol.KDF import PBKDF2

        algorithm = self.algorithm
        key_size = 16

        if algorithm == ZipEncryptionAlgorithm.AES128:
            block_cipher = AES
        elif algorithm == ZipEncryptionAlgorithm.AES192:
            key_size = 24
            block_cipher = AES
        elif algorithm == ZipEncryptionAlgorithm.AES256:
            key_size = 32
            block_cipher = AES
        elif algorithm == ZipEncryptionAlgorithm.DES:
            key_size = 8
            block_cipher = DES
        elif algorithm == ZipEncryptionAlgorithm.TrippleDES168:
            key_size = 24
            block_cipher = DES3
        elif algorithm == ZipEncryptionAlgorithm.TrippleDES112:
            block_cipher = DES3
        elif algorithm == ZipEncryptionAlgorithm.RC2:
            block_cipher = ARC2
        elif algorithm == ZipEncryptionAlgorithm.RC4:
            block_cipher = None
        elif algorithm == ZipEncryptionAlgorithm.Blowfish:
            block_cipher = Blowfish
        elif algorithm == ZipEncryptionAlgorithm.BuggyRC2:
            raise NotImplementedError(
                F&#39;This ZIP uses a buggy and unsupported RC2 implementation, indicated by the legacy identifier {algorithm:#x}.&#39;)
        elif algorithm == ZipEncryptionAlgorithm.Twofish:
            raise NotImplementedError(
                &#39;This ZIP uses the unsupported Twofish encryption mode.&#39;)
        else:
            raise ValueError(
                F&#39;Unsupported encryption algorithm {algorithm:#x}.&#39;)

        password_hash = SHA1.new(password.encode(&#39;utf-8&#39;)).digest()
        master_key_material = PBKDF2(
            password_hash.decode(&#39;latin1&#39;),
            password_hash,
            dkLen=key_size * 2 + 2,
            count=1000,
            hmac_hash_module=SHA1
        )
        master_key = master_key_material[:key_size]

        rd = _cipher(master_key).decrypt(self.erd)
        iv = SHA1.new(self.iv + rd).digest()
        key_material = PBKDF2(
            iv.decode(&#39;latin1&#39;),
            iv,
            dkLen=key_size * 2 + 2,
            count=1000,
            hmac_hash_module=SHA1
        )

        data_key = key_material[:key_size]
        auth_key = key_material[key_size:key_size * 2]
        password_verify = key_material[key_size * 2:key_size * 2 + 2]

        if password_verify != self.validation[:2]:
            self._derivations[password] = None
            raise InvalidPassword
        else:
            self._derivations[password] = block_cipher, data_key, auth_key
    else:
        if derived is None:
            raise InvalidPassword
        block_cipher, data_key, auth_key = derived

    return _cipher(data_key), auth_key</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionHeader.checkpwd"><code class="name flex">
<span>def <span class="ident">checkpwd</span></span>(<span>self, password)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L364-L372" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkpwd(self, password: str | None):
    if password is None:
        return False
    try:
        self.derive_key(password)
    except InvalidPassword:
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.ZipEncryptionHeader.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self, password, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L374-L384" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decrypt(self, password: str, data: bytes):
    from Cryptodome.Hash import HMAC, SHA1
    cipher, hmk = self.derive_key(password)

    if len(self.validation) &gt; 2:
        computed_hmac = HMAC.new(hmk, data, SHA1).digest()
        expected_hmac = self.validation[2:12] if len(self.validation) &gt;= 12 else self.validation[2:]
        if computed_hmac[:len(expected_hmac)] != expected_hmac:
            raise DataIntegrityError

    return cipher.decrypt(data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipArchiveExtraDataRecord"><code class="flex name class">
<span>class <span class="ident">ZipArchiveExtraDataRecord</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L387-L394" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipArchiveExtraDataRecord(Struct):
    Signature = B&#39;PK\x06\x08&#39;

    def __init__(self, reader: StructReader[memoryview]):
        if reader.read(4) != self.Signature:
            raise ValueError
        self.extra_field_data = reader.read_exactly(reader.u32())
        self.extra_fields = ZipExtraField.ParseBuffer(self.extra_field_data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipArchiveExtraDataRecord.Signature"><code class="name">var <span class="ident">Signature</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipArchiveExtraDataRecord.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipDigitalSignature"><code class="flex name class">
<span>class <span class="ident">ZipDigitalSignature</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L397-L404" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipDigitalSignature(Struct):
    Signature = B&#39;PK\x05\x05&#39;

    def __init__(self, reader: StructReader[memoryview]):
        if reader.read(4) != self.Signature:
            raise ValueError
        self.size_of_data = reader.u16()
        self.signature_data = reader.read_exactly(self.size_of_data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipDigitalSignature.Signature"><code class="name">var <span class="ident">Signature</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipDigitalSignature.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipDataDescriptorRaw"><code class="flex name class">
<span>class <span class="ident">ZipDataDescriptorRaw</span></span>
<span>(</span><span>crc32, csize, usize)</span>
</code></dt>
<dd>
<section class="desc"><p>ZipDataDescriptorRaw(crc32, csize, usize)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L407-L410" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipDataDescriptorRaw(NamedTuple):
    crc32: int
    csize: int
    usize: int</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipDataDescriptorRaw.crc32"><code class="name">var <span class="ident">crc32</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L407-L410" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipDataDescriptorRaw(NamedTuple):
    crc32: int
    csize: int
    usize: int</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.ZipDataDescriptorRaw.csize"><code class="name">var <span class="ident">csize</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L407-L410" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipDataDescriptorRaw(NamedTuple):
    crc32: int
    csize: int
    usize: int</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.ZipDataDescriptorRaw.usize"><code class="name">var <span class="ident">usize</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L407-L410" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipDataDescriptorRaw(NamedTuple):
    crc32: int
    csize: int
    usize: int</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipDataDescriptor"><code class="flex name class">
<span>class <span class="ident">ZipDataDescriptor</span></span>
<span>(</span><span>reader, is64bit=False, expected_size=-1)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L413-L441" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipDataDescriptor(Struct):
    Signature = B&#39;PK\x07\x08&#39;

    def __init__(
        self,
        reader: StructReader[memoryview],
        is64bit: bool = False,
        expected_size: int = -1,
    ):
        if reader.read(4) != self.Signature:
            raise ValueError
        self.crc32 = reader.u32()
        if expected_size &gt;= 0:
            u64value = reader.u64(peek=True)
            u32value = reader.u32(peek=True)
            if expected_size == u32value:
                if expected_size != u64value:
                    is64bit = False
            elif expected_size == u64value:
                if expected_size != u32value:
                    is64bit = True
        size = reader.u64 if is64bit else reader.u32
        self.csize = size()
        self.usize = size()
        if not is64bit and self.usize == 0 and self.csize &gt; 0x100:
            # This is likely a 64-bit descriptor despite what we thought.
            self.usize = reader.u64()
            is64bit = True
        self.is64bit = is64bit</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipDataDescriptor.Signature"><code class="name">var <span class="ident">Signature</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipDataDescriptor.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipFileRecord"><code class="flex name class">
<span>class <span class="ident">ZipFileRecord</span></span>
<span>(</span><span>reader, is64bit=False, ddirs=None, read_data=True, dir=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L444-L705" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipFileRecord(Struct):
    Signature = B&#39;PK\x03\x04&#39;

    def __init__(
        self,
        reader: StructReader[memoryview],
        is64bit: bool = False,
        ddirs: list[int] | None = None,
        read_data: bool = True,
        dir: ZipDirEntry | None = None,
    ):
        self._unpacked = None
        self._decrypted = None
        self.offset = reader.tell()
        self.dir = dir

        self.anomalies = ZipAnomalies.Normal

        if reader.read(4) != self.Signature:
            raise ValueError
        self.version = reader.u16()
        self.flags = ZipFlags(reader.u16())
        self.method_value = reader.u16()
        try:
            self.method = ZipCompressionMethod(self.method_value)
        except ValueError:
            self.method = None
        try:
            self.date = dostime(reader.u32(peek=True))
        except Exception:
            self.date = None
        self.mtime = reader.u16()
        self.mdate = reader.u16()

        self.crc32_ignored = False

        descriptor = reader.peek(12)
        self.crc32 = reader.u32()
        self.csize = reader.u32()
        self.usize = reader.u32()

        nl = reader.u16()
        xl = reader.u16()
        self.name_bytes = reader.read_exactly(nl)
        self.xtra_data = reader.read_exactly(xl)
        self.xtra = ZipExtraField.ParseBuffer(self.xtra_data)

        self.ae = None
        self.ux = None
        self.up = None
        self.ts = None

        codec = &#39;utf8&#39; if self.flags.UseUTF8 else &#39;latin1&#39;
        self.name = codecs.decode(self.name_bytes, codec)

        for x in self.xtra:
            if z64 := ZipExtInfo64.TryParse(x, self.usize, self.csize):
                self.usize = z64.usize
                self.csize = z64.csize
                is64bit = True
            elif ae := ZipExtAES.TryParse(x):
                if (m := self.method) != ZipCompressionMethod.AExENCRYPTION:
                    if m is not None:
                        m = m.name
                    raise ValueError(F&#39;AES extension found, but compression method was {m}.&#39;)
                self.ae = ae
                self.method = ae.method
            elif up := ZipExtUnicodePath.TryParse(x):
                self.up = up
                if up.crc == zlib.crc32(self.name_bytes) &amp; 0xFFFFFFFF:
                    self.name = up.name
            elif ux := ZipExtUnixIDs.TryParse(x):
                self.ux = ux
            elif ts := ZipExtTimestamp.TryParse(x):
                self.ts = ts

        self.data_offset = start = reader.tell()
        self.data_descriptor = None

        if not self.flags.Encrypted:
            self.encryption = NoCrypto()
        elif self.flags.StrongEncryption:
            self.encryption = ZipEncryptionHeader(reader)
        else:
            if ae := (dir.ae if dir else None) or self.ae:
                self.encryption = AExCrypto(reader, ae)
            else:
                self.encryption = ZipCrypto(reader, self.crc32)

        skipped = len(self.encryption)

        if not read_data:
            self.data = None
            return

        if 0 &lt; self.csize:
            rest = self.csize - skipped
            if rest &lt; 0:
                raise DataIntegrityError
            self.data = reader.read_exactly(rest)
        else:
            self.data = B&#39;&#39;

        if ddirs and not self.csize:
            k = bisect.bisect_left(ddirs, start)
            for k in range(k, len(ddirs)):
                ddpos = ddirs[k]
                csize = ddpos - self.data_offset
                self.data = reader.read_exactly(csize - skipped)
                self.data_descriptor = info = ZipDataDescriptor(reader, is64bit, csize)
                if info.csize == csize:
                    self.crc32 = info.crc32
                    self.csize = info.csize
                    self.usize = info.usize
                    is64bit = info.is64bit
                    break
                try:
                    u = self.unpack()
                except Exception:
                    pass
                else:
                    self.csize = csize
                    self.usize = len(u)
                    break
                reader.seekset(self.data_offset)
                start += 4
        elif self.flags.DataDescriptor or reader.peek(4) == ZipDataDescriptor.Signature:
            self.data_descriptor = info = ZipDataDescriptor(reader, is64bit)
            is64bit = info.is64bit
            self.crc32 = self.crc32 or info.crc32
            self.csize = self.csize or info.csize
            self.usize = self.usize or info.usize
        elif reader.peek(12) == descriptor:
            self.data_descriptor = ZipDataDescriptorRaw(reader.u32(), reader.u32(), reader.u32())
            self.anomalies |= ZipAnomalies.DataDescriptorWithoutHeader

        if self.name == &#39;AndroidManifest.xml&#39;:
            checkpoint = reader.tell()
            axml_magic = B&#39;\x03\x00\x08\x00&#39;
            reader.seekset(self.data_offset)
            if reader.peek(4) == axml_magic and (usize := self.usize) and (reader.remaining_bytes &gt;= usize):
                self.data = reader.read_exactly(usize)
                self.method = ZipCompressionMethod.STORE
                self.crc32_ignored = True
                self.encryption = NoCrypto()
            else:
                reader.seekset(checkpoint)

        self.is64bit = is64bit

    def get_mtime(self):
        ts = None
        if dir := self.dir:
            if (ts := dir.ts) is None and (dt := dir.date):
                return dt
        if ts and (t := ts.mtime) or self.ts and (t := self.ts.mtime):
            return datetime.fromtimestamp(t)
        return self.date

    def get_ctime(self):
        if self.dir and (ts := self.dir.ts) and (t := ts.ctime) or (ts := self.ts) and (t := ts.ctime):
            return datetime.fromtimestamp(t)

    def get_atime(self):
        if self.dir and (ts := self.dir.ts) and (t := ts.atime) or (ts := self.ts) and (t := ts.atime):
            return datetime.fromtimestamp(t)

    def get_name(self):
        if (dir := self.dir) and (name := dir.name):
            return name
        return self.name

    def get_gid(self):
        if ux := (d.ux if (d := self.dir) else None) or self.ux:
            return ux.gid

    def get_uid(self):
        if ux := (d.ux if (d := self.dir) else None) or self.ux:
            return ux.uid

    def is_dir(self):
        return self.get_name().endswith((&#39;/&#39;, &#39;\\&#39;))

    def is_password_ok(self, password: str | None = None):
        return self.encryption.checkpwd(password)

    def unpack(self, password: str | None = None, check: bool = True):
        if not check or self.crc32_ignored:
            def _nocheck(x):
                return x
            _checked = _nocheck
        else:
            def _checker(unpacked: buf):
                crc32loc = self.crc32
                crc32dir = 0 if (dir := self.dir) is None else dir.crc32
                if crc32loc == 0 and crc32dir == 0:
                    return unpacked
                crc32 = zlib.crc32(unpacked)
                if crc32 == crc32loc or crc32 == crc32dir:
                    return unpacked
                raise InvalidChecksum(self, unpacked, crc32dir or crc32loc, crc32)
            _checked = _checker

        if (d := self.data) is None:
            raise ValueError(F&#39;The data for this {self.__class__.__name__} was not read.&#39;)
        if (u := self._unpacked) is not None:
            return _checked(u)

        if e := self.encryption:
            if password is None:
                raise PasswordRequired
            compressed = e.decrypt(password, d)
        else:
            compressed = d

        if (m := self.method) == ZipCompressionMethod.STORE:
            u = compressed
        elif m == ZipCompressionMethod.DEFLATE:
            u = zlib.decompress(compressed, -15)
        elif m == ZipCompressionMethod.DEFLATE64:
            from refinery.lib.seven.deflate import Deflate
            u = bytearray()
            deflate = Deflate(u, StructReader(memoryview(compressed)), df64=True)
            deflate.decode()
        elif m == ZipCompressionMethod.BZIP2:
            import bz2
            u = bz2.decompress(compressed)
        elif m == ZipCompressionMethod.LZMA:
            import lzma
            cv = memoryview(compressed)
            cr = StructReader(cv)
            _ = cr.u8() # major version
            _ = cr.u8() # minor version
            n = cr.u16()
            properties_data = cr.read_exactly(n)
            compressed_data = cr.read()
            decompressor = lzma.LZMADecompressor(
                lzma.FORMAT_RAW, filters=[parse_lzma_properties(properties_data, 1)])
            u = decompressor.decompress(compressed_data)
        elif m == ZipCompressionMethod.PPMD:
            from refinery.lib.shared.pyppmd import pyppmd
            cv = memoryview(compressed)
            cr = StructReaderBits(cv)
            order = 1 + cr.read_nibble()
            msize = 1 + cr.read_byte() &lt;&lt; 20
            rm = cr.read_nibble()
            ppmd = pyppmd.PpmdDecompressor(order, msize, restore_method=rm)
            u = ppmd.decompress(bytes(cr.read()))
        elif m == ZipCompressionMethod.ZSTD:
            from refinery.lib.shared.pyzstd import pyzstd
            dctx = pyzstd.ZstdDecompressor()
            u = dctx.decompress(compressed)
        elif m == ZipCompressionMethod.XZ:
            import lzma
            u = lzma.decompress(compressed, format=lzma.FORMAT_XZ)
        else:
            if m is not None:
                m = m.name
            raise NotImplementedError(F&#39;Compression method {m} is not implemented.&#39;)

        self._unpacked = u
        return _checked(u)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipFileRecord.Signature"><code class="name">var <span class="ident">Signature</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipFileRecord.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipFileRecord.get_mtime"><code class="name flex">
<span>def <span class="ident">get_mtime</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L594-L601" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_mtime(self):
    ts = None
    if dir := self.dir:
        if (ts := dir.ts) is None and (dt := dir.date):
            return dt
    if ts and (t := ts.mtime) or self.ts and (t := self.ts.mtime):
        return datetime.fromtimestamp(t)
    return self.date</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.ZipFileRecord.get_ctime"><code class="name flex">
<span>def <span class="ident">get_ctime</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L603-L605" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_ctime(self):
    if self.dir and (ts := self.dir.ts) and (t := ts.ctime) or (ts := self.ts) and (t := ts.ctime):
        return datetime.fromtimestamp(t)</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.ZipFileRecord.get_atime"><code class="name flex">
<span>def <span class="ident">get_atime</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L607-L609" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_atime(self):
    if self.dir and (ts := self.dir.ts) and (t := ts.atime) or (ts := self.ts) and (t := ts.atime):
        return datetime.fromtimestamp(t)</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.ZipFileRecord.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L611-L614" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_name(self):
    if (dir := self.dir) and (name := dir.name):
        return name
    return self.name</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.ZipFileRecord.get_gid"><code class="name flex">
<span>def <span class="ident">get_gid</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L616-L618" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_gid(self):
    if ux := (d.ux if (d := self.dir) else None) or self.ux:
        return ux.gid</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.ZipFileRecord.get_uid"><code class="name flex">
<span>def <span class="ident">get_uid</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L620-L622" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_uid(self):
    if ux := (d.ux if (d := self.dir) else None) or self.ux:
        return ux.uid</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.ZipFileRecord.is_dir"><code class="name flex">
<span>def <span class="ident">is_dir</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L624-L625" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_dir(self):
    return self.get_name().endswith((&#39;/&#39;, &#39;\\&#39;))</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.ZipFileRecord.is_password_ok"><code class="name flex">
<span>def <span class="ident">is_password_ok</span></span>(<span>self, password=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L627-L628" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_password_ok(self, password: str | None = None):
    return self.encryption.checkpwd(password)</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.ZipFileRecord.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, password=None, check=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L630-L705" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpack(self, password: str | None = None, check: bool = True):
    if not check or self.crc32_ignored:
        def _nocheck(x):
            return x
        _checked = _nocheck
    else:
        def _checker(unpacked: buf):
            crc32loc = self.crc32
            crc32dir = 0 if (dir := self.dir) is None else dir.crc32
            if crc32loc == 0 and crc32dir == 0:
                return unpacked
            crc32 = zlib.crc32(unpacked)
            if crc32 == crc32loc or crc32 == crc32dir:
                return unpacked
            raise InvalidChecksum(self, unpacked, crc32dir or crc32loc, crc32)
        _checked = _checker

    if (d := self.data) is None:
        raise ValueError(F&#39;The data for this {self.__class__.__name__} was not read.&#39;)
    if (u := self._unpacked) is not None:
        return _checked(u)

    if e := self.encryption:
        if password is None:
            raise PasswordRequired
        compressed = e.decrypt(password, d)
    else:
        compressed = d

    if (m := self.method) == ZipCompressionMethod.STORE:
        u = compressed
    elif m == ZipCompressionMethod.DEFLATE:
        u = zlib.decompress(compressed, -15)
    elif m == ZipCompressionMethod.DEFLATE64:
        from refinery.lib.seven.deflate import Deflate
        u = bytearray()
        deflate = Deflate(u, StructReader(memoryview(compressed)), df64=True)
        deflate.decode()
    elif m == ZipCompressionMethod.BZIP2:
        import bz2
        u = bz2.decompress(compressed)
    elif m == ZipCompressionMethod.LZMA:
        import lzma
        cv = memoryview(compressed)
        cr = StructReader(cv)
        _ = cr.u8() # major version
        _ = cr.u8() # minor version
        n = cr.u16()
        properties_data = cr.read_exactly(n)
        compressed_data = cr.read()
        decompressor = lzma.LZMADecompressor(
            lzma.FORMAT_RAW, filters=[parse_lzma_properties(properties_data, 1)])
        u = decompressor.decompress(compressed_data)
    elif m == ZipCompressionMethod.PPMD:
        from refinery.lib.shared.pyppmd import pyppmd
        cv = memoryview(compressed)
        cr = StructReaderBits(cv)
        order = 1 + cr.read_nibble()
        msize = 1 + cr.read_byte() &lt;&lt; 20
        rm = cr.read_nibble()
        ppmd = pyppmd.PpmdDecompressor(order, msize, restore_method=rm)
        u = ppmd.decompress(bytes(cr.read()))
    elif m == ZipCompressionMethod.ZSTD:
        from refinery.lib.shared.pyzstd import pyzstd
        dctx = pyzstd.ZstdDecompressor()
        u = dctx.decompress(compressed)
    elif m == ZipCompressionMethod.XZ:
        import lzma
        u = lzma.decompress(compressed, format=lzma.FORMAT_XZ)
    else:
        if m is not None:
            m = m.name
        raise NotImplementedError(F&#39;Compression method {m} is not implemented.&#39;)

    self._unpacked = u
    return _checked(u)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipEndOfCentralDirectory"><code class="flex name class">
<span>class <span class="ident">ZipEndOfCentralDirectory</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L708-L721" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipEndOfCentralDirectory(Struct):
    Signature = B&#39;PK\x05\x06&#39;

    def __init__(self, reader: StructReader[memoryview]):
        self.offset = reader.tell()
        if reader.read(4) != self.Signature:
            raise ValueError
        self.disk_number = reader.u16()
        self.start_disk_number = reader.u16()
        self.entries_on_disk = reader.u16()
        self.entries_in_directory = reader.u16()
        self.directory_size = reader.u32()
        self.directory_offset = reader.u32()
        self.comment_length = reader.u16()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipEndOfCentralDirectory.Signature"><code class="name">var <span class="ident">Signature</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipEndOfCentralDirectory.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipEocdLocator64"><code class="flex name class">
<span>class <span class="ident">ZipEocdLocator64</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L724-L732" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipEocdLocator64(Struct):
    Signature = B&#39;PK\x06\x07&#39;

    def __init__(self, reader: StructReader[memoryview]):
        if reader.read(4) != self.Signature:
            raise ValueError
        self.disk_with_eocd64 = reader.u32()
        self.offset = reader.u64()
        self.total_disks = reader.u32()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipEocdLocator64.Signature"><code class="name">var <span class="ident">Signature</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipEocdLocator64.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipEndOfCentralDirectory64"><code class="flex name class">
<span>class <span class="ident">ZipEndOfCentralDirectory64</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L735-L752" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipEndOfCentralDirectory64(Struct):
    Signature = B&#39;PK\x06\x06&#39;

    def __init__(self, reader: StructReader[memoryview]):
        self.offset = reader.tell()
        if reader.read(4) != self.Signature:
            raise ValueError
        self.eocd64_size = reader.u64()
        self.version_made_by = reader.u16()
        self.version_to_extract = reader.u16()
        self.disk_number = reader.u32()
        self.start_disk_number = reader.u32()
        self.entries_on_disk = reader.u64()
        self.entries_in_directory = reader.u64()
        self.directory_size = reader.u64()
        self.directory_offset = reader.u64()
        self.locator = ZipEocdLocator64(reader)
        self.eocd32 = ZipEndOfCentralDirectory(reader)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipEndOfCentralDirectory64.Signature"><code class="name">var <span class="ident">Signature</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipEndOfCentralDirectory64.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipExtraField"><code class="flex name class">
<span>class <span class="ident">ZipExtraField</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L755-L772" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipExtraField(Struct):
    def __init__(self, reader: StructReader[memoryview]):
        self.header_id = reader.u16()
        self.data_size = reader.u16()
        self.data = reader.read_exactly(self.data_size)

    @classmethod
    def ParseBuffer(cls, data: buf | None) -&gt; list[ZipExtraField]:
        if data is None:
            return []
        reader = StructReader(memoryview(data))
        extras = []
        while not reader.eof:
            try:
                extras.append(cls(reader))
            except EOFError:
                break
        return extras</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipExtraField.ParseBuffer"><code class="name flex">
<span>def <span class="ident">ParseBuffer</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.zip.ZipExtraField.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipExt"><code class="flex name class">
<span>class <span class="ident">ZipExt</span></span>
<span>(</span><span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L775-L782" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipExt(Struct):
    HeaderID: int

    @classmethod
    def TryParse(cls, extra: ZipExtraField, *args, **kwargs):
        if extra.header_id != cls.HeaderID:
            return None
        return cls.Parse(extra.data, *args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.zip.ZipExtAES" href="#refinery.lib.zip.ZipExtAES">ZipExtAES</a></li>
<li><a title="refinery.lib.zip.ZipExtInfo64" href="#refinery.lib.zip.ZipExtInfo64">ZipExtInfo64</a></li>
<li><a title="refinery.lib.zip.ZipExtTimestamp" href="#refinery.lib.zip.ZipExtTimestamp">ZipExtTimestamp</a></li>
<li><a title="refinery.lib.zip.ZipExtUnicodePath" href="#refinery.lib.zip.ZipExtUnicodePath">ZipExtUnicodePath</a></li>
<li><a title="refinery.lib.zip.ZipExtUnixIDs" href="#refinery.lib.zip.ZipExtUnixIDs">ZipExtUnixIDs</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipExt.HeaderID"><code class="name">var <span class="ident">HeaderID</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipExt.TryParse"><code class="name flex">
<span>def <span class="ident">TryParse</span></span>(<span>extra, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.zip.ZipExt.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.NoCrypto"><code class="flex name class">
<span>class <span class="ident">NoCrypto</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L785-L796" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class NoCrypto:
    def __len__(self):
        return 0

    def __buffer__(self, flags: int, /):
        return memoryview(B&#39;&#39;)

    def decrypt(self, password: str, data: buf):
        return data

    def checkpwd(self, password: str | None):
        return not password</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.zip.NoCrypto.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self, password, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L792-L793" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decrypt(self, password: str, data: buf):
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.NoCrypto.checkpwd"><code class="name flex">
<span>def <span class="ident">checkpwd</span></span>(<span>self, password)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L795-L796" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkpwd(self, password: str | None):
    return not password</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.AExCrypto"><code class="flex name class">
<span>class <span class="ident">AExCrypto</span></span>
<span>(</span><span>cr, ae)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L799-L858" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class AExCrypto(Struct):
    def __init__(self, cr: StructReader[memoryview], ae: ZipExtAES):
        self.version = ae.version
        self.strength = ae.strength

        self.salt = cr.read((ae.strength + 1) &lt;&lt; 2)
        self.pvv = cr.read(2)
        if ae.version == 3:
            self.nonce = cr.read(12)
            self.auth_size = 16
        else:
            self.nonce = None
            self.auth_size = 10
        self.keylen = (ae.strength + 1) &lt;&lt; 3

    def _derive(self, password: str, salt: buf):
        from Cryptodome.Hash import SHA1
        from Cryptodome.Protocol.KDF import PBKDF2
        ks = self.keylen
        dk = ks + 2
        if self.version &lt; 3:
            dk += ks
        derived = PBKDF2(password, salt, dkLen=dk, count=1000, hmac_hash_module=SHA1)
        cr = StructReader(derived)
        key = cr.read(ks)
        mac = cr.read(ks) if self.version &lt; 3 else B&#39;&#39;
        pvv = cr.read()
        return key, mac, pvv

    def checkpwd(self, password: str | None):
        if password is None:
            return False
        _, _, dp = self._derive(password, self.salt)
        return dp == self.pvv

    def decrypt(self, password: str, data: buf):
        from Cryptodome.Cipher import AES
        from Cryptodome.Hash import HMAC, SHA1
        from Cryptodome.Util import Counter
        dk, dm, dp = self._derive(password, self.salt)
        if dp != self.pvv:
            raise InvalidPassword
        view = memoryview(data)
        ciphertext = view[:-self.auth_size]
        auth = view[-self.auth_size:]
        if self.version &lt; 3:
            hmac = HMAC.new(dm, ciphertext, SHA1).digest()
            if hmac[:10] != auth:
                raise DataIntegrityError
            ctr = Counter.new(128, initial_value=1, little_endian=True)
            cipher = AES.new(dk, AES.MODE_CTR, counter=ctr)
            result = cipher.decrypt(ciphertext)
        else:
            cipher = AES.new(dk, AES.MODE_GCM, nonce=self.nonce)
            result = cipher.decrypt(ciphertext)
            try:
                cipher.verify(auth)
            except ValueError as V:
                raise DataIntegrityError from V
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.AExCrypto.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.zip.AExCrypto.checkpwd"><code class="name flex">
<span>def <span class="ident">checkpwd</span></span>(<span>self, password)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L828-L832" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkpwd(self, password: str | None):
    if password is None:
        return False
    _, _, dp = self._derive(password, self.salt)
    return dp == self.pvv</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.AExCrypto.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self, password, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L834-L858" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decrypt(self, password: str, data: buf):
    from Cryptodome.Cipher import AES
    from Cryptodome.Hash import HMAC, SHA1
    from Cryptodome.Util import Counter
    dk, dm, dp = self._derive(password, self.salt)
    if dp != self.pvv:
        raise InvalidPassword
    view = memoryview(data)
    ciphertext = view[:-self.auth_size]
    auth = view[-self.auth_size:]
    if self.version &lt; 3:
        hmac = HMAC.new(dm, ciphertext, SHA1).digest()
        if hmac[:10] != auth:
            raise DataIntegrityError
        ctr = Counter.new(128, initial_value=1, little_endian=True)
        cipher = AES.new(dk, AES.MODE_CTR, counter=ctr)
        result = cipher.decrypt(ciphertext)
    else:
        cipher = AES.new(dk, AES.MODE_GCM, nonce=self.nonce)
        result = cipher.decrypt(ciphertext)
        try:
            cipher.verify(auth)
        except ValueError as V:
            raise DataIntegrityError from V
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipExtAES"><code class="flex name class">
<span>class <span class="ident">ZipExtAES</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L861-L874" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipExtAES(ZipExt):
    HeaderID = 0x9901

    def __init__(self, reader: StructReader[memoryview]):
        self.version = reader.u16()
        self.vendor = reader.u16()
        self.strength = reader.u8()
        if not 1 &lt;= self.strength &lt;= 3:
            raise ValueError(F&#39;Invalid AES strength {self.strength}.&#39;)
        self.method_value = reader.u16()
        try:
            self.method = ZipCompressionMethod(self.method_value)
        except ValueError:
            self.method = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.zip.ZipExt" href="#refinery.lib.zip.ZipExt">ZipExt</a></li>
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipExtAES.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.zip.ZipExt" href="#refinery.lib.zip.ZipExt">ZipExt</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.zip.ZipExt.HeaderID" href="#refinery.lib.zip.ZipExt.HeaderID">HeaderID</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.zip.ZipExtInfo64"><code class="flex name class">
<span>class <span class="ident">ZipExtInfo64</span></span>
<span>(</span><span>reader, usize, csize, header_offset=0, disk_nr_start=0)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L877-L900" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipExtInfo64(ZipExt):
    HeaderID = 0x0001

    def __init__(
        self,
        reader: StructReader[memoryview],
        usize: int,
        csize: int,
        header_offset: int = 0,
        disk_nr_start: int = 0,
    ):
        self.usize = usize
        self.csize = csize
        self.header_offset = header_offset
        self.disk_nr_start = disk_nr_start

        if usize == 0xFFFFFFFF:
            self.usize = reader.u64()
        if csize == 0xFFFFFFFF:
            self.csize = reader.u64()
        if header_offset == 0xFFFFFFFF:
            self.header_offset = reader.u64()
        if disk_nr_start == 0xFFFF:
            self.disk_nr_start = reader.u32()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.zip.ZipExt" href="#refinery.lib.zip.ZipExt">ZipExt</a></li>
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipExtInfo64.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.zip.ZipExt" href="#refinery.lib.zip.ZipExt">ZipExt</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.zip.ZipExt.HeaderID" href="#refinery.lib.zip.ZipExt.HeaderID">HeaderID</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.zip.ZipExtUnixIDs"><code class="flex name class">
<span>class <span class="ident">ZipExtUnixIDs</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L903-L909" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipExtUnixIDs(ZipExt):
    HeaderID = 0x7875

    def __init__(self, reader: StructReader[memoryview]):
        self.version = reader.u8()
        self.uid = reader.read_integer(reader.u8() * 8)
        self.gid = reader.read_integer(reader.u8() * 8)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.zip.ZipExt" href="#refinery.lib.zip.ZipExt">ZipExt</a></li>
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipExtUnixIDs.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.zip.ZipExt" href="#refinery.lib.zip.ZipExt">ZipExt</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.zip.ZipExt.HeaderID" href="#refinery.lib.zip.ZipExt.HeaderID">HeaderID</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.zip.ZipExtTimestampFlags"><code class="flex name class">
<span>class <span class="ident">ZipExtTimestampFlags</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>This class can be mixed into an <code>enum.IntFlag</code> for some quality of life improvements. Firstly,
you can now access flags as follows:</p>
<pre><code>class Flags(FlagAccessMixin, enum.IntFlag):
    IsBinary = 1
    IsCompressed = 2

flag = Flags(3)

if flag.IsCompressed:
    decompress()
</code></pre>
<p>Furthermore, flag values can be enumerated:</p>
<pre><code>&gt;&gt;&gt; list(flag)
[IsBinary, IsCompressed]
&gt;&gt;&gt; flag
IsBinary|IsCompressed
</code></pre>
<p>And finally, as visible from the above output, flag values are represented by their name by
default.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L912-L915" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipExtTimestampFlags(FlagAccessMixin, enum.IntFlag):
    Modification = 1
    Access = 2
    Creation = 4</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.FlagAccessMixin" href="structures.html#refinery.lib.structures.FlagAccessMixin">FlagAccessMixin</a></li>
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipExtTimestampFlags.Modification"><code class="name">var <span class="ident">Modification</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipExtTimestampFlags.Access"><code class="name">var <span class="ident">Access</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.zip.ZipExtTimestampFlags.Creation"><code class="name">var <span class="ident">Creation</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.ZipExtTimestamp"><code class="flex name class">
<span>class <span class="ident">ZipExtTimestamp</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L918-L931" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipExtTimestamp(ZipExt):
    HeaderID = 0x5455

    def __init__(self, reader: StructReader[memoryview]):
        self.flags = ZipExtTimestampFlags(reader.u8())
        self.mtime = None
        self.atime = None
        self.ctime = None
        if reader.remaining_bytes &gt;= 4 and self.flags.Modification:
            self.mtime = reader.u32()
        if reader.remaining_bytes &gt;= 4 and self.flags.Access:
            self.atime = reader.u32()
        if reader.remaining_bytes &gt;= 4 and self.flags.Creation:
            self.ctime = reader.u32()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.zip.ZipExt" href="#refinery.lib.zip.ZipExt">ZipExt</a></li>
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipExtTimestamp.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.zip.ZipExt" href="#refinery.lib.zip.ZipExt">ZipExt</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.zip.ZipExt.HeaderID" href="#refinery.lib.zip.ZipExt.HeaderID">HeaderID</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.zip.ZipExtUnicodePath"><code class="flex name class">
<span>class <span class="ident">ZipExtUnicodePath</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L934-L940" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipExtUnicodePath(ZipExt):
    HeaderID = 0x7075

    def __init__(self, reader: StructReader[memoryview]):
        self.version = reader.u8()
        self.crc = reader.u32()
        self.name = codecs.decode(reader.read(), &#39;utf8&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.zip.ZipExt" href="#refinery.lib.zip.ZipExt">ZipExt</a></li>
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipExtUnicodePath.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.zip.ZipExt" href="#refinery.lib.zip.ZipExt">ZipExt</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.zip.ZipExt.HeaderID" href="#refinery.lib.zip.ZipExt.HeaderID">HeaderID</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.zip.ZipDirEntry"><code class="flex name class">
<span>class <span class="ident">ZipDirEntry</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L943-L1004" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ZipDirEntry(Struct):
    Signature = B&#39;PK\x01\x02&#39;

    def is_dir(self):
        return self.name.endswith((&#39;/&#39;, &#39;\\&#39;))

    def __init__(self, reader: StructReader[memoryview]):
        if reader.read(4) != self.Signature:
            raise ValueError
        self.version_made_by = reader.u16()
        self.version_to_extract = reader.u16()
        self.flags = ZipFlags(reader.u16())
        self.method_value = reader.u16()
        try:
            self.compression = ZipCompressionMethod(self.method_value)
        except ValueError:
            self.compression = None
        try:
            self.date = dostime(reader.u32(peek=True))
        except Exception:
            self.date = None
        self.mtime = reader.u16()
        self.mdate = reader.u16()
        self.crc32 = reader.u32()
        self.csize = reader.u32()
        self.usize = reader.u32()
        nl = reader.u16()
        xl = reader.u16()
        cl = reader.u16()
        self.disk_nr_start = reader.u16()
        self.internal_attributes = ZipInternalFileAttributes(reader.u16())
        self.external_attributes = reader.u32()
        self.header_offset = reader.u32()
        self.name_bytes = reader.read_exactly(nl)
        extras = reader.read_exactly(xl)
        self.comment = reader.read_exactly(cl)
        self.xtra = ZipExtraField.ParseBuffer(extras)

        codec = &#39;utf8&#39; if self.flags.UseUTF8 else &#39;latin1&#39;
        self.name = codecs.decode(self.name_bytes, codec)

        self.ae = None
        self.up = None
        self.ux = None
        self.ts = None

        for x in self.xtra:
            if z64 := ZipExtInfo64.TryParse(x, self.usize, self.csize, self.header_offset, self.disk_nr_start):
                self.usize = z64.usize
                self.csize = z64.csize
                self.header_offset = z64.header_offset
                self.disk_nr_start = z64.disk_nr_start
            elif ae := ZipExtAES.TryParse(x):
                self.ae = ae
            elif up := ZipExtUnicodePath.TryParse(x):
                self.up = up
                if up.crc == zlib.crc32(self.name_bytes) &amp; 0xFFFFFFFF:
                    self.name = up.name
            elif ux := ZipExtUnixIDs.TryParse(x):
                self.ux = ux
            elif ts := ZipExtTimestamp.TryParse(x):
                self.ts = ts</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.zip.ZipDirEntry.Signature"><code class="name">var <span class="ident">Signature</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipDirEntry.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.zip.ZipDirEntry.is_dir"><code class="name flex">
<span>def <span class="ident">is_dir</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L946-L947" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_dir(self):
    return self.name.endswith((&#39;/&#39;, &#39;\\&#39;))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.zip.Zip"><code class="flex name class">
<span>class <span class="ident">Zip</span></span>
<span>(</span><span>data, password=None, read_records=True, read_unreferenced_records=True, sub_archives_covered=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L1007-L1239" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Zip:

    def parse_record(self, offset: int | None = None, read_data: bool = True, dir: ZipDirEntry | None = None):
        if offset is not None:
            self.reader.seekset(offset)
        return ZipFileRecord(
            self.reader,
            is64bit=self.is64bit,
            ddirs=self.ddirs,
            read_data=read_data,
            dir=dir,
        )

    def read(self, entry: str | int | ZipDirEntry):
        if isinstance(entry, str):
            entries = self.by_name[entry]
            if (c := len(entries)) &gt; 1:
                raise RuntimeError(F&#39;There are {c} central directory entries for: {entry}&#39;)
            entry = entries[0]
        if isinstance(entry, ZipDirEntry):
            start = entry.header_offset + self.shift
            dir = entry
        else:
            start = entry
            dir = None
        if start &lt; 0:
            raise EOFError(F&#39;Record referenced at {-start} bytes before start of file.&#39;)
        if (x := start - len(self.reader)) &gt;= 0:
            raise EOFError(F&#39;Record referenced at offset {x} from EOF.&#39;)
        try:
            return self.records[start]
        except KeyError:
            pass
        self.reader.seekset(start)
        self.records[start] = r = self.parse_record(dir=dir)
        self.coverage.addi(start, len(r))
        self.unreferenced_records.pop(start, None)
        return r

    def sub_archive_count(self):
        return sum(sub.sub_archive_count() + 1 for sub in self.sub_archives.values())

    def __init__(
        self,
        data: buf,
        password: str | None = None,
        read_records: bool = True,
        read_unreferenced_records: bool = True,
        sub_archives_covered: bool = True,
    ):
        self.reader = reader = StructReader(view := memoryview(data))
        self.is64bit = True
        self.coverage = coverage = IntIntervalUnion()
        self.password = password

        self.has_pk00_header = (data[:4] == B&#39;PK00&#39;)
        if self.has_pk00_header:
            self.coverage.addi(0, 4)

        for EOCD in (
            ZipEndOfCentralDirectory64,
            ZipEndOfCentralDirectory,
        ):
            if (end := buffer_offset(view, EOCD.Signature, back2front=True)) &gt;= 0:
                reader.seekset(end)
                self.offset_eocd = end
                self.eocd = eocd = EOCD(reader)
                coverage.addi(end, len(eocd))
                break
            else:
                self.is64bit = False
        else:
            raise ValueError(&#39;No EOCD.&#39;)

        start = eocd.directory_offset
        self.shift = end - eocd.directory_size - start
        if self.shift:
            start = end - eocd.directory_size
        if start &lt; 0:
            raise ValueError(&#39;Invalid end of central directory size&#39;)
        self.offset_directory = start
        reader.seekset(start)
        apksig = None

        for sb in (
            ApkSigningBlock42,
            RpkSigningBlock42,
            ApkSigningBlock42_VariantWithAt,
            UnknownSigningBlockPK57,
        ):
            self.apksig = sb.FromCentralDir(reader)
            if (apksig := self.apksig):
                coverage.addi(apksig.offset, len(apksig))
                break

        if reader.peek(4) == ZipArchiveExtraDataRecord.Signature:
            self.archive_extra_data = ZipArchiveExtraDataRecord(reader)
            coverage.addi(start, len(self.archive_extra_data))
            start = reader.tell()
        else:
            self.archive_extra_data = None

        if reader.peek(4) != ZipDirEntry.Signature:
            self.encryption = ZipEncryptionHeader(reader)
            coverage.addi(start, len(self.encryption))
            start = reader.tell()
            size = eocd.directory_size - (start - self.offset_directory)
            self.encrypted_directory = reader.read_exactly(size)
            coverage.addi(start, size)
            if password is None:
                raise PasswordRequired
            decrypted_cd = self.encryption.decrypt(password, self.encrypted_directory)
            cd = StructReader(memoryview(decrypted_cd))
            self.directory = [
                ZipDirEntry(cd) for _ in range(eocd.entries_in_directory)
            ]
        else:
            self.encryption = None
            self.encrypted_directory = None
            self.directory = [
                ZipDirEntry(reader) for _ in range(eocd.entries_in_directory)
            ]
            coverage.addi(start, sum(len(d) for d in self.directory))

        by_name: dict[str, list[ZipDirEntry]] = {}
        self.by_name = by_name

        for entry in self.directory:
            by_name.setdefault(entry.name, []).append(entry)

        records: dict[int, ZipFileRecord] = {}
        unreferenced_records: dict[int, ZipFileRecord] = {}
        unreferenced_dirents: dict[int, ZipDirEntry] = {}
        self.records = records
        self.unreferenced_records = unreferenced_records
        self.unreferenced_dirents = unreferenced_dirents
        start = reader.tell()

        if reader.peek(4) == ZipDigitalSignature.Signature:
            self.digital_signature = ZipDigitalSignature(reader)
            coverage.addi(start, len(self.digital_signature))
            start = reader.tell()
        else:
            self.digital_signature = None

        self.ddirs = [match.start()
            for match in re.finditer(re.escape(ZipDataDescriptor.Signature), view)]

        if not read_records:
            return

        verdicts64bit = {self.is64bit}

        for entry in self.directory:
            try:
                record = self.read(entry)
            except Exception:
                pass
            else:
                verdicts64bit.add(record.is64bit)

        if len(verdicts64bit) == 2:
            # For at least one record, a data descriptor indicated that our 64-bit assumption
            # was incorrect. We try to re-parse with the opposite assumption and use whatever
            # produces more correctly parsed records.
            backup_records = self.records
            self.records.clear()
            self.is64bit = not self.is64bit
            for entry in self.directory:
                try:
                    record = self.read(entry)
                except Exception:
                    pass
            self.is64bit = not self.is64bit
            if len(self.records) &lt; len(backup_records):
                self.records = backup_records

        sub_archives: dict[int, Zip] = {}
        end = self.eocd.offset

        while True:
            try:
                sub = Zip(view[:end], read_unreferenced_records=False)
            except Exception:
                break
            if (sub_eocd := sub.eocd.offset) in self.coverage:
                end = sub_eocd
                continue
            sub_archives[sub_eocd] = sub
            if sub_archives_covered:
                for i in sub.coverage:
                    self.coverage.addi(*i)
            end = sub.eocd.offset

        self.sub_archives = sub_archives

        if not read_unreferenced_records:
            return

        for start, end in list(coverage.gaps(0, len(view))):
            gap = view[start:end]
            if apksig and end == apksig.offset and not any(gap):
                coverage.addi(start, len(gap))
                continue
            while gap[:2] == B&#39;PK&#39;:
                reader.seekset(start)
                if gap[:4] == ZipDirEntry.Signature:
                    try:
                        r = ZipDirEntry(reader)
                        n = len(r)
                    except Exception:
                        break
                    unreferenced_dirents[start] = r
                elif gap[:4] == ZipFileRecord.Signature:
                    try:
                        r = self.parse_record(read_data=False)
                        n = len(r)
                    except Exception:
                        break
                    if gap[n:n + 4] != ZipFileRecord.Signature and len(gap) &gt;= n + r.csize:
                        reader.seekset(start)
                        try:
                            r = self.parse_record()
                        except Exception:
                            pass
                        else:
                            n = len(r)
                    unreferenced_records[start] = r
                else:
                    break
                gap = gap[n:]
                coverage.addi(start, n)
                start += n</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.zip.Zip.parse_record"><code class="name flex">
<span>def <span class="ident">parse_record</span></span>(<span>self, offset=None, read_data=True, dir=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L1009-L1018" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_record(self, offset: int | None = None, read_data: bool = True, dir: ZipDirEntry | None = None):
    if offset is not None:
        self.reader.seekset(offset)
    return ZipFileRecord(
        self.reader,
        is64bit=self.is64bit,
        ddirs=self.ddirs,
        read_data=read_data,
        dir=dir,
    )</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.Zip.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, entry)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L1020-L1044" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read(self, entry: str | int | ZipDirEntry):
    if isinstance(entry, str):
        entries = self.by_name[entry]
        if (c := len(entries)) &gt; 1:
            raise RuntimeError(F&#39;There are {c} central directory entries for: {entry}&#39;)
        entry = entries[0]
    if isinstance(entry, ZipDirEntry):
        start = entry.header_offset + self.shift
        dir = entry
    else:
        start = entry
        dir = None
    if start &lt; 0:
        raise EOFError(F&#39;Record referenced at {-start} bytes before start of file.&#39;)
    if (x := start - len(self.reader)) &gt;= 0:
        raise EOFError(F&#39;Record referenced at offset {x} from EOF.&#39;)
    try:
        return self.records[start]
    except KeyError:
        pass
    self.reader.seekset(start)
    self.records[start] = r = self.parse_record(dir=dir)
    self.coverage.addi(start, len(r))
    self.unreferenced_records.pop(start, None)
    return r</code></pre>
</details>
</dd>
<dt id="refinery.lib.zip.Zip.sub_archive_count"><code class="name flex">
<span>def <span class="ident">sub_archive_count</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/zip.py#L1046-L1047" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sub_archive_count(self):
    return sum(sub.sub_archive_count() + 1 for sub in self.sub_archives.values())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.zip.PasswordRequired" href="#refinery.lib.zip.PasswordRequired">PasswordRequired</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.zip.InvalidPassword" href="#refinery.lib.zip.InvalidPassword">InvalidPassword</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.zip.InvalidChecksum" href="#refinery.lib.zip.InvalidChecksum">InvalidChecksum</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.zip.DataIntegrityError" href="#refinery.lib.zip.DataIntegrityError">DataIntegrityError</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipAnomalies" href="#refinery.lib.zip.ZipAnomalies">ZipAnomalies</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipFlags" href="#refinery.lib.zip.ZipFlags">ZipFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipEncryptionAlgorithm" href="#refinery.lib.zip.ZipEncryptionAlgorithm">ZipEncryptionAlgorithm</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipEncryptionFlags" href="#refinery.lib.zip.ZipEncryptionFlags">ZipEncryptionFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipCompressionMethod" href="#refinery.lib.zip.ZipCompressionMethod">ZipCompressionMethod</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipCrypto" href="#refinery.lib.zip.ZipCrypto">ZipCrypto</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipCrypto.Parse" href="#refinery.lib.zip.ZipCrypto.Parse">Parse</a></code></li>
<li><code><a title="refinery.lib.zip.ZipCrypto.checkpwd" href="#refinery.lib.zip.ZipCrypto.checkpwd">checkpwd</a></code></li>
<li><code><a title="refinery.lib.zip.ZipCrypto.decrypt" href="#refinery.lib.zip.ZipCrypto.decrypt">decrypt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipInternalFileAttributes" href="#refinery.lib.zip.ZipInternalFileAttributes">ZipInternalFileAttributes</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.zip.SigningBlock42Entry" href="#refinery.lib.zip.SigningBlock42Entry">SigningBlock42Entry</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.SigningBlock42Entry.Parse" href="#refinery.lib.zip.SigningBlock42Entry.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.PkgSigningBlock" href="#refinery.lib.zip.PkgSigningBlock">PkgSigningBlock</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.PkgSigningBlock.FromCentralDir" href="#refinery.lib.zip.PkgSigningBlock.FromCentralDir">FromCentralDir</a></code></li>
<li><code><a title="refinery.lib.zip.PkgSigningBlock.Parse" href="#refinery.lib.zip.PkgSigningBlock.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ApkSigningBlock42" href="#refinery.lib.zip.ApkSigningBlock42">ApkSigningBlock42</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ApkSigningBlock42.Parse" href="#refinery.lib.zip.ApkSigningBlock42.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.RpkSigningBlock42" href="#refinery.lib.zip.RpkSigningBlock42">RpkSigningBlock42</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.RpkSigningBlock42.Parse" href="#refinery.lib.zip.RpkSigningBlock42.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ApkSigningBlock42_VariantWithAt" href="#refinery.lib.zip.ApkSigningBlock42_VariantWithAt">ApkSigningBlock42_VariantWithAt</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ApkSigningBlock42_VariantWithAt.Parse" href="#refinery.lib.zip.ApkSigningBlock42_VariantWithAt.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.UnknownSigningBlockPK57" href="#refinery.lib.zip.UnknownSigningBlockPK57">UnknownSigningBlockPK57</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.UnknownSigningBlockPK57.Parse" href="#refinery.lib.zip.UnknownSigningBlockPK57.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipEncryptionHeader" href="#refinery.lib.zip.ZipEncryptionHeader">ZipEncryptionHeader</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipEncryptionHeader.Parse" href="#refinery.lib.zip.ZipEncryptionHeader.Parse">Parse</a></code></li>
<li><code><a title="refinery.lib.zip.ZipEncryptionHeader.derive_key" href="#refinery.lib.zip.ZipEncryptionHeader.derive_key">derive_key</a></code></li>
<li><code><a title="refinery.lib.zip.ZipEncryptionHeader.checkpwd" href="#refinery.lib.zip.ZipEncryptionHeader.checkpwd">checkpwd</a></code></li>
<li><code><a title="refinery.lib.zip.ZipEncryptionHeader.decrypt" href="#refinery.lib.zip.ZipEncryptionHeader.decrypt">decrypt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipArchiveExtraDataRecord" href="#refinery.lib.zip.ZipArchiveExtraDataRecord">ZipArchiveExtraDataRecord</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipArchiveExtraDataRecord.Parse" href="#refinery.lib.zip.ZipArchiveExtraDataRecord.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipDigitalSignature" href="#refinery.lib.zip.ZipDigitalSignature">ZipDigitalSignature</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipDigitalSignature.Parse" href="#refinery.lib.zip.ZipDigitalSignature.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipDataDescriptorRaw" href="#refinery.lib.zip.ZipDataDescriptorRaw">ZipDataDescriptorRaw</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipDataDescriptor" href="#refinery.lib.zip.ZipDataDescriptor">ZipDataDescriptor</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipDataDescriptor.Parse" href="#refinery.lib.zip.ZipDataDescriptor.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipFileRecord" href="#refinery.lib.zip.ZipFileRecord">ZipFileRecord</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.lib.zip.ZipFileRecord.Parse" href="#refinery.lib.zip.ZipFileRecord.Parse">Parse</a></code></li>
<li><code><a title="refinery.lib.zip.ZipFileRecord.get_mtime" href="#refinery.lib.zip.ZipFileRecord.get_mtime">get_mtime</a></code></li>
<li><code><a title="refinery.lib.zip.ZipFileRecord.get_ctime" href="#refinery.lib.zip.ZipFileRecord.get_ctime">get_ctime</a></code></li>
<li><code><a title="refinery.lib.zip.ZipFileRecord.get_atime" href="#refinery.lib.zip.ZipFileRecord.get_atime">get_atime</a></code></li>
<li><code><a title="refinery.lib.zip.ZipFileRecord.get_name" href="#refinery.lib.zip.ZipFileRecord.get_name">get_name</a></code></li>
<li><code><a title="refinery.lib.zip.ZipFileRecord.get_gid" href="#refinery.lib.zip.ZipFileRecord.get_gid">get_gid</a></code></li>
<li><code><a title="refinery.lib.zip.ZipFileRecord.get_uid" href="#refinery.lib.zip.ZipFileRecord.get_uid">get_uid</a></code></li>
<li><code><a title="refinery.lib.zip.ZipFileRecord.is_dir" href="#refinery.lib.zip.ZipFileRecord.is_dir">is_dir</a></code></li>
<li><code><a title="refinery.lib.zip.ZipFileRecord.is_password_ok" href="#refinery.lib.zip.ZipFileRecord.is_password_ok">is_password_ok</a></code></li>
<li><code><a title="refinery.lib.zip.ZipFileRecord.unpack" href="#refinery.lib.zip.ZipFileRecord.unpack">unpack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipEndOfCentralDirectory" href="#refinery.lib.zip.ZipEndOfCentralDirectory">ZipEndOfCentralDirectory</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipEndOfCentralDirectory.Parse" href="#refinery.lib.zip.ZipEndOfCentralDirectory.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipEocdLocator64" href="#refinery.lib.zip.ZipEocdLocator64">ZipEocdLocator64</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipEocdLocator64.Parse" href="#refinery.lib.zip.ZipEocdLocator64.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipEndOfCentralDirectory64" href="#refinery.lib.zip.ZipEndOfCentralDirectory64">ZipEndOfCentralDirectory64</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipEndOfCentralDirectory64.Parse" href="#refinery.lib.zip.ZipEndOfCentralDirectory64.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipExtraField" href="#refinery.lib.zip.ZipExtraField">ZipExtraField</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipExtraField.ParseBuffer" href="#refinery.lib.zip.ZipExtraField.ParseBuffer">ParseBuffer</a></code></li>
<li><code><a title="refinery.lib.zip.ZipExtraField.Parse" href="#refinery.lib.zip.ZipExtraField.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipExt" href="#refinery.lib.zip.ZipExt">ZipExt</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipExt.TryParse" href="#refinery.lib.zip.ZipExt.TryParse">TryParse</a></code></li>
<li><code><a title="refinery.lib.zip.ZipExt.Parse" href="#refinery.lib.zip.ZipExt.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.NoCrypto" href="#refinery.lib.zip.NoCrypto">NoCrypto</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.NoCrypto.decrypt" href="#refinery.lib.zip.NoCrypto.decrypt">decrypt</a></code></li>
<li><code><a title="refinery.lib.zip.NoCrypto.checkpwd" href="#refinery.lib.zip.NoCrypto.checkpwd">checkpwd</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.AExCrypto" href="#refinery.lib.zip.AExCrypto">AExCrypto</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.AExCrypto.Parse" href="#refinery.lib.zip.AExCrypto.Parse">Parse</a></code></li>
<li><code><a title="refinery.lib.zip.AExCrypto.checkpwd" href="#refinery.lib.zip.AExCrypto.checkpwd">checkpwd</a></code></li>
<li><code><a title="refinery.lib.zip.AExCrypto.decrypt" href="#refinery.lib.zip.AExCrypto.decrypt">decrypt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipExtAES" href="#refinery.lib.zip.ZipExtAES">ZipExtAES</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipExtAES.Parse" href="#refinery.lib.zip.ZipExtAES.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipExtInfo64" href="#refinery.lib.zip.ZipExtInfo64">ZipExtInfo64</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipExtInfo64.Parse" href="#refinery.lib.zip.ZipExtInfo64.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipExtUnixIDs" href="#refinery.lib.zip.ZipExtUnixIDs">ZipExtUnixIDs</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipExtUnixIDs.Parse" href="#refinery.lib.zip.ZipExtUnixIDs.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipExtTimestampFlags" href="#refinery.lib.zip.ZipExtTimestampFlags">ZipExtTimestampFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipExtTimestamp" href="#refinery.lib.zip.ZipExtTimestamp">ZipExtTimestamp</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipExtTimestamp.Parse" href="#refinery.lib.zip.ZipExtTimestamp.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipExtUnicodePath" href="#refinery.lib.zip.ZipExtUnicodePath">ZipExtUnicodePath</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipExtUnicodePath.Parse" href="#refinery.lib.zip.ZipExtUnicodePath.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.ZipDirEntry" href="#refinery.lib.zip.ZipDirEntry">ZipDirEntry</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.ZipDirEntry.Parse" href="#refinery.lib.zip.ZipDirEntry.Parse">Parse</a></code></li>
<li><code><a title="refinery.lib.zip.ZipDirEntry.is_dir" href="#refinery.lib.zip.ZipDirEntry.is_dir">is_dir</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.zip.Zip" href="#refinery.lib.zip.Zip">Zip</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.zip.Zip.parse_record" href="#refinery.lib.zip.Zip.parse_record">parse_record</a></code></li>
<li><code><a title="refinery.lib.zip.Zip.read" href="#refinery.lib.zip.Zip.read">read</a></code></li>
<li><code><a title="refinery.lib.zip.Zip.sub_archive_count" href="#refinery.lib.zip.Zip.sub_archive_count">sub_archive_count</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
