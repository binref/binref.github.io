<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.emulator documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.emulator</code></h1>
</header>
<section id="section-intro">
<p>This module implements an emulator abstraction layer.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/__init__.py#L1-L46" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module implements an emulator abstraction layer.
&#34;&#34;&#34;
from __future__ import annotations

import enum

from .abstract import (
    CC,
    Arch,
    EmulationError,
    Emulator,
    Hook,
    NopCodeByArch,
    NopCodeMaxLen,
    Register,
    RetCodeByArch,
    RetCodeMaxLen,
)
from .ic import IcicleEmulator
from .se import SpeakeasyEmulator
from .uc import UnicornEmulator


class Engine(enum.Enum):
    speakeasy = SpeakeasyEmulator
    icicle = IcicleEmulator
    unicorn = UnicornEmulator


__all__ = [
    &#39;Arch&#39;,
    &#39;CC&#39;,
    &#39;EmulationError&#39;,
    &#39;Emulator&#39;,
    &#39;Engine&#39;,
    &#39;Hook&#39;,
    &#39;IcicleEmulator&#39;,
    &#39;NopCodeByArch&#39;,
    &#39;NopCodeMaxLen&#39;,
    &#39;Register&#39;,
    &#39;RetCodeByArch&#39;,
    &#39;RetCodeMaxLen&#39;,
    &#39;SpeakeasyEmulator&#39;,
    &#39;UnicornEmulator&#39;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="refinery.lib.emulator.abstract" href="abstract.html">refinery.lib.emulator.abstract</a></code></dt>
<dd>
<section class="desc"><p>This module defines the refinery emulator abstraction layer interface.</p></section>
</dd>
<dt><code class="name"><a title="refinery.lib.emulator.ic" href="ic.html">refinery.lib.emulator.ic</a></code></dt>
<dd>
<section class="desc"><p>Implements <code>refinery.lib.emulator.interface.RawMetalEmulator</code> for the icicle backend.</p></section>
</dd>
<dt><code class="name"><a title="refinery.lib.emulator.se" href="se.html">refinery.lib.emulator.se</a></code></dt>
<dd>
<section class="desc"><p>Implements <code>refinery.lib.emulator.interface.Emulator</code> for the speakeasy backend.</p></section>
</dd>
<dt><code class="name"><a title="refinery.lib.emulator.uc" href="uc.html">refinery.lib.emulator.uc</a></code></dt>
<dd>
<section class="desc"><p>Implements <code>refinery.lib.emulator.interface.RawMetalEmulator</code> for the unicorn backend.</p></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.emulator.Arch"><code class="flex name class">
<span>class <span class="ident">Arch</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration of supported architectures and their register sizes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L158-L172" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Arch(ArchItem, Enum):
    &#34;&#34;&#34;
    An enumeration of supported architectures and their register sizes.
    &#34;&#34;&#34;
    X32 = (32, &#39;X32&#39;)
    X64 = (64, &#39;X64&#39;)
    ARM32 = (32, &#39;ARM32&#39;)
    ARM64 = (64, &#39;ARM64&#39;)
    MIPS16 = (16, &#39;MIPS16&#39;)
    MIPS32 = (32, &#39;MIPS32&#39;)
    MIPS64 = (64, &#39;MIPS64&#39;)
    PPC32 = (32, &#39;PPC32&#39;)
    PPC64 = (64, &#39;PPC64&#39;)
    SPARC32 = (32, &#39;SPARC32&#39;)
    SPARC64 = (64, &#39;SPARC64&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.executable.ArchItem" href="../executable.html#refinery.lib.executable.ArchItem">ArchItem</a></li>
<li>builtins.tuple</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.emulator.Arch.X32"><code class="name">var <span class="ident">X32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Arch.X64"><code class="name">var <span class="ident">X64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Arch.ARM32"><code class="name">var <span class="ident">ARM32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Arch.ARM64"><code class="name">var <span class="ident">ARM64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Arch.MIPS16"><code class="name">var <span class="ident">MIPS16</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Arch.MIPS32"><code class="name">var <span class="ident">MIPS32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Arch.MIPS64"><code class="name">var <span class="ident">MIPS64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Arch.PPC32"><code class="name">var <span class="ident">PPC32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Arch.PPC64"><code class="name">var <span class="ident">PPC64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Arch.SPARC32"><code class="name">var <span class="ident">SPARC32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Arch.SPARC64"><code class="name">var <span class="ident">SPARC64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.executable.ArchItem" href="../executable.html#refinery.lib.executable.ArchItem">ArchItem</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.executable.ArchItem.id" href="../executable.html#refinery.lib.executable.ArchItem.id">id</a></code></li>
<li><code><a title="refinery.lib.executable.ArchItem.pointer_size" href="../executable.html#refinery.lib.executable.ArchItem.pointer_size">pointer_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.emulator.CC"><code class="flex name class">
<span>class <span class="ident">CC</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>A selection of x86 calling conventions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L27-L34" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CC(str, Enum):
    &#34;&#34;&#34;
    A selection of x86 calling conventions.
    &#34;&#34;&#34;
    CDecl = &#39;__cdecl&#39;
    FastCall = &#39;__fastcall&#39;
    StdCall = &#39;__stdcall&#39;
    ThisCall = &#39;__thiscall&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.emulator.CC.CDecl"><code class="name">var <span class="ident">CDecl</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.CC.FastCall"><code class="name">var <span class="ident">FastCall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.CC.StdCall"><code class="name">var <span class="ident">StdCall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.CC.ThisCall"><code class="name">var <span class="ident">ThisCall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.emulator.EmulationError"><code class="flex name class">
<span>class <span class="ident">EmulationError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for any exceptions raised by emulators.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L21-L24" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class EmulationError(Exception):
    &#34;&#34;&#34;
    Base class for any exceptions raised by emulators.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.emulator.se.SpeakeasyNotInitialized" href="se.html#refinery.lib.emulator.se.SpeakeasyNotInitialized">SpeakeasyNotInitialized</a></li>
</ul>
</dd>
<dt id="refinery.lib.emulator.Emulator"><code class="flex name class">
<span>class <span class="ident">Emulator</span></span>
<span>(</span><span>data, base=None, arch=None, hooks=18, align_size=4096, alloc_size=4096)</span>
</code></dt>
<dd>
<section class="desc"><p>The emulator base class.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L128-L682" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Emulator(ABC, Generic[_E, _R, _T]):
    &#34;&#34;&#34;
    The emulator base class.
    &#34;&#34;&#34;
    stack_base: int
    stack_size: int
    alloc_base: int

    state: _T | None

    def __init__(
        self,
        data: Executable | buf,
        base: int | None = None,
        arch: Arch | None = None,
        hooks: Hook = Hook.OnlyErrors,
        align_size: int = 0x1000,
        alloc_size: int = 0x1000,
    ):
        if isinstance(data, Executable):
            exe = data
            raw = False
        else:
            try:
                exe = Executable.Load(data, base)
            except ValueError:
                exe = ExecutableCodeBlob(data, base, arch or Arch.X32)
                raw = True
            else:
                raw = False

        self.exe = exe
        self.raw = raw

        self.hooks = hooks
        self.base = exe.base

        self.align_size = align_size
        self.alloc_size = alloc_size
        self._resetonce = False

        self._sp, self._ip, self._rv = {
            Arch.PPC32   : (&#39;1&#39;,   &#39;pc&#39;,  &#39;3&#39;  ), # noqa
            Arch.PPC64   : (&#39;1&#39;,   &#39;pc&#39;,  &#39;3&#39;  ), # noqa
            Arch.X32     : (&#39;esp&#39;, &#39;eip&#39;, &#39;eax&#39;), # noqa
            Arch.X64     : (&#39;rsp&#39;, &#39;rip&#39;, &#39;rax&#39;), # noqa
            Arch.ARM32   : (&#39;sp&#39;,  &#39;pc&#39;,  &#39;r0&#39; ), # noqa
            Arch.ARM64   : (&#39;sp&#39;,  &#39;pc&#39;,  &#39;x0&#39; ), # noqa
            Arch.MIPS16  : (&#39;sp&#39;,  &#39;pc&#39;,  &#39;0&#39;  ), # noqa
            Arch.MIPS32  : (&#39;sp&#39;,  &#39;pc&#39;,  &#39;v0&#39; ), # noqa
            Arch.MIPS64  : (&#39;sp&#39;,  &#39;pc&#39;,  &#39;v0&#39; ), # noqa
            Arch.SPARC32 : (&#39;sp&#39;,  &#39;pc&#39;,  &#39;o0&#39; ), # noqa
            Arch.SPARC64 : (&#39;sp&#39;,  &#39;pc&#39;,  &#39;o0&#39; ), # noqa
        }[exe.arch()]

        self._init()

    def call(
        self,
        address: int,
        until: int | None = None,
        *args: buf | int,
        cc: CC = CC.StdCall,
    ):
        if until is None:
            try:
                until = self._return_trap
            except AttributeError:
                nopcode = NopCodeByArch[self.exe.arch()]
                self._return_trap = until = self.malloc(len(nopcode))
                self.mem_write(until, nopcode)

        self.set_return_address(until)

        for k, value in enumerate(args):
            if b := asbuffer(value):
                b = bytes(b)
                value = self.malloc(len(b))
                self.mem_write(value, b)
            self.callarg(k, cc, value=value)

        self.emulate(address, until)
        return self.rv

    def callarg(
        self,
        index: int,
        cc: CC = CC.StdCall,
        size: int | None = None,
        value: int | None = None,
    ) -&gt; int:
        arch = self.exe.arch()
        if index &lt; 0:
            raise ValueError(index)
        if arch == Arch.X32:
            if cc == CC.FastCall:
                regs = (&#39;ecx&#39;, &#39;edx&#39;)
            elif cc == CC.ThisCall:
                regs = (&#39;ecx&#39;,)
            else:
                regs = ()
        elif arch == Arch.X64:
            regs = (&#39;rcx&#39;, &#39;rdx&#39;, &#39;r8&#39;, &#39;r9&#39;)
        elif arch == Arch.ARM32:
            regs = (&#39;r0&#39;, &#39;r1&#39;, &#39;r2&#39;, &#39;r3&#39;)
        elif arch == Arch.ARM64:
            regs = (&#39;x0&#39;, &#39;x1&#39;, &#39;x2&#39;, &#39;x3&#39;, &#39;x4&#39;, &#39;x5&#39;, &#39;x6&#39;, &#39;x7&#39;)
        else:
            raise NotImplementedError(F&#39;Calling convention {cc.value} is not implemented for {arch.name}&#39;)
        try:
            reg = regs[index]
        except IndexError:
            address = self.sp + (index - len(regs)) * self.exe.pointer_size_in_bytes
            if value is None:
                return self.mem_read_int(address)
            else:
                self.mem_write_int(address, value)
                return value
        else:
            if value is None:
                arg = self.get_register(reg)
                if size is not None:
                    arg &amp;= (1 &lt;&lt; (size &lt;&lt; 3)) - 1
                return arg
            else:
                self.set_register(reg, value)
                return value

    @cached_property
    def _reg_sp(self):
        return self._lookup_register(self._sp).code

    @cached_property
    def _reg_ip(self):
        return self._lookup_register(self._ip).code

    @cached_property
    def _reg_rv(self):
        return self._lookup_register(self._rv).code

    def hooked(self, hook: Hook) -&gt; bool:
        &#34;&#34;&#34;
        Return whether the given hook is (supposed to be) set.
        &#34;&#34;&#34;
        return self.hooks &amp; hook == hook

    def reset(self, state: _T | None = None):
        &#34;&#34;&#34;
        This function resets the emulator to an initial state. This will create a new instance of
        the underlying emulator engine, map the input executable to memory, and install any of the
        requested hooks.
        &#34;&#34;&#34;
        self._resetonce = True
        self._memorymap = IntIntervalUnion()
        self.state = state
        self._reset()
        for rd in self.exe.relocations():
            self.mem_write_int(rd.address, rd.value, rd.size)
        return self

    def step(self, address: int, count: int = 1) -&gt; int:
        &#34;&#34;&#34;
        This method emulates `count` many instructions starting at `address`. Returns the current
        instruction pointer value after stepping.
        &#34;&#34;&#34;
        if not self._resetonce:
            self.reset()
        try:
            self._enable_single_step()
            for _ in range(count):
                self.emulate(address)
                address = self.ip
            return address
        finally:
            self._disable_single_step()

    def base_exe_to_emu(self, address: int | None):
        &#34;&#34;&#34;
        Rebase a virtual address from the base executable&#39;s address space to the one used by the
        emulator.
        &#34;&#34;&#34;
        if address is not None:
            address = address - self.exe.base + self.base
        return address

    def base_emu_to_exe(self, address: int | None):
        &#34;&#34;&#34;
        Rebase a virtual address from the emulator&#39;s address space to the one used by the base
        executable.
        &#34;&#34;&#34;
        if address is not None:
            address = address + self.exe.base - self.base
        return address

    def emulate(self, start: int, end: int | None = None):
        &#34;&#34;&#34;
        Call this function to begin emulation. The `start` parameter is the address where execution
        should begin, the `end` parameter is an optional address to halt at.
        &#34;&#34;&#34;
        if not self._resetonce:
            self.reset()
        return self._emulate(start, end)

    def mem_read_int(self, address: int, size: int | None = None):
        &#34;&#34;&#34;
        Read an integer from memory at the given address. The default for the size parameter is
        the pointer size of the emulated executable.
        &#34;&#34;&#34;
        if size is None:
            size = self.exe.pointer_size_in_bytes
        return int.from_bytes(self.mem_read(address, size), self.exe.byte_order().value)

    def mem_write_int(self, address: int, value: int, size: int | None = None):
        &#34;&#34;&#34;
        Read an integer from memory at the given address. The default for the size parameter is
        the pointer size of the emulated executable.
        &#34;&#34;&#34;
        if size is None:
            size = self.exe.pointer_size_in_bytes
        return self.mem_write(address, value.to_bytes(size, self.exe.byte_order().value))

    @abstractmethod
    def _reset(self):
        &#34;&#34;&#34;
        Called as part of `refinery.lib.emulator.Emulator.reset`.
        &#34;&#34;&#34;
        ...

    def _init(self):
        &#34;&#34;&#34;
        Called at the very end of the object initializer. Can be overridden by child classes to
        initialize variables that do not depend on the emulator engine to be ready.
        &#34;&#34;&#34;

    @abstractmethod
    def _emulate(self, start: int, end: int | None = None):
        &#34;&#34;&#34;
        This is the tail call of `refinery.lib.emulator.Emulator.emulate`.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def halt(self):
        &#34;&#34;&#34;
        Causes the emulation to halt, usually when called from a hook.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def _set_register(self, register: _R, v: int):
        &#34;&#34;&#34;
        Called as part of `refinery.lib.emulator.Emulator.set_register`.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def _get_register(self, register: _R) -&gt; int:
        &#34;&#34;&#34;
        Called as part of `refinery.lib.emulator.Emulator.get_register`.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def _lookup_register(self, var: str | _R) -&gt; Register[_R]:
        &#34;&#34;&#34;
        Called as part of `refinery.lib.emulator.Emulator.lookup_register`.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def _map(self, address: int, size: int):
        &#34;&#34;&#34;
        Called as part of `refinery.lib.emulator.Emulator.map`.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def mem_write(self, address: int, data: bytes):
        &#34;&#34;&#34;
        Write data to already mapped memory.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def mem_read(self, address: int, size: int) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the emulator&#39;s mapped memory.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def malloc(self, size: int) -&gt; int:
        &#34;&#34;&#34;
        Allocate (i.e. map) the given amount of memory in the emulator&#39;s memory space.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def _enable_single_step(self):
        &#34;&#34;&#34;
        Enable single stepping.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def _disable_single_step(self):
        &#34;&#34;&#34;
        Enable single stepping.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def morestack(self):
        &#34;&#34;&#34;
        Allocate more memory for the stack to grow into.
        &#34;&#34;&#34;
        ...

    def lookup_register(self, var: str | _R | Register[_R]):
        &#34;&#34;&#34;
        Return the `refinery.lib.emulator.Register` for the given name or code. `Register` type
        inputs are passed through unaltered.
        &#34;&#34;&#34;
        if isinstance(var, Register):
            return var
        return self._lookup_register(var)

    def _map_update(self):
        &#34;&#34;&#34;
        This function can be implemented by a child class to update the internal memory maps before
        resizing a requested mapping to fit with the already existing maps.
        &#34;&#34;&#34;

    def is_mapped(self, address: int, size: int = 1):
        &#34;&#34;&#34;
        Can be used to test whether a certain amount of memory at a given address is already mapped.
        &#34;&#34;&#34;
        self._map_update()
        for interval in self._memorymap.overlap(address, size):
            if sum(interval) &gt;= address + size:
                return True
        return False

    def map(self, address: int, size: int, update_map=True):
        &#34;&#34;&#34;
        Map memory of the given size at the given address. This function does not fail when part
        of the memory is already mapped; it will instead map only the missing pieces.
        &#34;&#34;&#34;
        if size &lt;= 0:
            return
        if update_map:
            self._map_update()
        lower = address
        upper = address + size
        for start, value in self._memorymap.overlap(address, size):
            pivot = start + value
            a = start - lower
            b = upper - pivot
            if a &gt;= 0 and b &gt;= 0:
                self.map(lower, a, update_map=False)
                self.map(pivot, b, update_map=False)
                return
            if a &gt;= 0:
                upper = start
            if b &gt;= 0:
                lower = pivot
            if lower &gt;= upper:
                return
        self._map(lower, upper - lower)
        self._memorymap.addi(address, size)

    @property
    def sp(self):
        &#34;&#34;&#34;
        The stack pointer.
        &#34;&#34;&#34;
        return self.get_register(self._reg_sp)

    @sp.setter
    def sp(self, value: int):
        return self.set_register(self._reg_sp, value)

    @property
    def rv(self):
        &#34;&#34;&#34;
        The return value.
        &#34;&#34;&#34;
        return self.get_register(self._reg_rv)

    @rv.setter
    def rv(self, value: int):
        return self.set_register(self._reg_rv, value)

    @property
    def ip(self):
        &#34;&#34;&#34;
        The instruction pointer.
        &#34;&#34;&#34;
        return self.get_register(self._reg_ip)

    @ip.setter
    def ip(self, value: int):
        return self.set_register(self._reg_ip, value)

    def measure_register_size(self, reg: _R) -&gt; int:
        &#34;&#34;&#34;
        Measures the size of a register by writing a very large number to it with all bits set,
        subsequently reading the register value, and counting the number of bits in the
        measurement. Props for this one go to Matthieu Walter who originally proposed it as a
        joke; I have not found a better way to do this for uncooperative emulators.
        &#34;&#34;&#34;
        val = self._get_register(reg)
        self._set_register(reg, (1 &lt;&lt; 512) - 1)
        q, r = divmod(self._get_register(reg).bit_length(), 8)
        assert r == 0
        self._set_register(reg, val)
        return q

    def set_return_address(self, address: int):
        if (arch := self.exe.arch()) in (Arch.X32, Arch.X64):
            self.push(address)
        elif arch == Arch.ARM64:
            self.set_register(&#39;x30&#39;, address)
        elif arch == Arch.ARM32:
            self.set_register(&#39;r14&#39;, address)
        elif arch in (Arch.PPC32, Arch.PPC64):
            self.set_register(&#39;lr&#39;, address)
        elif arch in (Arch.MIPS16, Arch.MIPS32, Arch.MIPS64):
            self.set_register(&#39;re&#39;, address)
        elif arch in (Arch.SPARC32, Arch.SPARC64):
            self.set_register(&#39;i7&#39;, address)

    def push(self, val: int, size: int | None = None):
        &#34;&#34;&#34;
        Push the given integer value to the stack. If the `size` parameter is missing, the function
        will push a machine word sized value.
        &#34;&#34;&#34;
        if size is None:
            size = self.exe.pointer_size // 8
        tos = self.sp - size
        for already_retried_once in (False, True):
            try:
                self.mem_write(tos, val.to_bytes(size, self.exe.byte_order().value))
            except Exception:
                if already_retried_once:
                    raise
                self.morestack()
            else:
                self.sp = tos
                break

    def pop(self, size: int | None = None):
        &#34;&#34;&#34;
        Pop an integer value from the stack. If the `size` parameter is missing, the function will
        pop a machine word sized value.
        &#34;&#34;&#34;
        if size is None:
            size = self.exe.pointer_size // 8
        sp = self.sp
        sv = int.from_bytes(self.mem_read(sp, size), self.exe.byte_order().value)
        self.sp = sp + size
        return sv

    def push_register(self, reg: str | _R | Register[_R]):
        &#34;&#34;&#34;
        Push the contents of the given register to the stack.
        &#34;&#34;&#34;
        reg = self.lookup_register(reg)
        val = self.get_register(reg.code)
        self.push(val, reg.size)

    def align(self, value, down=False):
        &#34;&#34;&#34;
        Align the given value according to the emulator&#39;s alignment setting. If the `down` parameter
        is set, it will return the nearest lower address instead of the nearest higher one.
        &#34;&#34;&#34;
        return align(self.align_size, value, down=down)

    def set_register(self, register: str | _R | Register[_R], value: int):
        &#34;&#34;&#34;
        Write the given value to the given CPU register.
        &#34;&#34;&#34;
        r = self.lookup_register(register)
        return self._set_register(r.code, value)

    def get_register(self, register: str | _R | Register[_R]) -&gt; int:
        &#34;&#34;&#34;
        Read the contents of the given CPU register.
        &#34;&#34;&#34;
        r = self.lookup_register(register)
        return self._get_register(r.code)

    def hook_code_execute(self, emu: _E, address: int, size: int, state: _T | None = None) -&gt; bool:
        &#34;&#34;&#34;
        Called when code execution is hooked.
        &#34;&#34;&#34;
        return True

    def hook_code_error(self, emu: _E, state: _T | None = None) -&gt; bool:
        &#34;&#34;&#34;
        Called when code errors are hooked.
        &#34;&#34;&#34;
        self.halt()
        return False

    def hook_mem_read(self, emu: _E, access: int, address: int, size: int, value: int, state: _T | None = None) -&gt; bool:
        &#34;&#34;&#34;
        Called when memory reads are hooked.
        &#34;&#34;&#34;
        return True

    def hook_mem_write(self, emu: _E, access: int, address: int, size: int, value: int, state: _T | None = None) -&gt; bool:
        &#34;&#34;&#34;
        Called when memory writes are hooked.
        &#34;&#34;&#34;
        return True

    def hook_mem_error(self, emu: _E, access: int, address: int, size: int, value: int, state: _T | None = None) -&gt; bool:
        &#34;&#34;&#34;
        Called when memory errors are hooked.
        &#34;&#34;&#34;
        try:
            self.map(self.align(address, down=True), self.alloc_size)
        except Exception:
            pass
        return True

    def hook_api_call(self, emu: _E, name: str, cb=None, args=()) -&gt; Any:
        return None

    def disassemble_instruction(self, address: int):
        &#34;&#34;&#34;
        Disassemble a single instruction at the given address.
        &#34;&#34;&#34;
        if not self._resetonce:
            self.reset()
        cs = self.exe.disassembler()
        cs.detail = True
        data = self.mem_read(address, 0x20)
        return next(cs.disasm(data, address, 1))

    def general_purpose_registers(self):
        &#34;&#34;&#34;
        A generator that lists the general purpose registers for the current architecture. The
        implementation is currently incomplete and only has support for the Intel architectures.
        For other architectures, this is an empty generator.
        &#34;&#34;&#34;
        arch = self.exe.arch()
        regs = []
        if arch is Arch.X32:
            regs = (&#39;eax&#39;, &#39;ebx&#39;, &#39;ecx&#39;, &#39;edx&#39;, &#39;esi&#39;, &#39;edi&#39;, &#39;ebp&#39;)
        elif arch is Arch.X64:
            regs = (&#39;rax&#39;, &#39;rbx&#39;, &#39;rcx&#39;, &#39;rdx&#39;, &#39;rsi&#39;, &#39;rdi&#39;, &#39;rbp&#39;, &#39;r8&#39;, &#39;r9&#39;, &#39;r10&#39;, &#39;r11&#39;, &#39;r12&#39;, &#39;r13&#39;, &#39;r14&#39;, &#39;r15&#39;)
        for reg in regs:
            yield self._lookup_register(reg)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.emulator.abstract.RawMetalEmulator" href="abstract.html#refinery.lib.emulator.abstract.RawMetalEmulator">RawMetalEmulator</a></li>
<li><a title="refinery.lib.emulator.se.SpeakeasyEmulator" href="se.html#refinery.lib.emulator.se.SpeakeasyEmulator">SpeakeasyEmulator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.emulator.Emulator.stack_base"><code class="name">var <span class="ident">stack_base</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Emulator.stack_size"><code class="name">var <span class="ident">stack_size</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Emulator.alloc_base"><code class="name">var <span class="ident">alloc_base</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Emulator.state"><code class="name">var <span class="ident">state</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.emulator.Emulator.sp"><code class="name">var <span class="ident">sp</span></code></dt>
<dd>
<section class="desc"><p>The stack pointer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L499-L504" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def sp(self):
    &#34;&#34;&#34;
    The stack pointer.
    &#34;&#34;&#34;
    return self.get_register(self._reg_sp)</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.rv"><code class="name">var <span class="ident">rv</span></code></dt>
<dd>
<section class="desc"><p>The return value.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L510-L515" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def rv(self):
    &#34;&#34;&#34;
    The return value.
    &#34;&#34;&#34;
    return self.get_register(self._reg_rv)</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.ip"><code class="name">var <span class="ident">ip</span></code></dt>
<dd>
<section class="desc"><p>The instruction pointer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L521-L526" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def ip(self):
    &#34;&#34;&#34;
    The instruction pointer.
    &#34;&#34;&#34;
    return self.get_register(self._reg_ip)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.emulator.Emulator.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, address, until=None, *args, cc=CC.StdCall)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L185-L210" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def call(
    self,
    address: int,
    until: int | None = None,
    *args: buf | int,
    cc: CC = CC.StdCall,
):
    if until is None:
        try:
            until = self._return_trap
        except AttributeError:
            nopcode = NopCodeByArch[self.exe.arch()]
            self._return_trap = until = self.malloc(len(nopcode))
            self.mem_write(until, nopcode)

    self.set_return_address(until)

    for k, value in enumerate(args):
        if b := asbuffer(value):
            b = bytes(b)
            value = self.malloc(len(b))
            self.mem_write(value, b)
        self.callarg(k, cc, value=value)

    self.emulate(address, until)
    return self.rv</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.callarg"><code class="name flex">
<span>def <span class="ident">callarg</span></span>(<span>self, index, cc=CC.StdCall, size=None, value=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L212-L254" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def callarg(
    self,
    index: int,
    cc: CC = CC.StdCall,
    size: int | None = None,
    value: int | None = None,
) -&gt; int:
    arch = self.exe.arch()
    if index &lt; 0:
        raise ValueError(index)
    if arch == Arch.X32:
        if cc == CC.FastCall:
            regs = (&#39;ecx&#39;, &#39;edx&#39;)
        elif cc == CC.ThisCall:
            regs = (&#39;ecx&#39;,)
        else:
            regs = ()
    elif arch == Arch.X64:
        regs = (&#39;rcx&#39;, &#39;rdx&#39;, &#39;r8&#39;, &#39;r9&#39;)
    elif arch == Arch.ARM32:
        regs = (&#39;r0&#39;, &#39;r1&#39;, &#39;r2&#39;, &#39;r3&#39;)
    elif arch == Arch.ARM64:
        regs = (&#39;x0&#39;, &#39;x1&#39;, &#39;x2&#39;, &#39;x3&#39;, &#39;x4&#39;, &#39;x5&#39;, &#39;x6&#39;, &#39;x7&#39;)
    else:
        raise NotImplementedError(F&#39;Calling convention {cc.value} is not implemented for {arch.name}&#39;)
    try:
        reg = regs[index]
    except IndexError:
        address = self.sp + (index - len(regs)) * self.exe.pointer_size_in_bytes
        if value is None:
            return self.mem_read_int(address)
        else:
            self.mem_write_int(address, value)
            return value
    else:
        if value is None:
            arg = self.get_register(reg)
            if size is not None:
                arg &amp;= (1 &lt;&lt; (size &lt;&lt; 3)) - 1
            return arg
        else:
            self.set_register(reg, value)
            return value</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.hooked"><code class="name flex">
<span>def <span class="ident">hooked</span></span>(<span>self, hook)</span>
</code></dt>
<dd>
<section class="desc"><p>Return whether the given hook is (supposed to be) set.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L268-L272" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hooked(self, hook: Hook) -&gt; bool:
    &#34;&#34;&#34;
    Return whether the given hook is (supposed to be) set.
    &#34;&#34;&#34;
    return self.hooks &amp; hook == hook</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, state=None)</span>
</code></dt>
<dd>
<section class="desc"><p>This function resets the emulator to an initial state. This will create a new instance of
the underlying emulator engine, map the input executable to memory, and install any of the
requested hooks.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L274-L286" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reset(self, state: _T | None = None):
    &#34;&#34;&#34;
    This function resets the emulator to an initial state. This will create a new instance of
    the underlying emulator engine, map the input executable to memory, and install any of the
    requested hooks.
    &#34;&#34;&#34;
    self._resetonce = True
    self._memorymap = IntIntervalUnion()
    self.state = state
    self._reset()
    for rd in self.exe.relocations():
        self.mem_write_int(rd.address, rd.value, rd.size)
    return self</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, address, count=1)</span>
</code></dt>
<dd>
<section class="desc"><p>This method emulates <code>count</code> many instructions starting at <code>address</code>. Returns the current
instruction pointer value after stepping.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L288-L302" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def step(self, address: int, count: int = 1) -&gt; int:
    &#34;&#34;&#34;
    This method emulates `count` many instructions starting at `address`. Returns the current
    instruction pointer value after stepping.
    &#34;&#34;&#34;
    if not self._resetonce:
        self.reset()
    try:
        self._enable_single_step()
        for _ in range(count):
            self.emulate(address)
            address = self.ip
        return address
    finally:
        self._disable_single_step()</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.base_exe_to_emu"><code class="name flex">
<span>def <span class="ident">base_exe_to_emu</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<section class="desc"><p>Rebase a virtual address from the base executable's address space to the one used by the
emulator.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L304-L311" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def base_exe_to_emu(self, address: int | None):
    &#34;&#34;&#34;
    Rebase a virtual address from the base executable&#39;s address space to the one used by the
    emulator.
    &#34;&#34;&#34;
    if address is not None:
        address = address - self.exe.base + self.base
    return address</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.base_emu_to_exe"><code class="name flex">
<span>def <span class="ident">base_emu_to_exe</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<section class="desc"><p>Rebase a virtual address from the emulator's address space to the one used by the base
executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L313-L320" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def base_emu_to_exe(self, address: int | None):
    &#34;&#34;&#34;
    Rebase a virtual address from the emulator&#39;s address space to the one used by the base
    executable.
    &#34;&#34;&#34;
    if address is not None:
        address = address + self.exe.base - self.base
    return address</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.emulate"><code class="name flex">
<span>def <span class="ident">emulate</span></span>(<span>self, start, end=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Call this function to begin emulation. The <code>start</code> parameter is the address where execution
should begin, the <code>end</code> parameter is an optional address to halt at.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L322-L329" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def emulate(self, start: int, end: int | None = None):
    &#34;&#34;&#34;
    Call this function to begin emulation. The `start` parameter is the address where execution
    should begin, the `end` parameter is an optional address to halt at.
    &#34;&#34;&#34;
    if not self._resetonce:
        self.reset()
    return self._emulate(start, end)</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.mem_read_int"><code class="name flex">
<span>def <span class="ident">mem_read_int</span></span>(<span>self, address, size=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Read an integer from memory at the given address. The default for the size parameter is
the pointer size of the emulated executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L331-L338" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mem_read_int(self, address: int, size: int | None = None):
    &#34;&#34;&#34;
    Read an integer from memory at the given address. The default for the size parameter is
    the pointer size of the emulated executable.
    &#34;&#34;&#34;
    if size is None:
        size = self.exe.pointer_size_in_bytes
    return int.from_bytes(self.mem_read(address, size), self.exe.byte_order().value)</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.mem_write_int"><code class="name flex">
<span>def <span class="ident">mem_write_int</span></span>(<span>self, address, value, size=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Read an integer from memory at the given address. The default for the size parameter is
the pointer size of the emulated executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L340-L347" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mem_write_int(self, address: int, value: int, size: int | None = None):
    &#34;&#34;&#34;
    Read an integer from memory at the given address. The default for the size parameter is
    the pointer size of the emulated executable.
    &#34;&#34;&#34;
    if size is None:
        size = self.exe.pointer_size_in_bytes
    return self.mem_write(address, value.to_bytes(size, self.exe.byte_order().value))</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.halt"><code class="name flex">
<span>def <span class="ident">halt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Causes the emulation to halt, usually when called from a hook.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L369-L374" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def halt(self):
    &#34;&#34;&#34;
    Causes the emulation to halt, usually when called from a hook.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.mem_write"><code class="name flex">
<span>def <span class="ident">mem_write</span></span>(<span>self, address, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Write data to already mapped memory.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L404-L409" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def mem_write(self, address: int, data: bytes):
    &#34;&#34;&#34;
    Write data to already mapped memory.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.mem_read"><code class="name flex">
<span>def <span class="ident">mem_read</span></span>(<span>self, address, size)</span>
</code></dt>
<dd>
<section class="desc"><p>Read data from the emulator's mapped memory.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L411-L416" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def mem_read(self, address: int, size: int) -&gt; bytes:
    &#34;&#34;&#34;
    Read data from the emulator&#39;s mapped memory.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.malloc"><code class="name flex">
<span>def <span class="ident">malloc</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<section class="desc"><p>Allocate (i.e. map) the given amount of memory in the emulator's memory space.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L418-L423" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def malloc(self, size: int) -&gt; int:
    &#34;&#34;&#34;
    Allocate (i.e. map) the given amount of memory in the emulator&#39;s memory space.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.morestack"><code class="name flex">
<span>def <span class="ident">morestack</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Allocate more memory for the stack to grow into.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L439-L444" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def morestack(self):
    &#34;&#34;&#34;
    Allocate more memory for the stack to grow into.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.lookup_register"><code class="name flex">
<span>def <span class="ident">lookup_register</span></span>(<span>self, var)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the <code><a title="refinery.lib.emulator.Register" href="#refinery.lib.emulator.Register">Register</a></code> for the given name or code. <code><a title="refinery.lib.emulator.Register" href="#refinery.lib.emulator.Register">Register</a></code> type
inputs are passed through unaltered.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L446-L453" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def lookup_register(self, var: str | _R | Register[_R]):
    &#34;&#34;&#34;
    Return the `refinery.lib.emulator.Register` for the given name or code. `Register` type
    inputs are passed through unaltered.
    &#34;&#34;&#34;
    if isinstance(var, Register):
        return var
    return self._lookup_register(var)</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.is_mapped"><code class="name flex">
<span>def <span class="ident">is_mapped</span></span>(<span>self, address, size=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Can be used to test whether a certain amount of memory at a given address is already mapped.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L461-L469" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_mapped(self, address: int, size: int = 1):
    &#34;&#34;&#34;
    Can be used to test whether a certain amount of memory at a given address is already mapped.
    &#34;&#34;&#34;
    self._map_update()
    for interval in self._memorymap.overlap(address, size):
        if sum(interval) &gt;= address + size:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, address, size, update_map=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Map memory of the given size at the given address. This function does not fail when part
of the memory is already mapped; it will instead map only the missing pieces.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L471-L497" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def map(self, address: int, size: int, update_map=True):
    &#34;&#34;&#34;
    Map memory of the given size at the given address. This function does not fail when part
    of the memory is already mapped; it will instead map only the missing pieces.
    &#34;&#34;&#34;
    if size &lt;= 0:
        return
    if update_map:
        self._map_update()
    lower = address
    upper = address + size
    for start, value in self._memorymap.overlap(address, size):
        pivot = start + value
        a = start - lower
        b = upper - pivot
        if a &gt;= 0 and b &gt;= 0:
            self.map(lower, a, update_map=False)
            self.map(pivot, b, update_map=False)
            return
        if a &gt;= 0:
            upper = start
        if b &gt;= 0:
            lower = pivot
        if lower &gt;= upper:
            return
    self._map(lower, upper - lower)
    self._memorymap.addi(address, size)</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.measure_register_size"><code class="name flex">
<span>def <span class="ident">measure_register_size</span></span>(<span>self, reg)</span>
</code></dt>
<dd>
<section class="desc"><p>Measures the size of a register by writing a very large number to it with all bits set,
subsequently reading the register value, and counting the number of bits in the
measurement. Props for this one go to Matthieu Walter who originally proposed it as a
joke; I have not found a better way to do this for uncooperative emulators.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L532-L544" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def measure_register_size(self, reg: _R) -&gt; int:
    &#34;&#34;&#34;
    Measures the size of a register by writing a very large number to it with all bits set,
    subsequently reading the register value, and counting the number of bits in the
    measurement. Props for this one go to Matthieu Walter who originally proposed it as a
    joke; I have not found a better way to do this for uncooperative emulators.
    &#34;&#34;&#34;
    val = self._get_register(reg)
    self._set_register(reg, (1 &lt;&lt; 512) - 1)
    q, r = divmod(self._get_register(reg).bit_length(), 8)
    assert r == 0
    self._set_register(reg, val)
    return q</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.set_return_address"><code class="name flex">
<span>def <span class="ident">set_return_address</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L546-L558" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_return_address(self, address: int):
    if (arch := self.exe.arch()) in (Arch.X32, Arch.X64):
        self.push(address)
    elif arch == Arch.ARM64:
        self.set_register(&#39;x30&#39;, address)
    elif arch == Arch.ARM32:
        self.set_register(&#39;r14&#39;, address)
    elif arch in (Arch.PPC32, Arch.PPC64):
        self.set_register(&#39;lr&#39;, address)
    elif arch in (Arch.MIPS16, Arch.MIPS32, Arch.MIPS64):
        self.set_register(&#39;re&#39;, address)
    elif arch in (Arch.SPARC32, Arch.SPARC64):
        self.set_register(&#39;i7&#39;, address)</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, val, size=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Push the given integer value to the stack. If the <code>size</code> parameter is missing, the function
will push a machine word sized value.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L560-L577" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def push(self, val: int, size: int | None = None):
    &#34;&#34;&#34;
    Push the given integer value to the stack. If the `size` parameter is missing, the function
    will push a machine word sized value.
    &#34;&#34;&#34;
    if size is None:
        size = self.exe.pointer_size // 8
    tos = self.sp - size
    for already_retried_once in (False, True):
        try:
            self.mem_write(tos, val.to_bytes(size, self.exe.byte_order().value))
        except Exception:
            if already_retried_once:
                raise
            self.morestack()
        else:
            self.sp = tos
            break</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Pop an integer value from the stack. If the <code>size</code> parameter is missing, the function will
pop a machine word sized value.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L579-L589" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pop(self, size: int | None = None):
    &#34;&#34;&#34;
    Pop an integer value from the stack. If the `size` parameter is missing, the function will
    pop a machine word sized value.
    &#34;&#34;&#34;
    if size is None:
        size = self.exe.pointer_size // 8
    sp = self.sp
    sv = int.from_bytes(self.mem_read(sp, size), self.exe.byte_order().value)
    self.sp = sp + size
    return sv</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.push_register"><code class="name flex">
<span>def <span class="ident">push_register</span></span>(<span>self, reg)</span>
</code></dt>
<dd>
<section class="desc"><p>Push the contents of the given register to the stack.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L591-L597" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def push_register(self, reg: str | _R | Register[_R]):
    &#34;&#34;&#34;
    Push the contents of the given register to the stack.
    &#34;&#34;&#34;
    reg = self.lookup_register(reg)
    val = self.get_register(reg.code)
    self.push(val, reg.size)</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.align"><code class="name flex">
<span>def <span class="ident">align</span></span>(<span>self, value, down=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Align the given value according to the emulator's alignment setting. If the <code>down</code> parameter
is set, it will return the nearest lower address instead of the nearest higher one.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L599-L604" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def align(self, value, down=False):
    &#34;&#34;&#34;
    Align the given value according to the emulator&#39;s alignment setting. If the `down` parameter
    is set, it will return the nearest lower address instead of the nearest higher one.
    &#34;&#34;&#34;
    return align(self.align_size, value, down=down)</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.set_register"><code class="name flex">
<span>def <span class="ident">set_register</span></span>(<span>self, register, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Write the given value to the given CPU register.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L606-L611" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_register(self, register: str | _R | Register[_R], value: int):
    &#34;&#34;&#34;
    Write the given value to the given CPU register.
    &#34;&#34;&#34;
    r = self.lookup_register(register)
    return self._set_register(r.code, value)</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.get_register"><code class="name flex">
<span>def <span class="ident">get_register</span></span>(<span>self, register)</span>
</code></dt>
<dd>
<section class="desc"><p>Read the contents of the given CPU register.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L613-L618" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_register(self, register: str | _R | Register[_R]) -&gt; int:
    &#34;&#34;&#34;
    Read the contents of the given CPU register.
    &#34;&#34;&#34;
    r = self.lookup_register(register)
    return self._get_register(r.code)</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.hook_code_execute"><code class="name flex">
<span>def <span class="ident">hook_code_execute</span></span>(<span>self, emu, address, size, state=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when code execution is hooked.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L620-L624" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hook_code_execute(self, emu: _E, address: int, size: int, state: _T | None = None) -&gt; bool:
    &#34;&#34;&#34;
    Called when code execution is hooked.
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.hook_code_error"><code class="name flex">
<span>def <span class="ident">hook_code_error</span></span>(<span>self, emu, state=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when code errors are hooked.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L626-L631" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hook_code_error(self, emu: _E, state: _T | None = None) -&gt; bool:
    &#34;&#34;&#34;
    Called when code errors are hooked.
    &#34;&#34;&#34;
    self.halt()
    return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.hook_mem_read"><code class="name flex">
<span>def <span class="ident">hook_mem_read</span></span>(<span>self, emu, access, address, size, value, state=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when memory reads are hooked.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L633-L637" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hook_mem_read(self, emu: _E, access: int, address: int, size: int, value: int, state: _T | None = None) -&gt; bool:
    &#34;&#34;&#34;
    Called when memory reads are hooked.
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.hook_mem_write"><code class="name flex">
<span>def <span class="ident">hook_mem_write</span></span>(<span>self, emu, access, address, size, value, state=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when memory writes are hooked.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L639-L643" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hook_mem_write(self, emu: _E, access: int, address: int, size: int, value: int, state: _T | None = None) -&gt; bool:
    &#34;&#34;&#34;
    Called when memory writes are hooked.
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.hook_mem_error"><code class="name flex">
<span>def <span class="ident">hook_mem_error</span></span>(<span>self, emu, access, address, size, value, state=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when memory errors are hooked.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L645-L653" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hook_mem_error(self, emu: _E, access: int, address: int, size: int, value: int, state: _T | None = None) -&gt; bool:
    &#34;&#34;&#34;
    Called when memory errors are hooked.
    &#34;&#34;&#34;
    try:
        self.map(self.align(address, down=True), self.alloc_size)
    except Exception:
        pass
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.hook_api_call"><code class="name flex">
<span>def <span class="ident">hook_api_call</span></span>(<span>self, emu, name, cb=None, args=())</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L655-L656" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hook_api_call(self, emu: _E, name: str, cb=None, args=()) -&gt; Any:
    return None</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.disassemble_instruction"><code class="name flex">
<span>def <span class="ident">disassemble_instruction</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<section class="desc"><p>Disassemble a single instruction at the given address.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L658-L667" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def disassemble_instruction(self, address: int):
    &#34;&#34;&#34;
    Disassemble a single instruction at the given address.
    &#34;&#34;&#34;
    if not self._resetonce:
        self.reset()
    cs = self.exe.disassembler()
    cs.detail = True
    data = self.mem_read(address, 0x20)
    return next(cs.disasm(data, address, 1))</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Emulator.general_purpose_registers"><code class="name flex">
<span>def <span class="ident">general_purpose_registers</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>A generator that lists the general purpose registers for the current architecture. The
implementation is currently incomplete and only has support for the Intel architectures.
For other architectures, this is an empty generator.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L669-L682" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def general_purpose_registers(self):
    &#34;&#34;&#34;
    A generator that lists the general purpose registers for the current architecture. The
    implementation is currently incomplete and only has support for the Intel architectures.
    For other architectures, this is an empty generator.
    &#34;&#34;&#34;
    arch = self.exe.arch()
    regs = []
    if arch is Arch.X32:
        regs = (&#39;eax&#39;, &#39;ebx&#39;, &#39;ecx&#39;, &#39;edx&#39;, &#39;esi&#39;, &#39;edi&#39;, &#39;ebp&#39;)
    elif arch is Arch.X64:
        regs = (&#39;rax&#39;, &#39;rbx&#39;, &#39;rcx&#39;, &#39;rdx&#39;, &#39;rsi&#39;, &#39;rdi&#39;, &#39;rbp&#39;, &#39;r8&#39;, &#39;r9&#39;, &#39;r10&#39;, &#39;r11&#39;, &#39;r12&#39;, &#39;r13&#39;, &#39;r14&#39;, &#39;r15&#39;)
    for reg in regs:
        yield self._lookup_register(reg)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.emulator.Engine"><code class="flex name class">
<span>class <span class="ident">Engine</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a collection of name/value pairs.</p>
<p>Example enumeration:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     BLUE = 2
...     GREEN = 3
</code></pre>
<p>Access them by:</p>
<ul>
<li>attribute access:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color.RED
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>value lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color(1)
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>name lookup:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>Color['RED']
<Color.RED: 1></p>
</blockquote>
</blockquote>
</blockquote>
<p>Enumerations can be iterated over, and know how many members they have:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; len(Color)
3
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</code></pre>
<p>Methods can be added to enumerations, and members can have their own
attributes &ndash; see the documentation for details.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/__init__.py#L25-L28" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Engine(enum.Enum):
    speakeasy = SpeakeasyEmulator
    icicle = IcicleEmulator
    unicorn = UnicornEmulator</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.emulator.Engine.speakeasy"><code class="name">var <span class="ident">speakeasy</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Engine.icicle"><code class="name">var <span class="ident">icicle</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Engine.unicorn"><code class="name">var <span class="ident">unicorn</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.emulator.Hook"><code class="flex name class">
<span>class <span class="ident">Hook</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>A bit mask flag for the types of hooks that are requested from an emulator.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L76-L93" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Hook(IntFlag):
    &#34;&#34;&#34;
    A bit mask flag for the types of hooks that are requested from an emulator.
    &#34;&#34;&#34;
    CodeExecute  = 0b000_00001  # noqa
    CodeError    = 0b000_00010  # noqa
    MemoryRead   = 0b000_00100  # noqa
    MemoryWrite  = 0b000_01000  # noqa
    MemoryError  = 0b000_10000  # noqa
    ApiCall      = 0b001_00000  # noqa

    OnlyErrors   = 0b000_10010  # noqa
    Default      = 0b000_11111  # noqa
    Everything   = 0b111_11111  # noqa
    Nothing      = 0b000_00000  # noqa
    MemoryAccess = 0b000_01100  # noqa
    Memory       = 0b000_11100  # noqa
    NoErrors     = 0b001_01101  # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.emulator.Hook.CodeExecute"><code class="name">var <span class="ident">CodeExecute</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Hook.CodeError"><code class="name">var <span class="ident">CodeError</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Hook.MemoryRead"><code class="name">var <span class="ident">MemoryRead</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Hook.MemoryWrite"><code class="name">var <span class="ident">MemoryWrite</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Hook.MemoryError"><code class="name">var <span class="ident">MemoryError</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Hook.ApiCall"><code class="name">var <span class="ident">ApiCall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Hook.OnlyErrors"><code class="name">var <span class="ident">OnlyErrors</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Hook.Default"><code class="name">var <span class="ident">Default</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Hook.Everything"><code class="name">var <span class="ident">Everything</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Hook.Nothing"><code class="name">var <span class="ident">Nothing</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Hook.MemoryAccess"><code class="name">var <span class="ident">MemoryAccess</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Hook.Memory"><code class="name">var <span class="ident">Memory</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.emulator.Hook.NoErrors"><code class="name">var <span class="ident">NoErrors</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.emulator.IcicleEmulator"><code class="flex name class">
<span>class <span class="ident">IcicleEmulator</span></span>
<span>(</span><span>data, base=None, arch=None, hooks=18, align_size=4096, alloc_size=4096)</span>
</code></dt>
<dd>
<section class="desc"><p>An Icicle-based emulator. Icicle is a more recent emulator engine and not yet as mature as
Unicorn. There are some compelling arguments for its robustness, but with the current
interface it is completely lacking any memory write hook support, which makes it difficult
to use for most of our applications. See also the <a href="https://arxiv.org/pdf/2301.13346">Icicle paper</a>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/ic.py#L23-L182" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IcicleEmulator(RawMetalEmulator[Ic, str, _T]):
    &#34;&#34;&#34;
    An Icicle-based emulator. Icicle is a more recent emulator engine and not yet as mature as
    Unicorn. There are some compelling arguments for its robustness, but with the current
    interface it is completely lacking any memory write hook support, which makes it difficult
    to use for most of our applications. See also the [Icicle paper][ICE].

    [ICE]: https://arxiv.org/pdf/2301.13346
    &#34;&#34;&#34;

    icicle: Ic

    def _init(self):
        super()._init()
        self._single_step = False

    def _reset(self):
        super()._reset()
        exe = self.exe

        try:
            arch = {
                Arch.X32: &#39;i686&#39;,
                Arch.X64: &#39;x86_64&#39;,
            }[exe.arch()]
        except KeyError:
            arch = None
        if arch not in ic.architectures():
            raise NotImplementedError(F&#39;Icicle cannot handle executables of arch {exe.arch().name}&#39;)

        self.icicle = ice = ic.Icicle(arch)
        self.regmap = {reg.casefold(): val[1] for reg, val in ice.reg_list().items()}

        self._map_segments()
        self._map_stack_and_heap()

        if self.hooked(Hook.ApiCall):
            self._install_api_trampoline()

    def _enable_single_step(self):
        self._single_step = True

    def _disable_single_step(self):
        self._single_step = False

    def _emulate(self, start: int, end: int | None = None):
        RS = ic.RunStatus
        MP = ic.MemoryProtection
        ice = self.icicle

        code_hooked = self.hooked(Hook.CodeExecute)
        apis_hooked = self.hooked(Hook.ApiCall)
        mm_e_hooked = self.hooked(Hook.MemoryError)
        mm_w_hooked = self.hooked(Hook.MemoryWrite)
        mm_r_hooked = self.hooked(Hook.MemoryRead)

        halt = self._single_step
        dasm = self.exe.disassembler()
        dasm.detail = True

        if code_hooked or halt:
            step = partial(ice.step, 1)
        elif end is not None:
            step = partial(ice.run_until, end)
        else:
            step = ice.run

        self.ip = ip = start
        mprotect: list[tuple[int, int]] = []
        cb_write = None
        retrying = 0

        while True:
            if end is not None and self.ip == end:
                break
            if (code_hooked or apis_hooked) and not retrying:
                insn = next(dasm.disasm(self.mem_read(ip, 20), 1))
                args = (ice, ip, insn.size, self.state)
                if apis_hooked:
                    self._hook_api_call_check(*args)
                if code_hooked:
                    self.hook_code_execute(*args)
            else:
                insn = None
            if mprotect:
                ice.mem_protect(*mprotect[-1], MP.ExecuteReadWrite)
                self.ip = ip
            if (status := step()) == RS.InstructionLimit:
                for p in mprotect:
                    ice.mem_protect(*p, MP.ExecuteOnly)
                if cb_write:
                    addr, size = cb_write
                    value = self.mem_read_int(addr, size)
                    if self.hook_mem_write(ice, 0, addr, size, value, self.state) is False:
                        break
                    cb_write = None
                mprotect.clear()
                retrying = 0
                ip = self.ip
            elif status in (
                RS.Breakpoint,
                RS.Halt,
                RS.Killed,
            ):
                break
            elif status == RS.UnhandledException:
                insn = insn or next(dasm.disasm(self.mem_read(ip, 20), 1))
                size = max((op.size for op in insn.operands), default=insn.addr_size)
                EC = ic.ExceptionCode
                ea = ice.exception_value
                ec = ice.exception_code
                if ec in (EC.ReadUnmapped, EC.WriteUnmapped) and mm_e_hooked:
                    if self.hook_mem_error(ice, 0, ea, size, 0, self.state) is not False:
                        retrying += 1
                        continue
                elif ec == EC.ReadPerm and mm_r_hooked:
                    value = self.mem_read_int(ea, size)
                    if self.hook_mem_read(ice, 0, ea, size, value, self.state) is not False:
                        mprotect.append((ea, size))
                        retrying += 1
                        continue
                elif ec == EC.WritePerm and mm_w_hooked:
                    cb_write = (ea, size)
                    mprotect.append(cb_write)
                    retrying += 1
                    continue
                else:
                    raise EmulationError(ec.name)
            elif status != RS.Running:
                raise EmulationError(status.name)
            if halt:
                break

    def halt(self):
        self.icicle.add_breakpoint(self.ip)

    def _lookup_register(self, var: str) -&gt; Register[str]:
        name = var.casefold()
        size = self.regmap[name]
        return Register(name, name, size)

    def _map(self, address: int, size: int):
        MP = ic.MemoryProtection
        if self.hooks &amp; Hook.MemoryAccess:
            perm = MP.ExecuteOnly
        else:
            perm = MP.ExecuteReadWrite
        return self.icicle.mem_map(address, size, perm)

    def _set_register(self, register: str, v: int) -&gt; None:
        return self.icicle.reg_write(register, v)

    def _get_register(self, register: str) -&gt; int:
        return self.icicle.reg_read(register)

    def mem_write(self, address: int, data: bytes):
        return self.icicle.mem_write(address, data)

    def mem_read(self, address: int, size: int):
        return self.icicle.mem_read(address, size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.emulator.abstract.RawMetalEmulator" href="abstract.html#refinery.lib.emulator.abstract.RawMetalEmulator">RawMetalEmulator</a></li>
<li><a title="refinery.lib.emulator.abstract.Emulator" href="abstract.html#refinery.lib.emulator.abstract.Emulator">Emulator</a></li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.emulator.IcicleEmulator.icicle"><code class="name">var <span class="ident">icicle</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.emulator.abstract.RawMetalEmulator" href="abstract.html#refinery.lib.emulator.abstract.RawMetalEmulator">RawMetalEmulator</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.align" href="abstract.html#refinery.lib.emulator.abstract.Emulator.align">align</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.base_emu_to_exe" href="abstract.html#refinery.lib.emulator.abstract.Emulator.base_emu_to_exe">base_emu_to_exe</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.base_exe_to_emu" href="abstract.html#refinery.lib.emulator.abstract.Emulator.base_exe_to_emu">base_exe_to_emu</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.disassemble_instruction" href="abstract.html#refinery.lib.emulator.abstract.Emulator.disassemble_instruction">disassemble_instruction</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.emulate" href="abstract.html#refinery.lib.emulator.abstract.Emulator.emulate">emulate</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.general_purpose_registers" href="abstract.html#refinery.lib.emulator.abstract.Emulator.general_purpose_registers">general_purpose_registers</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.get_register" href="abstract.html#refinery.lib.emulator.abstract.Emulator.get_register">get_register</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.halt" href="abstract.html#refinery.lib.emulator.abstract.Emulator.halt">halt</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.hook_code_error" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_code_error">hook_code_error</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.hook_code_execute" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_code_execute">hook_code_execute</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.hook_mem_error" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_mem_error">hook_mem_error</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.hook_mem_read" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_mem_read">hook_mem_read</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.hook_mem_write" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_mem_write">hook_mem_write</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.hooked" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hooked">hooked</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.ip" href="abstract.html#refinery.lib.emulator.abstract.Emulator.ip">ip</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.is_mapped" href="abstract.html#refinery.lib.emulator.abstract.Emulator.is_mapped">is_mapped</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.lookup_register" href="abstract.html#refinery.lib.emulator.abstract.Emulator.lookup_register">lookup_register</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.malloc" href="abstract.html#refinery.lib.emulator.abstract.Emulator.malloc">malloc</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.map" href="abstract.html#refinery.lib.emulator.abstract.Emulator.map">map</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.measure_register_size" href="abstract.html#refinery.lib.emulator.abstract.Emulator.measure_register_size">measure_register_size</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.mem_read" href="abstract.html#refinery.lib.emulator.abstract.Emulator.mem_read">mem_read</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.mem_read_int" href="abstract.html#refinery.lib.emulator.abstract.Emulator.mem_read_int">mem_read_int</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.mem_write" href="abstract.html#refinery.lib.emulator.abstract.Emulator.mem_write">mem_write</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.mem_write_int" href="abstract.html#refinery.lib.emulator.abstract.Emulator.mem_write_int">mem_write_int</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.morestack" href="abstract.html#refinery.lib.emulator.abstract.Emulator.morestack">morestack</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.pop" href="abstract.html#refinery.lib.emulator.abstract.Emulator.pop">pop</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.push" href="abstract.html#refinery.lib.emulator.abstract.Emulator.push">push</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.push_register" href="abstract.html#refinery.lib.emulator.abstract.Emulator.push_register">push_register</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.reset" href="abstract.html#refinery.lib.emulator.abstract.Emulator.reset">reset</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.rv" href="abstract.html#refinery.lib.emulator.abstract.Emulator.rv">rv</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.set_register" href="abstract.html#refinery.lib.emulator.abstract.Emulator.set_register">set_register</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.sp" href="abstract.html#refinery.lib.emulator.abstract.Emulator.sp">sp</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.step" href="abstract.html#refinery.lib.emulator.abstract.Emulator.step">step</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.emulator.Register"><code class="flex name class">
<span>class <span class="ident">Register</span></span>
<span>(</span><span>name, code, size=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Represents an arbitrary CPU register.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L37-L73" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Register(Generic[_R]):
    &#34;&#34;&#34;
    Represents an arbitrary CPU register.
    &#34;&#34;&#34;
    __slots__ = (
        &#39;name&#39;,
        &#39;code&#39;,
        &#39;size&#39;,
    )
    name: str
    &#34;&#34;&#34;
    This is the common name of the register, like &#34;eax&#34; on x86.
    &#34;&#34;&#34;
    code: _R
    &#34;&#34;&#34;
    The code of a register is any emulator-specific internal identifier for the register.
    &#34;&#34;&#34;
    size: int | None
    &#34;&#34;&#34;
    If not `None`, this property contains the size of the register in bytes.
    &#34;&#34;&#34;

    def __repr__(self):
        return self.name

    def __init__(self, name: str, code: _R, size: int | None = 0):
        self.name = name
        self.code = code
        self.size = size

    def __eq__(self, other):
        if not isinstance(other, Register):
            return False
        return self.code == other.code and self.size == other.size

    def __hash__(self):
        return hash((self.code, self.size))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.emulator.Register.code"><code class="name">var <span class="ident">code</span></code></dt>
<dd>
<section class="desc"><p>The code of a register is any emulator-specific internal identifier for the register.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L37-L73" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Register(Generic[_R]):
    &#34;&#34;&#34;
    Represents an arbitrary CPU register.
    &#34;&#34;&#34;
    __slots__ = (
        &#39;name&#39;,
        &#39;code&#39;,
        &#39;size&#39;,
    )
    name: str
    &#34;&#34;&#34;
    This is the common name of the register, like &#34;eax&#34; on x86.
    &#34;&#34;&#34;
    code: _R
    &#34;&#34;&#34;
    The code of a register is any emulator-specific internal identifier for the register.
    &#34;&#34;&#34;
    size: int | None
    &#34;&#34;&#34;
    If not `None`, this property contains the size of the register in bytes.
    &#34;&#34;&#34;

    def __repr__(self):
        return self.name

    def __init__(self, name: str, code: _R, size: int | None = 0):
        self.name = name
        self.code = code
        self.size = size

    def __eq__(self, other):
        if not isinstance(other, Register):
            return False
        return self.code == other.code and self.size == other.size

    def __hash__(self):
        return hash((self.code, self.size))</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Register.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>This is the common name of the register, like "eax" on x86.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L37-L73" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Register(Generic[_R]):
    &#34;&#34;&#34;
    Represents an arbitrary CPU register.
    &#34;&#34;&#34;
    __slots__ = (
        &#39;name&#39;,
        &#39;code&#39;,
        &#39;size&#39;,
    )
    name: str
    &#34;&#34;&#34;
    This is the common name of the register, like &#34;eax&#34; on x86.
    &#34;&#34;&#34;
    code: _R
    &#34;&#34;&#34;
    The code of a register is any emulator-specific internal identifier for the register.
    &#34;&#34;&#34;
    size: int | None
    &#34;&#34;&#34;
    If not `None`, this property contains the size of the register in bytes.
    &#34;&#34;&#34;

    def __repr__(self):
        return self.name

    def __init__(self, name: str, code: _R, size: int | None = 0):
        self.name = name
        self.code = code
        self.size = size

    def __eq__(self, other):
        if not isinstance(other, Register):
            return False
        return self.code == other.code and self.size == other.size

    def __hash__(self):
        return hash((self.code, self.size))</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.Register.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<section class="desc"><p>If not <code>None</code>, this property contains the size of the register in bytes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/abstract.py#L37-L73" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Register(Generic[_R]):
    &#34;&#34;&#34;
    Represents an arbitrary CPU register.
    &#34;&#34;&#34;
    __slots__ = (
        &#39;name&#39;,
        &#39;code&#39;,
        &#39;size&#39;,
    )
    name: str
    &#34;&#34;&#34;
    This is the common name of the register, like &#34;eax&#34; on x86.
    &#34;&#34;&#34;
    code: _R
    &#34;&#34;&#34;
    The code of a register is any emulator-specific internal identifier for the register.
    &#34;&#34;&#34;
    size: int | None
    &#34;&#34;&#34;
    If not `None`, this property contains the size of the register in bytes.
    &#34;&#34;&#34;

    def __repr__(self):
        return self.name

    def __init__(self, name: str, code: _R, size: int | None = 0):
        self.name = name
        self.code = code
        self.size = size

    def __eq__(self, other):
        if not isinstance(other, Register):
            return False
        return self.code == other.code and self.size == other.size

    def __hash__(self):
        return hash((self.code, self.size))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.emulator.SpeakeasyEmulator"><code class="flex name class">
<span>class <span class="ident">SpeakeasyEmulator</span></span>
<span>(</span><span>data, base=None, arch=None, hooks=18, align_size=4096, alloc_size=4096)</span>
</code></dt>
<dd>
<section class="desc"><p>A Speakeasy-based emulator. Speakeasy only supports PE files, but it has support for several
Windows API routines which can be an advantage.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/se.py#L31-L337" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SpeakeasyEmulator(Emulator[Se, str, _T]):
    &#34;&#34;&#34;
    A Speakeasy-based emulator. Speakeasy only supports PE files, but it has support for several
    Windows API routines which can be an advantage.
    &#34;&#34;&#34;

    speakeasy: Se

    def _init(self):
        self._regs: dict[str, Register[str]] = {}

    class _singlestep:
        def __init__(self):
            self.stepped = False

        def __call__(self, se: Se, *_, **kw):
            if self.stepped:
                self.stepped = False
                se.stop()
            else:
                self.stepped = True
            return True

    class _stackfix:
        hook: CodeHook | None

        def __init__(self, parent: SpeakeasyEmulator):
            self.hook = None
            self.parent = parent

        def __call__(self, base_emu: Se, address: int, size: int, ctx: list):
            if hook := self.hook:
                emu = self.parent
                stack = emu.stack_region
                emu.sp = stack.base + stack.size // 3
                hook.disable()

    def _reset(self):
        exe = self.exe
        if exe.type not in (ET.PE, ET.BLOB):
            raise NotImplementedError(F&#39;Speakeasy cannot handle executables of type {exe.type.name}.&#39;)
        try:
            arch = {
                Arch.X32: &#39;x86&#39;,
                Arch.X64: &#39;x64&#39;,
            }[exe.arch()]
        except KeyError as KE:
            raise NotImplementedError(F&#39;Speakeasy cannot handle executables of arch {exe.arch().name}&#39;) from KE

        emu = self.speakeasy = se.Speakeasy()

        with VirtualFileSystem() as vfs:
            db = bytes(exe.data)
            vf = vfs.new(db)
            if exe.blob:
                self.base = emu.load_shellcode(vf.path, data=db, arch=arch)
            else:
                self.base = emu.load_module(vf.path, data=db).get_base()

        if emu.emu is None:
            raise RuntimeError(&#39;emulator failed to initialize&#39;)

        self._end_hook_s = None
        self._end_hook_d = None

        self._single_step_hook_s = emu.add_code_hook(self._singlestep())
        self._single_step_hook_d = emu.add_dyn_code_hook(self._singlestep())
        self._disable_single_step()

        stackfix = self._stackfix(self)
        stackfix.hook = emu.add_code_hook(stackfix)

        emu.emu.timeout = 0

        # prevent memory hook from being overridden, this is a bug in speakeasy
        emu.emu.add_interrupt_hook(cb=emu.emu._hook_interrupt)
        emu.emu.builtin_hooks_set = True

        if self.hooked(Hook.CodeExecute):
            emu.add_code_hook(self.hook_code_execute, ctx=self.state)
            emu.add_dyn_code_hook(self.hook_code_execute, ctx=self.state)

        if self.hooked(Hook.MemoryRead):
            emu.add_mem_read_hook(self.hook_mem_read)

        if self.hooked(Hook.MemoryWrite):
            emu.add_mem_write_hook(self.hook_mem_write)

        if self.hooked(Hook.MemoryError):
            emu.add_mem_invalid_hook(self.hook_mem_error)

        if self.hooked(Hook.ApiCall):
            emu.add_api_hook(self.hook_api_call, &#39;*&#39;, &#39;*&#39;)

    def _enable_single_step(self):
        hd = self._single_step_hook_d
        hs = self._single_step_hook_s
        if hd is None or hs is None:
            raise RuntimeError(&#39;single stepping hooks failed to be installed&#39;)
        hd.cb.stepped = False
        hs.cb.stepped = False
        hd.enable()
        hs.enable()

    def _disable_single_step(self):
        if hook := self._single_step_hook_d:
            hook.disable()
        if hook := self._single_step_hook_s:
            hook.disable()

    @property
    def stack_region(self):
        emu = self.speakeasy
        tos = self.sp
        mms: list[MemMap] = emu.get_mem_maps()
        if tos != emu.get_stack_ptr():
            raise EmulationError(&#39;Unexpected stack pointer misalignment&#39;)
        try:
            sm, = (mm for mm in mms if tos in range(mm.base, mm.base + mm.size))
        except Exception:
            raise EmulationError(&#39;Ambiguous memory, unable to locate the stack.&#39;)
        return sm

    @property
    def stack_base(self):
        return self.stack_region.base

    @stack_base.setter
    def stack_base(self, value):
        raise AttributeError

    @property
    def stack_size(self):
        return self.stack_region.size

    @stack_size.setter
    def stack_size(self, value):
        raise AttributeError

    def _map_update(self):
        self._memorymap.clear()
        if (e := self.speakeasy.emu) and (eng := e.emu_eng) and (emu := eng.emu):
            for a, b, _ in emu.mem_regions():
                self._memorymap.addi(a, b - a + 1)
        else:
            raise SpeakeasyNotInitialized

    def malloc(self, size: int) -&gt; int:
        return self.speakeasy.mem_alloc(size)

    def morestack(self):
        spksy = self.speakeasy
        stack = self.stack_region
        base = stack.base - self.alloc_size
        if (emu := spksy.emu) is None:
            raise SpeakeasyNotInitialized
        emu.mem_map(self.alloc_size, base)
        stack.base = base
        stack.size = stack.size + self.alloc_size

    class _stop:
        hook: SeHook | None
        address: int | None

        def __init__(self, address: int | None = None):
            self.address = address
            self.hook = None

        def __call__(self, spky: Se, address: int, size: int, ctx: list):
            if hook := self.hook:
                if address == self.address:
                    spky.stop()
                    hook.disable()

    _end_hook_s: _stop | None
    _end_hook_d: _stop | None

    def _remove_hook(self, hook: SeHook | None):
        if hook is None:
            return
        hook.emu_eng.hook_del(hook.handle)
        emu = self.speakeasy.emu
        assert emu is not None
        for hooklist in emu.hooks.values():
            assert isinstance(hooklist, list)
            for k, h in enumerate(hooklist):
                if h is hook:
                    del hooklist[k]
                    break

    def _set_end(self, end: int | None):
        if h := self._end_hook_s:
            self._remove_hook(h.hook)
        if h := self._end_hook_d:
            self._remove_hook(h.hook)
        if end is None:
            self._end_hook_s = None
            self._end_hook_d = None
        else:
            self._end_hook_s = h = self._stop(end)
            h.hook = self.speakeasy.add_code_hook(h, end, end + 1)
            self._end_hook_d = h = self._stop(end)
            h.hook = self.speakeasy.add_dyn_code_hook(h)

    def _emulate(self, start: int, end: int | None = None):
        spk = self.speakeasy

        if (inner := spk.emu) is None:
            raise SpeakeasyNotInitialized

        win32 = isinstance(inner, se.Win32Emulator)
        self._set_end(end)

        if inner.get_current_run():
            return spk.resume(start)

        if self.exe.blob:
            offset = start - self.base
            if offset &lt; 0:
                raise ValueError(F&#39;invalid offset 0x{start:X} specified; base address is 0x{self.base:X}&#39;)
            spk.run_shellcode(self.base, offset=offset)
        else:
            inner.stack_base, _ = inner.alloc_stack(self.stack_size)
            inner.set_func_args(inner.stack_base, inner.return_hook)

            run = se.profiler.Run()
            run.type = &#39;thread&#39;         # type:ignore
            run.start_addr = start      # type:ignore
            run.instr_cnt = 0           # type:ignore
            run.args = ()               # type:ignore

            inner.add_run(run)

            if win32:
                if not (process := inner.init_container_process()):
                    process = se.windows.objman.Process(self)
                inner.processes.append(process)
                inner.curr_process = process
            else:
                process = None

            if mm := inner.get_address_map(start): # type:ignore
                mm: MemMap
                mm.set_process(inner.curr_process)

            t = se.windows.objman.Thread(inner, stack_base=inner.stack_base, stack_commit=self.stack_size)

            inner.om.objects.update({t.address: t})
            inner.curr_process.threads.append(t)
            inner.curr_thread = t

            if win32:
                peb = inner.alloc_peb(process)
                inner.init_teb(t, peb)

            inner.start()

    def halt(self):
        return self.speakeasy.stop()

    def _set_register(self, register: str, v: int):
        return self.speakeasy.reg_write(register, v)

    def _get_register(self, register: str) -&gt; int:
        return self.speakeasy.reg_read(register)

    def _lookup_register(self, var: str) -&gt; Register[str]:
        try:
            reg = self._regs[var]
        except KeyError:
            try:
                size = self.measure_register_size(var)
            except Exception:
                raise LookupError(var)
            else:
                reg = self._regs[var] = Register(var, var, size)
        return reg

    def _map(self, address: int, size: int):
        spksy = self.speakeasy
        if (emu := spksy.emu) is None:
            raise SpeakeasyNotInitialized
        if emu.get_address_map(address):
            raise ValueError(address)
        if mm := emu.get_reserve_map(address):
            mm: MemMap = emu.get_address_map(emu.mem_map_reserve(mm.base))
            if address not in range(mm.base, mm.base + mm.size):
                raise RuntimeError(F&#39;Speakeasy claimed to map 0x{address:X} in map 0x{mm.base:X}-0x{mm.base + mm.size:X}.&#39;)
            map_size = mm.size
            map_base = mm.base
            _new_size = size - map_size + address - map_base
            _new_base = address + map_size
            if _new_size &gt; 0 and self._map(_new_base, _new_size) != _new_base:
                raise RuntimeError(F&#39;Attempting to remain rest of size 0x{_new_size:X} at 0x{_new_base:X} failed.&#39;)
            return address
        else:
            alloc = spksy.mem_alloc(size, address)
            if alloc != address:
                spksy.mem_free(alloc)
                raise LookupError(F&#39;Unable to allocate {size} bytes at address 0x{address:X} because Speakeasy has reserved this region.&#39;)
            return alloc

    def mem_write(self, address: int, data: bytes):
        return self.speakeasy.mem_write(address, data)

    def mem_read(self, address: int, size: int):
        return self.speakeasy.mem_read(address, size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.emulator.abstract.Emulator" href="abstract.html#refinery.lib.emulator.abstract.Emulator">Emulator</a></li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.emulator.SpeakeasyEmulator.speakeasy"><code class="name">var <span class="ident">speakeasy</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.emulator.SpeakeasyEmulator.stack_region"><code class="name">var <span class="ident">stack_region</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/se.py#L141-L152" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def stack_region(self):
    emu = self.speakeasy
    tos = self.sp
    mms: list[MemMap] = emu.get_mem_maps()
    if tos != emu.get_stack_ptr():
        raise EmulationError(&#39;Unexpected stack pointer misalignment&#39;)
    try:
        sm, = (mm for mm in mms if tos in range(mm.base, mm.base + mm.size))
    except Exception:
        raise EmulationError(&#39;Ambiguous memory, unable to locate the stack.&#39;)
    return sm</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.SpeakeasyEmulator.stack_base"><code class="name">var <span class="ident">stack_base</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/se.py#L154-L156" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def stack_base(self):
    return self.stack_region.base</code></pre>
</details>
</dd>
<dt id="refinery.lib.emulator.SpeakeasyEmulator.stack_size"><code class="name">var <span class="ident">stack_size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/se.py#L162-L164" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def stack_size(self):
    return self.stack_region.size</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.emulator.abstract.Emulator" href="abstract.html#refinery.lib.emulator.abstract.Emulator">Emulator</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.emulator.abstract.Emulator.align" href="abstract.html#refinery.lib.emulator.abstract.Emulator.align">align</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.base_emu_to_exe" href="abstract.html#refinery.lib.emulator.abstract.Emulator.base_emu_to_exe">base_emu_to_exe</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.base_exe_to_emu" href="abstract.html#refinery.lib.emulator.abstract.Emulator.base_exe_to_emu">base_exe_to_emu</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.disassemble_instruction" href="abstract.html#refinery.lib.emulator.abstract.Emulator.disassemble_instruction">disassemble_instruction</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.emulate" href="abstract.html#refinery.lib.emulator.abstract.Emulator.emulate">emulate</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.general_purpose_registers" href="abstract.html#refinery.lib.emulator.abstract.Emulator.general_purpose_registers">general_purpose_registers</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.get_register" href="abstract.html#refinery.lib.emulator.abstract.Emulator.get_register">get_register</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.halt" href="abstract.html#refinery.lib.emulator.abstract.Emulator.halt">halt</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.hook_code_error" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_code_error">hook_code_error</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.hook_code_execute" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_code_execute">hook_code_execute</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.hook_mem_error" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_mem_error">hook_mem_error</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.hook_mem_read" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_mem_read">hook_mem_read</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.hook_mem_write" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_mem_write">hook_mem_write</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.hooked" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hooked">hooked</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.ip" href="abstract.html#refinery.lib.emulator.abstract.Emulator.ip">ip</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.is_mapped" href="abstract.html#refinery.lib.emulator.abstract.Emulator.is_mapped">is_mapped</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.lookup_register" href="abstract.html#refinery.lib.emulator.abstract.Emulator.lookup_register">lookup_register</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.malloc" href="abstract.html#refinery.lib.emulator.abstract.Emulator.malloc">malloc</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.map" href="abstract.html#refinery.lib.emulator.abstract.Emulator.map">map</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.measure_register_size" href="abstract.html#refinery.lib.emulator.abstract.Emulator.measure_register_size">measure_register_size</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.mem_read" href="abstract.html#refinery.lib.emulator.abstract.Emulator.mem_read">mem_read</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.mem_read_int" href="abstract.html#refinery.lib.emulator.abstract.Emulator.mem_read_int">mem_read_int</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.mem_write" href="abstract.html#refinery.lib.emulator.abstract.Emulator.mem_write">mem_write</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.mem_write_int" href="abstract.html#refinery.lib.emulator.abstract.Emulator.mem_write_int">mem_write_int</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.morestack" href="abstract.html#refinery.lib.emulator.abstract.Emulator.morestack">morestack</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.pop" href="abstract.html#refinery.lib.emulator.abstract.Emulator.pop">pop</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.push" href="abstract.html#refinery.lib.emulator.abstract.Emulator.push">push</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.push_register" href="abstract.html#refinery.lib.emulator.abstract.Emulator.push_register">push_register</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.reset" href="abstract.html#refinery.lib.emulator.abstract.Emulator.reset">reset</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.rv" href="abstract.html#refinery.lib.emulator.abstract.Emulator.rv">rv</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.set_register" href="abstract.html#refinery.lib.emulator.abstract.Emulator.set_register">set_register</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.sp" href="abstract.html#refinery.lib.emulator.abstract.Emulator.sp">sp</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.Emulator.step" href="abstract.html#refinery.lib.emulator.abstract.Emulator.step">step</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.emulator.UnicornEmulator"><code class="flex name class">
<span>class <span class="ident">UnicornEmulator</span></span>
<span>(</span><span>data, base=None, arch=None, hooks=18, align_size=4096, alloc_size=4096)</span>
</code></dt>
<dd>
<section class="desc"><p>A Unicorn-based emulator.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/emulator/uc.py#L21-L165" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class UnicornEmulator(RawMetalEmulator[Uc, int, _T]):
    &#34;&#34;&#34;
    A Unicorn-based emulator.
    &#34;&#34;&#34;

    unicorn: Uc

    def _reset(self):
        super()._reset()

        uc_arch, uc_mode = {
            Arch.X32     : (uc.UC_ARCH_X86,   uc.UC_MODE_32),     # noqa
            Arch.X64     : (uc.UC_ARCH_X86,   uc.UC_MODE_64),     # noqa
            Arch.ARM32   : (uc.UC_ARCH_ARM,   uc.UC_MODE_ARM),    # noqa
            Arch.ARM64   : (uc.UC_ARCH_ARM64, uc.UC_MODE_ARM),  # noqa
            Arch.MIPS16  : (uc.UC_ARCH_MIPS,  uc.UC_MODE_16),     # noqa
            Arch.MIPS32  : (uc.UC_ARCH_MIPS,  uc.UC_MODE_32),     # noqa
            Arch.MIPS64  : (uc.UC_ARCH_MIPS,  uc.UC_MODE_64),     # noqa
            Arch.PPC32   : (uc.UC_ARCH_PPC,   uc.UC_MODE_32),     # noqa
            Arch.PPC64   : (uc.UC_ARCH_PPC,   uc.UC_MODE_64),     # noqa
            Arch.SPARC32 : (uc.UC_ARCH_SPARC, uc.UC_MODE_32),     # noqa
            Arch.SPARC64 : (uc.UC_ARCH_SPARC, uc.UC_MODE_V9),     # noqa
        }[self.exe.arch()]

        uc_mode |= {
            BO.BE: uc.UC_MODE_BIG_ENDIAN,
            BO.LE: uc.UC_MODE_LITTLE_ENDIAN,
        }[self.exe.byte_order()]

        self.unicorn = uc.Uc(uc_arch, uc_mode)
        self._single_step_hook = None

        self._map_segments()
        self._map_stack_and_heap()

        if self.hooked(Hook.ApiCall):
            self._install_api_trampoline()
            self.unicorn.hook_add(uc.UC_HOOK_CODE, self._hook_api_call_check, user_data=self.state)

        for hook, flag, callback in [
            (uc.UC_HOOK_CODE,           Hook.CodeExecute, self.hook_code_execute ),  # noqa
            (uc.UC_HOOK_INSN_INVALID,   Hook.CodeError,   self.hook_code_error   ),  # noqa
            (uc.UC_HOOK_MEM_READ_AFTER, Hook.MemoryRead,  self.hook_mem_read     ),  # noqa
            (uc.UC_HOOK_MEM_WRITE,      Hook.MemoryWrite, self.hook_mem_write    ),  # noqa
            (uc.UC_HOOK_MEM_INVALID,    Hook.MemoryError, self.hook_mem_error    ),  # noqa
        ]:
            if self.hooked(flag):
                self.unicorn.hook_add(hook, callback, user_data=self.state)

    class _singlestep:
        def __init__(self):
            self.stepped = False

        def __call__(self, uc: Uc, *_, **kw):
            if self.stepped:
                self.stepped = False
                uc.emu_stop()
            else:
                self.stepped = True

    def _enable_single_step(self):
        if self._single_step_hook is not None:
            return
        self._single_step_hook = self.unicorn.hook_add(uc.UC_HOOK_CODE, self._singlestep())

    def _disable_single_step(self):
        if hook := self._single_step_hook:
            self.unicorn.hook_del(hook)
            self._single_step_hook = None

    def _init(self):
        super()._init()
        self._reg_by_name: dict[Arch, dict[str, Register[int]]] = {}
        self._reg_by_code: dict[Arch, dict[int, Register[int]]] = {}
        for archs, module in [
            ((Arch.X32, Arch.X64), uc.x86_const),
            ((Arch.ARM32,), uc.arm_const),
            ((Arch.ARM64,), uc.arm64_const),
            ((Arch.SPARC32, Arch.SPARC64), uc.sparc_const),
            ((Arch.MIPS16, Arch.MIPS32, Arch.MIPS64), uc.mips_const),
        ]:
            md: dict[str, Any] = module.__dict__
            reg_by_name: dict[str, Register[int]] = {}
            reg_by_code: dict[int, Register[int]] = {}
            for name, code in md.items():
                try:
                    u, *_, kind, name = name.split(&#39;_&#39;)
                except Exception:
                    continue
                if kind != &#39;REG&#39; or u != &#39;UC&#39;:
                    continue
                name = name.casefold()
                reg = Register(name, code)
                reg_by_name[name] = reg
                reg_by_code[code] = reg
            for arch in archs:
                self._reg_by_code[arch] = reg_by_code
                self._reg_by_name[arch] = reg_by_name

    def _emulate(self, start: int, end: int | None = None):
        if end is None:
            end = self.exe.location_from_address(start).virtual.box.upper
        try:
            self.unicorn.emu_start(start, end)
        except uc.UcError as E:
            raise EmulationError(str(E)) from E

    def halt(self):
        self.unicorn.emu_stop()

    def _lookup_register(self, var: str | int) -&gt; Register[int]:
        reg = None
        arch = self.exe.arch()
        if isinstance(var, str):
            reg = self._reg_by_name[arch][var.casefold()]
        if isinstance(var, int):
            reg = self._reg_by_code[arch][var]
        if reg is None:
            raise TypeError(var)
        if reg.size is None:
            reg.size = self.measure_register_size(reg.code)
        return reg

    def _map(self, address: int, size: int):
        return self.unicorn.mem_map(address, size)

    def _set_register(self, register: int, v: int) -&gt; None:
        return self.unicorn.reg_write(register, v)

    def _get_register(self, register: int) -&gt; int:
        value = self.unicorn.reg_read(register)
        if isinstance(value, int):
            return value
        else:
            combined = 0
            for v in reversed(value):
                combined &lt;&lt;= 64
                combined |= v
            return combined

    def mem_write(self, address: int, data: bytes):
        return self.unicorn.mem_write(address, data)

    def mem_read(self, address: int, size: int):
        return self.unicorn.mem_read(address, size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.emulator.abstract.RawMetalEmulator" href="abstract.html#refinery.lib.emulator.abstract.RawMetalEmulator">RawMetalEmulator</a></li>
<li><a title="refinery.lib.emulator.abstract.Emulator" href="abstract.html#refinery.lib.emulator.abstract.Emulator">Emulator</a></li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.emulator.UnicornEmulator.unicorn"><code class="name">var <span class="ident">unicorn</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.emulator.abstract.RawMetalEmulator" href="abstract.html#refinery.lib.emulator.abstract.RawMetalEmulator">RawMetalEmulator</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.align" href="abstract.html#refinery.lib.emulator.abstract.Emulator.align">align</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.base_emu_to_exe" href="abstract.html#refinery.lib.emulator.abstract.Emulator.base_emu_to_exe">base_emu_to_exe</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.base_exe_to_emu" href="abstract.html#refinery.lib.emulator.abstract.Emulator.base_exe_to_emu">base_exe_to_emu</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.disassemble_instruction" href="abstract.html#refinery.lib.emulator.abstract.Emulator.disassemble_instruction">disassemble_instruction</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.emulate" href="abstract.html#refinery.lib.emulator.abstract.Emulator.emulate">emulate</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.general_purpose_registers" href="abstract.html#refinery.lib.emulator.abstract.Emulator.general_purpose_registers">general_purpose_registers</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.get_register" href="abstract.html#refinery.lib.emulator.abstract.Emulator.get_register">get_register</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.halt" href="abstract.html#refinery.lib.emulator.abstract.Emulator.halt">halt</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.hook_code_error" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_code_error">hook_code_error</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.hook_code_execute" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_code_execute">hook_code_execute</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.hook_mem_error" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_mem_error">hook_mem_error</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.hook_mem_read" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_mem_read">hook_mem_read</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.hook_mem_write" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hook_mem_write">hook_mem_write</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.hooked" href="abstract.html#refinery.lib.emulator.abstract.Emulator.hooked">hooked</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.ip" href="abstract.html#refinery.lib.emulator.abstract.Emulator.ip">ip</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.is_mapped" href="abstract.html#refinery.lib.emulator.abstract.Emulator.is_mapped">is_mapped</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.lookup_register" href="abstract.html#refinery.lib.emulator.abstract.Emulator.lookup_register">lookup_register</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.malloc" href="abstract.html#refinery.lib.emulator.abstract.Emulator.malloc">malloc</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.map" href="abstract.html#refinery.lib.emulator.abstract.Emulator.map">map</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.measure_register_size" href="abstract.html#refinery.lib.emulator.abstract.Emulator.measure_register_size">measure_register_size</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.mem_read" href="abstract.html#refinery.lib.emulator.abstract.Emulator.mem_read">mem_read</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.mem_read_int" href="abstract.html#refinery.lib.emulator.abstract.Emulator.mem_read_int">mem_read_int</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.mem_write" href="abstract.html#refinery.lib.emulator.abstract.Emulator.mem_write">mem_write</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.mem_write_int" href="abstract.html#refinery.lib.emulator.abstract.Emulator.mem_write_int">mem_write_int</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.morestack" href="abstract.html#refinery.lib.emulator.abstract.Emulator.morestack">morestack</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.pop" href="abstract.html#refinery.lib.emulator.abstract.Emulator.pop">pop</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.push" href="abstract.html#refinery.lib.emulator.abstract.Emulator.push">push</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.push_register" href="abstract.html#refinery.lib.emulator.abstract.Emulator.push_register">push_register</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.reset" href="abstract.html#refinery.lib.emulator.abstract.Emulator.reset">reset</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.rv" href="abstract.html#refinery.lib.emulator.abstract.Emulator.rv">rv</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.set_register" href="abstract.html#refinery.lib.emulator.abstract.Emulator.set_register">set_register</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.sp" href="abstract.html#refinery.lib.emulator.abstract.Emulator.sp">sp</a></code></li>
<li><code><a title="refinery.lib.emulator.abstract.RawMetalEmulator.step" href="abstract.html#refinery.lib.emulator.abstract.Emulator.step">step</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="../index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="refinery.lib.emulator.abstract" href="abstract.html">refinery.lib.emulator.abstract</a></code></li>
<li><code><a title="refinery.lib.emulator.ic" href="ic.html">refinery.lib.emulator.ic</a></code></li>
<li><code><a title="refinery.lib.emulator.se" href="se.html">refinery.lib.emulator.se</a></code></li>
<li><code><a title="refinery.lib.emulator.uc" href="uc.html">refinery.lib.emulator.uc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.emulator.Arch" href="#refinery.lib.emulator.Arch">Arch</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.emulator.CC" href="#refinery.lib.emulator.CC">CC</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.emulator.EmulationError" href="#refinery.lib.emulator.EmulationError">EmulationError</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.emulator.Emulator" href="#refinery.lib.emulator.Emulator">Emulator</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.emulator.Emulator.call" href="#refinery.lib.emulator.Emulator.call">call</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.callarg" href="#refinery.lib.emulator.Emulator.callarg">callarg</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.hooked" href="#refinery.lib.emulator.Emulator.hooked">hooked</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.reset" href="#refinery.lib.emulator.Emulator.reset">reset</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.step" href="#refinery.lib.emulator.Emulator.step">step</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.base_exe_to_emu" href="#refinery.lib.emulator.Emulator.base_exe_to_emu">base_exe_to_emu</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.base_emu_to_exe" href="#refinery.lib.emulator.Emulator.base_emu_to_exe">base_emu_to_exe</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.emulate" href="#refinery.lib.emulator.Emulator.emulate">emulate</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.mem_read_int" href="#refinery.lib.emulator.Emulator.mem_read_int">mem_read_int</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.mem_write_int" href="#refinery.lib.emulator.Emulator.mem_write_int">mem_write_int</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.halt" href="#refinery.lib.emulator.Emulator.halt">halt</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.mem_write" href="#refinery.lib.emulator.Emulator.mem_write">mem_write</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.mem_read" href="#refinery.lib.emulator.Emulator.mem_read">mem_read</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.malloc" href="#refinery.lib.emulator.Emulator.malloc">malloc</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.morestack" href="#refinery.lib.emulator.Emulator.morestack">morestack</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.lookup_register" href="#refinery.lib.emulator.Emulator.lookup_register">lookup_register</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.is_mapped" href="#refinery.lib.emulator.Emulator.is_mapped">is_mapped</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.map" href="#refinery.lib.emulator.Emulator.map">map</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.measure_register_size" href="#refinery.lib.emulator.Emulator.measure_register_size">measure_register_size</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.set_return_address" href="#refinery.lib.emulator.Emulator.set_return_address">set_return_address</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.push" href="#refinery.lib.emulator.Emulator.push">push</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.pop" href="#refinery.lib.emulator.Emulator.pop">pop</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.push_register" href="#refinery.lib.emulator.Emulator.push_register">push_register</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.align" href="#refinery.lib.emulator.Emulator.align">align</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.set_register" href="#refinery.lib.emulator.Emulator.set_register">set_register</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.get_register" href="#refinery.lib.emulator.Emulator.get_register">get_register</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.hook_code_execute" href="#refinery.lib.emulator.Emulator.hook_code_execute">hook_code_execute</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.hook_code_error" href="#refinery.lib.emulator.Emulator.hook_code_error">hook_code_error</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.hook_mem_read" href="#refinery.lib.emulator.Emulator.hook_mem_read">hook_mem_read</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.hook_mem_write" href="#refinery.lib.emulator.Emulator.hook_mem_write">hook_mem_write</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.hook_mem_error" href="#refinery.lib.emulator.Emulator.hook_mem_error">hook_mem_error</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.hook_api_call" href="#refinery.lib.emulator.Emulator.hook_api_call">hook_api_call</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.disassemble_instruction" href="#refinery.lib.emulator.Emulator.disassemble_instruction">disassemble_instruction</a></code></li>
<li><code><a title="refinery.lib.emulator.Emulator.general_purpose_registers" href="#refinery.lib.emulator.Emulator.general_purpose_registers">general_purpose_registers</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.emulator.Engine" href="#refinery.lib.emulator.Engine">Engine</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.emulator.Hook" href="#refinery.lib.emulator.Hook">Hook</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.emulator.IcicleEmulator" href="#refinery.lib.emulator.IcicleEmulator">IcicleEmulator</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.emulator.Register" href="#refinery.lib.emulator.Register">Register</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.emulator.SpeakeasyEmulator" href="#refinery.lib.emulator.SpeakeasyEmulator">SpeakeasyEmulator</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.emulator.UnicornEmulator" href="#refinery.lib.emulator.UnicornEmulator">UnicornEmulator</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
