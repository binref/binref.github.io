<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.batch documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.batch</code></h1>
</header>
<section id="section-intro">
<h2 id="set-statement">Set Statement</h2>
<p>There are two kinds of set statement:
The quoted and the unquoted set.
A quoted set looks like this:</p>
<pre><code>set "name=var" (...)
</code></pre>
<p>It is interpreted as follows:</p>
<ul>
<li>Everything between the first and the last quote in the command is extracted.</li>
<li>The resulting string is split at the first equals symbol.</li>
<li>The LHS is the variable name.</li>
<li>The RHS is unescaped once <strong>not</strong> respecting quotes, then becomes the variable content.</li>
</ul>
<h2 id="examples">Examples</h2>
<blockquote>
<p>set
"name="a"^^"b"c
echo %name%
"a"^"b</p>
<p>set
"name="a"^^"b"c
echo %name%
a"^"b</p>
</blockquote>
<p>Note how the trailing c is always discarded because it occurs after the last quote.
The unquoted set looks like this:</p>
<pre><code>set name=var
</code></pre>
<p>It is parsed as follows:</p>
<ul>
<li>The entire command is parsed and unescaped respecting quotes as usual.</li>
<li>The set expression starts with the first non-whitespace character after the set keyword.</li>
<li>This expression is split at the first equals symbol.</li>
<li>The LHS is the variable name.</li>
<li>The RHS is unescaped once respecting quotes, then becomes the variable content.</li>
</ul>
<p>Input redirection may occur in a set line, basically anywhere:</p>
<pre><code>&gt; set 1&gt;"NUL" "var=val
&gt; echo %var%
val
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/__init__.py#L1-L59" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;

## Set Statement

There are two kinds of set statement:
The quoted and the unquoted set.
A quoted set looks like this:

    set &#34;name=var&#34; (...)

It is interpreted as follows:

- Everything between the first and the last quote in the command is extracted.
- The resulting string is split at the first equals symbol.
- The LHS is the variable name.
- The RHS is unescaped once **not** respecting quotes, then becomes the variable content.

Examples:

    &gt; set  &#34;name=&#34;a&#34;^^&#34;b&#34;c
    &gt; echo %name%
    &#34;a&#34;^&#34;b

    &gt; set  &#34;name=&#34;a&#34;^^&#34;b&#34;c
    &gt; echo %name%
    a&#34;^&#34;b

Note how the trailing c is always discarded because it occurs after the last quote.
The unquoted set looks like this:

    set name=var

It is parsed as follows:

- The entire command is parsed and unescaped respecting quotes as usual.
- The set expression starts with the first non-whitespace character after the set keyword.
- This expression is split at the first equals symbol.
- The LHS is the variable name.
- The RHS is unescaped once respecting quotes, then becomes the variable content.

Input redirection may occur in a set line, basically anywhere:

    &gt; set 1&gt;&#34;NUL&#34; &#34;var=val
    &gt; echo %var%
    val
&#34;&#34;&#34;
from __future__ import annotations

from .emulator import BatchEmulator
from .lexer import BatchLexer
from .parser import BatchParser
from .state import BatchState

__all__ = [
    &#39;BatchEmulator&#39;,
    &#39;BatchLexer&#39;,
    &#39;BatchParser&#39;,
    &#39;BatchState&#39;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="refinery.lib.batch.const" href="const.html">refinery.lib.batch.const</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.lib.batch.emulator" href="emulator.html">refinery.lib.batch.emulator</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.lib.batch.help" href="help.html">refinery.lib.batch.help</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.lib.batch.lexer" href="lexer.html">refinery.lib.batch.lexer</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.lib.batch.model" href="model.html">refinery.lib.batch.model</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.lib.batch.parser" href="parser.html">refinery.lib.batch.parser</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.lib.batch.state" href="state.html">refinery.lib.batch.state</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.lib.batch.synth" href="synth.html">refinery.lib.batch.synth</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="refinery.lib.batch.util" href="util.html">refinery.lib.batch.util</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.batch.BatchEmulator"><code class="flex name class">
<span>class <span class="ident">BatchEmulator</span></span>
<span>(</span><span>data, state=None, cfg=None, std=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L173-L1330" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BatchEmulator:

    class _node:
        handlers: ClassVar[dict[
            type[AstNode],
            Callable[[
                BatchEmulator,
                AstNode,
                IO,
                bool,
            ], Generator[SynNodeBase[AstNode] | Error]]
        ]] = {}

        def __init__(self, key: type[AstNode]):
            self.key = key

        def __call__(self, handler):
            self.handlers[self.key] = handler
            return handler

    class _command:
        handlers: ClassVar[dict[
            str,
            Callable[[
                BatchEmulator,
                SynCommand,
                IO,
                bool,
            ], Generator[str, None, int | None] | int | ErrorZero | None]
        ]] = {}

        def __init__(self, key: str):
            self.key = key.upper()

        def __call__(self, handler):
            self.handlers[self.key] = handler
            return handler

    def __init__(
        self,
        data: str | buf | BatchParser,
        state: BatchState | None = None,
        cfg: BatchEmulatorConfig | None = None,
        std: IO | None = None,
    ):
        self.stack = []
        self.parser = BatchParser(data, state)
        self.std = std or IO()
        self.cfg = cfg or BatchEmulatorConfig()
        self.block_labels = set()

    def spawn(self, data: str | buf | BatchParser, state: BatchState | None = None, std: IO | None = None):
        return BatchEmulator(
            data,
            state,
            self.cfg,
            std,
        )

    @property
    def state(self):
        return self.parser.state

    @property
    def environment(self):
        return self.state.environment

    @property
    def delayexpand(self):
        return self.state.delayexpand

    def clone_state(
        self,
        delayexpand: bool | None = None,
        cmdextended: bool | None = None,
        environment: dict | None | ellipsis = ...,
        filename: str | None = None,
    ):
        state = self.state
        if delayexpand is None:
            delayexpand = False
        if cmdextended is None:
            cmdextended = state.cmdextended
        if environment is ...:
            environment = dict(state.environment)
        return BatchState(
            delayexpand,
            cmdextended,
            environment=environment,
            file_system=state.file_system,
            username=state.username,
            hostname=state.hostname,
            now=state.now,
            cwd=state.cwd,
            filename=filename,
        )

    def get_for_variable_regex(self, vars: Iterable[str]):
        return re.compile(RF&#39;%((?:~[fdpnxsatz]*)?)((?:\\$\\w+)?)([{&#34;&#34;.join(vars)}])&#39;)

    def expand_delayed_variables(self, block: str):
        def expansion(match: re.Match[str]):
            name = match.group(1)
            try:
                return parse(name)
            except MissingVariable:
                _, _, rest = name.partition(&#39;:&#39;)
                return rest
        parse = self.parser.lexer.parse_env_variable
        return re.sub(r&#39;!([^!\n]*)!&#39;, expansion, block)

    def expand_forloop_variables(self, block: str, vars: dict[str, str] | None):
        def expansion(match: re.Match[str]):
            flags = ArgVarFlags.Empty
            for flag in match[1]:
                flags |= ArgVarFlags.FromToken(ord(flag))
            return _vars[match[3]]
        if not vars:
            return block
        _vars = vars
        return self.get_for_variable_regex(vars).sub(expansion, block)

    def contains_for_variable(self, ast: AstNode, vars: Iterable[str]):
        def check(token):
            if isinstance(token, list):
                return any(check(v) for v in token)
            if isinstance(token, dict):
                return any(check(v) for v in token.values())
            if isinstance(token, Enum):
                return False
            if isinstance(token, str):
                return bool(checker(token))
            if isinstance(token, AstNode):
                for tf in fields(token):
                    if tf.name == &#39;parent&#39;:
                        continue
                    if check(getattr(token, tf.name)):
                        return True
            return False
        checker = self.get_for_variable_regex(vars).search
        return check(ast) # type:ignore

    def expand_ast_node(self, ast: _T) -&gt; _T:
        def expand(token):
            if isinstance(token, list):
                return [expand(v) for v in token]
            if isinstance(token, dict):
                return {k: expand(v) for k, v in token.items()}
            if isinstance(token, Enum):
                return token
            if isinstance(token, str):
                if delayexpand:
                    token = self.expand_delayed_variables(token)
                return self.expand_forloop_variables(token, variables)
            if isinstance(token, AstNode):
                new = {}
                for tf in fields(token):
                    value = getattr(token, tf.name)
                    if tf.name != &#39;parent&#39;:
                        value = expand(value)
                    new[tf.name] = value
                return token.__class__(**new)
            return token
        delayexpand = self.delayexpand
        variables = self.state.for_loop_variables
        if not variables and not delayexpand:
            return ast
        return expand(ast) # type:ignore

    def execute_find_or_findstr(self, cmd: SynCommand, std: IO, findstr: bool):
        needles = []
        paths: list[str | ellipsis] = [...]
        flags = {}
        it = iter(cmd.args)
        arg = None
        yield cmd

        for arg in it:
            if not arg.startswith(&#39;/&#39;):
                if not findstr and not arg.startswith(&#39;&#34;&#39;):
                    return 1
                needles.extend(unquote(arg).split())
                break
            name, has_param, value = arg[1:].partition(&#39;:&#39;)
            name = name.upper()
            if name in (&#39;OFF&#39;, &#39;OFFLINE&#39;):
                continue
            elif len(name) &gt; 1:
                return 1
            elif name == &#39;C&#39;:
                needles.append(unquote(value))
            elif name == &#39;F&#39; and findstr:
                if (p := self.state.ingest_file(value)) is None:
                    return 1
                paths.extend(p.splitlines(False))
            elif name == &#39;G&#39; and findstr:
                if (n := self.state.ingest_file(value)) is None:
                    return 1
                needles.extend(n.splitlines(False))
            elif has_param:
                flags[name] = value
            else:
                flags[name] = True

        valid_flags = &#39;VNI&#39;
        if findstr:
            valid_flags += &#39;BELRSXMOPADQ&#39;

        for v in flags:
            if v not in valid_flags:
                return 1

        prefix_filename = False
        state = self.state

        for arg in it:
            pattern = unquote(arg)
            if &#39;*&#39; in pattern or &#39;?&#39; in pattern:
                prefix_filename = True
                for path in state.file_system:
                    if winfnmatch(path, pattern, state.cwd):
                        paths.append(path)
            else:
                paths.append(pattern)

        if len(paths) &gt; 1:
            prefix_filename = True

        for n, needle in enumerate(needles):
            if not findstr or &#39;L&#39; in flags:
                needle = re.escape(needle)
            if &#39;X&#39; in flags:
                needle = F&#39;^{needle}$&#39;
            elif &#39;B&#39; in flags:
                needle = F&#39;^{needle}&#39;
            elif &#39;E&#39; in flags:
                needle = F&#39;{needle}$&#39;
            needles[n] = needle

        _V = &#39;V&#39; in flags # noqa; Prints only lines that do not contain a match.
        _P = &#39;P&#39; in flags # noqa; Skip files with non-printable characters.
        _O = &#39;O&#39; in flags # noqa; Prints character offset before each matching line.
        _N = &#39;N&#39; in flags # noqa; Prints the line number before each line that matches.
        _M = &#39;M&#39; in flags # noqa; Prints only the filename if a file contains a match.

        nothing_found = True
        offset = 0

        for path in paths:
            if path is (...):
                data = std.i.read()
            else:
                data = state.ingest_file(path)
            if data is None:
                return 1
            if _P and not re.fullmatch(&#39;[\\s!-~]+&#39;, data):
                continue
            for n, line in enumerate(data.splitlines(True), 1):
                for needle in needles:
                    hit = re.search(needle, line)
                    if _V == bool(hit):
                        continue
                    nothing_found = False
                    if not _M:
                        if _O:
                            o = offset + (hit.start() if hit else 0)
                            line = F&#39;{o}:{line}&#39;
                        if _N:
                            line = F&#39;{n}:{line}&#39;
                        if prefix_filename:
                            line = F&#39;{path}:{line}&#39;
                        std.o.write(line)
                    elif path is not (...):
                        std.o.write(path)
                        break
                offset += len(line)

        return int(nothing_found)

    @_command(&#39;TYPE&#39;)
    def execute_type(self, cmd: SynCommand, std: IO, *_):
        path = cmd.argument_string.strip()
        data = self.state.ingest_file(path)
        if data is None:
            yield ErrorCannotFindFile
            return 1
        else:
            std.o.write(data)
            return 0

    @_command(&#39;FIND&#39;)
    def execute_find(self, cmd: SynCommand, std: IO, *_):
        return self.execute_find_or_findstr(cmd, std, findstr=False)

    @_command(&#39;FINDSTR&#39;)
    def execute_findstr(self, cmd: SynCommand, std: IO, *_):
        return self.execute_find_or_findstr(cmd, std, findstr=True)

    @_command(&#39;SET&#39;)
    def execute_set(self, cmd: SynCommand, std: IO, *_):
        if not (args := cmd.args):
            raise EmulatorException(&#39;Empty SET instruction&#39;)

        if cmd.verb.upper() != &#39;SET&#39;:
            raise RuntimeError

        # Since variables can be used in GOTO, a SET can be used to change the behavior of a GOTO.
        self.block_labels.clear()

        arithmetic = False
        quote_mode = False
        prompt = None

        it = iter(args)
        tk = next(it)

        if tk.upper() == &#39;/P&#39;:
            if std.i.closed:
                prompt = &#39;&#39;
            elif not (prompt := std.i.readline()).endswith(&#39;\n&#39;):
                raise InputLocked
            else:
                prompt = prompt.rstrip(&#39;\r\n&#39;)
            tk = next(it)
        else:
            cmd.junk = not self.cfg.show_sets

        yield cmd

        if tk.upper() == &#39;/A&#39;:
            arithmetic = True
            try:
                tk = next(it)
            except StopIteration:
                tk = &#39;&#39;

        args = [tk, *it, *cmd.trailing_spaces]

        if arithmetic:
            def defang(s: str):
                def r(m: re.Match[str]):
                    return F&#39;_{prefix}{ord(m[0]):X}_&#39;
                return re.sub(r&#39;[^-\s()!~*/%+&gt;&lt;&amp;^|_\w]&#39;, r, s)
            def refang(s: str): # noqa
                def r(m: re.Match[str]):
                    return chr(int(m[1], 16))
                return re.sub(rf&#39;_{prefix}([A-F0-9]+)_&#39;, r, s)
            prefix = F&#39;{uuid.uuid4().time_mid:X}&#39;
            namespace = {}
            translate = {}
            value = None
            if not (program := &#39;&#39;.join(args)):
                std.e.write(&#39;The syntax of the command is incorrect.\r\n&#39;)
                return ErrorZero.Val
            for assignment in program.split(&#39;,&#39;):
                assignment = assignment.strip()
                if not assignment:
                    std.e.write(&#39;Missing operand.\r\n&#39;)
                    return ErrorZero.Val
                name, operator, definition = re.split(r&#39;([*+^|/%-&amp;]|&lt;&lt;|&gt;&gt;|)=&#39;, assignment, maxsplit=1)
                name = name.upper()
                definition = re.sub(r&#39;\b0([0-7]+)\b&#39;, r&#39;0o\1&#39;, definition)
                if operator:
                    definition = F&#39;{name}{operator}({definition})&#39;
                definition = defang(definition)
                expression = cautious_parse(definition)
                names = names_in_expression(expression)
                if names.stored or names.others:
                    raise EmulatorException(&#39;Arithmetic SET had unexpected variable access.&#39;)
                for var in names.loaded:
                    original = refang(name).upper()
                    translate[original] = var
                    if var in namespace:
                        continue
                    try:
                        namespace[var] = batchint(self.environment[original])
                    except (KeyError, ValueError):
                        namespace[var] = 0
                code = compile(expression, filename=&#39;[ast]&#39;, mode=&#39;eval&#39;)
                value = eval(code, namespace, {})
                self.environment[name] = str(value)
                namespace[defang(name)] = value
            if value is None:
                std.e.write(&#39;The syntax of the command is incorrect.&#39;)
                return
            else:
                std.o.write(F&#39;{value!s}\r\n&#39;)
        else:
            try:
                eq = args.index(Ctrl.Equals)
            except ValueError:
                assignment = cmd.argument_string
                if assignment.startswith(&#39;&#34;&#39;):
                    quote_mode = True
                    assignment, _, unquoted = assignment[1:].rpartition(&#39;&#34;&#39;)
                    assignment = assignment or unquoted
                else:
                    assignment = &#39;&#39;.join(args)
                name, _, content = assignment.partition(&#39;=&#39;)
            else:
                with StringIO() as io:
                    for k in range(eq + 1, len(args)):
                        io.write(args[k])
                    content = io.getvalue()
                    name = cmd.args[eq - 1] if eq else &#39;&#39;
            name = name.upper()
            trailing_caret, content = uncaret(content, quote_mode)
            if trailing_caret:
                content = content[:-1]
            if prompt is not None:
                if (qc := content.strip()).startswith(&#39;&#34;&#39;):
                    _, _, qc = qc. partition(&#39;&#34;&#39;) # noqa
                    qc, _, r = qc.rpartition(&#39;&#34;&#39;) # noqa
                    content = qc or r
                std.o.write(content)
                content = prompt
            if name:
                if content:
                    self.environment[name] = content
                else:
                    self.environment.pop(name, None)

    @_command(&#39;CALL&#39;)
    def execute_call(self, cmd: SynCommand, std: IO, *_):
        cmdl = cmd.argument_string
        empty, colon, label = cmdl.partition(&#39;:&#39;)
        if colon and not empty:
            try:
                offset = self.parser.lexer.labels[label.upper()]
            except KeyError as KE:
                raise InvalidLabel(label) from KE
            emu = self.spawn(self.parser, std=std)
        else:
            offset = 0
            path = cmdl.strip()
            code = self.state.ingest_file(path)
            if code is None:
                yield cmd
                return
            state = self.clone_state(environment=self.state.environment, filename=path)
            emu = self.spawn(code, std=std, state=state)
        if self.cfg.skip_call:
            emu.execute(called=True)
        else:
            yield from emu.trace(offset, called=True)

    @_command(&#39;SETLOCAL&#39;)
    def execute_setlocal(self, cmd: SynCommand, *_):
        yield cmd
        setting = cmd.argument_string.strip().upper()
        delay = {
            &#39;DISABLEDELAYEDEXPANSION&#39;: False,
            &#39;ENABLEDELAYEDEXPANSION&#39; : True,
        }.get(setting, self.state.delayexpand)
        cmdxt = {
            &#39;DISABLEEXTENSIONS&#39;: False,
            &#39;ENABLEEXTENSIONS&#39; : True,
        }.get(setting, self.state.cmdextended)
        self.state.delayexpand_stack.append(delay)
        self.state.cmdextended_stack.append(cmdxt)
        self.state.environment_stack.append(dict(self.environment))

    @_command(&#39;ENDLOCAL&#39;)
    def execute_endlocal(self, cmd: SynCommand, *_):
        yield cmd
        if len(self.state.environment_stack) &gt; 1:
            self.state.environment_stack.pop()
            self.state.delayexpand_stack.pop()

    @_command(&#39;GOTO&#39;)
    def execute_goto(self, cmd: SynCommand, std: IO, *_):
        if self.cfg.skip_goto:
            yield cmd
            return
        it = iter(cmd.args)
        mark = False
        for label in it:
            if not isinstance(label, Ctrl):
                break
            if label == Ctrl.Label:
                mark = True
                for label in it:
                    break
                else:
                    label = &#39;&#39;
                break
        else:
            std.e.write(&#39;No batch label specified to GOTO command.\r\n&#39;)
            raise AbortExecution
        label, *_ = label.split(maxsplit=1)
        key = label.upper()
        if mark and key == &#39;EOF&#39;:
            raise Exit(int(self.state.ec), False)
        if key not in self.block_labels:
            raise Goto(label)
        else:
            yield Error(F&#39;Infinite Loop detected for label {key}&#39;)

    @_command(&#39;EXIT&#39;)
    def execute_exit(self, cmd: SynCommand, *_):
        it = iter(cmd.args)
        exit = True
        token = 0
        for arg in it:
            if arg.upper() == &#39;/B&#39;:
                exit = False
                continue
            token = arg
            break
        try:
            code = int(token)
        except ValueError:
            code = 0
        yield cmd
        if self.cfg.skip_exit:
            return
        raise Exit(code, exit)

    @_command(&#39;CHDIR&#39;)
    @_command(&#39;CD&#39;)
    def execute_chdir(self, cmd: SynCommand, *_):
        yield cmd
        self.state.cwd = cmd.argument_string.strip()

    @_command(&#39;PUSHD&#39;)
    def execute_pushd(self, cmd: SynCommand, *_):
        yield cmd
        self.state.dirstack.append(self.state.cwd)
        self.execute_chdir(cmd)

    @_command(&#39;POPD&#39;)
    def execute_popd(self, cmd: SynCommand, *_):
        yield cmd
        try:
            self.state.cwd = self.state.dirstack.pop()
        except IndexError:
            pass

    @_command(&#39;ECHO&#39;)
    def execute_echo(self, cmd: SynCommand, std: IO, in_group: bool):
        cmdl = cmd.argument_string
        mode = cmdl.strip().lower()
        current_state = self.state.echo
        if mode == &#39;on&#39;:
            if self.cfg.show_nops or current_state is False:
                yield cmd
            self.state.echo = True
            return
        if mode == &#39;off&#39;:
            if self.cfg.show_nops or current_state is True:
                yield cmd
            self.state.echo = False
            return
        yield cmd
        if mode:
            if in_group and not cmdl.endswith(&#39; &#39;):
                cmdl += &#39; &#39;
            std.o.write(F&#39;{cmdl}\r\n&#39;)
        else:
            mode = &#39;on&#39; if self.state.echo else &#39;off&#39;
            std.o.write(F&#39;ECHO is {mode}.\r\n&#39;)

    @_command(&#39;CLS&#39;)
    def execute_cls(self, cmd: SynCommand, *_):
        yield cmd

    @_command(&#39;ERASE&#39;)
    @_command(&#39;DEL&#39;)
    def execute_del(self, cmd: SynCommand, std: IO, *_):
        if not cmd.args:
            yield Error(&#39;The syntax of the command is incorrect&#39;)
            return 1
        else:
            yield cmd
        flags = {}
        it = iter(cmd.args)
        while (arg := next(it)).startswith(&#39;/&#39;) and 1 &lt; len(arg):
            flag = arg.upper()
            if flag[:3] == &#39;/A:&#39;:
                flags[&#39;A&#39;] = flag[3:]
                continue
            flags[flag[1]] = True
        _P = &#39;P&#39; in flags # Prompts for confirmation before deleting each file.
        _F = &#39;F&#39; in flags # Force deleting of read-only files.
        _S = &#39;S&#39; in flags # Delete specified files from all subdirectories.
        _Q = &#39;Q&#39; in flags # Quiet mode, do not ask if ok to delete on global wildcard
        paths = [arg, *it]
        state = self.state
        cwd = state.cwd
        for pattern in paths:
            for path in list(state.file_system):
                if not winfnmatch(pattern, path, cwd):
                    continue
                if _F:
                    pass
                if _S:
                    pass
                if _Q:
                    pass
                if _P and state.exists_file(pattern):
                    std.o.write(F&#39;{pattern}, Delete (Y/N)? &#39;)
                    decision = None
                    while decision not in (&#39;y&#39;, &#39;n&#39;):
                        confirmation = std.i.readline()
                        if not confirmation.endswith(&#39;\n&#39;):
                            raise InputLocked
                        decision = confirmation[:1].lower()
                    if decision == &#39;n&#39;:
                        continue
                state.remove_file(path)
        return 0

    @_command(&#39;START&#39;)
    def execute_start(self, cmd: SynCommand, std: IO, *_):
        yield cmd
        it = iter(cmd.ast.fragments)
        it = itertools.islice(it, cmd.argument_offset, None)
        title = None
        start = None
        cwd = self.state.cwd
        env = ...
        for arg in it:
            if title is None:
                if &#39;&#34;&#39; not in arg:
                    title = &#39;&#39;
                else:
                    title = unquote(arg)
                    continue
            if arg.isspace():
                continue
            if not arg.startswith(&#39;/&#39;):
                start = unquote(arg)
                break
            if (flag := arg.upper()) in (&#39;/NODE&#39;, &#39;/AFFINITY&#39;, &#39;/MACHINE&#39;):
                next(it)
            elif flag == &#39;/D&#39;:
                cwd = next(it)
            elif flag == &#39;/I&#39;:
                env = None
        if start and (batch := self.state.ingest_file(start)):
            state = self.clone_state(environment=env)
            state.cwd = cwd
            state.command_line = _fuse(it).strip()
            shell = self.spawn(batch, state, std)
            yield from shell.trace()

    @_command(&#39;CMD&#39;)
    def execute_cmd(self, cmd: SynCommand, std: IO, *_):
        yield cmd
        it = iter(cmd.ast.fragments)
        command = None
        quiet = False
        strip = False
        codec = &#39;cp1252&#39;
        delayexpand = None
        cmdextended = None

        for arg in it:
            if arg.isspace() or not arg.startswith(&#39;/&#39;):
                continue
            name, _, flag = arg[1:].partition(&#39;:&#39;)
            flag = flag.upper()
            name = name.upper()
            if name in &#39;CKR&#39;:
                command = _fuse(it)
                break
            elif name == &#39;Q&#39;:
                quiet = True
            elif name == &#39;S&#39;:
                strip = True
            elif name == &#39;U&#39;:
                codec = &#39;utf-16le&#39;
            elif name == &#39;E&#39;:
                cmdextended = _onoff(flag)
            elif name == &#39;V&#39;:
                delayexpand = _onoff(flag)
        else:
            return 0

        if (stripped := re.search(&#39;^\\s*&#34;(.*)&#34;&#39;, command)) and (strip
            or command.count(&#39;&#34;&#39;) != 2
            or re.search(&#39;[&amp;&lt;&gt;()@^|]&#39;, stripped[1])
            or re.search(&#39;\\s&#39;, stripped[1]) is None
        ):
            command = stripped[1]

        state = self.clone_state(delayexpand=delayexpand, cmdextended=cmdextended)
        state.codec = codec
        state.echo = not quiet
        shell = self.spawn(command, state, std)
        yield from shell.trace()

    @_command(&#39;ARP&#39;)
    @_command(&#39;AT&#39;)
    @_command(&#39;ATBROKER&#39;)
    @_command(&#39;BGINFO&#39;)
    @_command(&#39;BITSADMIN&#39;)
    @_command(&#39;CERTUTIL&#39;)
    @_command(&#39;CLIP&#39;)
    @_command(&#39;CMSTP&#39;)
    @_command(&#39;COMPACT&#39;)
    @_command(&#39;CONTROL&#39;)
    @_command(&#39;CSCRIPT&#39;)
    @_command(&#39;CURL&#39;)
    @_command(&#39;DEFRAG&#39;)
    @_command(&#39;DISKSHADOW&#39;)
    @_command(&#39;ESENTUTL&#39;)
    @_command(&#39;EXPAND&#39;)
    @_command(&#39;EXPLORER&#39;)
    @_command(&#39;EXTRAC32&#39;)
    @_command(&#39;FODHELPER&#39;)
    @_command(&#39;FORFILES&#39;)
    @_command(&#39;FTP&#39;)
    @_command(&#39;HOSTNAME&#39;)
    @_command(&#39;HOSTNAME&#39;)
    @_command(&#39;INSTALLUTIL&#39;)
    @_command(&#39;IPCONFIG&#39;)
    @_command(&#39;LOGOFF&#39;)
    @_command(&#39;MAKECAB&#39;)
    @_command(&#39;MAVINJECT&#39;)
    @_command(&#39;MOUNTVOL&#39;)
    @_command(&#39;MSBUILD&#39;)
    @_command(&#39;MSHTA&#39;)
    @_command(&#39;MSIEXEC&#39;)
    @_command(&#39;MSTSC&#39;)
    @_command(&#39;NET&#39;)
    @_command(&#39;NET1&#39;)
    @_command(&#39;NETSH&#39;)
    @_command(&#39;NSLOOKUP&#39;)
    @_command(&#39;ODBCCONF&#39;)
    @_command(&#39;PATHPING&#39;)
    @_command(&#39;PING&#39;)
    @_command(&#39;POWERSHELL&#39;)
    @_command(&#39;PRESENTATIONHOST&#39;)
    @_command(&#39;PWSH&#39;)
    @_command(&#39;REG&#39;)
    @_command(&#39;REGSVR32&#39;)
    @_command(&#39;ROUTE&#39;)
    @_command(&#39;RUNDLL32&#39;)
    @_command(&#39;SCP&#39;)
    @_command(&#39;SDCLT&#39;)
    @_command(&#39;SETX&#39;)
    @_command(&#39;SFTP&#39;)
    @_command(&#39;SHUTDOWN&#39;)
    @_command(&#39;SSH&#39;)
    @_command(&#39;SUBST&#39;)
    @_command(&#39;SYNCAPPVPUBLISHINGSERVER&#39;)
    @_command(&#39;SYSTEMINFO&#39;)
    @_command(&#39;TAR&#39;)
    @_command(&#39;TELNET&#39;)
    @_command(&#39;TFTP&#39;)
    @_command(&#39;TIMEOUT&#39;)
    @_command(&#39;TRACERT&#39;)
    @_command(&#39;VSSADMIN&#39;)
    @_command(&#39;WBADMIN&#39;)
    @_command(&#39;WHERE&#39;)
    @_command(&#39;WHOAMI&#39;)
    @_command(&#39;WINRM&#39;)
    @_command(&#39;WINRS&#39;)
    @_command(&#39;WSCRIPT&#39;)
    def execute_unimplemented_program(self, cmd: SynCommand, *_):
        yield cmd
        return 0

    @_command(&#39;CLS&#39;)
    def execute_unimplemented_command_unmodified_ec(self, cmd: SynCommand, *_):
        yield cmd

    @_command(&#39;ASSOC&#39;)
    @_command(&#39;ATTRIB&#39;)
    @_command(&#39;BCDEDIT&#39;)
    @_command(&#39;BREAK&#39;)
    @_command(&#39;CACLS&#39;)
    @_command(&#39;CHCP&#39;)
    @_command(&#39;CHKDSK&#39;)
    @_command(&#39;CHKNTFS&#39;)
    @_command(&#39;COLOR&#39;)
    @_command(&#39;COMP&#39;)
    @_command(&#39;COMPACT&#39;)
    @_command(&#39;CONVERT&#39;)
    @_command(&#39;COPY&#39;)
    @_command(&#39;DATE&#39;)
    @_command(&#39;DIR&#39;)
    @_command(&#39;DISKPART&#39;)
    @_command(&#39;DOSKEY&#39;)
    @_command(&#39;DRIVERQUERY&#39;)
    @_command(&#39;FC&#39;)
    @_command(&#39;FORMAT&#39;)
    @_command(&#39;FSUTIL&#39;)
    @_command(&#39;FTYPE&#39;)
    @_command(&#39;GPRESULT&#39;)
    @_command(&#39;ICACLS&#39;)
    @_command(&#39;LABEL&#39;)
    @_command(&#39;MD&#39;)
    @_command(&#39;MKDIR&#39;)
    @_command(&#39;MKLINK&#39;)
    @_command(&#39;MODE&#39;)
    @_command(&#39;MORE&#39;)
    @_command(&#39;MOVE&#39;)
    @_command(&#39;OPENFILES&#39;)
    @_command(&#39;PATH&#39;)
    @_command(&#39;PAUSE&#39;)
    @_command(&#39;PRINT&#39;)
    @_command(&#39;PROMPT&#39;)
    @_command(&#39;RD&#39;)
    @_command(&#39;RECOVER&#39;)
    @_command(&#39;REN&#39;)
    @_command(&#39;RENAME&#39;)
    @_command(&#39;REPLACE&#39;)
    @_command(&#39;RMDIR&#39;)
    @_command(&#39;ROBOCOPY&#39;)
    @_command(&#39;SC&#39;)
    @_command(&#39;SCHTASKS&#39;)
    @_command(&#39;SHIFT&#39;)
    @_command(&#39;SHUTDOWN&#39;)
    @_command(&#39;SORT&#39;)
    @_command(&#39;SUBST&#39;)
    @_command(&#39;SYSTEMINFO&#39;)
    @_command(&#39;TASKKILL&#39;)
    @_command(&#39;TASKLIST&#39;)
    @_command(&#39;TIME&#39;)
    @_command(&#39;TITLE&#39;)
    @_command(&#39;TREE&#39;)
    @_command(&#39;TYPE&#39;)
    @_command(&#39;VER&#39;)
    @_command(&#39;VERIFY&#39;)
    @_command(&#39;VOL&#39;)
    @_command(&#39;WMIC&#39;)
    @_command(&#39;XCOPY&#39;)
    def execute_unimplemented_command(self, cmd: SynCommand, *_):
        yield cmd
        return 0

    @_command(&#39;REM&#39;)
    def execute_rem(self, cmd: SynCommand, *_):
        if self.cfg.show_comments:
            yield cmd

    @_command(&#39;HELP&#39;)
    def execute_help(self, cmd: SynCommand, std: IO, *_):
        yield cmd
        std.o.write(HelpOutput[&#39;HELP&#39;])
        return 0

    def execute_command(self, cmd: SynCommand, std: IO, in_group: bool):
        verb = cmd.verb.upper().strip()
        handler = self._command.handlers.get(verb)

        if handler is None:
            base, ext = ntpath.splitext(verb)
            handler = None
            if any(ext == pe.upper() for pe in self.state.envar(&#39;PATHEXT&#39;, &#39;&#39;).split(&#39;;&#39;)):
                handler = self._command.handlers.get(base)

        if handler is None:
            if self.state.exists_file(verb):
                self.state.ec = 0
            elif not indicators.winfpath.value.fullmatch(verb):
                if &#39;\uFFFD&#39; in verb or not verb.isprintable():
                    self.state.ec = 9009
                    cmd.junk = True
                else:
                    cmd.junk = not self.cfg.show_junk
            yield cmd
            return

        paths: dict[int, str] = {}

        for src, r in cmd.ast.redirects.items():
            if not 0 &lt;= src &lt;= 2 or (src == 0) != r.is_input:
                continue
            if isinstance((target := r.target), str):
                if target.upper() == &#39;NUL&#39;:
                    std[src] = DevNull()
                else:
                    data = self.state.ingest_file(target)
                    if src == 0:
                        if data is None:
                            yield ErrorCannotFindFile
                            return
                        std.i = StringIO(data)
                    else:
                        if r.is_out_append:
                            buffer = StringIO(data)
                            buffer.seek(0, 2)
                        else:
                            buffer = StringIO()
                        std[src] = buffer
                        paths[src] = target
            elif src == 1 and target == 2:
                std.o = std.e
            elif src == 2 and target == 1:
                std.e = std.o

        if &#39;/?&#39; in cmd.args:
            std.o.write(HelpOutput[verb])
            self.state.ec = 0
            return

        if (result := handler(self, cmd, std, in_group)) is None:
            pass
        elif not isinstance(result, (int, ErrorZero)):
            result = (yield from result)

        for k, path in paths.items():
            self.state.create_file(path, std[k].getvalue())

        if result is not None:
            self.state.ec = result

    @_node(AstPipeline)
    def trace_pipeline(self, pipeline: AstPipeline, std: IO, in_group: bool):
        length = len(pipeline.parts)
        streams = IO(*std)
        if length &gt; 1:
            yield synthesize(pipeline)
        for k, part in enumerate(pipeline.parts, 1):
            if k != 1:
                streams.i = streams.o
                streams.i.seek(0)
            if k == length:
                streams.o = std.o
            else:
                streams.o = StringIO()
            if isinstance(part, AstGroup):
                it = self.trace_group(part, streams, in_group)
            else:
                ast = self.expand_ast_node(part)
                cmd = synthesize(ast)
                it = self.execute_command(cmd, streams, in_group)
            yield from it

    @_node(AstSequence)
    def trace_sequence(self, sequence: AstSequence, std: IO, in_group: bool):
        yield from self.trace_statement(sequence.head, std, in_group)
        for cs in sequence.tail:
            if cs.condition == AstCondition.Failure:
                if bool(self.state.ec) is False:
                    continue
            if cs.condition == AstCondition.Success:
                if bool(self.state.ec) is True:
                    continue
            yield from self.trace_statement(cs.statement, std, in_group)

    @_node(AstIf)
    def trace_if(self, _if: AstIf, std: IO, in_group: bool):
        yield synthesize(_if)
        _if = self.expand_ast_node(_if)
        self.block_labels.clear()

        if _if.variant == AstIfVariant.ErrorLevel:
            condition = _if.var_int &lt;= self.state.ec
        elif _if.variant == AstIfVariant.CmdExtVersion:
            condition = _if.var_int &lt;= self.state.extensions_version
        elif _if.variant == AstIfVariant.Exist:
            condition = self.state.exists_file(_if.var_str)
        elif _if.variant == AstIfVariant.Defined:
            condition = _if.var_str.upper() in self.state.environment
        else:
            lhs = _if.lhs
            rhs = _if.rhs
            cmp = _if.cmp
            assert lhs is not None
            assert rhs is not None
            if cmp == AstIfCmp.STR:
                if _if.casefold:
                    if isinstance(lhs, str):
                        lhs = lhs.casefold()
                    if isinstance(rhs, str):
                        rhs = rhs.casefold()
                condition = lhs == rhs
            elif cmp == AstIfCmp.GTR:
                condition = lhs &gt; rhs
            elif cmp == AstIfCmp.GEQ:
                condition = lhs &gt;= rhs
            elif cmp == AstIfCmp.NEQ:
                condition = lhs != rhs
            elif cmp == AstIfCmp.EQU:
                condition = lhs == rhs
            elif cmp == AstIfCmp.LSS:
                condition = lhs &lt; rhs
            elif cmp == AstIfCmp.LEQ:
                condition = lhs &lt;= rhs
            else:
                raise RuntimeError(cmp)
        if _if.negated:
            condition = not condition

        if condition:
            yield from self.trace_sequence(_if.then_do, std, in_group)
        elif (_else := _if.else_do):
            yield from self.trace_sequence(_else, std, in_group)

    @_node(AstFor)
    def trace_for(self, _for: AstFor, std: IO, in_group: bool):
        state = self.state
        cwd = state.cwd
        vars = state.new_forloop()
        body = _for.body
        name = _for.variable
        vars[name] = &#39;&#39;

        if (
            self.contains_for_variable(body, vars)
                or _for.variant != AstForVariant.NumericLoop
                or len(_for.spec) != 1
        ):
            yield synthesize(_for)

        if _for.variant == AstForVariant.FileParsing:
            if _for.mode == AstForParserMode.Command:
                emulator = self.spawn(_for.specline, self.clone_state(filename=state.name))
                yield from emulator.trace()
                lines = emulator.std.o.getvalue().splitlines()
            elif _for.mode == AstForParserMode.Literal:
                lines = _for.spec
            else:
                def lines_from_files():
                    fs = state.file_system
                    for name in _for.spec:
                        for path, content in fs.items():
                            if not winfnmatch(path, name, cwd):
                                continue
                            yield from content.splitlines(False)
                lines = lines_from_files()
            opt = _for.options
            tokens = sorted(opt.tokens)
            split = re.compile(&#39;[{}]+&#39;.format(re.escape(opt.delims)))
            count = tokens[-1] + 1 if tokens else 0
            first_variable = ord(name)
            if opt.asterisk:
                tokens.append(count)
            for n, line in enumerate(lines):
                if n &lt; opt.skip:
                    continue
                if opt.comment and line.startswith(opt.comment):
                    continue
                if count:
                    tokenized = split.split(line, maxsplit=count)
                else:
                    tokenized = (line,)
                for k, tok in enumerate(tokens):
                    name = chr(first_variable + k)
                    if not name.isalpha():
                        raise EmulatorException(&#39;Ran out of variables in FOR-Loop.&#39;)
                    try:
                        vars[name] = tokenized[tok]
                    except IndexError:
                        vars[name] = &#39;&#39;
                yield from self.trace_sequence(body, std, in_group)
        else:
            for entry in _for.spec:
                vars[name] = entry
                yield from self.trace_sequence(body, std, in_group)
        state.end_forloop()

    @_node(AstGroup)
    def trace_group(self, group: AstGroup, std: IO, in_group: bool):
        for sequence in group.fragments:
            yield from self.trace_sequence(sequence, std, True)
        yield synthesize(group)

    @_node(AstLabel)
    def trace_label(self, label: AstLabel, *_):
        if label.comment:
            if self.cfg.show_comments:
                yield synthesize(label)
        else:
            if self.cfg.show_labels:
                yield synthesize(label)
            self.block_labels.add(label.label.upper())

    def trace_statement(self, statement: AstStatement, std: IO, in_group: bool):
        try:
            handler = self._node.handlers[statement.__class__]
        except KeyError:
            raise RuntimeError(statement)
        yield from handler(self, statement, std, in_group)

    def emulate_commands(self, allow_junk=False):
        for syn in self.trace():
            if not isinstance(syn, SynCommand):
                continue
            if not allow_junk and syn.junk:
                continue
            yield str(syn)

    def emulate_to_depth(self, depth: int = 0):
        for syn in self.trace():
            if not isinstance(syn, SynNodeBase):
                continue
            if syn.ast.depth &lt;= depth:
                yield str(syn)

    def emulate(self, offset: int = 0):
        last: AstNode | None = None
        junk: AstNode | None = None
        for syn in self.trace(offset):
            if not isinstance(syn, SynNodeBase):
                continue
            ast = syn.ast
            if isinstance(syn, SynCommand) and syn.junk:
                junk = ast
                continue
            if junk is not None:
                if junk.is_descendant_of(ast):
                    if not last or not last.is_descendant_of(ast):
                        continue
            if last is not None:
                if ast.is_descendant_of(last):
                    # we already synthesized a parent construct, like a FOR loop or IF block
                    continue
                if last.is_descendant_of(ast):
                    # we synthesized a command and no longer need to synthesize an AST node that
                    # wraps it, like a group
                    continue
            if isinstance(ast, AstPipeline):
                if len(ast.parts) == 1:
                    continue
            if last is ast:
                raise RuntimeError(&#39;Emulator attempted to synthesize the same command twice.&#39;)
            last = ast
            yield str(syn)

    def execute(self, offset: int = 0, called: bool = False):
        for _ in self.trace(offset, called=called):
            pass

    def trace(self, offset: int = 0, called: bool = False):
        if (name := self.state.name):
            self.state.create_file(name, self.parser.lexer.text)
        length = len(self.parser.lexer.code)
        labels = self.parser.lexer.labels

        while offset &lt; length:
            try:
                for sequence in self.parser.parse(offset):
                    if isinstance(sequence, AstError):
                        yield Error(sequence.error)
                        continue
                    yield from self.trace_sequence(sequence, self.std, False)
            except Goto as goto:
                try:
                    offset = labels[goto.label.upper()]
                except KeyError:
                    raise InvalidLabel(goto.label) from goto
                continue
            except Exit as exit:
                self.state.ec = exit.code
                if exit.exit and called:
                    raise
                else:
                    break
            except AbortExecution:
                self.state.ec = 1
                break
            else:
                break</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.batch.BatchEmulator.state"><code class="name">var <span class="ident">state</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L232-L234" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def state(self):
    return self.parser.state</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.environment"><code class="name">var <span class="ident">environment</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L236-L238" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def environment(self):
    return self.state.environment</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.delayexpand"><code class="name">var <span class="ident">delayexpand</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L240-L242" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def delayexpand(self):
    return self.state.delayexpand</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.batch.BatchEmulator.spawn"><code class="name flex">
<span>def <span class="ident">spawn</span></span>(<span>self, data, state=None, std=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L224-L230" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def spawn(self, data: str | buf | BatchParser, state: BatchState | None = None, std: IO | None = None):
    return BatchEmulator(
        data,
        state,
        self.cfg,
        std,
    )</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.clone_state"><code class="name flex">
<span>def <span class="ident">clone_state</span></span>(<span>self, delayexpand=None, cmdextended=None, environment=Ellipsis, filename=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L244-L268" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clone_state(
    self,
    delayexpand: bool | None = None,
    cmdextended: bool | None = None,
    environment: dict | None | ellipsis = ...,
    filename: str | None = None,
):
    state = self.state
    if delayexpand is None:
        delayexpand = False
    if cmdextended is None:
        cmdextended = state.cmdextended
    if environment is ...:
        environment = dict(state.environment)
    return BatchState(
        delayexpand,
        cmdextended,
        environment=environment,
        file_system=state.file_system,
        username=state.username,
        hostname=state.hostname,
        now=state.now,
        cwd=state.cwd,
        filename=filename,
    )</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.get_for_variable_regex"><code class="name flex">
<span>def <span class="ident">get_for_variable_regex</span></span>(<span>self, vars)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L270-L271" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_for_variable_regex(self, vars: Iterable[str]):
    return re.compile(RF&#39;%((?:~[fdpnxsatz]*)?)((?:\\$\\w+)?)([{&#34;&#34;.join(vars)}])&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.expand_delayed_variables"><code class="name flex">
<span>def <span class="ident">expand_delayed_variables</span></span>(<span>self, block)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L273-L282" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def expand_delayed_variables(self, block: str):
    def expansion(match: re.Match[str]):
        name = match.group(1)
        try:
            return parse(name)
        except MissingVariable:
            _, _, rest = name.partition(&#39;:&#39;)
            return rest
    parse = self.parser.lexer.parse_env_variable
    return re.sub(r&#39;!([^!\n]*)!&#39;, expansion, block)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.expand_forloop_variables"><code class="name flex">
<span>def <span class="ident">expand_forloop_variables</span></span>(<span>self, block, vars)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L284-L293" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def expand_forloop_variables(self, block: str, vars: dict[str, str] | None):
    def expansion(match: re.Match[str]):
        flags = ArgVarFlags.Empty
        for flag in match[1]:
            flags |= ArgVarFlags.FromToken(ord(flag))
        return _vars[match[3]]
    if not vars:
        return block
    _vars = vars
    return self.get_for_variable_regex(vars).sub(expansion, block)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.contains_for_variable"><code class="name flex">
<span>def <span class="ident">contains_for_variable</span></span>(<span>self, ast, vars)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L295-L313" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def contains_for_variable(self, ast: AstNode, vars: Iterable[str]):
    def check(token):
        if isinstance(token, list):
            return any(check(v) for v in token)
        if isinstance(token, dict):
            return any(check(v) for v in token.values())
        if isinstance(token, Enum):
            return False
        if isinstance(token, str):
            return bool(checker(token))
        if isinstance(token, AstNode):
            for tf in fields(token):
                if tf.name == &#39;parent&#39;:
                    continue
                if check(getattr(token, tf.name)):
                    return True
        return False
    checker = self.get_for_variable_regex(vars).search
    return check(ast) # type:ignore</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.expand_ast_node"><code class="name flex">
<span>def <span class="ident">expand_ast_node</span></span>(<span>self, ast)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L315-L340" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def expand_ast_node(self, ast: _T) -&gt; _T:
    def expand(token):
        if isinstance(token, list):
            return [expand(v) for v in token]
        if isinstance(token, dict):
            return {k: expand(v) for k, v in token.items()}
        if isinstance(token, Enum):
            return token
        if isinstance(token, str):
            if delayexpand:
                token = self.expand_delayed_variables(token)
            return self.expand_forloop_variables(token, variables)
        if isinstance(token, AstNode):
            new = {}
            for tf in fields(token):
                value = getattr(token, tf.name)
                if tf.name != &#39;parent&#39;:
                    value = expand(value)
                new[tf.name] = value
            return token.__class__(**new)
        return token
    delayexpand = self.delayexpand
    variables = self.state.for_loop_variables
    if not variables and not delayexpand:
        return ast
    return expand(ast) # type:ignore</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_find_or_findstr"><code class="name flex">
<span>def <span class="ident">execute_find_or_findstr</span></span>(<span>self, cmd, std, findstr)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L342-L450" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def execute_find_or_findstr(self, cmd: SynCommand, std: IO, findstr: bool):
    needles = []
    paths: list[str | ellipsis] = [...]
    flags = {}
    it = iter(cmd.args)
    arg = None
    yield cmd

    for arg in it:
        if not arg.startswith(&#39;/&#39;):
            if not findstr and not arg.startswith(&#39;&#34;&#39;):
                return 1
            needles.extend(unquote(arg).split())
            break
        name, has_param, value = arg[1:].partition(&#39;:&#39;)
        name = name.upper()
        if name in (&#39;OFF&#39;, &#39;OFFLINE&#39;):
            continue
        elif len(name) &gt; 1:
            return 1
        elif name == &#39;C&#39;:
            needles.append(unquote(value))
        elif name == &#39;F&#39; and findstr:
            if (p := self.state.ingest_file(value)) is None:
                return 1
            paths.extend(p.splitlines(False))
        elif name == &#39;G&#39; and findstr:
            if (n := self.state.ingest_file(value)) is None:
                return 1
            needles.extend(n.splitlines(False))
        elif has_param:
            flags[name] = value
        else:
            flags[name] = True

    valid_flags = &#39;VNI&#39;
    if findstr:
        valid_flags += &#39;BELRSXMOPADQ&#39;

    for v in flags:
        if v not in valid_flags:
            return 1

    prefix_filename = False
    state = self.state

    for arg in it:
        pattern = unquote(arg)
        if &#39;*&#39; in pattern or &#39;?&#39; in pattern:
            prefix_filename = True
            for path in state.file_system:
                if winfnmatch(path, pattern, state.cwd):
                    paths.append(path)
        else:
            paths.append(pattern)

    if len(paths) &gt; 1:
        prefix_filename = True

    for n, needle in enumerate(needles):
        if not findstr or &#39;L&#39; in flags:
            needle = re.escape(needle)
        if &#39;X&#39; in flags:
            needle = F&#39;^{needle}$&#39;
        elif &#39;B&#39; in flags:
            needle = F&#39;^{needle}&#39;
        elif &#39;E&#39; in flags:
            needle = F&#39;{needle}$&#39;
        needles[n] = needle

    _V = &#39;V&#39; in flags # noqa; Prints only lines that do not contain a match.
    _P = &#39;P&#39; in flags # noqa; Skip files with non-printable characters.
    _O = &#39;O&#39; in flags # noqa; Prints character offset before each matching line.
    _N = &#39;N&#39; in flags # noqa; Prints the line number before each line that matches.
    _M = &#39;M&#39; in flags # noqa; Prints only the filename if a file contains a match.

    nothing_found = True
    offset = 0

    for path in paths:
        if path is (...):
            data = std.i.read()
        else:
            data = state.ingest_file(path)
        if data is None:
            return 1
        if _P and not re.fullmatch(&#39;[\\s!-~]+&#39;, data):
            continue
        for n, line in enumerate(data.splitlines(True), 1):
            for needle in needles:
                hit = re.search(needle, line)
                if _V == bool(hit):
                    continue
                nothing_found = False
                if not _M:
                    if _O:
                        o = offset + (hit.start() if hit else 0)
                        line = F&#39;{o}:{line}&#39;
                    if _N:
                        line = F&#39;{n}:{line}&#39;
                    if prefix_filename:
                        line = F&#39;{path}:{line}&#39;
                    std.o.write(line)
                elif path is not (...):
                    std.o.write(path)
                    break
            offset += len(line)

    return int(nothing_found)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_type"><code class="name flex">
<span>def <span class="ident">execute_type</span></span>(<span>self, cmd, std, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L452-L461" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;TYPE&#39;)
def execute_type(self, cmd: SynCommand, std: IO, *_):
    path = cmd.argument_string.strip()
    data = self.state.ingest_file(path)
    if data is None:
        yield ErrorCannotFindFile
        return 1
    else:
        std.o.write(data)
        return 0</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_find"><code class="name flex">
<span>def <span class="ident">execute_find</span></span>(<span>self, cmd, std, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L463-L465" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;FIND&#39;)
def execute_find(self, cmd: SynCommand, std: IO, *_):
    return self.execute_find_or_findstr(cmd, std, findstr=False)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_findstr"><code class="name flex">
<span>def <span class="ident">execute_findstr</span></span>(<span>self, cmd, std, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L467-L469" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;FINDSTR&#39;)
def execute_findstr(self, cmd: SynCommand, std: IO, *_):
    return self.execute_find_or_findstr(cmd, std, findstr=True)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_set"><code class="name flex">
<span>def <span class="ident">execute_set</span></span>(<span>self, cmd, std, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L471-L593" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;SET&#39;)
def execute_set(self, cmd: SynCommand, std: IO, *_):
    if not (args := cmd.args):
        raise EmulatorException(&#39;Empty SET instruction&#39;)

    if cmd.verb.upper() != &#39;SET&#39;:
        raise RuntimeError

    # Since variables can be used in GOTO, a SET can be used to change the behavior of a GOTO.
    self.block_labels.clear()

    arithmetic = False
    quote_mode = False
    prompt = None

    it = iter(args)
    tk = next(it)

    if tk.upper() == &#39;/P&#39;:
        if std.i.closed:
            prompt = &#39;&#39;
        elif not (prompt := std.i.readline()).endswith(&#39;\n&#39;):
            raise InputLocked
        else:
            prompt = prompt.rstrip(&#39;\r\n&#39;)
        tk = next(it)
    else:
        cmd.junk = not self.cfg.show_sets

    yield cmd

    if tk.upper() == &#39;/A&#39;:
        arithmetic = True
        try:
            tk = next(it)
        except StopIteration:
            tk = &#39;&#39;

    args = [tk, *it, *cmd.trailing_spaces]

    if arithmetic:
        def defang(s: str):
            def r(m: re.Match[str]):
                return F&#39;_{prefix}{ord(m[0]):X}_&#39;
            return re.sub(r&#39;[^-\s()!~*/%+&gt;&lt;&amp;^|_\w]&#39;, r, s)
        def refang(s: str): # noqa
            def r(m: re.Match[str]):
                return chr(int(m[1], 16))
            return re.sub(rf&#39;_{prefix}([A-F0-9]+)_&#39;, r, s)
        prefix = F&#39;{uuid.uuid4().time_mid:X}&#39;
        namespace = {}
        translate = {}
        value = None
        if not (program := &#39;&#39;.join(args)):
            std.e.write(&#39;The syntax of the command is incorrect.\r\n&#39;)
            return ErrorZero.Val
        for assignment in program.split(&#39;,&#39;):
            assignment = assignment.strip()
            if not assignment:
                std.e.write(&#39;Missing operand.\r\n&#39;)
                return ErrorZero.Val
            name, operator, definition = re.split(r&#39;([*+^|/%-&amp;]|&lt;&lt;|&gt;&gt;|)=&#39;, assignment, maxsplit=1)
            name = name.upper()
            definition = re.sub(r&#39;\b0([0-7]+)\b&#39;, r&#39;0o\1&#39;, definition)
            if operator:
                definition = F&#39;{name}{operator}({definition})&#39;
            definition = defang(definition)
            expression = cautious_parse(definition)
            names = names_in_expression(expression)
            if names.stored or names.others:
                raise EmulatorException(&#39;Arithmetic SET had unexpected variable access.&#39;)
            for var in names.loaded:
                original = refang(name).upper()
                translate[original] = var
                if var in namespace:
                    continue
                try:
                    namespace[var] = batchint(self.environment[original])
                except (KeyError, ValueError):
                    namespace[var] = 0
            code = compile(expression, filename=&#39;[ast]&#39;, mode=&#39;eval&#39;)
            value = eval(code, namespace, {})
            self.environment[name] = str(value)
            namespace[defang(name)] = value
        if value is None:
            std.e.write(&#39;The syntax of the command is incorrect.&#39;)
            return
        else:
            std.o.write(F&#39;{value!s}\r\n&#39;)
    else:
        try:
            eq = args.index(Ctrl.Equals)
        except ValueError:
            assignment = cmd.argument_string
            if assignment.startswith(&#39;&#34;&#39;):
                quote_mode = True
                assignment, _, unquoted = assignment[1:].rpartition(&#39;&#34;&#39;)
                assignment = assignment or unquoted
            else:
                assignment = &#39;&#39;.join(args)
            name, _, content = assignment.partition(&#39;=&#39;)
        else:
            with StringIO() as io:
                for k in range(eq + 1, len(args)):
                    io.write(args[k])
                content = io.getvalue()
                name = cmd.args[eq - 1] if eq else &#39;&#39;
        name = name.upper()
        trailing_caret, content = uncaret(content, quote_mode)
        if trailing_caret:
            content = content[:-1]
        if prompt is not None:
            if (qc := content.strip()).startswith(&#39;&#34;&#39;):
                _, _, qc = qc. partition(&#39;&#34;&#39;) # noqa
                qc, _, r = qc.rpartition(&#39;&#34;&#39;) # noqa
                content = qc or r
            std.o.write(content)
            content = prompt
        if name:
            if content:
                self.environment[name] = content
            else:
                self.environment.pop(name, None)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_call"><code class="name flex">
<span>def <span class="ident">execute_call</span></span>(<span>self, cmd, std, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L595-L617" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;CALL&#39;)
def execute_call(self, cmd: SynCommand, std: IO, *_):
    cmdl = cmd.argument_string
    empty, colon, label = cmdl.partition(&#39;:&#39;)
    if colon and not empty:
        try:
            offset = self.parser.lexer.labels[label.upper()]
        except KeyError as KE:
            raise InvalidLabel(label) from KE
        emu = self.spawn(self.parser, std=std)
    else:
        offset = 0
        path = cmdl.strip()
        code = self.state.ingest_file(path)
        if code is None:
            yield cmd
            return
        state = self.clone_state(environment=self.state.environment, filename=path)
        emu = self.spawn(code, std=std, state=state)
    if self.cfg.skip_call:
        emu.execute(called=True)
    else:
        yield from emu.trace(offset, called=True)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_setlocal"><code class="name flex">
<span>def <span class="ident">execute_setlocal</span></span>(<span>self, cmd, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L619-L633" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;SETLOCAL&#39;)
def execute_setlocal(self, cmd: SynCommand, *_):
    yield cmd
    setting = cmd.argument_string.strip().upper()
    delay = {
        &#39;DISABLEDELAYEDEXPANSION&#39;: False,
        &#39;ENABLEDELAYEDEXPANSION&#39; : True,
    }.get(setting, self.state.delayexpand)
    cmdxt = {
        &#39;DISABLEEXTENSIONS&#39;: False,
        &#39;ENABLEEXTENSIONS&#39; : True,
    }.get(setting, self.state.cmdextended)
    self.state.delayexpand_stack.append(delay)
    self.state.cmdextended_stack.append(cmdxt)
    self.state.environment_stack.append(dict(self.environment))</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_endlocal"><code class="name flex">
<span>def <span class="ident">execute_endlocal</span></span>(<span>self, cmd, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L635-L640" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;ENDLOCAL&#39;)
def execute_endlocal(self, cmd: SynCommand, *_):
    yield cmd
    if len(self.state.environment_stack) &gt; 1:
        self.state.environment_stack.pop()
        self.state.delayexpand_stack.pop()</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_goto"><code class="name flex">
<span>def <span class="ident">execute_goto</span></span>(<span>self, cmd, std, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L642-L669" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;GOTO&#39;)
def execute_goto(self, cmd: SynCommand, std: IO, *_):
    if self.cfg.skip_goto:
        yield cmd
        return
    it = iter(cmd.args)
    mark = False
    for label in it:
        if not isinstance(label, Ctrl):
            break
        if label == Ctrl.Label:
            mark = True
            for label in it:
                break
            else:
                label = &#39;&#39;
            break
    else:
        std.e.write(&#39;No batch label specified to GOTO command.\r\n&#39;)
        raise AbortExecution
    label, *_ = label.split(maxsplit=1)
    key = label.upper()
    if mark and key == &#39;EOF&#39;:
        raise Exit(int(self.state.ec), False)
    if key not in self.block_labels:
        raise Goto(label)
    else:
        yield Error(F&#39;Infinite Loop detected for label {key}&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_exit"><code class="name flex">
<span>def <span class="ident">execute_exit</span></span>(<span>self, cmd, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L671-L689" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;EXIT&#39;)
def execute_exit(self, cmd: SynCommand, *_):
    it = iter(cmd.args)
    exit = True
    token = 0
    for arg in it:
        if arg.upper() == &#39;/B&#39;:
            exit = False
            continue
        token = arg
        break
    try:
        code = int(token)
    except ValueError:
        code = 0
    yield cmd
    if self.cfg.skip_exit:
        return
    raise Exit(code, exit)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_chdir"><code class="name flex">
<span>def <span class="ident">execute_chdir</span></span>(<span>self, cmd, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L691-L695" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;CHDIR&#39;)
@_command(&#39;CD&#39;)
def execute_chdir(self, cmd: SynCommand, *_):
    yield cmd
    self.state.cwd = cmd.argument_string.strip()</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_pushd"><code class="name flex">
<span>def <span class="ident">execute_pushd</span></span>(<span>self, cmd, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L697-L701" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;PUSHD&#39;)
def execute_pushd(self, cmd: SynCommand, *_):
    yield cmd
    self.state.dirstack.append(self.state.cwd)
    self.execute_chdir(cmd)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_popd"><code class="name flex">
<span>def <span class="ident">execute_popd</span></span>(<span>self, cmd, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L703-L709" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;POPD&#39;)
def execute_popd(self, cmd: SynCommand, *_):
    yield cmd
    try:
        self.state.cwd = self.state.dirstack.pop()
    except IndexError:
        pass</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_echo"><code class="name flex">
<span>def <span class="ident">execute_echo</span></span>(<span>self, cmd, std, in_group)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L711-L733" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;ECHO&#39;)
def execute_echo(self, cmd: SynCommand, std: IO, in_group: bool):
    cmdl = cmd.argument_string
    mode = cmdl.strip().lower()
    current_state = self.state.echo
    if mode == &#39;on&#39;:
        if self.cfg.show_nops or current_state is False:
            yield cmd
        self.state.echo = True
        return
    if mode == &#39;off&#39;:
        if self.cfg.show_nops or current_state is True:
            yield cmd
        self.state.echo = False
        return
    yield cmd
    if mode:
        if in_group and not cmdl.endswith(&#39; &#39;):
            cmdl += &#39; &#39;
        std.o.write(F&#39;{cmdl}\r\n&#39;)
    else:
        mode = &#39;on&#39; if self.state.echo else &#39;off&#39;
        std.o.write(F&#39;ECHO is {mode}.\r\n&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_cls"><code class="name flex">
<span>def <span class="ident">execute_cls</span></span>(<span>self, cmd, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L735-L737" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;CLS&#39;)
def execute_cls(self, cmd: SynCommand, *_):
    yield cmd</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_del"><code class="name flex">
<span>def <span class="ident">execute_del</span></span>(<span>self, cmd, std, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L739-L783" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;ERASE&#39;)
@_command(&#39;DEL&#39;)
def execute_del(self, cmd: SynCommand, std: IO, *_):
    if not cmd.args:
        yield Error(&#39;The syntax of the command is incorrect&#39;)
        return 1
    else:
        yield cmd
    flags = {}
    it = iter(cmd.args)
    while (arg := next(it)).startswith(&#39;/&#39;) and 1 &lt; len(arg):
        flag = arg.upper()
        if flag[:3] == &#39;/A:&#39;:
            flags[&#39;A&#39;] = flag[3:]
            continue
        flags[flag[1]] = True
    _P = &#39;P&#39; in flags # Prompts for confirmation before deleting each file.
    _F = &#39;F&#39; in flags # Force deleting of read-only files.
    _S = &#39;S&#39; in flags # Delete specified files from all subdirectories.
    _Q = &#39;Q&#39; in flags # Quiet mode, do not ask if ok to delete on global wildcard
    paths = [arg, *it]
    state = self.state
    cwd = state.cwd
    for pattern in paths:
        for path in list(state.file_system):
            if not winfnmatch(pattern, path, cwd):
                continue
            if _F:
                pass
            if _S:
                pass
            if _Q:
                pass
            if _P and state.exists_file(pattern):
                std.o.write(F&#39;{pattern}, Delete (Y/N)? &#39;)
                decision = None
                while decision not in (&#39;y&#39;, &#39;n&#39;):
                    confirmation = std.i.readline()
                    if not confirmation.endswith(&#39;\n&#39;):
                        raise InputLocked
                    decision = confirmation[:1].lower()
                if decision == &#39;n&#39;:
                    continue
            state.remove_file(path)
    return 0</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_start"><code class="name flex">
<span>def <span class="ident">execute_start</span></span>(<span>self, cmd, std, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L785-L817" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;START&#39;)
def execute_start(self, cmd: SynCommand, std: IO, *_):
    yield cmd
    it = iter(cmd.ast.fragments)
    it = itertools.islice(it, cmd.argument_offset, None)
    title = None
    start = None
    cwd = self.state.cwd
    env = ...
    for arg in it:
        if title is None:
            if &#39;&#34;&#39; not in arg:
                title = &#39;&#39;
            else:
                title = unquote(arg)
                continue
        if arg.isspace():
            continue
        if not arg.startswith(&#39;/&#39;):
            start = unquote(arg)
            break
        if (flag := arg.upper()) in (&#39;/NODE&#39;, &#39;/AFFINITY&#39;, &#39;/MACHINE&#39;):
            next(it)
        elif flag == &#39;/D&#39;:
            cwd = next(it)
        elif flag == &#39;/I&#39;:
            env = None
    if start and (batch := self.state.ingest_file(start)):
        state = self.clone_state(environment=env)
        state.cwd = cwd
        state.command_line = _fuse(it).strip()
        shell = self.spawn(batch, state, std)
        yield from shell.trace()</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_cmd"><code class="name flex">
<span>def <span class="ident">execute_cmd</span></span>(<span>self, cmd, std, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L819-L863" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;CMD&#39;)
def execute_cmd(self, cmd: SynCommand, std: IO, *_):
    yield cmd
    it = iter(cmd.ast.fragments)
    command = None
    quiet = False
    strip = False
    codec = &#39;cp1252&#39;
    delayexpand = None
    cmdextended = None

    for arg in it:
        if arg.isspace() or not arg.startswith(&#39;/&#39;):
            continue
        name, _, flag = arg[1:].partition(&#39;:&#39;)
        flag = flag.upper()
        name = name.upper()
        if name in &#39;CKR&#39;:
            command = _fuse(it)
            break
        elif name == &#39;Q&#39;:
            quiet = True
        elif name == &#39;S&#39;:
            strip = True
        elif name == &#39;U&#39;:
            codec = &#39;utf-16le&#39;
        elif name == &#39;E&#39;:
            cmdextended = _onoff(flag)
        elif name == &#39;V&#39;:
            delayexpand = _onoff(flag)
    else:
        return 0

    if (stripped := re.search(&#39;^\\s*&#34;(.*)&#34;&#39;, command)) and (strip
        or command.count(&#39;&#34;&#39;) != 2
        or re.search(&#39;[&amp;&lt;&gt;()@^|]&#39;, stripped[1])
        or re.search(&#39;\\s&#39;, stripped[1]) is None
    ):
        command = stripped[1]

    state = self.clone_state(delayexpand=delayexpand, cmdextended=cmdextended)
    state.codec = codec
    state.echo = not quiet
    shell = self.spawn(command, state, std)
    yield from shell.trace()</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_unimplemented_program"><code class="name flex">
<span>def <span class="ident">execute_unimplemented_program</span></span>(<span>self, cmd, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L865-L935" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;ARP&#39;)
@_command(&#39;AT&#39;)
@_command(&#39;ATBROKER&#39;)
@_command(&#39;BGINFO&#39;)
@_command(&#39;BITSADMIN&#39;)
@_command(&#39;CERTUTIL&#39;)
@_command(&#39;CLIP&#39;)
@_command(&#39;CMSTP&#39;)
@_command(&#39;COMPACT&#39;)
@_command(&#39;CONTROL&#39;)
@_command(&#39;CSCRIPT&#39;)
@_command(&#39;CURL&#39;)
@_command(&#39;DEFRAG&#39;)
@_command(&#39;DISKSHADOW&#39;)
@_command(&#39;ESENTUTL&#39;)
@_command(&#39;EXPAND&#39;)
@_command(&#39;EXPLORER&#39;)
@_command(&#39;EXTRAC32&#39;)
@_command(&#39;FODHELPER&#39;)
@_command(&#39;FORFILES&#39;)
@_command(&#39;FTP&#39;)
@_command(&#39;HOSTNAME&#39;)
@_command(&#39;HOSTNAME&#39;)
@_command(&#39;INSTALLUTIL&#39;)
@_command(&#39;IPCONFIG&#39;)
@_command(&#39;LOGOFF&#39;)
@_command(&#39;MAKECAB&#39;)
@_command(&#39;MAVINJECT&#39;)
@_command(&#39;MOUNTVOL&#39;)
@_command(&#39;MSBUILD&#39;)
@_command(&#39;MSHTA&#39;)
@_command(&#39;MSIEXEC&#39;)
@_command(&#39;MSTSC&#39;)
@_command(&#39;NET&#39;)
@_command(&#39;NET1&#39;)
@_command(&#39;NETSH&#39;)
@_command(&#39;NSLOOKUP&#39;)
@_command(&#39;ODBCCONF&#39;)
@_command(&#39;PATHPING&#39;)
@_command(&#39;PING&#39;)
@_command(&#39;POWERSHELL&#39;)
@_command(&#39;PRESENTATIONHOST&#39;)
@_command(&#39;PWSH&#39;)
@_command(&#39;REG&#39;)
@_command(&#39;REGSVR32&#39;)
@_command(&#39;ROUTE&#39;)
@_command(&#39;RUNDLL32&#39;)
@_command(&#39;SCP&#39;)
@_command(&#39;SDCLT&#39;)
@_command(&#39;SETX&#39;)
@_command(&#39;SFTP&#39;)
@_command(&#39;SHUTDOWN&#39;)
@_command(&#39;SSH&#39;)
@_command(&#39;SUBST&#39;)
@_command(&#39;SYNCAPPVPUBLISHINGSERVER&#39;)
@_command(&#39;SYSTEMINFO&#39;)
@_command(&#39;TAR&#39;)
@_command(&#39;TELNET&#39;)
@_command(&#39;TFTP&#39;)
@_command(&#39;TIMEOUT&#39;)
@_command(&#39;TRACERT&#39;)
@_command(&#39;VSSADMIN&#39;)
@_command(&#39;WBADMIN&#39;)
@_command(&#39;WHERE&#39;)
@_command(&#39;WHOAMI&#39;)
@_command(&#39;WINRM&#39;)
@_command(&#39;WINRS&#39;)
@_command(&#39;WSCRIPT&#39;)
def execute_unimplemented_program(self, cmd: SynCommand, *_):
    yield cmd
    return 0</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_unimplemented_command_unmodified_ec"><code class="name flex">
<span>def <span class="ident">execute_unimplemented_command_unmodified_ec</span></span>(<span>self, cmd, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L937-L939" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;CLS&#39;)
def execute_unimplemented_command_unmodified_ec(self, cmd: SynCommand, *_):
    yield cmd</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_unimplemented_command"><code class="name flex">
<span>def <span class="ident">execute_unimplemented_command</span></span>(<span>self, cmd, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L941-L1004" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;ASSOC&#39;)
@_command(&#39;ATTRIB&#39;)
@_command(&#39;BCDEDIT&#39;)
@_command(&#39;BREAK&#39;)
@_command(&#39;CACLS&#39;)
@_command(&#39;CHCP&#39;)
@_command(&#39;CHKDSK&#39;)
@_command(&#39;CHKNTFS&#39;)
@_command(&#39;COLOR&#39;)
@_command(&#39;COMP&#39;)
@_command(&#39;COMPACT&#39;)
@_command(&#39;CONVERT&#39;)
@_command(&#39;COPY&#39;)
@_command(&#39;DATE&#39;)
@_command(&#39;DIR&#39;)
@_command(&#39;DISKPART&#39;)
@_command(&#39;DOSKEY&#39;)
@_command(&#39;DRIVERQUERY&#39;)
@_command(&#39;FC&#39;)
@_command(&#39;FORMAT&#39;)
@_command(&#39;FSUTIL&#39;)
@_command(&#39;FTYPE&#39;)
@_command(&#39;GPRESULT&#39;)
@_command(&#39;ICACLS&#39;)
@_command(&#39;LABEL&#39;)
@_command(&#39;MD&#39;)
@_command(&#39;MKDIR&#39;)
@_command(&#39;MKLINK&#39;)
@_command(&#39;MODE&#39;)
@_command(&#39;MORE&#39;)
@_command(&#39;MOVE&#39;)
@_command(&#39;OPENFILES&#39;)
@_command(&#39;PATH&#39;)
@_command(&#39;PAUSE&#39;)
@_command(&#39;PRINT&#39;)
@_command(&#39;PROMPT&#39;)
@_command(&#39;RD&#39;)
@_command(&#39;RECOVER&#39;)
@_command(&#39;REN&#39;)
@_command(&#39;RENAME&#39;)
@_command(&#39;REPLACE&#39;)
@_command(&#39;RMDIR&#39;)
@_command(&#39;ROBOCOPY&#39;)
@_command(&#39;SC&#39;)
@_command(&#39;SCHTASKS&#39;)
@_command(&#39;SHIFT&#39;)
@_command(&#39;SHUTDOWN&#39;)
@_command(&#39;SORT&#39;)
@_command(&#39;SUBST&#39;)
@_command(&#39;SYSTEMINFO&#39;)
@_command(&#39;TASKKILL&#39;)
@_command(&#39;TASKLIST&#39;)
@_command(&#39;TIME&#39;)
@_command(&#39;TITLE&#39;)
@_command(&#39;TREE&#39;)
@_command(&#39;TYPE&#39;)
@_command(&#39;VER&#39;)
@_command(&#39;VERIFY&#39;)
@_command(&#39;VOL&#39;)
@_command(&#39;WMIC&#39;)
@_command(&#39;XCOPY&#39;)
def execute_unimplemented_command(self, cmd: SynCommand, *_):
    yield cmd
    return 0</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_rem"><code class="name flex">
<span>def <span class="ident">execute_rem</span></span>(<span>self, cmd, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1006-L1009" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;REM&#39;)
def execute_rem(self, cmd: SynCommand, *_):
    if self.cfg.show_comments:
        yield cmd</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_help"><code class="name flex">
<span>def <span class="ident">execute_help</span></span>(<span>self, cmd, std, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1011-L1015" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_command(&#39;HELP&#39;)
def execute_help(self, cmd: SynCommand, std: IO, *_):
    yield cmd
    std.o.write(HelpOutput[&#39;HELP&#39;])
    return 0</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute_command"><code class="name flex">
<span>def <span class="ident">execute_command</span></span>(<span>self, cmd, std, in_group)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1017-L1081" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def execute_command(self, cmd: SynCommand, std: IO, in_group: bool):
    verb = cmd.verb.upper().strip()
    handler = self._command.handlers.get(verb)

    if handler is None:
        base, ext = ntpath.splitext(verb)
        handler = None
        if any(ext == pe.upper() for pe in self.state.envar(&#39;PATHEXT&#39;, &#39;&#39;).split(&#39;;&#39;)):
            handler = self._command.handlers.get(base)

    if handler is None:
        if self.state.exists_file(verb):
            self.state.ec = 0
        elif not indicators.winfpath.value.fullmatch(verb):
            if &#39;\uFFFD&#39; in verb or not verb.isprintable():
                self.state.ec = 9009
                cmd.junk = True
            else:
                cmd.junk = not self.cfg.show_junk
        yield cmd
        return

    paths: dict[int, str] = {}

    for src, r in cmd.ast.redirects.items():
        if not 0 &lt;= src &lt;= 2 or (src == 0) != r.is_input:
            continue
        if isinstance((target := r.target), str):
            if target.upper() == &#39;NUL&#39;:
                std[src] = DevNull()
            else:
                data = self.state.ingest_file(target)
                if src == 0:
                    if data is None:
                        yield ErrorCannotFindFile
                        return
                    std.i = StringIO(data)
                else:
                    if r.is_out_append:
                        buffer = StringIO(data)
                        buffer.seek(0, 2)
                    else:
                        buffer = StringIO()
                    std[src] = buffer
                    paths[src] = target
        elif src == 1 and target == 2:
            std.o = std.e
        elif src == 2 and target == 1:
            std.e = std.o

    if &#39;/?&#39; in cmd.args:
        std.o.write(HelpOutput[verb])
        self.state.ec = 0
        return

    if (result := handler(self, cmd, std, in_group)) is None:
        pass
    elif not isinstance(result, (int, ErrorZero)):
        result = (yield from result)

    for k, path in paths.items():
        self.state.create_file(path, std[k].getvalue())

    if result is not None:
        self.state.ec = result</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.trace_pipeline"><code class="name flex">
<span>def <span class="ident">trace_pipeline</span></span>(<span>self, pipeline, std, in_group)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1083-L1103" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_node(AstPipeline)
def trace_pipeline(self, pipeline: AstPipeline, std: IO, in_group: bool):
    length = len(pipeline.parts)
    streams = IO(*std)
    if length &gt; 1:
        yield synthesize(pipeline)
    for k, part in enumerate(pipeline.parts, 1):
        if k != 1:
            streams.i = streams.o
            streams.i.seek(0)
        if k == length:
            streams.o = std.o
        else:
            streams.o = StringIO()
        if isinstance(part, AstGroup):
            it = self.trace_group(part, streams, in_group)
        else:
            ast = self.expand_ast_node(part)
            cmd = synthesize(ast)
            it = self.execute_command(cmd, streams, in_group)
        yield from it</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.trace_sequence"><code class="name flex">
<span>def <span class="ident">trace_sequence</span></span>(<span>self, sequence, std, in_group)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1105-L1115" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_node(AstSequence)
def trace_sequence(self, sequence: AstSequence, std: IO, in_group: bool):
    yield from self.trace_statement(sequence.head, std, in_group)
    for cs in sequence.tail:
        if cs.condition == AstCondition.Failure:
            if bool(self.state.ec) is False:
                continue
        if cs.condition == AstCondition.Success:
            if bool(self.state.ec) is True:
                continue
        yield from self.trace_statement(cs.statement, std, in_group)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.trace_if"><code class="name flex">
<span>def <span class="ident">trace_if</span></span>(<span>self, _if, std, in_group)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1117-L1164" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_node(AstIf)
def trace_if(self, _if: AstIf, std: IO, in_group: bool):
    yield synthesize(_if)
    _if = self.expand_ast_node(_if)
    self.block_labels.clear()

    if _if.variant == AstIfVariant.ErrorLevel:
        condition = _if.var_int &lt;= self.state.ec
    elif _if.variant == AstIfVariant.CmdExtVersion:
        condition = _if.var_int &lt;= self.state.extensions_version
    elif _if.variant == AstIfVariant.Exist:
        condition = self.state.exists_file(_if.var_str)
    elif _if.variant == AstIfVariant.Defined:
        condition = _if.var_str.upper() in self.state.environment
    else:
        lhs = _if.lhs
        rhs = _if.rhs
        cmp = _if.cmp
        assert lhs is not None
        assert rhs is not None
        if cmp == AstIfCmp.STR:
            if _if.casefold:
                if isinstance(lhs, str):
                    lhs = lhs.casefold()
                if isinstance(rhs, str):
                    rhs = rhs.casefold()
            condition = lhs == rhs
        elif cmp == AstIfCmp.GTR:
            condition = lhs &gt; rhs
        elif cmp == AstIfCmp.GEQ:
            condition = lhs &gt;= rhs
        elif cmp == AstIfCmp.NEQ:
            condition = lhs != rhs
        elif cmp == AstIfCmp.EQU:
            condition = lhs == rhs
        elif cmp == AstIfCmp.LSS:
            condition = lhs &lt; rhs
        elif cmp == AstIfCmp.LEQ:
            condition = lhs &lt;= rhs
        else:
            raise RuntimeError(cmp)
    if _if.negated:
        condition = not condition

    if condition:
        yield from self.trace_sequence(_if.then_do, std, in_group)
    elif (_else := _if.else_do):
        yield from self.trace_sequence(_else, std, in_group)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.trace_for"><code class="name flex">
<span>def <span class="ident">trace_for</span></span>(<span>self, _for, std, in_group)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1166-L1227" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_node(AstFor)
def trace_for(self, _for: AstFor, std: IO, in_group: bool):
    state = self.state
    cwd = state.cwd
    vars = state.new_forloop()
    body = _for.body
    name = _for.variable
    vars[name] = &#39;&#39;

    if (
        self.contains_for_variable(body, vars)
            or _for.variant != AstForVariant.NumericLoop
            or len(_for.spec) != 1
    ):
        yield synthesize(_for)

    if _for.variant == AstForVariant.FileParsing:
        if _for.mode == AstForParserMode.Command:
            emulator = self.spawn(_for.specline, self.clone_state(filename=state.name))
            yield from emulator.trace()
            lines = emulator.std.o.getvalue().splitlines()
        elif _for.mode == AstForParserMode.Literal:
            lines = _for.spec
        else:
            def lines_from_files():
                fs = state.file_system
                for name in _for.spec:
                    for path, content in fs.items():
                        if not winfnmatch(path, name, cwd):
                            continue
                        yield from content.splitlines(False)
            lines = lines_from_files()
        opt = _for.options
        tokens = sorted(opt.tokens)
        split = re.compile(&#39;[{}]+&#39;.format(re.escape(opt.delims)))
        count = tokens[-1] + 1 if tokens else 0
        first_variable = ord(name)
        if opt.asterisk:
            tokens.append(count)
        for n, line in enumerate(lines):
            if n &lt; opt.skip:
                continue
            if opt.comment and line.startswith(opt.comment):
                continue
            if count:
                tokenized = split.split(line, maxsplit=count)
            else:
                tokenized = (line,)
            for k, tok in enumerate(tokens):
                name = chr(first_variable + k)
                if not name.isalpha():
                    raise EmulatorException(&#39;Ran out of variables in FOR-Loop.&#39;)
                try:
                    vars[name] = tokenized[tok]
                except IndexError:
                    vars[name] = &#39;&#39;
            yield from self.trace_sequence(body, std, in_group)
    else:
        for entry in _for.spec:
            vars[name] = entry
            yield from self.trace_sequence(body, std, in_group)
    state.end_forloop()</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.trace_group"><code class="name flex">
<span>def <span class="ident">trace_group</span></span>(<span>self, group, std, in_group)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1229-L1233" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_node(AstGroup)
def trace_group(self, group: AstGroup, std: IO, in_group: bool):
    for sequence in group.fragments:
        yield from self.trace_sequence(sequence, std, True)
    yield synthesize(group)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.trace_label"><code class="name flex">
<span>def <span class="ident">trace_label</span></span>(<span>self, label, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1235-L1243" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_node(AstLabel)
def trace_label(self, label: AstLabel, *_):
    if label.comment:
        if self.cfg.show_comments:
            yield synthesize(label)
    else:
        if self.cfg.show_labels:
            yield synthesize(label)
        self.block_labels.add(label.label.upper())</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.trace_statement"><code class="name flex">
<span>def <span class="ident">trace_statement</span></span>(<span>self, statement, std, in_group)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1245-L1250" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def trace_statement(self, statement: AstStatement, std: IO, in_group: bool):
    try:
        handler = self._node.handlers[statement.__class__]
    except KeyError:
        raise RuntimeError(statement)
    yield from handler(self, statement, std, in_group)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.emulate_commands"><code class="name flex">
<span>def <span class="ident">emulate_commands</span></span>(<span>self, allow_junk=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1252-L1258" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def emulate_commands(self, allow_junk=False):
    for syn in self.trace():
        if not isinstance(syn, SynCommand):
            continue
        if not allow_junk and syn.junk:
            continue
        yield str(syn)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.emulate_to_depth"><code class="name flex">
<span>def <span class="ident">emulate_to_depth</span></span>(<span>self, depth=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1260-L1265" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def emulate_to_depth(self, depth: int = 0):
    for syn in self.trace():
        if not isinstance(syn, SynNodeBase):
            continue
        if syn.ast.depth &lt;= depth:
            yield str(syn)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.emulate"><code class="name flex">
<span>def <span class="ident">emulate</span></span>(<span>self, offset=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1267-L1295" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def emulate(self, offset: int = 0):
    last: AstNode | None = None
    junk: AstNode | None = None
    for syn in self.trace(offset):
        if not isinstance(syn, SynNodeBase):
            continue
        ast = syn.ast
        if isinstance(syn, SynCommand) and syn.junk:
            junk = ast
            continue
        if junk is not None:
            if junk.is_descendant_of(ast):
                if not last or not last.is_descendant_of(ast):
                    continue
        if last is not None:
            if ast.is_descendant_of(last):
                # we already synthesized a parent construct, like a FOR loop or IF block
                continue
            if last.is_descendant_of(ast):
                # we synthesized a command and no longer need to synthesize an AST node that
                # wraps it, like a group
                continue
        if isinstance(ast, AstPipeline):
            if len(ast.parts) == 1:
                continue
        if last is ast:
            raise RuntimeError(&#39;Emulator attempted to synthesize the same command twice.&#39;)
        last = ast
        yield str(syn)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, offset=0, called=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1297-L1299" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def execute(self, offset: int = 0, called: bool = False):
    for _ in self.trace(offset, called=called):
        pass</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchEmulator.trace"><code class="name flex">
<span>def <span class="ident">trace</span></span>(<span>self, offset=0, called=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/emulator.py#L1301-L1330" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def trace(self, offset: int = 0, called: bool = False):
    if (name := self.state.name):
        self.state.create_file(name, self.parser.lexer.text)
    length = len(self.parser.lexer.code)
    labels = self.parser.lexer.labels

    while offset &lt; length:
        try:
            for sequence in self.parser.parse(offset):
                if isinstance(sequence, AstError):
                    yield Error(sequence.error)
                    continue
                yield from self.trace_sequence(sequence, self.std, False)
        except Goto as goto:
            try:
                offset = labels[goto.label.upper()]
            except KeyError:
                raise InvalidLabel(goto.label) from goto
            continue
        except Exit as exit:
            self.state.ec = exit.code
            if exit.exit and called:
                raise
            else:
                break
        except AbortExecution:
            self.state.ec = 1
            break
        else:
            break</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.batch.BatchLexer"><code class="flex name class">
<span>class <span class="ident">BatchLexer</span></span>
<span>(</span><span>data, state=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L113-L767" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BatchLexer:

    labels: dict[str, int]
    code: memoryview

    pending_redirect: RedirectIO | None

    cursor: BatchLexerCursor
    resume: BatchLexerCursor | None

    class _register:
        # A handler is given the current mode and char. It returns a boolean indicating
        # whether or not the character was processed and may be consumed.
        handlers: ClassVar[dict[Mode, Callable[
            [BatchLexer, Mode, int], Generator[Token, None, bool]
        ]]] = {}

        def __init__(self, *modes: Mode):
            self.modes = modes

        def __call__(self, handler):
            for mode in self.modes:
                self.handlers[mode] = handler
            return handler

    def __init__(self, data: str | buf | BatchLexer, state: BatchState | None = None):
        if isinstance(data, BatchLexer):
            if state is not None:
                raise NotImplementedError
            self.text = data.text
            self.code = data.code
            self.labels = data.labels
            self.state = data.state
        else:
            if state is None:
                state = BatchState()
            self.state = state
            self.preparse(data)

    def parse_group(self):
        self.group += 1

    def parse_label(self):
        if (m := self.mode) != Mode.Text or len(self.modes) != 1:
            raise EmulatorException(F&#39;Switching to LABEL while in mode {m.name}&#39;)
        self.mode_switch(Mode.Label)

    def parse_set(self):
        if (m := self.mode) != Mode.Text or len(self.modes) != 1:
            raise EmulatorException(F&#39;Switching to SET while in mode {m.name}&#39;)
        self.mode_switch(Mode.SetStarted)

    @property
    def environment(self):
        return self.state.environment

    def parse_arg_variable(self, var: ArgVar):
        &#34;&#34;&#34;
        %* in a batch script refers to all the arguments (e.g. %1 %2 %3
            %4 %5 ...)
        Substitution of batch parameters (%n) has been enhanced.  You can
        now use the following optional syntax:
            %~1         - expands %1 removing any surrounding quotes (&#34;)
            %~f1        - expands %1 to a fully qualified path name
            %~d1        - expands %1 to a drive letter only
            %~p1        - expands %1 to a path only
            %~n1        - expands %1 to a file name only
            %~x1        - expands %1 to a file extension only
            %~s1        - expanded path contains short names only
            %~a1        - expands %1 to file attributes
            %~t1        - expands %1 to date/time of file
            %~z1        - expands %1 to size of file
            %~$PATH:1   - searches the directories listed in the PATH
                           environment variable and expands %1 to the fully
                           qualified name of the first one found.  If the
                           environment variable name is not defined or the
                           file is not found by the search, then this
                           modifier expands to the empty string
        The modifiers can be combined to get compound results:
            %~dp1       - expands %1 to a drive letter and path only
            %~nx1       - expands %1 to a file name and extension only
            %~dp$PATH:1 - searches the directories listed in the PATH
                           environment variable for %1 and expands to the
                           drive letter and path of the first one found.
            %~ftza1     - expands %1 to a DIR like output line
        In the above examples %1 and PATH can be replaced by other
        valid values.  The %~ syntax is terminated by a valid argument
        number.  The %~ modifiers may not be used with %*
        &#34;&#34;&#34;
        state = self.state
        flags = var.flags

        if (k := var.offset) is (...):
            return state.command_line
        if (j := k - 1) &lt; 0:
            argval = state.name
        elif j &lt; len(args := state.args):
            argval = args[j]
        else:
            return &#39;&#39;

        if not flags:
            return argval

        has_path = 0 != ArgVarFlags.FullPath &amp; flags

        if flags.StripQuotes and argval.startswith(&#39;&#34;&#39;) and argval.endswith(&#39;&#34;&#39;):
            argval = argval[1:-1]

        if flags.ShortName and not has_path:
            flags |= ArgVarFlags.FullPath
            has_path = True

        with io.StringIO() as out:
            if flags.Attributes:
                out.write(&#39;--a--------&#39;) # TODO: placeholder
            if flags.DateTime:
                dt = state.start_time.isoformat(&#39; &#39;, &#39;minutes&#39;)
                out.write(F&#39; {dt}&#39;)
            if flags.FileSize:
                out.write(F&#39; {state.sizeof_file(argval)}&#39;)
            if has_path:
                out.write(&#39; &#39;)
                full_path = state.resolve_path(argval)
                drv, rest = ntpath.splitdrive(full_path)
                *pp, name = ntpath.split(rest)
                name, ext = ntpath.splitext(name)
                if flags.DriveLetter:
                    out.write(drv)
                if flags.FilePath:
                    out.write(ntpath.join(*pp))
                if flags.FileName:
                    out.write(name)
                if flags.FileExtension:
                    out.write(ext)
            return out.getvalue().lstrip()

    @property
    def modes(self):
        return self.cursor.modes

    def reset(self, offset: int):
        self.quote = False
        self.caret = False
        self.white = False
        self.first_after_gap = True
        self.group = 0
        self.cursor = BatchLexerCursor(offset)
        self.modes.append(Mode.Text)
        self.resume = None
        self.pending_redirect = None

    def mode_reset(self):
        del self.modes[1:]

    def mode_finish(self):
        modes = self.modes
        if len(modes) &lt;= 1:
            raise RuntimeError(&#39;Trying to exit base mode.&#39;)
        self.modes.pop()

    def mode_switch(self, mode: Mode):
        self.modes.append(mode)

    @property
    def mode(self):
        return self.modes[-1]

    @mode.setter
    def mode(self, value: Mode):
        self.modes[-1] = value

    @property
    def substituting(self):
        return self.cursor.substituting

    @property
    def eof(self):
        return (c := self.cursor).offset &gt;= len(self.code) and not c.subst_buffer

    def quick_save(self):
        self.resume = self.cursor.copy()

    def quick_load(self):
        if (resume := self.resume) is None:
            raise RuntimeError
        self.cursor = resume
        self.resume = None

    def current_char(self):
        cursor = self.cursor
        if not (subst := cursor.subst_buffer):
            offset = cursor.offset
            if self.code[offset] == PERCENT:
                cursor.offset += 1
                self.fill_substitution_buffer()
                return self.current_char()
        else:
            offset = cursor.subst_offset
            if offset &gt;= (n := len(subst)):
                offset -= n
                offset += cursor.offset
            else:
                return subst[offset]
        try:
            return self.code[offset]
        except IndexError:
            raise UnexpectedEOF

    def consume_char(self):
        cursor = self.cursor
        if subst := cursor.subst_buffer:
            offset = cursor.subst_offset + 1
            if offset &gt;= len(subst):
                del subst[:]
                cursor.subst_offset = -1
            else:
                cursor.subst_offset = offset
        else:
            offset = cursor.offset + 1
            if offset &gt; len(self.code):
                raise EOFError(&#39;Consumed a character beyond EOF.&#39;)
            cursor.offset = offset

    def next_char(self):
        self.consume_char()
        return self.current_char()

    def parse_env_variable(self, var: str):
        if var == &#39;&#39;:
            return &#39;%&#39;
        name, _, modifier = var.partition(&#39;:&#39;)
        base = self.state.envar(name)
        if not modifier or not base:
            return base
        if &#39;=&#39; in modifier:
            old, _, new = modifier.partition(&#39;=&#39;)
            kwargs = {}
            if old.startswith(&#39;~&#39;):
                old = old[1:]
                kwargs.update(count=1)
            return base.replace(old, new, **kwargs)
        else:
            if not modifier.startswith(&#39;~&#39;):
                raise EmulatorException
            offset, _, length = modifier[1:].partition(&#39;,&#39;)
            offset = batchint(offset)
            if offset &lt; 0:
                offset = max(0, len(base) + offset)
            if length:
                end = offset + batchint(length)
            else:
                end = len(base)
            return base[offset:end]

    def emit_token(self):
        switched = False
        if (buffer := self.cursor.token) and (token := u16(buffer)):
            if (pr := self.pending_redirect):
                pr.target = unquote(token)
                self.pending_redirect = None
                self.mode_switch(Mode.Gap)
                yield pr
                switched = True
            else:
                yield Word(token)
        del buffer[:]
        self.first_after_gap = False
        return switched

    def tokens(self, offset: int) -&gt; Generator[Token]:
        self.reset(offset)
        handlers = self._register.handlers
        current_char = self.current_char
        consume_char = self.consume_char
        size = len(self.code)

        while not self.cursor.eof(size):
            c = current_char()
            m = self.mode
            h = handlers[m]
            if (yield from h(self, m, c)):
                consume_char()

        if not self.first_after_gap:
            yield from self.emit_token()

    def check_line_break(self, mode: Mode, char: int):
        if char != LINEBREAK:
            return False
        if not self.caret:
            # caret is not reset until the next char!
            yield from self.emit_token()
            self.white = True
            self.quote = False
            self.mode_reset()
            yield Ctrl.NewLine
        self.consume_char()
        return True

    def check_caret(self, char: int):
        if self.caret:
            self.cursor.token.append(char)
            self.caret = False
            self.consume_char()
            return True
        elif char == CARET:
            self.caret = True
            self.consume_char()
            return True
        else:
            return False

    def check_command_separators(self, char: int):
        if char == PAREN_CLOSE and (g := self.group) &gt; 0:
            yield from self.emit_token()
            yield Ctrl.EndGroup
            self.mode_reset()
            self.consume_char()
            self.group = g - 1
            return True
        elif char == AMPERSAND:
            tok = Ctrl.Ampersand
        elif char == PIPE:
            tok = Ctrl.Pipe
        else:
            return False
        yield from self.emit_token()
        self.mode_reset()
        self.consume_char()
        yield tok
        return True

    def check_quote_start(self, char: int):
        if char != QUOTE:
            return False
        self.cursor.token.append(char)
        self.mode_switch(Mode.Quote)
        self.caret = False
        self.consume_char()
        return True

    def check_redirect_io(self, char: int):
        if char not in ANGLES:
            return False

        output = char != ANGLE_OPEN
        token = self.cursor.token

        if len(token) == 1 and (src := token[0] - ZERO) in range(10):
            del token[:]
            source = src
        else:
            source = int(output)

        char = self.next_char()

        if not output:
            how = Redirect.In
        elif char == ANGLE_CLOSE:
            how = Redirect.OutAppend
            char = self.next_char()
        else:
            how = Redirect.OutCreate

        yield from self.emit_token()

        if char != AMPERSAND:
            self.pending_redirect = RedirectIO(how, source)
            self.mode_switch(Mode.Gap)
        else:
            char = self.next_char()
            if char not in range(ZERO, NINE + 1):
                raise UnexpectedToken(char)
            self.consume_char()
            yield RedirectIO(how, source, char - ZERO)

        return True

    def fill_substitution_buffer(self):
        if (cursor := self.cursor).substituting:
            return

        code = self.code
        var_resume = -1
        var_dollar = -1
        var_cmdarg = ArgVar()
        variable = None
        phase = EV.New
        q = ArgVarFlags.StripQuotes

        for current in range((current := cursor.offset), len(code)):
            char = code[current]
            if char == LINEBREAK:
                break
            elif char == PERCENT:
                try:
                    var_name = u16(self.code[cursor.offset:current])
                    variable = u16(self.parse_env_variable(var_name))
                except MissingVariable:
                    if var_resume &lt; 0:
                        var_resume = current + 1
                    break
            elif var_cmdarg:
                if ZERO &lt;= char &lt;= NINE:
                    var_cmdarg.offset = char - ZERO
                    variable = u16(self.parse_arg_variable(var_cmdarg))
                elif char == ASTERIX and cursor.offset == current:
                    var_cmdarg.offset = (...)
                    variable = u16(self.parse_arg_variable(var_cmdarg))
            if variable is not None:
                cursor.subst_offset = 0
                cursor.subst_buffer.extend(variable)
                var_resume = current + 1
                break
            if phase == EV.Mod:
                var_cmdarg = None
            elif phase == EV.Env:
                if char == COLON:
                    if var_cmdarg:
                        assert var_dollar &gt; 0
                        var_cmdarg.path = u16(self.code[var_dollar:current])
                    var_resume = current + 1
            else:
                if char == DOLLAR:
                    var_dollar = current + 1
                    phase = EV.Env
                    continue
                if char == COLON:
                    var_cmdarg = None
                    var_resume = current + 1
                    phase = EV.Mod
                    continue
                if not var_cmdarg:
                    continue
                try:
                    var_cmdarg.flags |= ArgVarFlags.FromToken(char)
                except KeyError:
                    var_cmdarg = None
                    continue
                if q not in var_cmdarg.flags:
                    var_cmdarg = None
        if var_resume &gt;= 0:
            cursor.offset = var_resume

    @_register(Mode.Label)
    def gobble_label(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
        if (yield from self.check_line_break(mode, char)):
            return False
        self.cursor.token.append(char)
        return True

    @_register(Mode.Quote)
    def gobble_quote(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
        if (yield from self.check_line_break(mode, char)):
            return False
        self.cursor.token.append(char)
        if char == QUOTE:
            self.mode_finish()
        return True

    @_register(Mode.Whitespace)
    def gobble_whitespace(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
        if char in WHITESPACE:
            self.cursor.token.append(char)
            return True
        self.mode_finish()
        token = self.cursor.token
        yield Word(u16(token))
        del token[:]
        return False

    @_register(Mode.SetQuoted)
    def gobble_quoted_set(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
        if char == QUOTE:
            self.consume_char()
            self.cursor.token.append(QUOTE)
            self.quick_save()
            return False

        if char == LINEBREAK:
            if self.resume is None:
                yield from self.emit_token()
                self.mode_reset()
                yield Ctrl.NewLine
                return True
            elif self.caret:
                self.caret = False
                return True
            else:
                self.quick_load()
                yield from self.emit_token()
                return False

        if self.resume is not None:
            if char == CARET:
                self.caret = not self.caret
            elif not self.caret:
                if (char == PAREN_CLOSE and self.group &gt; 0) or char in (PIPE, AMPERSAND):
                    self.quick_load()
                    yield from self.emit_token()
                    self.mode_finish()
                    # after a quick load, the ending quote was already consumed.
                    return False

        self.cursor.token.append(char)
        return True

    @_register(Mode.SetStarted)
    def gobble_set(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
        token = self.cursor.token
        if (yield from self.check_line_break(mode, char)):
            return False
        if char in WHITESPACE:
            yield from self.emit_token()
            token.append(char)
            self.mode_switch(Mode.Whitespace)
            return True
        if char == SLASH and not self.pending_redirect:
            yield from self.emit_token()
            token.append(char)
            return True
        if not token and char == QUOTE:
            self.caret = False
            token.append(char)
            self.mode = Mode.SetQuoted
            return True
        if self.check_caret(char):
            return False
        if char == EQUALS:
            yield from self.emit_token()
            yield Ctrl.Equals
            self.mode = Mode.SetRegular
            return True
        if self.check_quote_start(char):
            return False
        if (yield from self.check_command_separators(char)):
            return False
        if (yield from self.check_redirect_io(char)):
            return False
        token.append(char)
        return True

    def common_token_checks(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
        return (False
            or (yield from self.check_line_break(mode, char))
            or self.check_caret(char)
            or self.check_quote_start(char)
            or (yield from self.check_command_separators(char))
            or (yield from self.check_redirect_io(char)))

    @_register(Mode.SetRegular)
    def gobble_set_regular(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
        if (yield from self.common_token_checks(mode, char)):
            return False
        if (pr := self.pending_redirect) and char in WHITESPACE:
            token = self.cursor.token
            self.pending_redirect = None
            pr.target = unquote(u16(token))
            del token[:]
            yield pr
        self.cursor.token.append(char)
        return True

    @_register(Mode.Gap)
    def gobble_gap(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
        yield from ()
        if char in SEPARATORS:
            return True
        self.mode_finish()
        self.first_after_gap = True
        return False

    @_register(Mode.Text)
    def gobble_txt(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
        if (yield from self.common_token_checks(mode, char)):
            return False
        if char in WHITESPACE:
            yield from self.emit_token()
            self.cursor.token.append(char)
            self.mode_switch(Mode.Whitespace)
            return True
        if char == SLASH and not self.pending_redirect:
            yield from self.emit_token()
        if char == COLON:
            if (yield from self.emit_token()):
                return False
            elif self.next_char() == COLON:
                yield Ctrl.Comment
                return True
            else:
                yield Ctrl.Label
                return False
        try:
            token = SeparatorMap[char]
        except KeyError:
            pass
        else:
            if (yield from self.emit_token()):
                return False
            else:
                yield token
                return True
        self.cursor.token.append(char)
        return True

    @staticmethod
    def label(text: str, uppercase=True):
        parts = re.split(&#39;([\x20\t\v])&#39;, text.lstrip())
        for k, part in itertools.islice(enumerate(parts), 0, None, 2):
            tq, part = uncaret(part, True)
            if not tq:
                parts[k] = part
                del parts[k + 1:]
                break
            parts[k] = part[:-1]
        label = &#39;&#39;.join(parts)
        if uppercase:
            label = label.upper()
        return label

    def preparse(self, text: str | buf):
        self.labels = {}

        if not isinstance(text, str):
            text = codecs.decode(text, &#39;utf8&#39;, errors=&#39;replace&#39;)

        _tail = text[-10:]
        lines = text.splitlines(keepends=False)
        utf16 = array.array(&#39;H&#39;)

        if _tail.splitlines() != F&#39;{_tail}\n&#39;.splitlines():
            # the text had a trailing line break, which is swallowed by the splitlines method
            lines.append(&#39;&#39;)

        for k, line in enumerate(lines):
            if k &gt; 0:
                utf16.append(LINEBREAK)
            encoded = line.encode(&#39;utf-16le&#39;)
            if not encoded:
                continue
            encoded = memoryview(encoded).cast(&#39;H&#39;)
            offset = len(utf16)
            prefix = re.search(&#39;^@?[\\s]*:&#39;, line)
            if prefix:
                p = prefix.end()
                if lb := self.label(u16(encoded[p:])):
                    self.labels.setdefault(lb, offset + p - 1)
            utf16.extend(encoded)

        self.text = text
        self.code = memoryview(utf16)

    if set(_register.handlers) != set(Mode):
        raise NotImplementedError(&#39;Not all handlers were implemented.&#39;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.batch.BatchLexer.labels"><code class="name">var <span class="ident">labels</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.batch.BatchLexer.code"><code class="name">var <span class="ident">code</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.batch.BatchLexer.pending_redirect"><code class="name">var <span class="ident">pending_redirect</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.batch.BatchLexer.cursor"><code class="name">var <span class="ident">cursor</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.batch.BatchLexer.resume"><code class="name">var <span class="ident">resume</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.batch.BatchLexer.label"><code class="name flex">
<span>def <span class="ident">label</span></span>(<span>text, uppercase=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L719-L732" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def label(text: str, uppercase=True):
    parts = re.split(&#39;([\x20\t\v])&#39;, text.lstrip())
    for k, part in itertools.islice(enumerate(parts), 0, None, 2):
        tq, part = uncaret(part, True)
        if not tq:
            parts[k] = part
            del parts[k + 1:]
            break
        parts[k] = part[:-1]
    label = &#39;&#39;.join(parts)
    if uppercase:
        label = label.upper()
    return label</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.batch.BatchLexer.environment"><code class="name">var <span class="ident">environment</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L165-L167" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def environment(self):
    return self.state.environment</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.modes"><code class="name">var <span class="ident">modes</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L250-L252" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def modes(self):
    return self.cursor.modes</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.mode"><code class="name">var <span class="ident">mode</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L277-L279" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def mode(self):
    return self.modes[-1]</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.substituting"><code class="name">var <span class="ident">substituting</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L285-L287" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def substituting(self):
    return self.cursor.substituting</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.eof"><code class="name">var <span class="ident">eof</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L289-L291" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eof(self):
    return (c := self.cursor).offset &gt;= len(self.code) and not c.subst_buffer</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.batch.BatchLexer.parse_group"><code class="name flex">
<span>def <span class="ident">parse_group</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L152-L153" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_group(self):
    self.group += 1</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.parse_label"><code class="name flex">
<span>def <span class="ident">parse_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L155-L158" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_label(self):
    if (m := self.mode) != Mode.Text or len(self.modes) != 1:
        raise EmulatorException(F&#39;Switching to LABEL while in mode {m.name}&#39;)
    self.mode_switch(Mode.Label)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.parse_set"><code class="name flex">
<span>def <span class="ident">parse_set</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L160-L163" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_set(self):
    if (m := self.mode) != Mode.Text or len(self.modes) != 1:
        raise EmulatorException(F&#39;Switching to SET while in mode {m.name}&#39;)
    self.mode_switch(Mode.SetStarted)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.parse_arg_variable"><code class="name flex">
<span>def <span class="ident">parse_arg_variable</span></span>(<span>self, var)</span>
</code></dt>
<dd>
<section class="desc"><p>%<em> in a batch script refers to all the arguments (e.g. %1 %2 %3
%4 %5 &hellip;)
Substitution of batch parameters (%n) has been enhanced.
You can
now use the following optional syntax:
%~1
- expands %1 removing any surrounding quotes (")
%~f1
- expands %1 to a fully qualified path name
%~d1
- expands %1 to a drive letter only
%~p1
- expands %1 to a path only
%~n1
- expands %1 to a file name only
%~x1
- expands %1 to a file extension only
%~s1
- expanded path contains short names only
%~a1
- expands %1 to file attributes
%~t1
- expands %1 to date/time of file
%~z1
- expands %1 to size of file
%~$PATH:1
- searches the directories listed in the PATH
environment variable and expands %1 to the fully
qualified name of the first one found.
If the
environment variable name is not defined or the
file is not found by the search, then this
modifier expands to the empty string
The modifiers can be combined to get compound results:
%~dp1
- expands %1 to a drive letter and path only
%~nx1
- expands %1 to a file name and extension only
%~dp$PATH:1 - searches the directories listed in the PATH
environment variable for %1 and expands to the
drive letter and path of the first one found.
%~ftza1
- expands %1 to a DIR like output line
In the above examples %1 and PATH can be replaced by other
valid values.
The %~ syntax is terminated by a valid argument
number.
The %~ modifiers may not be used with %</em></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L169-L248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_arg_variable(self, var: ArgVar):
    &#34;&#34;&#34;
    %* in a batch script refers to all the arguments (e.g. %1 %2 %3
        %4 %5 ...)
    Substitution of batch parameters (%n) has been enhanced.  You can
    now use the following optional syntax:
        %~1         - expands %1 removing any surrounding quotes (&#34;)
        %~f1        - expands %1 to a fully qualified path name
        %~d1        - expands %1 to a drive letter only
        %~p1        - expands %1 to a path only
        %~n1        - expands %1 to a file name only
        %~x1        - expands %1 to a file extension only
        %~s1        - expanded path contains short names only
        %~a1        - expands %1 to file attributes
        %~t1        - expands %1 to date/time of file
        %~z1        - expands %1 to size of file
        %~$PATH:1   - searches the directories listed in the PATH
                       environment variable and expands %1 to the fully
                       qualified name of the first one found.  If the
                       environment variable name is not defined or the
                       file is not found by the search, then this
                       modifier expands to the empty string
    The modifiers can be combined to get compound results:
        %~dp1       - expands %1 to a drive letter and path only
        %~nx1       - expands %1 to a file name and extension only
        %~dp$PATH:1 - searches the directories listed in the PATH
                       environment variable for %1 and expands to the
                       drive letter and path of the first one found.
        %~ftza1     - expands %1 to a DIR like output line
    In the above examples %1 and PATH can be replaced by other
    valid values.  The %~ syntax is terminated by a valid argument
    number.  The %~ modifiers may not be used with %*
    &#34;&#34;&#34;
    state = self.state
    flags = var.flags

    if (k := var.offset) is (...):
        return state.command_line
    if (j := k - 1) &lt; 0:
        argval = state.name
    elif j &lt; len(args := state.args):
        argval = args[j]
    else:
        return &#39;&#39;

    if not flags:
        return argval

    has_path = 0 != ArgVarFlags.FullPath &amp; flags

    if flags.StripQuotes and argval.startswith(&#39;&#34;&#39;) and argval.endswith(&#39;&#34;&#39;):
        argval = argval[1:-1]

    if flags.ShortName and not has_path:
        flags |= ArgVarFlags.FullPath
        has_path = True

    with io.StringIO() as out:
        if flags.Attributes:
            out.write(&#39;--a--------&#39;) # TODO: placeholder
        if flags.DateTime:
            dt = state.start_time.isoformat(&#39; &#39;, &#39;minutes&#39;)
            out.write(F&#39; {dt}&#39;)
        if flags.FileSize:
            out.write(F&#39; {state.sizeof_file(argval)}&#39;)
        if has_path:
            out.write(&#39; &#39;)
            full_path = state.resolve_path(argval)
            drv, rest = ntpath.splitdrive(full_path)
            *pp, name = ntpath.split(rest)
            name, ext = ntpath.splitext(name)
            if flags.DriveLetter:
                out.write(drv)
            if flags.FilePath:
                out.write(ntpath.join(*pp))
            if flags.FileName:
                out.write(name)
            if flags.FileExtension:
                out.write(ext)
        return out.getvalue().lstrip()</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L254-L263" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reset(self, offset: int):
    self.quote = False
    self.caret = False
    self.white = False
    self.first_after_gap = True
    self.group = 0
    self.cursor = BatchLexerCursor(offset)
    self.modes.append(Mode.Text)
    self.resume = None
    self.pending_redirect = None</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.mode_reset"><code class="name flex">
<span>def <span class="ident">mode_reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L265-L266" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mode_reset(self):
    del self.modes[1:]</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.mode_finish"><code class="name flex">
<span>def <span class="ident">mode_finish</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L268-L272" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mode_finish(self):
    modes = self.modes
    if len(modes) &lt;= 1:
        raise RuntimeError(&#39;Trying to exit base mode.&#39;)
    self.modes.pop()</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.mode_switch"><code class="name flex">
<span>def <span class="ident">mode_switch</span></span>(<span>self, mode)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L274-L275" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mode_switch(self, mode: Mode):
    self.modes.append(mode)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.quick_save"><code class="name flex">
<span>def <span class="ident">quick_save</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L293-L294" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def quick_save(self):
    self.resume = self.cursor.copy()</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.quick_load"><code class="name flex">
<span>def <span class="ident">quick_load</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L296-L300" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def quick_load(self):
    if (resume := self.resume) is None:
        raise RuntimeError
    self.cursor = resume
    self.resume = None</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.current_char"><code class="name flex">
<span>def <span class="ident">current_char</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L302-L320" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def current_char(self):
    cursor = self.cursor
    if not (subst := cursor.subst_buffer):
        offset = cursor.offset
        if self.code[offset] == PERCENT:
            cursor.offset += 1
            self.fill_substitution_buffer()
            return self.current_char()
    else:
        offset = cursor.subst_offset
        if offset &gt;= (n := len(subst)):
            offset -= n
            offset += cursor.offset
        else:
            return subst[offset]
    try:
        return self.code[offset]
    except IndexError:
        raise UnexpectedEOF</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.consume_char"><code class="name flex">
<span>def <span class="ident">consume_char</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L322-L335" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def consume_char(self):
    cursor = self.cursor
    if subst := cursor.subst_buffer:
        offset = cursor.subst_offset + 1
        if offset &gt;= len(subst):
            del subst[:]
            cursor.subst_offset = -1
        else:
            cursor.subst_offset = offset
    else:
        offset = cursor.offset + 1
        if offset &gt; len(self.code):
            raise EOFError(&#39;Consumed a character beyond EOF.&#39;)
        cursor.offset = offset</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.next_char"><code class="name flex">
<span>def <span class="ident">next_char</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L337-L339" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def next_char(self):
    self.consume_char()
    return self.current_char()</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.parse_env_variable"><code class="name flex">
<span>def <span class="ident">parse_env_variable</span></span>(<span>self, var)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L341-L366" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_env_variable(self, var: str):
    if var == &#39;&#39;:
        return &#39;%&#39;
    name, _, modifier = var.partition(&#39;:&#39;)
    base = self.state.envar(name)
    if not modifier or not base:
        return base
    if &#39;=&#39; in modifier:
        old, _, new = modifier.partition(&#39;=&#39;)
        kwargs = {}
        if old.startswith(&#39;~&#39;):
            old = old[1:]
            kwargs.update(count=1)
        return base.replace(old, new, **kwargs)
    else:
        if not modifier.startswith(&#39;~&#39;):
            raise EmulatorException
        offset, _, length = modifier[1:].partition(&#39;,&#39;)
        offset = batchint(offset)
        if offset &lt; 0:
            offset = max(0, len(base) + offset)
        if length:
            end = offset + batchint(length)
        else:
            end = len(base)
        return base[offset:end]</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.emit_token"><code class="name flex">
<span>def <span class="ident">emit_token</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L368-L381" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def emit_token(self):
    switched = False
    if (buffer := self.cursor.token) and (token := u16(buffer)):
        if (pr := self.pending_redirect):
            pr.target = unquote(token)
            self.pending_redirect = None
            self.mode_switch(Mode.Gap)
            yield pr
            switched = True
        else:
            yield Word(token)
    del buffer[:]
    self.first_after_gap = False
    return switched</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.tokens"><code class="name flex">
<span>def <span class="ident">tokens</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L383-L398" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tokens(self, offset: int) -&gt; Generator[Token]:
    self.reset(offset)
    handlers = self._register.handlers
    current_char = self.current_char
    consume_char = self.consume_char
    size = len(self.code)

    while not self.cursor.eof(size):
        c = current_char()
        m = self.mode
        h = handlers[m]
        if (yield from h(self, m, c)):
            consume_char()

    if not self.first_after_gap:
        yield from self.emit_token()</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.check_line_break"><code class="name flex">
<span>def <span class="ident">check_line_break</span></span>(<span>self, mode, char)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L400-L411" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check_line_break(self, mode: Mode, char: int):
    if char != LINEBREAK:
        return False
    if not self.caret:
        # caret is not reset until the next char!
        yield from self.emit_token()
        self.white = True
        self.quote = False
        self.mode_reset()
        yield Ctrl.NewLine
    self.consume_char()
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.check_caret"><code class="name flex">
<span>def <span class="ident">check_caret</span></span>(<span>self, char)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L413-L424" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check_caret(self, char: int):
    if self.caret:
        self.cursor.token.append(char)
        self.caret = False
        self.consume_char()
        return True
    elif char == CARET:
        self.caret = True
        self.consume_char()
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.check_command_separators"><code class="name flex">
<span>def <span class="ident">check_command_separators</span></span>(<span>self, char)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L426-L444" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check_command_separators(self, char: int):
    if char == PAREN_CLOSE and (g := self.group) &gt; 0:
        yield from self.emit_token()
        yield Ctrl.EndGroup
        self.mode_reset()
        self.consume_char()
        self.group = g - 1
        return True
    elif char == AMPERSAND:
        tok = Ctrl.Ampersand
    elif char == PIPE:
        tok = Ctrl.Pipe
    else:
        return False
    yield from self.emit_token()
    self.mode_reset()
    self.consume_char()
    yield tok
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.check_quote_start"><code class="name flex">
<span>def <span class="ident">check_quote_start</span></span>(<span>self, char)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L446-L453" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check_quote_start(self, char: int):
    if char != QUOTE:
        return False
    self.cursor.token.append(char)
    self.mode_switch(Mode.Quote)
    self.caret = False
    self.consume_char()
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.check_redirect_io"><code class="name flex">
<span>def <span class="ident">check_redirect_io</span></span>(<span>self, char)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L455-L490" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check_redirect_io(self, char: int):
    if char not in ANGLES:
        return False

    output = char != ANGLE_OPEN
    token = self.cursor.token

    if len(token) == 1 and (src := token[0] - ZERO) in range(10):
        del token[:]
        source = src
    else:
        source = int(output)

    char = self.next_char()

    if not output:
        how = Redirect.In
    elif char == ANGLE_CLOSE:
        how = Redirect.OutAppend
        char = self.next_char()
    else:
        how = Redirect.OutCreate

    yield from self.emit_token()

    if char != AMPERSAND:
        self.pending_redirect = RedirectIO(how, source)
        self.mode_switch(Mode.Gap)
    else:
        char = self.next_char()
        if char not in range(ZERO, NINE + 1):
            raise UnexpectedToken(char)
        self.consume_char()
        yield RedirectIO(how, source, char - ZERO)

    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.fill_substitution_buffer"><code class="name flex">
<span>def <span class="ident">fill_substitution_buffer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L492-L556" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fill_substitution_buffer(self):
    if (cursor := self.cursor).substituting:
        return

    code = self.code
    var_resume = -1
    var_dollar = -1
    var_cmdarg = ArgVar()
    variable = None
    phase = EV.New
    q = ArgVarFlags.StripQuotes

    for current in range((current := cursor.offset), len(code)):
        char = code[current]
        if char == LINEBREAK:
            break
        elif char == PERCENT:
            try:
                var_name = u16(self.code[cursor.offset:current])
                variable = u16(self.parse_env_variable(var_name))
            except MissingVariable:
                if var_resume &lt; 0:
                    var_resume = current + 1
                break
        elif var_cmdarg:
            if ZERO &lt;= char &lt;= NINE:
                var_cmdarg.offset = char - ZERO
                variable = u16(self.parse_arg_variable(var_cmdarg))
            elif char == ASTERIX and cursor.offset == current:
                var_cmdarg.offset = (...)
                variable = u16(self.parse_arg_variable(var_cmdarg))
        if variable is not None:
            cursor.subst_offset = 0
            cursor.subst_buffer.extend(variable)
            var_resume = current + 1
            break
        if phase == EV.Mod:
            var_cmdarg = None
        elif phase == EV.Env:
            if char == COLON:
                if var_cmdarg:
                    assert var_dollar &gt; 0
                    var_cmdarg.path = u16(self.code[var_dollar:current])
                var_resume = current + 1
        else:
            if char == DOLLAR:
                var_dollar = current + 1
                phase = EV.Env
                continue
            if char == COLON:
                var_cmdarg = None
                var_resume = current + 1
                phase = EV.Mod
                continue
            if not var_cmdarg:
                continue
            try:
                var_cmdarg.flags |= ArgVarFlags.FromToken(char)
            except KeyError:
                var_cmdarg = None
                continue
            if q not in var_cmdarg.flags:
                var_cmdarg = None
    if var_resume &gt;= 0:
        cursor.offset = var_resume</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.gobble_label"><code class="name flex">
<span>def <span class="ident">gobble_label</span></span>(<span>self, mode, char)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L558-L563" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_register(Mode.Label)
def gobble_label(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
    if (yield from self.check_line_break(mode, char)):
        return False
    self.cursor.token.append(char)
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.gobble_quote"><code class="name flex">
<span>def <span class="ident">gobble_quote</span></span>(<span>self, mode, char)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L565-L572" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_register(Mode.Quote)
def gobble_quote(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
    if (yield from self.check_line_break(mode, char)):
        return False
    self.cursor.token.append(char)
    if char == QUOTE:
        self.mode_finish()
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.gobble_whitespace"><code class="name flex">
<span>def <span class="ident">gobble_whitespace</span></span>(<span>self, mode, char)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L574-L583" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_register(Mode.Whitespace)
def gobble_whitespace(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
    if char in WHITESPACE:
        self.cursor.token.append(char)
        return True
    self.mode_finish()
    token = self.cursor.token
    yield Word(u16(token))
    del token[:]
    return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.gobble_quoted_set"><code class="name flex">
<span>def <span class="ident">gobble_quoted_set</span></span>(<span>self, mode, char)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L585-L619" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_register(Mode.SetQuoted)
def gobble_quoted_set(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
    if char == QUOTE:
        self.consume_char()
        self.cursor.token.append(QUOTE)
        self.quick_save()
        return False

    if char == LINEBREAK:
        if self.resume is None:
            yield from self.emit_token()
            self.mode_reset()
            yield Ctrl.NewLine
            return True
        elif self.caret:
            self.caret = False
            return True
        else:
            self.quick_load()
            yield from self.emit_token()
            return False

    if self.resume is not None:
        if char == CARET:
            self.caret = not self.caret
        elif not self.caret:
            if (char == PAREN_CLOSE and self.group &gt; 0) or char in (PIPE, AMPERSAND):
                self.quick_load()
                yield from self.emit_token()
                self.mode_finish()
                # after a quick load, the ending quote was already consumed.
                return False

    self.cursor.token.append(char)
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.gobble_set"><code class="name flex">
<span>def <span class="ident">gobble_set</span></span>(<span>self, mode, char)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L621-L654" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_register(Mode.SetStarted)
def gobble_set(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
    token = self.cursor.token
    if (yield from self.check_line_break(mode, char)):
        return False
    if char in WHITESPACE:
        yield from self.emit_token()
        token.append(char)
        self.mode_switch(Mode.Whitespace)
        return True
    if char == SLASH and not self.pending_redirect:
        yield from self.emit_token()
        token.append(char)
        return True
    if not token and char == QUOTE:
        self.caret = False
        token.append(char)
        self.mode = Mode.SetQuoted
        return True
    if self.check_caret(char):
        return False
    if char == EQUALS:
        yield from self.emit_token()
        yield Ctrl.Equals
        self.mode = Mode.SetRegular
        return True
    if self.check_quote_start(char):
        return False
    if (yield from self.check_command_separators(char)):
        return False
    if (yield from self.check_redirect_io(char)):
        return False
    token.append(char)
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.common_token_checks"><code class="name flex">
<span>def <span class="ident">common_token_checks</span></span>(<span>self, mode, char)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L656-L662" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def common_token_checks(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
    return (False
        or (yield from self.check_line_break(mode, char))
        or self.check_caret(char)
        or self.check_quote_start(char)
        or (yield from self.check_command_separators(char))
        or (yield from self.check_redirect_io(char)))</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.gobble_set_regular"><code class="name flex">
<span>def <span class="ident">gobble_set_regular</span></span>(<span>self, mode, char)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L664-L675" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_register(Mode.SetRegular)
def gobble_set_regular(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
    if (yield from self.common_token_checks(mode, char)):
        return False
    if (pr := self.pending_redirect) and char in WHITESPACE:
        token = self.cursor.token
        self.pending_redirect = None
        pr.target = unquote(u16(token))
        del token[:]
        yield pr
    self.cursor.token.append(char)
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.gobble_gap"><code class="name flex">
<span>def <span class="ident">gobble_gap</span></span>(<span>self, mode, char)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L677-L684" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_register(Mode.Gap)
def gobble_gap(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
    yield from ()
    if char in SEPARATORS:
        return True
    self.mode_finish()
    self.first_after_gap = True
    return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.gobble_txt"><code class="name flex">
<span>def <span class="ident">gobble_txt</span></span>(<span>self, mode, char)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L686-L717" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_register(Mode.Text)
def gobble_txt(self, mode: Mode, char: int) -&gt; Generator[Token, None, bool]:
    if (yield from self.common_token_checks(mode, char)):
        return False
    if char in WHITESPACE:
        yield from self.emit_token()
        self.cursor.token.append(char)
        self.mode_switch(Mode.Whitespace)
        return True
    if char == SLASH and not self.pending_redirect:
        yield from self.emit_token()
    if char == COLON:
        if (yield from self.emit_token()):
            return False
        elif self.next_char() == COLON:
            yield Ctrl.Comment
            return True
        else:
            yield Ctrl.Label
            return False
    try:
        token = SeparatorMap[char]
    except KeyError:
        pass
    else:
        if (yield from self.emit_token()):
            return False
        else:
            yield token
            return True
    self.cursor.token.append(char)
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchLexer.preparse"><code class="name flex">
<span>def <span class="ident">preparse</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/lexer.py#L734-L764" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def preparse(self, text: str | buf):
    self.labels = {}

    if not isinstance(text, str):
        text = codecs.decode(text, &#39;utf8&#39;, errors=&#39;replace&#39;)

    _tail = text[-10:]
    lines = text.splitlines(keepends=False)
    utf16 = array.array(&#39;H&#39;)

    if _tail.splitlines() != F&#39;{_tail}\n&#39;.splitlines():
        # the text had a trailing line break, which is swallowed by the splitlines method
        lines.append(&#39;&#39;)

    for k, line in enumerate(lines):
        if k &gt; 0:
            utf16.append(LINEBREAK)
        encoded = line.encode(&#39;utf-16le&#39;)
        if not encoded:
            continue
        encoded = memoryview(encoded).cast(&#39;H&#39;)
        offset = len(utf16)
        prefix = re.search(&#39;^@?[\\s]*:&#39;, line)
        if prefix:
            p = prefix.end()
            if lb := self.label(u16(encoded[p:])):
                self.labels.setdefault(lb, offset + p - 1)
        utf16.extend(encoded)

    self.text = text
    self.code = memoryview(utf16)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.batch.BatchParser"><code class="flex name class">
<span>class <span class="ident">BatchParser</span></span>
<span>(</span><span>data, state=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L144-L621" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BatchParser:

    def __init__(self, data: str | buf | BatchParser, state: BatchState | None = None):
        if isinstance(data, BatchParser):
            if state is not None:
                raise NotImplementedError
            src = data.lexer
        else:
            src = data
        self.lexer = BatchLexer(src, state)

    @property
    def state(self):
        return self.lexer.state

    @property
    def environment(self):
        return self.state.environment

    def skip_prefix(self, tokens: LookAhead) -&gt; tuple[int, list[Token]]:
        token = tokens.peek()
        prefix = []
        skip = {
            Ctrl.At,
            Ctrl.Semicolon,
            Ctrl.Comma,
            Ctrl.Equals,
        }
        at = 0
        while True:
            if isinstance(token, Word):
                if not token.isspace():
                    break
                prefix.append(token)
            elif token not in skip:
                break
            else:
                prefix.append(token)
                if token == Ctrl.At:
                    at += 1
                else:
                    at = 0
            token = tokens.drop_and_peek()
        return at, prefix

    def command(
        self,
        parent: AstNode,
        tokens: LookAhead,
        redirects: dict[int, RedirectIO],
        in_group: bool,
        silenced: bool,
    ) -&gt; AstCommand | None:
        ast = AstCommand(tokens.offset(), parent, silenced, redirects)
        tok = tokens.peek()
        cmd = ast.fragments

        eat_token = False
        add_space = False
        nsp_merge = True

        nonspace = io.StringIO()

        if not ast.redirects:
            assert not isinstance(tok, RedirectIO)
            tok_upper = tok.upper()
            if tok_upper.startswith(&#39;ECHO&#39;):
                if len(tok_upper) &gt; 4 and tok_upper[4] == &#39;.&#39;:
                    cmd.append(tok[:4])
                    cmd.append(&#39; &#39;)
                    tok = tok[5:]
                    add_space = False
                else:
                    add_space = True
                    eat_token = True
            elif tok_upper == &#39;SET&#39;:
                self.lexer.parse_set()
                nsp_merge = False
            elif tok_upper == &#39;GOTO&#39;:
                nsp_merge = False
            if add_space or not nsp_merge:
                cmd.append(tok)
            else:
                nonspace.write(tok)
            tok = tokens.drop_and_peek()

        while tok not in (
            Ctrl.Ampersand,
            Ctrl.Pipe,
            Ctrl.NewLine,
            Ctrl.EndOfFile,
        ) or not isinstance(tok, Ctrl):
            if in_group and tok == Ctrl.EndGroup:
                break
            if isinstance(tok, RedirectIO):
                ast.redirects[tok.source] = tok
            elif add_space:
                add_space = False
                if not tok.isspace():
                    cmd.append(&#39; &#39;)
                    if eat_token:
                        tok = tok[1:]
                if tok:
                    cmd.append(tok)
            elif not nsp_merge:
                cmd.append(tok)
            elif tok.isspace() or tok.startswith(&#39;/&#39;):
                if nsp := nonspace.getvalue():
                    nonspace.seek(0)
                    nonspace.truncate(0)
                    cmd.append(nsp)
                cmd.append(tok)
            else:
                nonspace.write(tok)
            tok = tokens.drop_and_peek()
        if nsp := nonspace.getvalue():
            cmd.append(nsp)
        if ast:
            return ast

    def redirects(self, tokens: LookAhead):
        redirects = {}
        while isinstance((t := tokens.peek()), RedirectIO):
            redirects[t.source] = t
            tokens.pop()
            tokens.skip_space()
        return redirects

    def pipeline(self, parent: AstNode | None, tokens: LookAhead, in_group: bool, silenced: bool) -&gt; AstPipeline | None:
        ast = AstPipeline(tokens.offset(), parent, silenced)
        while True:
            redirects = self.redirects(tokens)
            if not (cmd := self.group(ast, tokens, redirects, silenced)):
                if not (cmd := self.command(ast, tokens, redirects, in_group, silenced)):
                    break
            ast.parts.append(cmd)
            if not tokens.pop(Ctrl.Pipe) or tokens.peek() == Ctrl.Pipe:
                break
            at, _ = self.skip_prefix(tokens)
            silenced = at &gt; 0
        if ast.parts:
            return ast

    def ifthen(self, parent: AstNode | None, tokens: LookAhead, in_group: bool, silenced: bool) -&gt; AstIf | None:
        offset = tokens.offset()

        if not tokens.pop_string(&#39;IF&#39;):
            return None

        casefold = False
        negated = False
        lhs = None
        rhs = None

        token = tokens.word()

        if token.upper() == &#39;/I&#39;:
            casefold = True
            token = tokens.word()
        if token.upper() == &#39;NOT&#39;:
            negated = True
            token = tokens.word()
        try:
            variant = AstIfVariant(token.upper())
        except Exception:
            tokens.skip_space()
            variant = None
            lhs = token
            cmp = next(tokens)

            if cmp == Ctrl.Equals:
                if tokens.pop(Ctrl.Equals):
                    cmp = AstIfCmp(&#39;==&#39;)
                else:
                    raise UnexpectedToken(offset, tokens.peek())
            else:
                try:
                    cmp = AstIfCmp(cmp.upper())
                except Exception:
                    raise UnexpectedToken(offset, cmp)
                if cmp != AstIfCmp.STR and self.state.extensions_version &lt; 1:
                    raise UnexpectedToken(offset, cmp)

            rhs = tokens.consume_nonspace_words()

            try:
                ilh = batchint(lhs)
                irh = batchint(rhs)
            except ValueError:
                pass
            else:
                lhs = ilh
                rhs = irh
        else:
            lhs = unquote(tokens.consume_nonspace_words())
            rhs = None
            cmp = None
            try:
                lhs = batchint(lhs)
            except ValueError:
                pass

        then_do = self.sequence(None, tokens, in_group)

        if then_do is None:
            raise UnexpectedToken(offset, tokens.peek())

        tokens.skip_space()

        ast = AstIf(
            offset,
            parent,
            silenced,
            then_do,
            None,
            variant,
            casefold,
            negated,
            cmp,
            lhs, rhs # type:ignore
        )
        then_do.parent = ast

        if tokens.peek().upper() == &#39;ELSE&#39;:
            tokens.pop()
            ast.else_do = self.sequence(ast, tokens, in_group)

        return ast

    def forloop_options(self, options: str) -&gt; AstForOptions:
        result = AstForOptions()

        if not options:
            return result
        elif (quote := re.search(&#39;&#34;(.*?)&#34;&#39;, options)):
            options = quote[1]

        parts = options.strip().split()
        count = len(parts)

        for k, part in enumerate(parts, 1):
            key, eq, value = part.partition(&#39;=&#39;)
            key = key.lower()
            if key == &#39;usebackq&#39;:
                if eq or value:
                    raise ValueError
                result.usebackq = True
            elif not eq:
                raise ValueError
            elif key == &#39;eol&#39;:
                if len(value) != 1:
                    raise ValueError
                result.comment = value
            elif key == &#39;skip&#39;:
                try:
                    result.skip = batchint(value)
                except Exception:
                    raise ValueError
            elif key == &#39;delims&#39;:
                if k == count:
                    _, _, value = options.partition(&#39;delims=&#39;)
                result.delims = value
            elif key == &#39;tokens&#39;:
                tokens: set[int] = set()
                if value.endswith(&#39;*&#39;):
                    result.asterisk = True
                    value = value[:-1]
                    if not value:
                        result.tokens = ()
                        continue
                for x in value.split(&#39;,&#39;):
                    x, _, y = x.partition(&#39;-&#39;)
                    x = batchint(x) - 1
                    if x &lt; 0:
                        raise ValueError
                    y = batchint(y) if y else x + 1
                    for t in range(x, y):
                        tokens.add(t)
                result.tokens = tuple(sorted(tokens))
            else:
                raise ValueError

        return result

    def forloop(self, parent: AstNode | None, tokens: LookAhead, in_group: bool, silenced: bool) -&gt; AstFor | None:
        offset = tokens.offset()

        if not tokens.pop_string(&#39;FOR&#39;):
            return None

        def isvar(token: str):
            return len(token) == 2 and token.startswith(&#39;%&#39;)

        path = None
        mode = AstForParserMode.FileSet
        spec = []
        options = &#39;&#39;

        if isvar(variable := tokens.word()):
            variant = AstForVariant.Default
        elif len(variable) != 2 or not variable.startswith(&#39;/&#39;):
            raise UnexpectedToken(offset, variable)
        else:
            try:
                variant = AstForVariant(variable[1].upper())
            except ValueError:
                raise UnexpectedToken(offset, variable)
            variable = tokens.word()
            if not isvar(variable):
                if variant == AstForVariant.FileParsing:
                    options = variable
                elif variant == AstForVariant.DescendRecursively:
                    path = unquote(variable)
                else:
                    raise UnexpectedToken(offset, variable)
                variable = tokens.word()
                if not isvar(variable):
                    raise UnexpectedToken(offset, variable)

        if (t := tokens.word()).upper() != &#39;IN&#39;:
            raise UnexpectedToken(offset, t)

        tokens.skip_space()

        if not tokens.pop(Ctrl.NewGroup):
            raise UnexpectedToken(offset, tokens.peek())

        with io.StringIO() as _spec:
            while not tokens.pop(Ctrl.EndGroup):
                if isinstance((t := next(tokens)), RedirectIO):
                    raise UnexpectedToken(offset, t)
                _spec.write(t)
            spec_string = _spec.getvalue().strip()

        tokens.skip_space()

        if not tokens.pop_string(&#39;DO&#39;):
            raise UnexpectedToken(offset, tokens.peek())

        if not (body := self.sequence(None, tokens, in_group)):
            raise UnexpectedToken(offset, tokens.peek())

        options = self.forloop_options(options)

        if variant == AstForVariant.FileParsing:
            quote_literal = &#34;&#39;&#34; if options.usebackq else &#39;&#34;&#39;
            quote_command = &#39;`&#39; if options.usebackq else &#34;&#39;&#34;
            for q, m in (
                (quote_literal, AstForParserMode.Literal),
                (quote_command, AstForParserMode.Command),
            ):
                if spec_string.startswith(q):
                    if not spec_string.endswith(q):
                        raise UnexpectedToken(offset, spec_string)
                    mode = m
                    spec = [spec_string[1:-1]]
                    break

        if not spec:
            spec = re.split(&#39;[\\s,;]+&#39;, spec_string)

        if variant == AstForVariant.NumericLoop:
            init = [0, 0, 0]
            for k, v in enumerate(spec):
                init[k] = batchint(v, 0)
            spec = batchrange(*init)

        ast = AstFor(
            offset,
            parent,
            silenced,
            variant,
            variable[1],
            options,
            body,
            spec,
            spec_string,
            path,
            mode,
        )
        ast.body.parent = ast
        return ast

    def block(self, parent: AstNode | None, tokens: LookAhead, in_group: bool):
        while True:
            while tokens.pop(Ctrl.NewLine):
                continue
            if in_group and tokens.pop(Ctrl.EndGroup):
                break
            if tokens.pop(Ctrl.EndOfFile):
                break
            if sequence := self.sequence(parent, tokens, in_group):
                yield sequence
            else:
                break

    def group(
        self,
        parent: AstNode | None,
        tokens: LookAhead,
        redirects: dict[int, RedirectIO],
        silenced: bool,
    ) -&gt; AstGroup | None:
        offset = tokens.offset()
        if tokens.peek() == Ctrl.NewGroup:
            self.lexer.parse_group()
            tokens.pop()
            group = AstGroup(offset, parent, silenced, redirects)
            group.fragments.extend(self.block(group, tokens, True))
            tokens.skip_space()
            group.redirects.update(self.redirects(tokens))
            return group

    def label(self, tokens: LookAhead, silenced: bool) -&gt; AstLabel | None:
        comment = False
        if (t := tokens.peek()) == Ctrl.Comment:
            comment = True
        elif t != Ctrl.Label:
            return None
        offset = tokens.offset()
        lexer = self.lexer
        lexer.parse_label()
        tokens.pop()
        line = tokens.word()
        if comment:
            label = line
        else:
            label = lexer.label(line, uppercase=False)
            if (x := lexer.labels[label.upper()]) != offset - 1:
                raise RuntimeError(F&#39;Expected offset for label {label} to be {offset}, got {x} instead.&#39;)
        return AstLabel(offset, None, silenced, line, label, comment)

    def statement(self, parent: AstNode | None, tokens: LookAhead, in_group: bool):
        at, _ = self.skip_prefix(tokens)
        silenced = at &gt; 0
        if at &lt;= 1 and (s := self.label(tokens, silenced)):
            return s
        if s := self.ifthen(parent, tokens, in_group, silenced):
            return s
        if s := self.forloop(parent, tokens, in_group, silenced):
            return s
        return self.pipeline(parent, tokens, in_group, silenced)

    def sequence(self, parent: AstNode | None, tokens: LookAhead, in_group: bool) -&gt; AstSequence | None:
        tokens.skip_space()
        head = self.statement(parent, tokens, in_group)
        if head is None:
            return None
        node = AstSequence(head.offset, parent, head)
        head.parent = node
        tokens.skip_space()
        while True:
            if tokens.pop(Ctrl.Ampersand):
                if tokens.pop(Ctrl.Ampersand):
                    condition = AstCondition.Success
                else:
                    condition = AstCondition.NoCheck
            elif tokens.pop(Ctrl.Pipe):
                condition = AstCondition.Failure
            else:
                break
            tokens.skip_space()
            if not (statement := self.statement(node, tokens, in_group)):
                raise EmulatorException(&#39;Failed to parse conditional statement.&#39;)
            node.tail.append(
                AstConditionalStatement(statement.offset, node, condition, statement))
            tokens.skip_space()
        return node

    def parse(self, offset: int):
        tokens = LookAhead(self.lexer, offset)
        while True:
            try:
                yield from self.block(None, tokens, False)
            except UnexpectedToken as ut:
                yield AstError(ut.offset, None, ut.token, ut.error)
            else:
                break</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.batch.BatchParser.state"><code class="name">var <span class="ident">state</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L155-L157" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def state(self):
    return self.lexer.state</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchParser.environment"><code class="name">var <span class="ident">environment</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L159-L161" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def environment(self):
    return self.state.environment</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.batch.BatchParser.skip_prefix"><code class="name flex">
<span>def <span class="ident">skip_prefix</span></span>(<span>self, tokens)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L163-L187" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def skip_prefix(self, tokens: LookAhead) -&gt; tuple[int, list[Token]]:
    token = tokens.peek()
    prefix = []
    skip = {
        Ctrl.At,
        Ctrl.Semicolon,
        Ctrl.Comma,
        Ctrl.Equals,
    }
    at = 0
    while True:
        if isinstance(token, Word):
            if not token.isspace():
                break
            prefix.append(token)
        elif token not in skip:
            break
        else:
            prefix.append(token)
            if token == Ctrl.At:
                at += 1
            else:
                at = 0
        token = tokens.drop_and_peek()
    return at, prefix</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchParser.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self, parent, tokens, redirects, in_group, silenced)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L189-L262" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def command(
    self,
    parent: AstNode,
    tokens: LookAhead,
    redirects: dict[int, RedirectIO],
    in_group: bool,
    silenced: bool,
) -&gt; AstCommand | None:
    ast = AstCommand(tokens.offset(), parent, silenced, redirects)
    tok = tokens.peek()
    cmd = ast.fragments

    eat_token = False
    add_space = False
    nsp_merge = True

    nonspace = io.StringIO()

    if not ast.redirects:
        assert not isinstance(tok, RedirectIO)
        tok_upper = tok.upper()
        if tok_upper.startswith(&#39;ECHO&#39;):
            if len(tok_upper) &gt; 4 and tok_upper[4] == &#39;.&#39;:
                cmd.append(tok[:4])
                cmd.append(&#39; &#39;)
                tok = tok[5:]
                add_space = False
            else:
                add_space = True
                eat_token = True
        elif tok_upper == &#39;SET&#39;:
            self.lexer.parse_set()
            nsp_merge = False
        elif tok_upper == &#39;GOTO&#39;:
            nsp_merge = False
        if add_space or not nsp_merge:
            cmd.append(tok)
        else:
            nonspace.write(tok)
        tok = tokens.drop_and_peek()

    while tok not in (
        Ctrl.Ampersand,
        Ctrl.Pipe,
        Ctrl.NewLine,
        Ctrl.EndOfFile,
    ) or not isinstance(tok, Ctrl):
        if in_group and tok == Ctrl.EndGroup:
            break
        if isinstance(tok, RedirectIO):
            ast.redirects[tok.source] = tok
        elif add_space:
            add_space = False
            if not tok.isspace():
                cmd.append(&#39; &#39;)
                if eat_token:
                    tok = tok[1:]
            if tok:
                cmd.append(tok)
        elif not nsp_merge:
            cmd.append(tok)
        elif tok.isspace() or tok.startswith(&#39;/&#39;):
            if nsp := nonspace.getvalue():
                nonspace.seek(0)
                nonspace.truncate(0)
                cmd.append(nsp)
            cmd.append(tok)
        else:
            nonspace.write(tok)
        tok = tokens.drop_and_peek()
    if nsp := nonspace.getvalue():
        cmd.append(nsp)
    if ast:
        return ast</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchParser.redirects"><code class="name flex">
<span>def <span class="ident">redirects</span></span>(<span>self, tokens)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L264-L270" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def redirects(self, tokens: LookAhead):
    redirects = {}
    while isinstance((t := tokens.peek()), RedirectIO):
        redirects[t.source] = t
        tokens.pop()
        tokens.skip_space()
    return redirects</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchParser.pipeline"><code class="name flex">
<span>def <span class="ident">pipeline</span></span>(<span>self, parent, tokens, in_group, silenced)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L272-L285" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pipeline(self, parent: AstNode | None, tokens: LookAhead, in_group: bool, silenced: bool) -&gt; AstPipeline | None:
    ast = AstPipeline(tokens.offset(), parent, silenced)
    while True:
        redirects = self.redirects(tokens)
        if not (cmd := self.group(ast, tokens, redirects, silenced)):
            if not (cmd := self.command(ast, tokens, redirects, in_group, silenced)):
                break
        ast.parts.append(cmd)
        if not tokens.pop(Ctrl.Pipe) or tokens.peek() == Ctrl.Pipe:
            break
        at, _ = self.skip_prefix(tokens)
        silenced = at &gt; 0
    if ast.parts:
        return ast</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchParser.ifthen"><code class="name flex">
<span>def <span class="ident">ifthen</span></span>(<span>self, parent, tokens, in_group, silenced)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L287-L371" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ifthen(self, parent: AstNode | None, tokens: LookAhead, in_group: bool, silenced: bool) -&gt; AstIf | None:
    offset = tokens.offset()

    if not tokens.pop_string(&#39;IF&#39;):
        return None

    casefold = False
    negated = False
    lhs = None
    rhs = None

    token = tokens.word()

    if token.upper() == &#39;/I&#39;:
        casefold = True
        token = tokens.word()
    if token.upper() == &#39;NOT&#39;:
        negated = True
        token = tokens.word()
    try:
        variant = AstIfVariant(token.upper())
    except Exception:
        tokens.skip_space()
        variant = None
        lhs = token
        cmp = next(tokens)

        if cmp == Ctrl.Equals:
            if tokens.pop(Ctrl.Equals):
                cmp = AstIfCmp(&#39;==&#39;)
            else:
                raise UnexpectedToken(offset, tokens.peek())
        else:
            try:
                cmp = AstIfCmp(cmp.upper())
            except Exception:
                raise UnexpectedToken(offset, cmp)
            if cmp != AstIfCmp.STR and self.state.extensions_version &lt; 1:
                raise UnexpectedToken(offset, cmp)

        rhs = tokens.consume_nonspace_words()

        try:
            ilh = batchint(lhs)
            irh = batchint(rhs)
        except ValueError:
            pass
        else:
            lhs = ilh
            rhs = irh
    else:
        lhs = unquote(tokens.consume_nonspace_words())
        rhs = None
        cmp = None
        try:
            lhs = batchint(lhs)
        except ValueError:
            pass

    then_do = self.sequence(None, tokens, in_group)

    if then_do is None:
        raise UnexpectedToken(offset, tokens.peek())

    tokens.skip_space()

    ast = AstIf(
        offset,
        parent,
        silenced,
        then_do,
        None,
        variant,
        casefold,
        negated,
        cmp,
        lhs, rhs # type:ignore
    )
    then_do.parent = ast

    if tokens.peek().upper() == &#39;ELSE&#39;:
        tokens.pop()
        ast.else_do = self.sequence(ast, tokens, in_group)

    return ast</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchParser.forloop_options"><code class="name flex">
<span>def <span class="ident">forloop_options</span></span>(<span>self, options)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L373-L426" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def forloop_options(self, options: str) -&gt; AstForOptions:
    result = AstForOptions()

    if not options:
        return result
    elif (quote := re.search(&#39;&#34;(.*?)&#34;&#39;, options)):
        options = quote[1]

    parts = options.strip().split()
    count = len(parts)

    for k, part in enumerate(parts, 1):
        key, eq, value = part.partition(&#39;=&#39;)
        key = key.lower()
        if key == &#39;usebackq&#39;:
            if eq or value:
                raise ValueError
            result.usebackq = True
        elif not eq:
            raise ValueError
        elif key == &#39;eol&#39;:
            if len(value) != 1:
                raise ValueError
            result.comment = value
        elif key == &#39;skip&#39;:
            try:
                result.skip = batchint(value)
            except Exception:
                raise ValueError
        elif key == &#39;delims&#39;:
            if k == count:
                _, _, value = options.partition(&#39;delims=&#39;)
            result.delims = value
        elif key == &#39;tokens&#39;:
            tokens: set[int] = set()
            if value.endswith(&#39;*&#39;):
                result.asterisk = True
                value = value[:-1]
                if not value:
                    result.tokens = ()
                    continue
            for x in value.split(&#39;,&#39;):
                x, _, y = x.partition(&#39;-&#39;)
                x = batchint(x) - 1
                if x &lt; 0:
                    raise ValueError
                y = batchint(y) if y else x + 1
                for t in range(x, y):
                    tokens.add(t)
            result.tokens = tuple(sorted(tokens))
        else:
            raise ValueError

    return result</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchParser.forloop"><code class="name flex">
<span>def <span class="ident">forloop</span></span>(<span>self, parent, tokens, in_group, silenced)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L428-L525" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def forloop(self, parent: AstNode | None, tokens: LookAhead, in_group: bool, silenced: bool) -&gt; AstFor | None:
    offset = tokens.offset()

    if not tokens.pop_string(&#39;FOR&#39;):
        return None

    def isvar(token: str):
        return len(token) == 2 and token.startswith(&#39;%&#39;)

    path = None
    mode = AstForParserMode.FileSet
    spec = []
    options = &#39;&#39;

    if isvar(variable := tokens.word()):
        variant = AstForVariant.Default
    elif len(variable) != 2 or not variable.startswith(&#39;/&#39;):
        raise UnexpectedToken(offset, variable)
    else:
        try:
            variant = AstForVariant(variable[1].upper())
        except ValueError:
            raise UnexpectedToken(offset, variable)
        variable = tokens.word()
        if not isvar(variable):
            if variant == AstForVariant.FileParsing:
                options = variable
            elif variant == AstForVariant.DescendRecursively:
                path = unquote(variable)
            else:
                raise UnexpectedToken(offset, variable)
            variable = tokens.word()
            if not isvar(variable):
                raise UnexpectedToken(offset, variable)

    if (t := tokens.word()).upper() != &#39;IN&#39;:
        raise UnexpectedToken(offset, t)

    tokens.skip_space()

    if not tokens.pop(Ctrl.NewGroup):
        raise UnexpectedToken(offset, tokens.peek())

    with io.StringIO() as _spec:
        while not tokens.pop(Ctrl.EndGroup):
            if isinstance((t := next(tokens)), RedirectIO):
                raise UnexpectedToken(offset, t)
            _spec.write(t)
        spec_string = _spec.getvalue().strip()

    tokens.skip_space()

    if not tokens.pop_string(&#39;DO&#39;):
        raise UnexpectedToken(offset, tokens.peek())

    if not (body := self.sequence(None, tokens, in_group)):
        raise UnexpectedToken(offset, tokens.peek())

    options = self.forloop_options(options)

    if variant == AstForVariant.FileParsing:
        quote_literal = &#34;&#39;&#34; if options.usebackq else &#39;&#34;&#39;
        quote_command = &#39;`&#39; if options.usebackq else &#34;&#39;&#34;
        for q, m in (
            (quote_literal, AstForParserMode.Literal),
            (quote_command, AstForParserMode.Command),
        ):
            if spec_string.startswith(q):
                if not spec_string.endswith(q):
                    raise UnexpectedToken(offset, spec_string)
                mode = m
                spec = [spec_string[1:-1]]
                break

    if not spec:
        spec = re.split(&#39;[\\s,;]+&#39;, spec_string)

    if variant == AstForVariant.NumericLoop:
        init = [0, 0, 0]
        for k, v in enumerate(spec):
            init[k] = batchint(v, 0)
        spec = batchrange(*init)

    ast = AstFor(
        offset,
        parent,
        silenced,
        variant,
        variable[1],
        options,
        body,
        spec,
        spec_string,
        path,
        mode,
    )
    ast.body.parent = ast
    return ast</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchParser.block"><code class="name flex">
<span>def <span class="ident">block</span></span>(<span>self, parent, tokens, in_group)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L527-L538" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def block(self, parent: AstNode | None, tokens: LookAhead, in_group: bool):
    while True:
        while tokens.pop(Ctrl.NewLine):
            continue
        if in_group and tokens.pop(Ctrl.EndGroup):
            break
        if tokens.pop(Ctrl.EndOfFile):
            break
        if sequence := self.sequence(parent, tokens, in_group):
            yield sequence
        else:
            break</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchParser.group"><code class="name flex">
<span>def <span class="ident">group</span></span>(<span>self, parent, tokens, redirects, silenced)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L540-L555" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def group(
    self,
    parent: AstNode | None,
    tokens: LookAhead,
    redirects: dict[int, RedirectIO],
    silenced: bool,
) -&gt; AstGroup | None:
    offset = tokens.offset()
    if tokens.peek() == Ctrl.NewGroup:
        self.lexer.parse_group()
        tokens.pop()
        group = AstGroup(offset, parent, silenced, redirects)
        group.fragments.extend(self.block(group, tokens, True))
        tokens.skip_space()
        group.redirects.update(self.redirects(tokens))
        return group</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchParser.label"><code class="name flex">
<span>def <span class="ident">label</span></span>(<span>self, tokens, silenced)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L557-L574" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def label(self, tokens: LookAhead, silenced: bool) -&gt; AstLabel | None:
    comment = False
    if (t := tokens.peek()) == Ctrl.Comment:
        comment = True
    elif t != Ctrl.Label:
        return None
    offset = tokens.offset()
    lexer = self.lexer
    lexer.parse_label()
    tokens.pop()
    line = tokens.word()
    if comment:
        label = line
    else:
        label = lexer.label(line, uppercase=False)
        if (x := lexer.labels[label.upper()]) != offset - 1:
            raise RuntimeError(F&#39;Expected offset for label {label} to be {offset}, got {x} instead.&#39;)
    return AstLabel(offset, None, silenced, line, label, comment)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchParser.statement"><code class="name flex">
<span>def <span class="ident">statement</span></span>(<span>self, parent, tokens, in_group)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L576-L585" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def statement(self, parent: AstNode | None, tokens: LookAhead, in_group: bool):
    at, _ = self.skip_prefix(tokens)
    silenced = at &gt; 0
    if at &lt;= 1 and (s := self.label(tokens, silenced)):
        return s
    if s := self.ifthen(parent, tokens, in_group, silenced):
        return s
    if s := self.forloop(parent, tokens, in_group, silenced):
        return s
    return self.pipeline(parent, tokens, in_group, silenced)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchParser.sequence"><code class="name flex">
<span>def <span class="ident">sequence</span></span>(<span>self, parent, tokens, in_group)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L587-L611" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sequence(self, parent: AstNode | None, tokens: LookAhead, in_group: bool) -&gt; AstSequence | None:
    tokens.skip_space()
    head = self.statement(parent, tokens, in_group)
    if head is None:
        return None
    node = AstSequence(head.offset, parent, head)
    head.parent = node
    tokens.skip_space()
    while True:
        if tokens.pop(Ctrl.Ampersand):
            if tokens.pop(Ctrl.Ampersand):
                condition = AstCondition.Success
            else:
                condition = AstCondition.NoCheck
        elif tokens.pop(Ctrl.Pipe):
            condition = AstCondition.Failure
        else:
            break
        tokens.skip_space()
        if not (statement := self.statement(node, tokens, in_group)):
            raise EmulatorException(&#39;Failed to parse conditional statement.&#39;)
        node.tail.append(
            AstConditionalStatement(statement.offset, node, condition, statement))
        tokens.skip_space()
    return node</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchParser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/parser.py#L613-L621" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse(self, offset: int):
    tokens = LookAhead(self.lexer, offset)
    while True:
        try:
            yield from self.block(None, tokens, False)
        except UnexpectedToken as ut:
            yield AstError(ut.offset, None, ut.token, ut.error)
        else:
            break</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.batch.BatchState"><code class="flex name class">
<span>class <span class="ident">BatchState</span></span>
<span>(</span><span>delayexpand=False, extensions_enabled=True, extensions_version=2, environment=None, file_system=None, username='Administrator', hostname=None, now=None, cwd='C:\\', filename='', echo=True, codec='cp1252')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L79-L274" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BatchState:

    name: str
    args: list[str]

    now: datetime
    start_time: datetime

    environment_stack: list[dict[str, str | RetainVariable]]
    delayexpand_stack: list[bool]
    cmdextended_stack: list[bool]

    _for_loops: list[dict[str, str]]
    file_system: dict[str, str]

    def __init__(
        self,
        delayexpand: bool = False,
        extensions_enabled: bool = True,
        extensions_version: int = 2,
        environment: dict | None = None,
        file_system: dict | None = None,
        username: str = &#39;Administrator&#39;,
        hostname: str | None = None,
        now: int | float | str | datetime | None = None,
        cwd: str = &#39;C:\\&#39;,
        filename: str | None = &#39;&#39;,
        echo: bool = True,
        codec: str = &#39;cp1252&#39;,
    ):
        self.extensions_version = extensions_version
        file_system = file_system or {}
        environment = environment or {}
        if hostname is None:
            hostname = str(uuid4())
        for key, value in _DEFAULT_ENVIRONMENT.items():
            environment.setdefault(
                key.upper(),
                value.format(h=hostname, u=username)
            )
        if isinstance(now, str):
            now = isodate(now)
        if isinstance(now, (int, float)):
            now = date_from_timestamp(now)
        if now is None:
            now = datetime.now()
        self.cwd = cwd
        self.now = now
        self.start_time = now
        seed(self.now.timestamp())
        self.hostname = hostname
        self.username = username
        self.labels = {}
        self._for_loops = []
        self.environment_stack = [environment]
        self.delayexpand_stack = [delayexpand]
        self.cmdextended_stack = [extensions_enabled]
        self.file_system = file_system
        self.dirstack = []
        self.linebreaks = []
        self.name = filename or F&#39;{uuid4()}.bat&#39;
        self.args = []
        self._cmd = &#39;&#39;
        self.ec = None
        self.echo = echo
        self.codec = codec

    @property
    def cwd(self):
        return self._cwd

    @cwd.setter
    def cwd(self, new: str):
        new = new.replace(&#39;/&#39;, &#39;\\&#39;)
        if not new.endswith(&#39;\\&#39;):
            new = F&#39;{new}\\&#39;
        if not ntpath.isabs(new):
            new = ntpath.join(self.cwd, new)
        if not ntpath.isabs(new):
            raise ValueError(F&#39;Invalid absolute path: {new}&#39;)
        self._cwd = ntpath.normcase(ntpath.normpath(new))

    @property
    def ec(self) -&gt; int | ErrorZero:
        return self.errorlevel

    @ec.setter
    def ec(self, value: int | ErrorZero | None):
        ec = value or 0
        self.environment[&#39;ERRORLEVEL&#39;] = str(ec)
        self.errorlevel = ec

    @property
    def command_line(self):
        return self._cmd

    @command_line.setter
    def command_line(self, value: str):
        self._cmd = value
        self.args = value.split()

    def envar(self, name: str, default: str | None = None) -&gt; str | RetainVariable:
        name = name.upper()
        if name in (e := self.environment):
            return e[name]
        elif name == &#39;DATE&#39;:
            return self.now.strftime(&#39;%Y-%m-%d&#39;)
        elif name == &#39;TIME&#39;:
            time = self.now.strftime(&#39;%M:%S,%f&#39;)
            return F&#39;{self.now.hour:2d}:{time:.8}&#39;
        elif name == &#39;RANDOM&#39;:
            return str(randrange(0, 32767))
        elif name == &#39;ERRORLEVEL&#39;:
            return str(self.ec)
        elif name == &#39;CD&#39;:
            return self.cwd
        elif name == &#39;CMDCMDLINE&#39;:
            line = self.envar(&#39;COMSPEC&#39;, &#39;cmd.exe&#39;)
            if args := self.args:
                args = &#39; &#39;.join(args)
                line = F&#39;{line} /c &#34;{args}&#34;&#39;
            return line
        elif name == &#39;CMDEXTVERSION&#39;:
            return str(self.extensions_version)
        elif name == &#39;HIGHESTNUMANODENUMBER&#39;:
            return &#39;0&#39;
        elif default is not None:
            return default
        else:
            raise MissingVariable

    def resolve_path(self, path: str) -&gt; str:
        if not ntpath.isabs(path):
            path = F&#39;{self.cwd}{path}&#39;
        return ntpath.normcase(ntpath.normpath(path))

    def create_file(self, path: str, data: str = &#39;&#39;):
        self.file_system[self.resolve_path(path)] = data

    def append_file(self, path: str, data: str):
        path = self.resolve_path(path)
        if left := self.file_system.get(path, None):
            data = F&#39;{left}{data}&#39;
        self.file_system[path] = data

    def remove_file(self, path: str):
        self.file_system.pop(self.resolve_path(path), None)

    def ingest_file(self, path: str) -&gt; str | None:
        return self.file_system.get(self.resolve_path(path))

    def exists_file(self, path: str) -&gt; bool:
        return self.resolve_path(path) in self.file_system

    def sizeof_file(self, path: str) -&gt; int:
        if data := self.ingest_file(path):
            return len(data)
        return -1

    def new_forloop(self) -&gt; dict[str, str]:
        new = {}
        old = self.for_loop_variables
        if old is not None:
            new.update(old)
        self._for_loops.append(new)
        return new

    def end_forloop(self):
        self._for_loops.pop()

    @property
    def environment(self):
        return self.environment_stack[-1]

    @property
    def delayexpand(self):
        return self.delayexpand_stack[-1]

    @delayexpand.setter
    def delayexpand(self, v):
        self.delayexpand_stack[-1] = v

    @property
    def cmdextended(self):
        return self.cmdextended_stack[-1]

    @cmdextended.setter
    def cmdextended(self, v):
        self.cmdextended_stack[-1] = v

    @property
    def for_loop_variables(self):
        if vars := self._for_loops:
            return vars[-1]
        else:
            return None</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.batch.BatchState.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.batch.BatchState.args"><code class="name">var <span class="ident">args</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.batch.BatchState.now"><code class="name">var <span class="ident">now</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.batch.BatchState.start_time"><code class="name">var <span class="ident">start_time</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.batch.BatchState.environment_stack"><code class="name">var <span class="ident">environment_stack</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.batch.BatchState.delayexpand_stack"><code class="name">var <span class="ident">delayexpand_stack</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.batch.BatchState.cmdextended_stack"><code class="name">var <span class="ident">cmdextended_stack</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.batch.BatchState.file_system"><code class="name">var <span class="ident">file_system</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.batch.BatchState.cwd"><code class="name">var <span class="ident">cwd</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L146-L148" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def cwd(self):
    return self._cwd</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.ec"><code class="name">var <span class="ident">ec</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L161-L163" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def ec(self) -&gt; int | ErrorZero:
    return self.errorlevel</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.command_line"><code class="name">var <span class="ident">command_line</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L171-L173" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def command_line(self):
    return self._cmd</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.environment"><code class="name">var <span class="ident">environment</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L249-L251" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def environment(self):
    return self.environment_stack[-1]</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.delayexpand"><code class="name">var <span class="ident">delayexpand</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L253-L255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def delayexpand(self):
    return self.delayexpand_stack[-1]</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.cmdextended"><code class="name">var <span class="ident">cmdextended</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L261-L263" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def cmdextended(self):
    return self.cmdextended_stack[-1]</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.for_loop_variables"><code class="name">var <span class="ident">for_loop_variables</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L269-L274" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def for_loop_variables(self):
    if vars := self._for_loops:
        return vars[-1]
    else:
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.batch.BatchState.envar"><code class="name flex">
<span>def <span class="ident">envar</span></span>(<span>self, name, default=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L180-L208" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def envar(self, name: str, default: str | None = None) -&gt; str | RetainVariable:
    name = name.upper()
    if name in (e := self.environment):
        return e[name]
    elif name == &#39;DATE&#39;:
        return self.now.strftime(&#39;%Y-%m-%d&#39;)
    elif name == &#39;TIME&#39;:
        time = self.now.strftime(&#39;%M:%S,%f&#39;)
        return F&#39;{self.now.hour:2d}:{time:.8}&#39;
    elif name == &#39;RANDOM&#39;:
        return str(randrange(0, 32767))
    elif name == &#39;ERRORLEVEL&#39;:
        return str(self.ec)
    elif name == &#39;CD&#39;:
        return self.cwd
    elif name == &#39;CMDCMDLINE&#39;:
        line = self.envar(&#39;COMSPEC&#39;, &#39;cmd.exe&#39;)
        if args := self.args:
            args = &#39; &#39;.join(args)
            line = F&#39;{line} /c &#34;{args}&#34;&#39;
        return line
    elif name == &#39;CMDEXTVERSION&#39;:
        return str(self.extensions_version)
    elif name == &#39;HIGHESTNUMANODENUMBER&#39;:
        return &#39;0&#39;
    elif default is not None:
        return default
    else:
        raise MissingVariable</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.resolve_path"><code class="name flex">
<span>def <span class="ident">resolve_path</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L210-L213" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resolve_path(self, path: str) -&gt; str:
    if not ntpath.isabs(path):
        path = F&#39;{self.cwd}{path}&#39;
    return ntpath.normcase(ntpath.normpath(path))</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.create_file"><code class="name flex">
<span>def <span class="ident">create_file</span></span>(<span>self, path, data='')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L215-L216" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def create_file(self, path: str, data: str = &#39;&#39;):
    self.file_system[self.resolve_path(path)] = data</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.append_file"><code class="name flex">
<span>def <span class="ident">append_file</span></span>(<span>self, path, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L218-L222" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def append_file(self, path: str, data: str):
    path = self.resolve_path(path)
    if left := self.file_system.get(path, None):
        data = F&#39;{left}{data}&#39;
    self.file_system[path] = data</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.remove_file"><code class="name flex">
<span>def <span class="ident">remove_file</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L224-L225" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def remove_file(self, path: str):
    self.file_system.pop(self.resolve_path(path), None)</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.ingest_file"><code class="name flex">
<span>def <span class="ident">ingest_file</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L227-L228" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ingest_file(self, path: str) -&gt; str | None:
    return self.file_system.get(self.resolve_path(path))</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.exists_file"><code class="name flex">
<span>def <span class="ident">exists_file</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L230-L231" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def exists_file(self, path: str) -&gt; bool:
    return self.resolve_path(path) in self.file_system</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.sizeof_file"><code class="name flex">
<span>def <span class="ident">sizeof_file</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L233-L236" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sizeof_file(self, path: str) -&gt; int:
    if data := self.ingest_file(path):
        return len(data)
    return -1</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.new_forloop"><code class="name flex">
<span>def <span class="ident">new_forloop</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L238-L244" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def new_forloop(self) -&gt; dict[str, str]:
    new = {}
    old = self.for_loop_variables
    if old is not None:
        new.update(old)
    self._for_loops.append(new)
    return new</code></pre>
</details>
</dd>
<dt id="refinery.lib.batch.BatchState.end_forloop"><code class="name flex">
<span>def <span class="ident">end_forloop</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/batch/state.py#L246-L247" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def end_forloop(self):
    self._for_loops.pop()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#set-statement">Set Statement</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="../index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="refinery.lib.batch.const" href="const.html">refinery.lib.batch.const</a></code></li>
<li><code><a title="refinery.lib.batch.emulator" href="emulator.html">refinery.lib.batch.emulator</a></code></li>
<li><code><a title="refinery.lib.batch.help" href="help.html">refinery.lib.batch.help</a></code></li>
<li><code><a title="refinery.lib.batch.lexer" href="lexer.html">refinery.lib.batch.lexer</a></code></li>
<li><code><a title="refinery.lib.batch.model" href="model.html">refinery.lib.batch.model</a></code></li>
<li><code><a title="refinery.lib.batch.parser" href="parser.html">refinery.lib.batch.parser</a></code></li>
<li><code><a title="refinery.lib.batch.state" href="state.html">refinery.lib.batch.state</a></code></li>
<li><code><a title="refinery.lib.batch.synth" href="synth.html">refinery.lib.batch.synth</a></code></li>
<li><code><a title="refinery.lib.batch.util" href="util.html">refinery.lib.batch.util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.batch.BatchEmulator" href="#refinery.lib.batch.BatchEmulator">BatchEmulator</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.batch.BatchEmulator.spawn" href="#refinery.lib.batch.BatchEmulator.spawn">spawn</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.clone_state" href="#refinery.lib.batch.BatchEmulator.clone_state">clone_state</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.get_for_variable_regex" href="#refinery.lib.batch.BatchEmulator.get_for_variable_regex">get_for_variable_regex</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.expand_delayed_variables" href="#refinery.lib.batch.BatchEmulator.expand_delayed_variables">expand_delayed_variables</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.expand_forloop_variables" href="#refinery.lib.batch.BatchEmulator.expand_forloop_variables">expand_forloop_variables</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.contains_for_variable" href="#refinery.lib.batch.BatchEmulator.contains_for_variable">contains_for_variable</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.expand_ast_node" href="#refinery.lib.batch.BatchEmulator.expand_ast_node">expand_ast_node</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_find_or_findstr" href="#refinery.lib.batch.BatchEmulator.execute_find_or_findstr">execute_find_or_findstr</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_type" href="#refinery.lib.batch.BatchEmulator.execute_type">execute_type</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_find" href="#refinery.lib.batch.BatchEmulator.execute_find">execute_find</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_findstr" href="#refinery.lib.batch.BatchEmulator.execute_findstr">execute_findstr</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_set" href="#refinery.lib.batch.BatchEmulator.execute_set">execute_set</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_call" href="#refinery.lib.batch.BatchEmulator.execute_call">execute_call</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_setlocal" href="#refinery.lib.batch.BatchEmulator.execute_setlocal">execute_setlocal</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_endlocal" href="#refinery.lib.batch.BatchEmulator.execute_endlocal">execute_endlocal</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_goto" href="#refinery.lib.batch.BatchEmulator.execute_goto">execute_goto</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_exit" href="#refinery.lib.batch.BatchEmulator.execute_exit">execute_exit</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_chdir" href="#refinery.lib.batch.BatchEmulator.execute_chdir">execute_chdir</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_pushd" href="#refinery.lib.batch.BatchEmulator.execute_pushd">execute_pushd</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_popd" href="#refinery.lib.batch.BatchEmulator.execute_popd">execute_popd</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_echo" href="#refinery.lib.batch.BatchEmulator.execute_echo">execute_echo</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_cls" href="#refinery.lib.batch.BatchEmulator.execute_cls">execute_cls</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_del" href="#refinery.lib.batch.BatchEmulator.execute_del">execute_del</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_start" href="#refinery.lib.batch.BatchEmulator.execute_start">execute_start</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_cmd" href="#refinery.lib.batch.BatchEmulator.execute_cmd">execute_cmd</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_unimplemented_program" href="#refinery.lib.batch.BatchEmulator.execute_unimplemented_program">execute_unimplemented_program</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_unimplemented_command_unmodified_ec" href="#refinery.lib.batch.BatchEmulator.execute_unimplemented_command_unmodified_ec">execute_unimplemented_command_unmodified_ec</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_unimplemented_command" href="#refinery.lib.batch.BatchEmulator.execute_unimplemented_command">execute_unimplemented_command</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_rem" href="#refinery.lib.batch.BatchEmulator.execute_rem">execute_rem</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_help" href="#refinery.lib.batch.BatchEmulator.execute_help">execute_help</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute_command" href="#refinery.lib.batch.BatchEmulator.execute_command">execute_command</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.trace_pipeline" href="#refinery.lib.batch.BatchEmulator.trace_pipeline">trace_pipeline</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.trace_sequence" href="#refinery.lib.batch.BatchEmulator.trace_sequence">trace_sequence</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.trace_if" href="#refinery.lib.batch.BatchEmulator.trace_if">trace_if</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.trace_for" href="#refinery.lib.batch.BatchEmulator.trace_for">trace_for</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.trace_group" href="#refinery.lib.batch.BatchEmulator.trace_group">trace_group</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.trace_label" href="#refinery.lib.batch.BatchEmulator.trace_label">trace_label</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.trace_statement" href="#refinery.lib.batch.BatchEmulator.trace_statement">trace_statement</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.emulate_commands" href="#refinery.lib.batch.BatchEmulator.emulate_commands">emulate_commands</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.emulate_to_depth" href="#refinery.lib.batch.BatchEmulator.emulate_to_depth">emulate_to_depth</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.emulate" href="#refinery.lib.batch.BatchEmulator.emulate">emulate</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.execute" href="#refinery.lib.batch.BatchEmulator.execute">execute</a></code></li>
<li><code><a title="refinery.lib.batch.BatchEmulator.trace" href="#refinery.lib.batch.BatchEmulator.trace">trace</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.batch.BatchLexer" href="#refinery.lib.batch.BatchLexer">BatchLexer</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.batch.BatchLexer.label" href="#refinery.lib.batch.BatchLexer.label">label</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.parse_group" href="#refinery.lib.batch.BatchLexer.parse_group">parse_group</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.parse_label" href="#refinery.lib.batch.BatchLexer.parse_label">parse_label</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.parse_set" href="#refinery.lib.batch.BatchLexer.parse_set">parse_set</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.parse_arg_variable" href="#refinery.lib.batch.BatchLexer.parse_arg_variable">parse_arg_variable</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.reset" href="#refinery.lib.batch.BatchLexer.reset">reset</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.mode_reset" href="#refinery.lib.batch.BatchLexer.mode_reset">mode_reset</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.mode_finish" href="#refinery.lib.batch.BatchLexer.mode_finish">mode_finish</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.mode_switch" href="#refinery.lib.batch.BatchLexer.mode_switch">mode_switch</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.quick_save" href="#refinery.lib.batch.BatchLexer.quick_save">quick_save</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.quick_load" href="#refinery.lib.batch.BatchLexer.quick_load">quick_load</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.current_char" href="#refinery.lib.batch.BatchLexer.current_char">current_char</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.consume_char" href="#refinery.lib.batch.BatchLexer.consume_char">consume_char</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.next_char" href="#refinery.lib.batch.BatchLexer.next_char">next_char</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.parse_env_variable" href="#refinery.lib.batch.BatchLexer.parse_env_variable">parse_env_variable</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.emit_token" href="#refinery.lib.batch.BatchLexer.emit_token">emit_token</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.tokens" href="#refinery.lib.batch.BatchLexer.tokens">tokens</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.check_line_break" href="#refinery.lib.batch.BatchLexer.check_line_break">check_line_break</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.check_caret" href="#refinery.lib.batch.BatchLexer.check_caret">check_caret</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.check_command_separators" href="#refinery.lib.batch.BatchLexer.check_command_separators">check_command_separators</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.check_quote_start" href="#refinery.lib.batch.BatchLexer.check_quote_start">check_quote_start</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.check_redirect_io" href="#refinery.lib.batch.BatchLexer.check_redirect_io">check_redirect_io</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.fill_substitution_buffer" href="#refinery.lib.batch.BatchLexer.fill_substitution_buffer">fill_substitution_buffer</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.gobble_label" href="#refinery.lib.batch.BatchLexer.gobble_label">gobble_label</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.gobble_quote" href="#refinery.lib.batch.BatchLexer.gobble_quote">gobble_quote</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.gobble_whitespace" href="#refinery.lib.batch.BatchLexer.gobble_whitespace">gobble_whitespace</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.gobble_quoted_set" href="#refinery.lib.batch.BatchLexer.gobble_quoted_set">gobble_quoted_set</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.gobble_set" href="#refinery.lib.batch.BatchLexer.gobble_set">gobble_set</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.common_token_checks" href="#refinery.lib.batch.BatchLexer.common_token_checks">common_token_checks</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.gobble_set_regular" href="#refinery.lib.batch.BatchLexer.gobble_set_regular">gobble_set_regular</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.gobble_gap" href="#refinery.lib.batch.BatchLexer.gobble_gap">gobble_gap</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.gobble_txt" href="#refinery.lib.batch.BatchLexer.gobble_txt">gobble_txt</a></code></li>
<li><code><a title="refinery.lib.batch.BatchLexer.preparse" href="#refinery.lib.batch.BatchLexer.preparse">preparse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.batch.BatchParser" href="#refinery.lib.batch.BatchParser">BatchParser</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.lib.batch.BatchParser.skip_prefix" href="#refinery.lib.batch.BatchParser.skip_prefix">skip_prefix</a></code></li>
<li><code><a title="refinery.lib.batch.BatchParser.command" href="#refinery.lib.batch.BatchParser.command">command</a></code></li>
<li><code><a title="refinery.lib.batch.BatchParser.redirects" href="#refinery.lib.batch.BatchParser.redirects">redirects</a></code></li>
<li><code><a title="refinery.lib.batch.BatchParser.pipeline" href="#refinery.lib.batch.BatchParser.pipeline">pipeline</a></code></li>
<li><code><a title="refinery.lib.batch.BatchParser.ifthen" href="#refinery.lib.batch.BatchParser.ifthen">ifthen</a></code></li>
<li><code><a title="refinery.lib.batch.BatchParser.forloop_options" href="#refinery.lib.batch.BatchParser.forloop_options">forloop_options</a></code></li>
<li><code><a title="refinery.lib.batch.BatchParser.forloop" href="#refinery.lib.batch.BatchParser.forloop">forloop</a></code></li>
<li><code><a title="refinery.lib.batch.BatchParser.block" href="#refinery.lib.batch.BatchParser.block">block</a></code></li>
<li><code><a title="refinery.lib.batch.BatchParser.group" href="#refinery.lib.batch.BatchParser.group">group</a></code></li>
<li><code><a title="refinery.lib.batch.BatchParser.label" href="#refinery.lib.batch.BatchParser.label">label</a></code></li>
<li><code><a title="refinery.lib.batch.BatchParser.statement" href="#refinery.lib.batch.BatchParser.statement">statement</a></code></li>
<li><code><a title="refinery.lib.batch.BatchParser.sequence" href="#refinery.lib.batch.BatchParser.sequence">sequence</a></code></li>
<li><code><a title="refinery.lib.batch.BatchParser.parse" href="#refinery.lib.batch.BatchParser.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.batch.BatchState" href="#refinery.lib.batch.BatchState">BatchState</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.lib.batch.BatchState.envar" href="#refinery.lib.batch.BatchState.envar">envar</a></code></li>
<li><code><a title="refinery.lib.batch.BatchState.resolve_path" href="#refinery.lib.batch.BatchState.resolve_path">resolve_path</a></code></li>
<li><code><a title="refinery.lib.batch.BatchState.create_file" href="#refinery.lib.batch.BatchState.create_file">create_file</a></code></li>
<li><code><a title="refinery.lib.batch.BatchState.append_file" href="#refinery.lib.batch.BatchState.append_file">append_file</a></code></li>
<li><code><a title="refinery.lib.batch.BatchState.remove_file" href="#refinery.lib.batch.BatchState.remove_file">remove_file</a></code></li>
<li><code><a title="refinery.lib.batch.BatchState.ingest_file" href="#refinery.lib.batch.BatchState.ingest_file">ingest_file</a></code></li>
<li><code><a title="refinery.lib.batch.BatchState.exists_file" href="#refinery.lib.batch.BatchState.exists_file">exists_file</a></code></li>
<li><code><a title="refinery.lib.batch.BatchState.sizeof_file" href="#refinery.lib.batch.BatchState.sizeof_file">sizeof_file</a></code></li>
<li><code><a title="refinery.lib.batch.BatchState.new_forloop" href="#refinery.lib.batch.BatchState.new_forloop">new_forloop</a></code></li>
<li><code><a title="refinery.lib.batch.BatchState.end_forloop" href="#refinery.lib.batch.BatchState.end_forloop">end_forloop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
