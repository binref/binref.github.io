<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.id documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.id</code></h1>
</header>
<section id="section-intro">
<p>This module contains functions to identify certain file formats; some of these functions are used
by units who operate on the same file format to implement the <code><a title="refinery.units.Unit.handles" href="../units/index.html#refinery.units.UnitBase.handles">Unit.handles()</a></code> method.
The method <code><a title="refinery.lib.id.get_structured_data_type" href="#refinery.lib.id.get_structured_data_type">get_structured_data_type()</a></code> is used to determine whether an unknown blob
is a known data format. Units like <code><a title="refinery.decompress" href="../index.html#refinery.decompress">decompress</a></code> or <code><a title="refinery.autoxor" href="../index.html#refinery.autoxor">autoxor</a></code> use this as part of
their heuristics to determine that a high quality output has been generated.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L1-L1339" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contains functions to identify certain file formats; some of these functions are used
by units who operate on the same file format to implement the `refinery.units.Unit.handles` method.
The method `refinery.lib.id.get_structured_data_type` is used to determine whether an unknown blob
is a known data format. Units like `refinery.decompress` or `refinery.autoxor` use this as part of
their heuristics to determine that a high quality output has been generated.
&#34;&#34;&#34;
from __future__ import annotations

import codecs
import enum
import re

from typing import Callable, NamedTuple
from unicodedata import category as unicode_category

from refinery.lib.tools import entropy
from refinery.lib.types import buf

ENCODINGS = [
    &#39;utf8&#39;,
    &#39;cp1252&#39;,
    &#39;cp1250&#39;,
    &#39;cp1251&#39;,
    &#39;cp1253&#39;,
    &#39;cp1254&#39;,
    &#39;cp1255&#39;,
    &#39;cp1256&#39;,
    &#39;cp1257&#39;,
    &#39;cp1258&#39;,
    &#39;gbk&#39;,
    &#39;iso_8859_1&#39;,
    &#39;iso_8859_14&#39;,
    &#39;big5&#39;,
    &#39;cp874&#39;,
    &#39;shift_jis&#39;,
    &#39;uhc&#39;,
]

try:
    import ctypes
except ImportError:
    def _meminfo_d(v: memoryview) -&gt; slice | None:
        return None
    meminfo = _meminfo_d
else:
    def _meminfo_c(v: memoryview):
        if not (n := len(v)):
            return None
        if v.readonly or not v.contiguous:
            return None
        base = memoryview(v.obj)
        offset, base_addr = (
            ctypes.addressof(ctypes.c_char.from_buffer(t)) for t in (v, base))
        start = offset - base_addr
        return slice(start, min(start + n, len(base)), 1)
    meminfo = _meminfo_c

MimeByExtension = {
    &#39;bin&#39;   : &#39;application/ocet-stream&#39;,
    &#39;exe&#39;   : &#39;application/exe&#39;,
    &#39;sys&#39;   : &#39;application/exe&#39;,
    &#39;dll&#39;   : &#39;application/exe&#39;,
    &#39;elf&#39;   : &#39;application/x-elf-executable&#39;,
    &#39;macho&#39; : &#39;application/x-mach-binary&#39;,
    &#39;class&#39; : &#39;application/java-byte-code&#39;,
    &#39;pdf&#39;   : &#39;application/pdf&#39;,
    &#39;djvu&#39;  : &#39;image/vnd.djvu&#39;,
    &#39;pcap&#39;  : &#39;application/vnd.tcpdump.pcap&#39;,
    &#39;db&#39;    : &#39;application/x-sqlite3&#39;,
    &#39;mdb&#39;   : &#39;application/x-msaccess&#39;,
    &#39;doc&#39;   : &#39;application/msword&#39;,
    &#39;xls&#39;   : &#39;application/vnd.ms-excel&#39;,
    &#39;ppt&#39;   : &#39;application/vnd.ms-powerpoint&#39;,
    &#39;msg&#39;   : &#39;application/vnd.ms-outlook&#39;,
    &#39;msi&#39;   : &#39;application/x-msi&#39;,
    &#39;docx&#39;  : &#39;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#39;,
    &#39;pptx&#39;  : &#39;application/vnd.openxmlformats-officedocument.presentationml.presentation&#39;,
    &#39;xlsx&#39;  : &#39;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&#39;,
    &#39;txt&#39;   : &#39;text/plain&#39;,
    &#39;json&#39;  : &#39;application/json&#39;,
    &#39;xml&#39;   : &#39;application/xml&#39;,
    &#39;html&#39;  : &#39;text/html&#39;,
    &#39;rtf&#39;   : &#39;application/rtf&#39;,
    &#39;vbe&#39;   : &#39;text/plain&#39;,
    &#39;eml&#39;   : &#39;message/rfc822&#39;,
    &#39;ico&#39;   : &#39;image/vnd.microsoft.icon&#39;,
    &#39;gif&#39;   : &#39;image/gif&#39;,
    &#39;tif&#39;   : &#39;image/tiff&#39;,
    &#39;jpg&#39;   : &#39;image/jpeg&#39;,
    &#39;png&#39;   : &#39;image/png&#39;,
    &#39;bmp&#39;   : &#39;image/bmp&#39;,
    &#39;ogg&#39;   : &#39;audio/ogg&#39;,
    &#39;wav&#39;   : &#39;audio/wav&#39;,
    &#39;avi&#39;   : &#39;video/x-msvideo&#39;,
    &#39;mp3&#39;   : &#39;audio/mpeg&#39;,
    &#39;m3u&#39;   : &#39;text/plain&#39;,
    &#39;mp4&#39;   : &#39;video/mp4&#39;,
    &#39;mpg&#39;   : &#39;video/mpeg&#39;,
    &#39;mid&#39;   : &#39;audio/midi&#39;,
    &#39;mkv&#39;   : &#39;video/x-matroska&#39;,
    &#39;swf&#39;   : &#39;application/x-shockwave-flash&#39;,
    &#39;tar&#39;   : &#39;application/x-tar&#39;,
    &#39;7z&#39;    : &#39;application/x-7z-compressed&#39;,
    &#39;zip&#39;   : &#39;application/zip&#39;,
    &#39;rar&#39;   : &#39;application/vnd.rar&#39;,
    &#39;cab&#39;   : &#39;application/vnd.ms-cab-compressed&#39;,
    &#39;bz&#39;    : &#39;application/x-bzip&#39;,
    &#39;bz2&#39;   : &#39;application/x-bzip2&#39;,
    &#39;gz&#39;    : &#39;application/gzip&#39;,
    &#39;xz&#39;    : &#39;application/x-xz&#39;,
    &#39;zstd&#39;  : &#39;application/x-zstd&#39;,
    &#39;zlib&#39;  : &#39;application/zlib&#39;,
}


class Format:
    __slots__ = &#39;category&#39;, &#39;extension&#39;, &#39;mime&#39;, &#39;mnemonic&#39;, &#39;details&#39;

    def __hash__(self):
        return hash((self.category, self.mnemonic))

    def __str__(self):
        return self.mnemonic

    def __le__(self, them):
        if not isinstance(them, Format):
            return False
        t1 = set(self.mnemonic.split(&#39;/&#39;))
        t2 = set(them.mnemonic.split(&#39;/&#39;))
        return t1 &lt;= t2

    def __eq__(self, them):
        if not isinstance(them, Format):
            return False
        return self.mnemonic == them.mnemonic

    def __ne__(self, them):
        return not self.__eq__(them)

    def __iter__(self):
        yield self.category
        yield self.extension
        yield self.mnemonic
        yield self.details
        yield self.mime

    def __init__(
        self,
        category: FormatCategory,
        extension: str | None = None,
        mnemonic: str | None = None,
        details: str | None = None,
        mime: str | None = None,
    ) -&gt; None:
        self.category = category
        self.extension = extension or &#39;bin&#39;
        self.mnemonic = mnemonic or self.extension.upper()
        self.details = details or self.mnemonic

        if mime is None:
            try:
                mime = MimeByExtension[self.extension]
            except KeyError:
                if category == FormatCategory.Text:
                    mime = &#39;text/plain&#39;
                else:
                    mime = &#39;application/ocet-stream&#39;

        self.mime = mime


class FormatCategory(enum.IntEnum):
    Executable = enum.auto()
    Text = enum.auto()
    Document = enum.auto()
    Image = enum.auto()
    Binary = enum.auto()
    Media = enum.auto()
    Archive = enum.auto()
    Compression = enum.auto()
    Serialized = enum.auto()


FC = FormatCategory

PycMagicPattern = re.compile(br&#39;&#39;&#39;(?x)
   [\x02\x03]\x99\x99\x00
  |(?:
  | \xca\xfe
  | \x89\x2e
  | \x04\x17
  | \x99\x4e
  | \xfc\xc4
  | \x87\xc6
  | \x65\x34
  | \x31\x61
  | \x2a\xeb
  | \x2d\xed
  |[\x3b\x45\x59\x63\x6d\x77\x81\x8b\x8c\x95\x9f\xa9\xb3\xb7\xc7\xd1\xdb\xe5\xef\xf9]\xf2
  |[\x03\x0a]\xf3
  | \x61\x0a
  |[\xb8\xc2\xcc\xd6\xe0\xea\xf4\xf5\xff]\x0b
  |[\x09\x13\x1d\x1f\x27\x3b\x45\x4f\x58\x62\x6c\x73\x76\x80\x94\x8a\x9e\xb2\xbc\xc6\xd0\xda\xe4\xee\xf8]\x0c
  |[\x02\x0c\x16\x17\x20\x21\x2a-\x2d\x2f-\x33\x3e-\x42\x48\x49\x52-\x55\x5c-\x61\x66-\x6f\x7a-\xa7\xac-\xcb\xde-\xf3]\x0d
  |[\x10-\x18\x1a\x1b\x1d-\x29\x2b\x47]\x0e
  |[\x30\x40\x70\xa0\xc0\xe0\xf0]\x00
  |[\x00\x40\x50\x80\xa0]\x01
  | \x61\x32
  | \x61\x31
  | \x9e\x52
  |[\x20\x2a]\x53
  | \xf3\x03
  | \x7a\x56
  ) \x0D\x0A
&#39;&#39;&#39;)


class Fmt(Format, enum.Enum):
    &#34;&#34;&#34;
    An enumeration of all known file formats that can be returned by
     `refinery.lib.id.get_structured_data_type`.
    &#34;&#34;&#34;
    ELF = (FC.Executable, &#39;elf&#39;, &#39;ELF&#39;)
    MACHO = (FC.Executable, &#39;macho&#39;, &#39;MachO&#39;)
    PE = (FC.Executable, &#39;exe&#39;, &#39;PE&#39;)

    PE32GUI = (FC.Executable, &#39;exe&#39;, &#39;PE/32/GUI&#39;)
    PE32CUI = (FC.Executable, &#39;exe&#39;, &#39;PE/32/CUI&#39;)
    PE32DLL = (FC.Executable, &#39;dll&#39;, &#39;PE/32/DLL&#39;)
    PE32SYS = (FC.Executable, &#39;sys&#39;, &#39;PE/32/SYS&#39;)
    PE64GUI = (FC.Executable, &#39;exe&#39;, &#39;PE/64/GUI&#39;)
    PE64CUI = (FC.Executable, &#39;exe&#39;, &#39;PE/64/CUI&#39;)
    PE64DLL = (FC.Executable, &#39;dll&#39;, &#39;PE/64/DLL&#39;)
    PE64SYS = (FC.Executable, &#39;sys&#39;, &#39;PE/64/SYS&#39;)

    ELF32LE = (FC.Executable, &#39;elf&#39;, &#39;ELF/32/LE&#39;)
    ELF64LE = (FC.Executable, &#39;elf&#39;, &#39;ELF/64/LE&#39;)
    ELF32BE = (FC.Executable, &#39;elf&#39;, &#39;ELF/32/BE&#39;)
    ELF64BE = (FC.Executable, &#39;elf&#39;, &#39;ELF/64/BE&#39;)

    MACHOuvLE = (FC.Executable, &#39;macho&#39;, &#39;MachO/Fat/LE&#39;)
    MACHOuvBE = (FC.Executable, &#39;macho&#39;, &#39;MachO/Fat/BE&#39;)
    MACHO32LE = (FC.Executable, &#39;macho&#39;, &#39;MachO/32/LE&#39;)
    MACHO64LE = (FC.Executable, &#39;macho&#39;, &#39;MachO/64/LE&#39;)
    MACHO32BE = (FC.Executable, &#39;macho&#39;, &#39;MachO/32/BE&#39;)
    MACHO64BE = (FC.Executable, &#39;macho&#39;, &#39;MachO/64/BE&#39;)

    JAVA = (FC.Executable, &#39;class&#39;, &#39;JavaClass&#39;)
    DEX = (FC.Executable, &#39;dex&#39;, &#39;Dalvik&#39;)
    WASM = (FC.Executable, &#39;wasm&#39;, &#39;WASM&#39;, &#39;Web Assembly&#39;)
    LUAC = (FC.Executable, &#39;luac&#39;, &#39;LUAC&#39;, &#39;LUA Bytecode&#39;)
    PYC = (FC.Executable, &#39;pyc&#39;, &#39;PYC&#39;, &#39;Python Bytecode&#39;)
    APK = (FC.Executable, &#39;apk&#39;, &#39;ZIP/APK&#39;, &#39;Android Package&#39;)

    PDF = (FC.Document, &#39;pdf&#39;, &#39;PDF&#39;, &#39;PDF Document&#39;)
    CHM = (FC.Document, &#39;chm&#39;, &#39;CHM&#39;, &#39;Microsoft Windows HtmlHelp Data&#39;)
    DJV = (FC.Document, &#39;djvu&#39;, &#39;DJVU&#39;, &#39;DJVu Document&#39;)

    PCAP = (FC.Binary, &#39;pcap&#39;, &#39;PCAP&#39;, &#39;Network Packet Capture&#39;)
    PCAPNG = (FC.Binary, &#39;pcapng&#39;, &#39;PCAP/NG&#39;, &#39;Next-Generation Network Packet Capture&#39;)
    SSP = (FC.Binary, &#39;ssp&#39;, &#39;SmartSniff&#39;, &#39;SmartSniff Packets File&#39;)
    SQLITE = (FC.Binary, &#39;db&#39;, &#39;SQLite&#39;, &#39;SQLite Database&#39;)
    DSS = (FC.Binary, &#39;DS_Store&#39;, &#39;DSS&#39;, &#39;MacOS DS Store&#39;)
    A3X = (FC.Binary, &#39;a3x&#39;, &#39;A3X&#39;, &#39;Compiled AutoIt3&#39;)
    IFPS = (FC.Binary, &#39;ifps&#39;, &#39;IFPS&#39;, &#39;InnerFuse PascalScript&#39;)
    PPK = (FC.Binary, &#39;ppk&#39;, &#39;PuTTY&#39;, &#39;PuTTY Private Key File&#39;)
    WIM = (FC.Binary, &#39;wim&#39;, &#39;WIM&#39;, &#39;Windows Imaging Format&#39;)
    EVT = (FC.Binary, &#39;evt&#39;, &#39;EVT&#39;, &#39;Windows Event Viewer&#39;)
    EVTX = (FC.Binary, &#39;evtx&#39;, &#39;EVTX&#39;, &#39;Windows Event Viewer XML&#39;)
    LNK = (FC.Binary, &#39;lnk&#39;, &#39;LNK&#39;, &#39;Windows Shortcut&#39;)
    DMP = (FC.Binary, &#39;dmp&#39;, &#39;MDMP&#39;, &#39;Mini DuMP Crash Report&#39;)

    REG = (FC.Binary, &#39;reg&#39;, &#39;WinReg&#39;, &#39;A Windows Registry Script or Hive File&#39;)
    REG_HIVE = (FC.Binary, &#39;reg&#39;, &#39;WinReg/Hive&#39;, &#39;Windows Registry Hive File&#39;, &#39;text/plain&#39;)
    REG_TEXT = (FC.Binary, &#39;reg&#39;, &#39;WinReg/Text&#39;, &#39;Windows Registry Script&#39;)

    OFFICE = (FC.Document, &#39;bin&#39;, &#39;OFFICE&#39;, &#39;A Microsoft Office Document&#39;)
    OFFICECRYPT = (FC.Document, &#39;bin&#39;, &#39;OFFICE/ENCRYPTED&#39;, &#39;Encrypted Microsoft Office Document&#39;)
    MDB = (FC.Document, &#39;accdb&#39;, &#39;OFFICE/MDB&#39;, &#39;Microsoft Access Database&#39;)
    DOC = (FC.Document, &#39;doc&#39;, &#39;OFFICE/DOC&#39;, &#39;Microsoft Word Document&#39;)
    ONE = (FC.Document, &#39;one&#39;, &#39;OFFICE/ONE&#39;, &#39;Microsoft OneNote Document&#39;)
    XLS = (FC.Document, &#39;xls&#39;, &#39;OFFICE/XLS&#39;, &#39;Microsoft Excel Document&#39;)
    PPT = (FC.Document, &#39;ppt&#39;, &#39;OFFICE/PPT&#39;, &#39;Microsoft PowerPoint Document&#39;)
    MSG = (FC.Document, &#39;msg&#39;, &#39;MSG&#39;, &#39;Microsoft Outlook EMail Message&#39;)
    MSI = (FC.Archive, &#39;msi&#39;, &#39;MSI&#39;, &#39;Microsoft Installer Archive (MSI)&#39;)
    CFF = (FC.Binary, &#39;ole&#39;, &#39;OLE&#39;, &#39;Compound File Format&#39;)
    IDB = (FC.Document, &#39;idb&#39;, &#39;IDB/32&#39;, &#39;IDA Database (32 Bit)&#39;)
    I64 = (FC.Document, &#39;i64&#39;, &#39;IDB/64&#39;, &#39;IDA Database (64 Bit)&#39;)

    DOCX = (FC.Document, &#39;docx&#39;, &#39;OFFICE/ZIP/DOCX&#39;, &#39;Microsoft ZIP/XML Document for Word&#39;)
    XLSX = (FC.Document, &#39;xlsx&#39;, &#39;OFFICE/ZIP/XLSX&#39;, &#39;Microsoft ZIP/XML Document for Excel&#39;)
    PPTX = (FC.Document, &#39;pptx&#39;, &#39;OFFICE/ZIP/PPTX&#39;, &#39;Microsoft ZIP/XML Document for PowerPoint&#39;)

    ODT = (FC.Document, &#39;odt&#39;, &#39;ZIP/ODT&#39;, &#39;Open Document Format&#39;)

    TEXT = (FC.Text, &#39;txt&#39;, &#39;Text&#39;, &#39;Plain Text Data&#39;)
    ASCII = (FC.Text, &#39;txt&#39;, &#39;Text/ASCII&#39;, &#39;Plain Text, Single Byte Encoding&#39;)
    UTF08 = (FC.Text, &#39;txt&#39;, &#39;Text/UTF08&#39;, &#39;Plain Text, UTF-08 Encoding&#39;)
    UTF16 = (FC.Text, &#39;txt&#39;, &#39;Text/UTF16&#39;, &#39;Plain Text, UTF-16 Encoding&#39;)
    UTF32 = (FC.Text, &#39;txt&#39;, &#39;Text/UTF32&#39;, &#39;Plain Text, UTF-32 Encoding&#39;)

    JSON = (FC.Text, &#39;json&#39;, &#39;Text/JSON&#39;)
    XML = (FC.Text, &#39;xml&#39;, &#39;Text/XML&#39;)
    HTM = (FC.Text, &#39;html&#39;, &#39;Text/HTML&#39;)
    RTF = (FC.Text, &#39;rtf&#39;, &#39;RTF&#39;)
    VBE = (FC.Text, &#39;vbe&#39;, &#39;VBE&#39;, &#39;Encoded VBScript&#39;)
    EML = (FC.Text, &#39;eml&#39;, &#39;EML&#39;, &#39;Plain-Text EMail Document&#39;)

    HIC = (FC.Image, &#39;heic&#39;, &#39;HEIC&#39;, &#39;High Efficiency Image Container&#39;)
    ICO = (FC.Image, r&#39;ico&#39;, r&#39;ICO&#39;, &#39;Icon&#39;)
    GIF = (FC.Image, r&#39;gif&#39;, r&#39;GIF&#39;, &#39;Graphics Interchange Format&#39;)
    TIF = (FC.Image, r&#39;tif&#39;, r&#39;TIF&#39;, &#39;Tagged Image File Format&#39;)
    CIN = (FC.Image, r&#39;cin&#39;, r&#39;CIN&#39;, &#39;Kodak Cineon Image&#39;)
    NUI = (FC.Image, r&#39;nui&#39;, r&#39;NUI&#39;, &#39;Nuru ASCI/ANSI Image or Palette&#39;)
    DPX = (FC.Image, r&#39;dpx&#39;, r&#39;DPX&#39;, &#39;SMPTE DPX Image&#39;)
    BPG = (FC.Image, r&#39;bpg&#39;, r&#39;BPG&#39;, &#39;Better Portable Graphics&#39;)
    EXR = (FC.Image, r&#39;exr&#39;, r&#39;EXR&#39;, &#39;OpenEXR Image&#39;)
    JPG = (FC.Image, r&#39;jpg&#39;, r&#39;JPG&#39;, &#39;Joint Photographic Experts Group Image&#39;)
    JP2 = (FC.Image, r&#39;jp2&#39;, r&#39;JP2&#39;, &#39;JPEG 2000&#39;)
    QOI = (FC.Image, r&#39;qoi&#39;, r&#39;QOI&#39;, &#39;Quite OK Image Format&#39;)
    IFF = (FC.Image, r&#39;iff&#39;, r&#39;IFF&#39;, &#39;IFF or Amiga Image&#39;)
    PNG = (FC.Image, r&#39;png&#39;, r&#39;PNG&#39;, &#39;Portable Network Graphics&#39;)
    PSD = (FC.Image, r&#39;psd&#39;, r&#39;PSD&#39;, &#39;Adobe Photoshop Document&#39;)
    BMP = (FC.Image, r&#39;bmp&#39;, r&#39;BMP&#39;, &#39;Bitmap&#39;)
    FIF = (FC.Image, &#39;flif&#39;, &#39;FLIF&#39;, &#39;Free Lossless Image Format&#39;)
    LEP = (FC.Image, r&#39;lep&#39;, r&#39;LEP&#39;, &#39;Lepton Compressed JPEG Image&#39;)
    HDR = (FC.Image, r&#39;hdr&#39;, r&#39;HDR&#39;, &#39;Radiance High Dynamic Range Image&#39;)

    OGG = (FC.Media, &#39;ogg&#39;)
    WAV = (FC.Media, &#39;wav&#39;)
    AVI = (FC.Media, &#39;avi&#39;)
    MP3 = (FC.Media, &#39;mp3&#39;)
    M3U = (FC.Media, &#39;m3u&#39;, &#39;M3U&#39;, &#39;Multimedia Playlist&#39;)
    MP4 = (FC.Media, &#39;mp4&#39;)
    MPG = (FC.Media, &#39;mpg&#39;)
    FLC = (FC.Media, &#39;flac&#39;)
    MID = (FC.Media, &#39;mid&#39;)
    MKV = (FC.Media, &#39;mkv&#39;)
    SWF = (FC.Media, &#39;swf&#39;)
    SIL = (FC.Media, &#39;sil&#39;)

    ACE = (FC.Archive, &#39;ace&#39;)
    ASAR = (FC.Archive, &#39;asar&#39;)
    VHD = (FC.Archive, &#39;vhd&#39;)
    VMDK = (FC.Archive, &#39;vmdk&#39;)
    ISO = (FC.Archive, &#39;iso&#39;)
    ISZ = (FC.Archive, &#39;isz&#39;, &#39;ISZ&#39;, &#39;Compressed ISO Image&#39;)
    DMG = (FC.Archive, &#39;dmg&#39;)
    XAR = (FC.Archive, &#39;xar&#39;, &#39;XAR&#39;, &#39;eXtensible ARchive Format&#39;)
    TAR = (FC.Archive, &#39;tar&#39;)
    OAR = (FC.Archive, &#39;oar&#39;)
    ZIP7 = (FC.Archive, &#39;7z&#39;, &#39;7Zip&#39;)
    ZIP = (FC.Archive, &#39;zip&#39;, &#39;ZIP&#39;)
    RAR = (FC.Archive, &#39;rar&#39;)
    CAB = (FC.Archive, &#39;cab&#39;)
    CPIO = (FC.Archive, &#39;cpio&#39;)
    ZPQ = (FC.Archive, &#39;zpq&#39;)

    S_JAV = (FC.Serialized, &#39;bin&#39;, &#39;Serialized/Java&#39;)
    S_DOT = (FC.Serialized, &#39;bin&#39;, &#39;Serialized/DotNet&#39;)
    S_PHP = (FC.Serialized, &#39;bin&#39;, &#39;Serialized/PHP&#39;)

    APLIB = (FC.Compression, &#39;ap&#39;, &#39;apLib&#39;)
    BZ2 = (FC.Compression, &#39;bz2&#39;, &#39;BZIP&#39;)
    JCALG = (FC.Compression, &#39;bin&#39;, &#39;jcAlg&#39;)
    LZMA = (FC.Compression, &#39;lzma&#39;)
    LZF = (FC.Compression, &#39;lzf&#39;)
    LZH = (FC.Compression, &#39;lzh&#39;)
    LZG = (FC.Compression, &#39;lzg&#39;)
    RNC = (FC.Compression, &#39;rnc&#39;, &#39;RNC&#39;, &#39;Rob Northern Compression&#39;)
    LZIP = (FC.Compression, &#39;lzip&#39;)
    LZO = (FC.Compression, &#39;lzo&#39;)
    LZ4 = (FC.Compression, &#39;lz4&#39;)
    LZW = (FC.Compression, &#39;lzw&#39;)
    LZFSE = (FC.Compression, &#39;lzfse&#39;)
    MSCF = (FC.Compression, &#39;mscf&#39;)
    SZDD = (FC.Compression, &#39;szdd&#39;)
    GZIP = (FC.Compression, &#39;gz&#39;)
    XZ = (FC.Compression, &#39;xz&#39;, &#39;XZ/LZMA2&#39;)
    ZLIB = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB&#39;)
    ZLIB0 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/0&#39;)
    ZLIB1 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/1&#39;)
    ZLIB2 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/2&#39;)
    ZLIB3 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/3&#39;)
    ZLIB4 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/4&#39;)
    ZLIB5 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/5&#39;)
    ZLIB6 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/6&#39;)
    ZLIB7 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/7&#39;)
    ZSTD = (FC.Compression, &#39;zstd&#39;)


FormatDetails = {format.mnemonic: format for format in Fmt}
StructuralChecks: list[Callable[[buf], Fmt | None]] = []


def _structural_check(fn: Callable[[buf], Fmt | None]):
    StructuralChecks.append(fn)
    return fn


@_structural_check
def get_pe_type(data: buf):
    &#34;&#34;&#34;
    Get the correct file type extension for a PE file, or None if the input is unlikely to be a
    portable executable in the first place.
    &#34;&#34;&#34;
    if data[:2] != B&#39;MZ&#39;:
        return None
    nt = data[0x3C:0x3E]
    if len(nt) &lt; 2:
        return None
    nt = int.from_bytes(nt, &#39;little&#39;)
    if data[nt:nt + 4] != B&#39;PE\0\0&#39;:
        return None
    arch = data[nt + 4:nt + 6]
    if arch == B&#39;\x64\x86&#39;:
        dll = Fmt.PE32DLL
        sub = (
            Fmt.PE32SYS,
            Fmt.PE32GUI,
            Fmt.PE32CUI,
        )
    elif arch == B&#39;\x4C\x01&#39;:
        dll = Fmt.PE64DLL
        sub = (
            Fmt.PE64SYS,
            Fmt.PE64GUI,
            Fmt.PE64CUI,
        )
    else:
        return None
    if data[nt + 0x17] &amp; 0x20:
        return dll
    subsystem = data[nt + 0x5C] - 1
    if not 0 &lt;= subsystem &lt;= 2:
        return None
    return sub[subsystem]


@_structural_check
def get_elf_type(data: buf):
    &#34;&#34;&#34;
    Get arch and byte order information of an ELF file or return None if the input is unlikely to be one.
    &#34;&#34;&#34;
    if not data[:4] == b&#39;\x7FELF&#39;:
        return None
    abo = data[4:6]
    if len(data) &lt; 0x40:
        return None
    elif data[6] != 1: # EI_VERSION
        return None
    elif abo == B&#39;\x01\x01&#39;:
        return Fmt.ELF32LE
    elif abo == B&#39;\x01\x02&#39;:
        return Fmt.ELF32BE
    elif abo == B&#39;\x02\x01&#39;:
        return Fmt.ELF64BE
    elif abo == B&#39;\x02\x02&#39;:
        return Fmt.ELF64BE


@_structural_check
def get_macho_type(data: buf):
    &#34;&#34;&#34;
    Get arch and byte order information of a MachO file or return None if the input is unlikely to be one.
    &#34;&#34;&#34;
    order = &#39;little&#39;
    magic = int.from_bytes(data[:4], order)
    isfat = False

    if len(data) &lt; 30:
        return None
    elif magic == 0xCE_FAEDFE:
        order = &#39;big&#39;
        mtype = Fmt.MACHO32BE
    elif magic == 0xCF_FAEDFE:
        order = &#39;big&#39;
        mtype = Fmt.MACHO64BE
    elif magic == 0xFEEDFACE:
        mtype = Fmt.MACHO32LE
    elif magic == 0xFEEDFACF:
        mtype = Fmt.MACHO64BE
    elif magic == 0xCAFEBABE:
        mtype = Fmt.MACHOuvLE
        isfat = True
    elif magic == 0xBEBAFECA:
        mtype = Fmt.MACHOuvBE
        isfat = True
    else:
        return None
    if isfat:
        cpu = int.from_bytes(data[8:0xC], order)
    else:
        cpu = int.from_bytes(data[4:0x8], order)
    if cpu in (
        0x00000001, # vax
        0x00000002, # ROMP
        0x00000004, # NS32032
        0x00000005, # NS32332
        0x00000006, # mc680x0
        0x00000007, # x32
        0x01000007, # x64
        0x00000008, # mips
        0x00000009, # NS32352
        0x0000000A, # mc98000
        0x0000000B, # hppa
        0x0000000C, # arm32
        0x0100000C, # arm64
        0x0000000D, # mc880000
        0x0000000E, # sparc
        0x0000000F, # i860
        0x00000010, # alpha
        0x00000011, # RS/6000
        0x00000012, # ppc32
        0x01000012, # ppc64
    ):
        return mtype


def get_executable_type(data: buf):
    &#34;&#34;&#34;
    Determine the type of an executable.
    &#34;&#34;&#34;
    if t := get_pe_type(data):
        return t
    if t := get_elf_type(data):
        return t
    if t := get_macho_type(data):
        return t
    if data[:4] == B&#39;PK\x03\x04&#39;:
        for marker in (
            B&#39;AndroidManifest.xml&#39;,
            B&#39;APK Sig Block 42&#39;,
        ):
            if buffer_contains(data, marker):
                return Fmt.APK


def is_likely_pe(data: buf):
    &#34;&#34;&#34;
    Tests whether the input data is likely a PE file by checking the first two bytes and the magic
    bytes at the beginning of what should be the NT header.
    &#34;&#34;&#34;
    return get_pe_type(data) is not None


def slice_offset(haystack: slice, needle: slice):
    &#34;&#34;&#34;
    Assuming that haystack and needle are used to slice the same buffer, this method determines the
    offset of that needle in the haystack, or `-1` if the haystack would not contain the needle.
    &#34;&#34;&#34;
    h_start = 0 if haystack.start is None else haystack.start
    h_stop = haystack.stop
    h_step = haystack.step or 1
    n_start = 0 if needle.start is None else needle.start
    n_stop = needle.stop
    n_step = needle.step or 1
    offset = n_start - h_start
    offset, remainder = divmod(offset, h_step)
    single_byte = False
    if h_stop is not None:
        if n_stop is None:
            return -1
        h_length, hr = divmod(h_stop - h_start, h_step)
        n_length, nr = divmod(n_stop - n_start, n_step)
        h_length += bool(hr)
        n_length += bool(nr)
        if n_length == 0:
            return 0
        if n_length + offset &gt; h_length:
            return -1
        if n_length == 1:
            single_byte = True
    if n_step != h_step and not single_byte:
        return -1
    if offset &lt; 0:
        return -1
    if remainder != 0:
        return -1
    return offset


def buffer_offset(
    haystack: buf,
    needle: buf,
    start: int = 0,
    end: int | None = None,
    ncopy: int = 0x100,
    back2front: bool = False,
) -&gt; int:
    &#34;&#34;&#34;
    Performs a substring search of `needle` in `haystack`. If `haystack` is a `bytes`-like object,
    it uses the standard method. If it is a `memoryview`, the function first checks whether it is
    a view onto a bytes or bytearray object at offset 0: In this case, it can reduce to using the
    underlying object&#39;s standard method. Otherwise, it uses a regular expression search. This fails
    when the memoryview is not contiguous: In this case, a bytearray is constructed from the view
    and searched instead.
    &#34;&#34;&#34;
    if (nc := len(needle)) == 0:
        return 0
    if (hc := len(haystack)) == 0:
        return -1
    if isinstance(haystack, memoryview):
        hs: memoryview = haystack[start:end] # type:ignore
        hi = meminfo(hs)
        if hi and hi.start == 0 and isinstance((obj := hs.obj), (bytes, bytearray)):
            end = len(hs) if end is None else min(len(hs), end)
            return buffer_offset(obj, needle, start, end, ncopy=ncopy, back2front=back2front)
        elif back2front:
            nv = memoryview(needle)
            _s = 0 if end is None else hc - end
            _e = hc - start if start else None
            pos = buffer_offset(haystack[::-1], nv[::-1], _s, _e, ncopy)
            if pos &lt; 0:
                return -1
            return hc - pos - len(nv)
        if isinstance(needle, memoryview):
            if hi and haystack.obj is needle.obj and (ni := meminfo(needle)):
                if (offset := slice_offset(hi, ni)) &gt;= 0:
                    return offset
        if not hs.contiguous:
            haystack = bytearray(haystack)
        else:
            prefix = needle[:ncopy]
            if isinstance(prefix, memoryview):
                prefix = bytes(prefix)
            match_sufficient = True
            suffix = B&#39;&#39;
            pattern = re.escape(prefix)
            if rest := nc - len(prefix):
                if rest &gt; ncopy:
                    suffix = needle[-ncopy:]
                    match_sufficient = False
                    rest -= ncopy
                else:
                    suffix = needle[-rest:]
                if isinstance(suffix, memoryview):
                    suffix = bytes(suffix)
            if suffix:
                suffix = re.escape(suffix)
                if rest &gt; 0:
                    suffix = B&#39;.{%d}%s&#39; % (rest, suffix)
                pattern += suffix
            for m in re.finditer(pattern, hs):
                offset = start + m.start()
                if match_sufficient or haystack[offset:offset + nc] == needle:
                    return offset
            else:
                return -1
    if isinstance(needle, memoryview) and not needle.contiguous:
        needle = bytearray(needle)
    find = haystack.rfind if back2front else haystack.find
    return find(needle, start, end)


def buffer_contains(haystack: buf, needle: buf):
    &#34;&#34;&#34;
    Determines whether `haystack` contains `needle`.
    &#34;&#34;&#34;
    return buffer_offset(haystack, needle) &gt;= 0


def is_likely_pe_dotnet(data: buf):
    &#34;&#34;&#34;
    Tests whether the input data is likely a .NET PE file by running `refinery.lib.id.is_likely_pe`
    and also checking for the characteristic strings `BSJB`, `#Strings`, and `#Blob`.
    &#34;&#34;&#34;
    if not is_likely_pe(data):
        return False
    if not buffer_contains(data, b&#39;BSJB&#39;):
        return False
    if not buffer_contains(data, b&#39;#Strings&#39;):
        return False
    if not buffer_contains(data, b&#39;#Blob&#39;):
        return False
    return True


@_structural_check
def get_reg_export_type(data: buf):
    &#34;&#34;&#34;
    Check whether the input data is a Windows registry file export.
    &#34;&#34;&#34;
    if data[:4] == b&#39;regf&#39;:
        return Fmt.REG_HIVE
    if data[:31] == b&#39;Windows Registry Editor Version&#39;:
        return Fmt.REG_TEXT


class TextEncoding(NamedTuple):
    codec: str
    bom: int = 0
    lsb: int = 0
    step: int = 1


def guess_text_encoding(
    data: buf,
    window_size: int = 0x1000,
    ascii_ratio: float = 0.98,
) -&gt; TextEncoding | None:
    &#34;&#34;&#34;
    Attempts to determine whether the input data is likely printable text. The return value is None
    if the input is unlikely to be text. Otherwise, the return value is a triple of integers: First
    the offset after the byte order mark (`0` in case there is none), then the offset of the first
    low byte of a character (odd for big endian encodings, even for others) and finally the size of
    each encoded character in bytes.
    &#34;&#34;&#34;
    def ascii_count(v: memoryview):
        count = 0
        ascii = range(0x20, 0x80)
        b = 0xFF
        for b in v:
            count += (b in ascii or b == 9 or b == 10 or b == 13)
        if b == 0 and count &gt; 0:
            # accept a terminating null byte
            count += 1
        return count

    view = memoryview(data)
    size = window_size
    step = 1
    maxbad = 1 - ascii_ratio
    bom = 0
    lsb = 0
    enc = None

    if data[:3] == B&#39;\xEF\xBB\xBF&#39;:
        bom = 3
        enc = &#39;utf8&#39;
    elif data[:4] == B&#39;\xFF\xFE\0\0&#39;:
        step = bom = lsb = 4
        enc = &#39;utf-32le&#39;
    elif data[:4] == B&#39;\0\0\xFE\xFF&#39;:
        step, bom, lsb = 4, 4, 7
        enc = &#39;utf-32be&#39;
    elif data[:2] == B&#39;\xFF\xFE&#39;:
        step = bom = lsb = 2
        enc = &#39;utf-16le&#39;
    elif data[:2] == B&#39;\xFE\xFF&#39;:
        step, bom, lsb = 2, 2, 3
        enc = &#39;utf-16be&#39;
    elif any(data[:4] == bom for bom in (
        b&#39;\x2B\x2F\x76\x38&#39;,
        b&#39;\x2B\x2F\x76\x39&#39;,
        b&#39;\x2B\x2F\x76\x2B&#39;,
        b&#39;\x2B\x2F\x76\x2F&#39;,
    )):
        bom = 4
        enc = &#39;utf7&#39;
    elif len(view) % 2 == 0:
        u16le = (win := view[1:size:2]) and ascii_count(win) / len(win) &lt;= maxbad
        u16be = (win := view[0:size:2]) and ascii_count(win) / len(win) &lt;= maxbad
        if u16le:
            if u16be:
                return None
            enc = &#39;utf-16le&#39;
            step, lsb = 2, 0
        elif u16be:
            enc = &#39;utf-16be&#39;
            step, lsb = 2, 1

    win = view[lsb:size:step]

    if len(data) &lt;= bom:
        return None

    if step &gt; 1:
        if len(data) % step != 0:
            return None
        if not win or ascii_count(win) / len(win) &lt; ascii_ratio:
            return None
        assert enc is not None
        return TextEncoding(enc, bom, lsb, step)

    for encoding in (enc and [enc] or ENCODINGS):
        try:
            decoded = codecs.decode(data, encoding)
        except UnicodeDecodeError:
            continue
        else:
            bad = sum(1 for c in decoded if unicode_category(c).startswith(&#39;C&#39;) and c not in &#39;\040\n\r\t&#39;)
            if bad / len(decoded) &lt;= maxbad:
                return TextEncoding(encoding, bom, lsb, step)


def xml_or_html(view: buf):
    &#34;&#34;&#34;
    Returns an `refinery.lib.id.Fmt` indicating either XML or HTML, or None if the data does not
    look like either of these formats at all.
    &#34;&#34;&#34;
    if tag_match := re.search(BR&#39;&#39;&#39;(?x)
        ^               # at the very start of the document
        \s{0,10}        # allow for some leading white space
        &lt;               # a tag opens
        ([?!]?          # allow for question or exclamation mark
         [-:\w]{3,64})  # the tag name
        \s{0,20}        # white space after tag name
        (/?&gt;            # the tag may end here, or:
        |[-:\w]{3,32})  # we have an attribute.
    &#39;&#39;&#39;, view, flags=re.DOTALL):
        tag = tag_match[1].lower()
        end = tag_match[2].lower()
        # &lt;?xml...
        if tag == b&#39;?xml&#39;:
            return Fmt.XML
        # &lt;HTML&gt;
        # &lt;BODY&gt;
        if tag in (b&#39;html&#39;, b&#39;body&#39;):
            return Fmt.HTM
        # &lt;!DOCTYPE html
        if tag == b&#39;!doctype&#39; and end == b&#39;html&#39;:
            return Fmt.HTM
        # &lt;project xmlns:xsi=...
        if end.startswith(b&#39;xml&#39;):
            return Fmt.XML
        else:
            return Fmt.HTM
    return None


def ascii_view(
    data: buf,
    window_size: int = 0x1000,
    ascii_ratio: float = 0.98,
):
    &#34;&#34;&#34;
    If the input data looks like text, get a memoryview of the least significant bytes of each
    encoded letter. Otherwise, return None. Whether or not the data looks like text is determined
    using `refinery.lib.id.guess_text_encoding`; all parameters are forwarded to this function.
    &#34;&#34;&#34;
    if encoding := guess_text_encoding(data, window_size=window_size, ascii_ratio=ascii_ratio):
        return memoryview(data)[encoding.lsb:len(data):encoding.step]


def is_likely_eml(
    data: buf,
    window_size: int = 0x10000,
):
    &#34;&#34;&#34;
    Checks the input for common strings that occur as email headers. If at least two are found,
    the function returns True.
    &#34;&#34;&#34;
    hits = 0
    view = memoryview(data)[:window_size]
    for marker in (
        b&#39;\nReceived:\x20from&#39;,
        b&#39;\nSubject:\x20&#39;,
        b&#39;\nTo:\x20&#39;,
        b&#39;\nFrom:\x20&#39;,
        b&#39;\nMessage-ID:\x20&#39;,
        b&#39;\nBcc:\x20&#39;,
        b&#39;\nContent-Transfer-Encoding:\x20&#39;,
        b&#39;\nContent-Type:\x20&#39;,
        b&#39;\nReturn-Path:\x20&#39;,
    ):
        if not buffer_contains(view, marker):
            continue
        if (hits := hits + 1) &gt;= 2:
            return True
    else:
        return False


def is_likely_vbe(data: buf):
    &#34;&#34;&#34;
    Checks whether the input contains the known markers used by encoded Visual Basic scripts.
    &#34;&#34;&#34;
    view = memoryview(data)
    if not buffer_contains(view[:+64], BR&#39;#@~^&#39;):
        return False
    if not buffer_contains(view[-64:], BR&#39;==^#~@&#39;):
        return False
    return True


def is_likely_json(data: buf):
    &#34;&#34;&#34;
    A fast regular expression based check for whether the input looks like JSON. The expression
    checks whether the input is a sequence of valid JSON tokens: quoted strings, constants,
    integer and floating-point numbers, and control characters. To be explicit, note that this
    function cannot check for correct nesting, regular expressions are insufficient for this.
    &#34;&#34;&#34;
    _json = RB&#34;&#34;&#34;
        \s*((                               # a sequence of the following tokens:
           &#34;([^&#34;\\\r\n]|\\[^\r\n])*&#34;        # a quoted string literal
          | true                            # true
          | false                           # false
          | null                            # null
          | [-+]?([1-9]\d*|0)               # an integer
          | [-+]?\d*\.?\d+([eE][-+]?\d+)?   # a float
          | [\{\}\[\]:,]                    # a structural token
        # | //(.*?)\n                       # do not allow comments (line)
        # | /\*.*?\*/                       # do not allow comments (block)
        )\s*)*?
    &#34;&#34;&#34;
    _json = RB&#39;(?x)\s*(\{%s\})|(\[%s\])\s*&#39; % (_json, _json)
    return re.fullmatch(_json, data) is not None


@_structural_check
def get_microsoft_format(data: buf):
    &#34;&#34;&#34;
    Checks for various Microsoft formats. This includes Access Database files and OneNote, but most
    importantly it can distinguish between various compound document formats like MSI, Word, Excel,
    PowerPoint, and Outlook.
    &#34;&#34;&#34;
    if data[:19] == b&#39;\0\01\0\0Standard ACE DB&#39;:
        return Fmt.MDB
    if data[:19] == b&#39;\0\01\0\0Standard Jet DB&#39;:
        return Fmt.MDB
    if data[:4] != B&#39;\xD0\xCF\x11\xE0&#39;:
        return None
    if data[4:8] != B&#39;\xA1\xB1\x1A\xE1&#39; and any(data[4:12]):
        return None
    if buffer_contains(data, b&#39;\xE4\x52\x5C\x7B\x8C\xD8\xA7\x4D\xAE\xB1\x53\x78\xD0\x29\x96\xD3&#39;):
        return Fmt.ONE
    for k in range(0x200, 0x10000, 0x200):
        mark = int.from_bytes(data[k:k + 4], &#39;little&#39;)
        if mark == 0x00C1A5EC:
            return Fmt.DOC
        if mark == 0x00100809 and data[k + 4:k + 8] == B&#39;\x00\x06\x05\x00&#39;:
            return Fmt.XLS
        if mark == 0xF01D46A0:
            return Fmt.PPT
        if mark == 0xF01E6E00:
            return Fmt.PPT
        if mark == 0x03E8000F:
            return Fmt.PPT
    if buffer_contains(data, b&#39;W\0o\0r\0d\0D\0o\0c\0u\0m\0e\0n\0t\0&#39;):
        # WordDocument
        return Fmt.DOC
    if buffer_contains(data, b&#39;P\0o\0w\0e\0r\0P\0o\0i\0n\0t\0&#39;):
        # PowerPoint
        return Fmt.PPT
    if buffer_contains(data, b&#39;W\0o\0r\0k\0b\0o\0o\0k\0&#39;):
        # Workbook
        return Fmt.XLS
    if buffer_contains(data, b&#39;_\0_\0s\0u\0b\0s\0t\0g\01\0.\00\0_\0&#39;):
        # __substg1._
        return Fmt.MSG
    if buffer_contains(data, b&#39;_\0_\0n\0a\0m\0e\0i\0d\0_\0v\0e\0r\0s\0i\0o\0n\0&#39;):
        # __nameid_version
        return Fmt.MSG
    if buffer_contains(data, b&#39;_\0_\0r\0e\0c\0i\0p\0_\0v\0e\0r\0s\0i\0o\0n\0&#39;):
        # __recip_version
        return Fmt.MSG
    if buffer_contains(data, b&#39;_\0_\0p\0r\0o\0p\0e\0r\0t\0i\0e\0s\0_\0v\0e\0r\0s\0i\0o\0n\0&#39;):
        # __properties_version
        return Fmt.MSG
    if buffer_contains(data, b&#39;B\0o\0o\0k\0&#39;):
        # Book
        return Fmt.XLS
    if buffer_contains(data, B&#39;E\0n\0c\0r\0y\0p\0t\0e\0d\0P\0a\0c\0k\0a\0g\0e\0&#39;):
        return Fmt.OFFICECRYPT
    if re.search(b&#39;Property|ProductCode|UpgradeCode|PackageCode|InstallExecuteSequence|Component|Feature|File|Media&#39;, data):
        return Fmt.MSI
    if re.search(B&#39;Msi(?:[A-Z][a-z]{2,30}){2,5}&#39;, data):
        return Fmt.MSI
    else:
        return Fmt.CFF


@_structural_check
def get_office_xml_type(data: buf):
    &#34;&#34;&#34;
    Checks for known XML-based Office document types like DOCX, XLSX, and PPTX.
    &#34;&#34;&#34;
    if data[:2] != B&#39;PK&#39;:
        return None
    if buffer_contains(data, B&#39;application/vnd.oasis.opendocument.text&#39;):
        if buffer_contains(data, B&#39;settings.xml&#39;):
            return Fmt.ODT
        if buffer_contains(data, B&#39;META-INF/manifest.xml&#39;):
            return Fmt.ODT
    if not buffer_contains(data, B&#39;_rels/.rels&#39;):
        return None
    if not buffer_contains(data, B&#39;[Content_Types].xml&#39;):
        return None
    if buffer_contains(data, B&#39;word/document.xml&#39;):
        return Fmt.DOCX
    if buffer_contains(data, B&#39;xl/document.xml&#39;):
        return Fmt.XLSX
    if buffer_contains(data, B&#39;xl/workbook.xml&#39;):
        return Fmt.XLSX
    if buffer_contains(data, B&#39;xl/worksheets/&#39;):
        return Fmt.XLSX
    if buffer_contains(data, B&#39;ppt/presentation.xml&#39;):
        return Fmt.PPTX


@_structural_check
def get_compression_type(
    data: buf,
    entropy_minimum: float = 0.7,
    entropy_look_at: int = 0x2000,
):
    &#34;&#34;&#34;
    This method looks for any of a number of known magic signatures for compression and archive
    formats. If one is find, the method selects a data window from the rest of the buffer and
    computes its entropy. If the entropy exceeds the given threshold, the input is idenfied as
    a known compression format.
    &#34;&#34;&#34;
    size = len(data)
    view = memoryview(data)
    T = True
    F = False

    if data[:4] == b&#39;\04\0\0\0&#39; and data[0x10:0x18] == B&#39;{&#34;files&#34;&#39;:
        return Fmt.ASAR

    for format, entropy_required, offset, signature in (
        (Fmt.APLIB       , T, 0, B&#39;AP32&#39;),                                      # noqa
        (Fmt.ACE         , F, 7, B&#39;**ACE**&#39;),                                   # noqa
        (Fmt.BZ2         , T, 0, B&#39;BZh&#39;),                                       # noqa
        (Fmt.JCALG       , T, 0, B&#39;JC&#39;),                                        # noqa
        (Fmt.LZMA        , T, 0, B&#39;\x5D\0\0\0&#39;),                                # noqa
        (Fmt.LZMA        , T, 0, B&#39;\xFD7zXZ&#39;),                                  # noqa
        (Fmt.RNC         , T, 0, B&#39;RNC\x01&#39;),                                   # noqa
        (Fmt.RNC         , T, 0, B&#39;RNC\x02&#39;),                                   # noqa
        (Fmt.LZF         , T, 0, B&#39;ZV&#39;),                                        # noqa
        (Fmt.LZG         , T, 0, B&#39;LZG&#39;),                                       # noqa
        (Fmt.LZIP        , T, 0, B&#39;LZIP&#39;),                                      # noqa
        (Fmt.LZ4         , T, 0, B&#39;\x04\x22\x4D\x18&#39;),                          # noqa
        (Fmt.LZO         , F, 0, B&#39;\x89\x4c\x5a\x4f\x00\x0d\x0a\x1a\x0a&#39;),      # noqa
        (Fmt.LZH         , T, 0, B&#39;\x1F\xA0&#39;),                                  # noqa
        (Fmt.LZW         , T, 0, B&#39;\x1F\x9D&#39;),                                  # noqa
        (Fmt.GZIP        , T, 0, B&#39;\x1F\x8B&#39;),                                  # noqa
        (Fmt.XZ          , F, 0, B&#39;\xFD\x37\x7A\x58\x5A\x00&#39;),                  # noqa
        (Fmt.MSCF        , T, 0, B&#39;\x0A\x51\xE5\xC0&#39;),                          # noqa
        (Fmt.RAR         , T, 0, B&#39;Rar!\x1A\x07&#39;),                              # noqa
        (Fmt.XAR         , T, 0, B&#39;xar!&#39;),                                      # noqa
        (Fmt.SZDD        , T, 0, B&#39;SZDD&#39;),                                      # noqa
        (Fmt.ZLIB0       , T, 0, B&#39;\x78\x01&#39;),                                  # noqa
        (Fmt.ZLIB1       , T, 0, B&#39;\x78\x5E&#39;),                                  # noqa
        (Fmt.ZLIB2       , T, 0, B&#39;\x78\x9C&#39;),                                  # noqa
        (Fmt.ZLIB3       , T, 0, B&#39;\x78\xDA&#39;),                                  # noqa
        (Fmt.ZLIB4       , T, 0, B&#39;\x78\x20&#39;),                                  # noqa
        (Fmt.ZLIB5       , T, 0, B&#39;\x78\x7D&#39;),                                  # noqa
        (Fmt.ZLIB6       , T, 0, B&#39;\x78\xBB&#39;),                                  # noqa
        (Fmt.ZLIB7       , T, 0, B&#39;\x78\xF9&#39;),                                  # noqa
        (Fmt.LZFSE       , T, 0, B&#39;bvx2&#39;),                                      # noqa
        (Fmt.ZSTD        , T, 0, B&#39;\x28\xB5\x2F\xFD&#39;),                          # noqa
        (Fmt.ZIP7        , T, 0, B&#39;7z\xBC\xAF\x27\x1C&#39;),                        # noqa
        (Fmt.CAB         , T, 0, B&#39;MSCF&#39;),                                      # noqa
        (Fmt.CHM         , T, 0, B&#39;ITSF&#39;),                                      # noqa
        (Fmt.CPIO        , F, 0, B&#39;070701&#39;),                                    # noqa
        (Fmt.CPIO        , F, 0, B&#39;070702&#39;),                                    # noqa
        (Fmt.CPIO        , F, 0, B&#39;070707&#39;),                                    # noqa
        (Fmt.ZIP         , T, 0, B&#39;PK\x03\x04&#39;),                                # noqa
        (Fmt.ZIP         , T, 0, B&#39;PK\x05\x06&#39;),                                # noqa
        (Fmt.ZIP         , T, 0, B&#39;PK\x07\x08&#39;),                                # noqa
        (Fmt.ISO         , F, 0x8001, B&#39;CD001&#39;),                                # noqa
        (Fmt.ISO         , F, 0x8801, B&#39;CD001&#39;),                                # noqa
        (Fmt.ISO         , F, 0x9001, B&#39;CD001&#39;),                                # noqa
        (Fmt.ISZ         , T, 0, B&#39;IsZ!&#39;),                                      # noqa
        (Fmt.TAR         , F, 257, B&#39;ustar&#39;),                                   # noqa
        (Fmt.OAR         , T, 0, B&#39;OAR&#39;),                                       # noqa
        (Fmt.ZPQ         , T, 0, B&#39;7kSt\xA01\x83\xD3\x8C\xB2\x28\xB0\xD3zPQ&#39;),  # noqa
        (Fmt.VMDK        , T, 0, B&#39;KDM&#39;),                                       # noqa
        (Fmt.VMDK        , T, 0, B&#39;# Disk Descripto&#39;),                          # noqa
        (Fmt.VHD         , T, 0, B&#39;conectix&#39;),                                  # noqa
        (Fmt.VHD         , T, 0, B&#39;vhdxfile&#39;),                                  # noqa
        (Fmt.DMG         , T, size - 512, B&#39;koly&#39;),                             # noqa
    ):
        if view[offset:offset + len(signature)] == signature:
            if not entropy_required or len(data) &lt; 0x100:
                return format
            for start in (0x1000, 0x400, 0x200, 0x100, 0x80, 0x40, 0x20, 0x10):
                if len(view) &gt;= start + entropy_look_at:
                    view = view[start:]
                    break
            else:
                return format
            if entropy(view[:entropy_look_at]) &gt;= entropy_minimum:
                return format


@_structural_check
def get_image_format(data: buf):
    &#34;&#34;&#34;
    Determine an image format based on known magic signatures or return None if there is no
    match.
    &#34;&#34;&#34;
    if data[:4] == B&#39;\0\0\x01\0&#39;:
        count = int.from_bytes(data[4:6], &#39;little&#39;)
        if not 1 &lt;= count &lt;= 100:
            return None
        w, h, _, r = data[6:10]
        if r != 0:
            return None
        p = int.from_bytes(data[10:12], &#39;little&#39;) # planes
        b = int.from_bytes(data[12:14], &#39;little&#39;) # bit count
        if not any((w == h, p == 1, b in (1, 2, 4, 8, 16, 24, 32, 64, 96, 128, 256))):
            return None
        return Fmt.ICO

    if data[:3] == B&#39;\xFF\xD8\xFF&#39;:
        if data[3] in (0xDB, 0xEE, 0xE0):
            return Fmt.JPG
        if data[3] == 0xE1 and data[6:12] == B&#39;Exif\0\0&#39;:
            return Fmt.JPG
        return None

    if data[:4] == b&#39;FORM&#39;:
        if data[8:12] in (
            B&#39;ILBM&#39;,
            B&#39;8SVX&#39;,
            B&#39;ACBM&#39;,
            B&#39;ANBM&#39;,
            B&#39;ANIM&#39;,
            B&#39;FAXX&#39;,
            B&#39;FTXT&#39;,
            B&#39;SMUS&#39;,
            B&#39;CMUS&#39;,
            B&#39;YUVN&#39;,
            B&#39;FANT&#39;,
            B&#39;AIFF&#39;,
        ):
            return Fmt.IFF
        else:
            return None

    for format, signature in (
        (Fmt.HIC, b&#39;ftypheic&#39;),
        (Fmt.GIF, B&#39;GIF87a&#39;),
        (Fmt.GIF, B&#39;GIF89a&#39;),
        (Fmt.TIF, B&#39;\x49\x49\x2A\x00&#39;),
        (Fmt.TIF, B&#39;\x4D\x4D\x00\x2A&#39;),
        (Fmt.TIF, B&#39;\x49\x49\x2B\x00&#39;),
        (Fmt.TIF, B&#39;\x4D\x4D\x00\x2B&#39;),
        (Fmt.CIN, B&#39;\x80\x2A\x5F\xD7&#39;),
        (Fmt.NUI, B&#39;NURUIMG&#39;),
        (Fmt.NUI, B&#39;NURUPAL&#39;),
        (Fmt.DPX, B&#39;SDPX&#39;),
        (Fmt.DPX, B&#39;XPDS&#39;),
        (Fmt.BPG, B&#39;BPG\xFB&#39;),
        (Fmt.EXR, B&#39;\x76\x2F\x31\x01&#39;),
        (Fmt.JP2, B&#39;\x00\x00\x00\x0C\x6A\x50\x20\x20\x0D\x0A\x87\x0A&#39;),
        (Fmt.JP2, B&#39;\xFF\x4F\xFF\x51&#39;),
        (Fmt.QOI, B&#39;\x71\x6f\x69\x66&#39;),
        (Fmt.PNG, B&#39;\x89\x50\x4E\x47\x0D\x0A\x1A\x0A&#39;),
        (Fmt.PSD, B&#39;8BPS&#39;),
        (Fmt.BMP, B&#39;BM&#39;),
        (Fmt.FIF, B&#39;FLIF&#39;),
        (Fmt.LEP, B&#39;\xCF\x84\x01&#39;),
        (Fmt.HDR, B&#39;#?RADIANCE\n&#39;),
        (Fmt.IDB, B&#39;IDA1&#39;),
        (Fmt.I64, B&#39;IDA2&#39;),
    ):
        if data[:len(signature)] == signature:
            return format


@_structural_check
def get_media_format(data: buf):
    &#34;&#34;&#34;
    Determine a multi-media format based on known magic signatures or return None if there is no
    match.
    &#34;&#34;&#34;
    if data[:4] == B&#39;RIFF&#39;:
        if data[8:12] == b&#39;WAVE&#39;:
            return Fmt.WAV
        if data[8:12] == b&#39;AVI &#39;:
            return Fmt.AVI
        return None

    for format, signature in (
        (Fmt.OGG, B&#39;OggS&#39;),
        (Fmt.MP3, B&#39;\xFF\xFB&#39;),
        (Fmt.MP3, B&#39;\xFF\xF3&#39;),
        (Fmt.MP3, B&#39;\xFF\xF2&#39;),
        (Fmt.MP3, B&#39;ID3&#39;),
        (Fmt.M3U, B&#39;#EXTM3U&#39;),
        (Fmt.MPG, B&#39;\0\0\01\xBA&#39;),
        (Fmt.MPG, B&#39;\0\0\01\xB3&#39;),
        (Fmt.FLC, B&#39;fLaC&#39;),
        (Fmt.MID, B&#39;MThd&#39;),
        (Fmt.MKV, B&#39;\x1A\x45\xDF\xA3&#39;),
        (Fmt.SWF, B&#39;CWS&#39;),
        (Fmt.SWF, B&#39;FWS&#39;),
        (Fmt.SIL, B&#39;#!SILK\n&#39;),
    ):
        if data[:len(signature)] == signature:
            return format

    if data[4:12] in (B&#39;ftypisom&#39;, B&#39;ftypMSNV&#39;):
        return Fmt.MPG

    if data[4:10] == B&#39;ftypM4&#39;:
        return Fmt.MP4

    if len(data) &lt; 0x1000:
        return None

    stop = min(len(data), 0x10000)
    if all(data[i] == 0x47 for i in range(0, stop, 188)):
        if any(data[i - 1] != 0x47 for i in range(0, stop, 188)):
            return Fmt.MPG


@_structural_check
def get_serialization_format(data: buf):
    &#34;&#34;&#34;
    Checks for known data serialization formats.
    &#34;&#34;&#34;
    if data[:4] == B&#39;\xAC\xED\x00\x05&#39;:
        return Fmt.S_JAV
    if data[:17] == B&#39;\0\01\0\0\0\xFF\xFF\xFF\xFF\x01\0\0\0\0\0\0\0&#39;:
        if data[17] in range(18) or data[17] in range(0x14, 0x17):
            return Fmt.S_DOT


@_structural_check
def get_misc_binary_formats(data: buf):
    &#34;&#34;&#34;
    Checks for various other binary formats that are not covered by other methods in this module.
    &#34;&#34;&#34;
    if len(data) &gt;= 0x30 and PycMagicPattern.fullmatch(data[:4]):
        if any(data[offset] &amp; 0x7F == 0x63 for offset in (8, 12, 16)):
            return Fmt.PYC

    for format, signature in (
        (Fmt.PDF, B&#39;%PDF-&#39;),
        (Fmt.A3X, B&#39;\xA3\x48\x4B\xBE\x98\x6C\x4A\xA9\x99\x4C\x53\x0A\x86\xD6\x48\x7D\x41\x55\x33\x21&#39;),
        (Fmt.CHM, B&#39;ITSF&#39;),
        (Fmt.DSS, B&#39;\0\0\0\01Bud1&#39;),
        (Fmt.DJV, B&#39;AT&amp;TFORM&#39;),
        (Fmt.DEX, B&#39;dex\n035\0&#39;),
        (Fmt.IFPS, B&#39;IFPS&#39;),
        (Fmt.JAVA, B&#39;\xCA\xFE\xBA\xBE&#39;),
        (Fmt.WASM, B&#39;\0asm&#39;),
        (Fmt.LUAC, B&#39;\x1BLua&#39;),
        (Fmt.LNK, B&#39;L\0\0\0\01\x14\02\0\0\0\0\0\xC0\0\0\0\0\0\0F&#39;),
        (Fmt.DMP, B&#39;MDMP&#39;),
        (Fmt.PCAP, B&#39;\xD4\xC3\xB2\xA1&#39;),
        (Fmt.PCAP, B&#39;\xA1\xB2\xC3\xD4&#39;),
        (Fmt.PCAP, B&#39;\x4D\x3C\xB2\xA1&#39;),
        (Fmt.PCAP, B&#39;\xA1\xB2\x3C\x4D&#39;),
        (Fmt.PCAPNG, B&#39;\n\r\n\r&#39;),
        (Fmt.SSP, B&#39;SMSNF200&#39;),
        (Fmt.SQLITE, B&#39;SQLite format 3\0&#39;),
        (Fmt.PPK, B&#39;PuTTY-User-Key-File-&#39;),
        (Fmt.WIM, B&#39;MSWIM\0\0\0\xD0\0\0\0\0&#39;),
        (Fmt.EVT, B&#39;LfLe&#39;),
        (Fmt.EVTX, B&#39;ElfFile&#39;),
    ):
        if data[:len(signature)] == signature:
            return format


@_structural_check
def get_text_format(data: buf):
    &#34;&#34;&#34;
    Implements a heuristic check for whether the input is likely XML data.
    &#34;&#34;&#34;
    encoding = guess_text_encoding(data)

    if encoding is None:
        return None

    step = encoding.step
    view = memoryview(data)[encoding.lsb:len(data):step]

    if is_likely_vbe(view):
        return Fmt.VBE
    if buffer_contains(view[:200], BR&#39;{\rtf&#39;):
        return Fmt.RTF
    if step == 1 and is_likely_eml(data):
        return Fmt.EML
    if step &gt; 1:
        # The following checks require a contiguous buffer for the regular expression searches.
        view = bytearray(view)
    if format := xml_or_html(view):
        return format
    if is_likely_json(view):
        return Fmt.JSON
    if step == 1:
        if encoding.codec == &#39;utf8&#39;:
            return Fmt.UTF08
        else:
            return Fmt.ASCII
    if step == 2:
        return Fmt.UTF16
    if step == 4:
        return Fmt.UTF32


def get_structured_data_type(data: buf):
    &#34;&#34;&#34;
    Attempts to determine whether the input data is just a meaningless blob or whether it has
    structure, i.e. adheres to a known file format. Returns an `refinery.lib.id.Fmt` or `None`.
    &#34;&#34;&#34;
    for check in StructuralChecks:
        if t := check(data):
            return t


def is_likely_xml(data: buf):
    &#34;&#34;&#34;
    Checks whether the input data is likely an XML document.
    &#34;&#34;&#34;
    if view := ascii_view(data, window_size=0):
        return xml_or_html(view) == Fmt.XML
    return False


def is_likely_htm(data: buf):
    &#34;&#34;&#34;
    Checks whether the input data is likely an HTML document.
    &#34;&#34;&#34;
    if view := ascii_view(data, window_size=0):
        return xml_or_html(view) == Fmt.HTM
    return False


def is_likely_msi(data: buf):
    &#34;&#34;&#34;
    Checks whether the input data is likely an MSI.
    &#34;&#34;&#34;
    return get_microsoft_format(data) == Fmt.MSI


def is_likely_email(data: buf):
    &#34;&#34;&#34;
    Checks whether the input data is likely a plain-text or Outlook email document.
    &#34;&#34;&#34;
    if is_likely_eml(data):
        return True
    return get_microsoft_format(data) == Fmt.MSG


def is_likely_doc(data: buf):
    if get_microsoft_format(data) == Fmt.DOC:
        return True
    if get_office_xml_type(data) in (Fmt.DOCX, Fmt.ODT):
        return True
    return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.id.meminfo"><code class="name flex">
<span>def <span class="ident">meminfo</span></span>(<span>v)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L47-L56" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def _meminfo_c(v: memoryview):
    if not (n := len(v)):
        return None
    if v.readonly or not v.contiguous:
        return None
    base = memoryview(v.obj)
    offset, base_addr = (
        ctypes.addressof(ctypes.c_char.from_buffer(t)) for t in (v, base))
    start = offset - base_addr
    return slice(start, min(start + n, len(base)), 1)</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.get_pe_type"><code class="name flex">
<span>def <span class="ident">get_pe_type</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the correct file type extension for a PE file, or None if the input is unlikely to be a
portable executable in the first place.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L402-L438" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_structural_check
def get_pe_type(data: buf):
    &#34;&#34;&#34;
    Get the correct file type extension for a PE file, or None if the input is unlikely to be a
    portable executable in the first place.
    &#34;&#34;&#34;
    if data[:2] != B&#39;MZ&#39;:
        return None
    nt = data[0x3C:0x3E]
    if len(nt) &lt; 2:
        return None
    nt = int.from_bytes(nt, &#39;little&#39;)
    if data[nt:nt + 4] != B&#39;PE\0\0&#39;:
        return None
    arch = data[nt + 4:nt + 6]
    if arch == B&#39;\x64\x86&#39;:
        dll = Fmt.PE32DLL
        sub = (
            Fmt.PE32SYS,
            Fmt.PE32GUI,
            Fmt.PE32CUI,
        )
    elif arch == B&#39;\x4C\x01&#39;:
        dll = Fmt.PE64DLL
        sub = (
            Fmt.PE64SYS,
            Fmt.PE64GUI,
            Fmt.PE64CUI,
        )
    else:
        return None
    if data[nt + 0x17] &amp; 0x20:
        return dll
    subsystem = data[nt + 0x5C] - 1
    if not 0 &lt;= subsystem &lt;= 2:
        return None
    return sub[subsystem]</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.get_elf_type"><code class="name flex">
<span>def <span class="ident">get_elf_type</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Get arch and byte order information of an ELF file or return None if the input is unlikely to be one.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L441-L460" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_structural_check
def get_elf_type(data: buf):
    &#34;&#34;&#34;
    Get arch and byte order information of an ELF file or return None if the input is unlikely to be one.
    &#34;&#34;&#34;
    if not data[:4] == b&#39;\x7FELF&#39;:
        return None
    abo = data[4:6]
    if len(data) &lt; 0x40:
        return None
    elif data[6] != 1: # EI_VERSION
        return None
    elif abo == B&#39;\x01\x01&#39;:
        return Fmt.ELF32LE
    elif abo == B&#39;\x01\x02&#39;:
        return Fmt.ELF32BE
    elif abo == B&#39;\x02\x01&#39;:
        return Fmt.ELF64BE
    elif abo == B&#39;\x02\x02&#39;:
        return Fmt.ELF64BE</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.get_macho_type"><code class="name flex">
<span>def <span class="ident">get_macho_type</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Get arch and byte order information of a MachO file or return None if the input is unlikely to be one.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L463-L518" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_structural_check
def get_macho_type(data: buf):
    &#34;&#34;&#34;
    Get arch and byte order information of a MachO file or return None if the input is unlikely to be one.
    &#34;&#34;&#34;
    order = &#39;little&#39;
    magic = int.from_bytes(data[:4], order)
    isfat = False

    if len(data) &lt; 30:
        return None
    elif magic == 0xCE_FAEDFE:
        order = &#39;big&#39;
        mtype = Fmt.MACHO32BE
    elif magic == 0xCF_FAEDFE:
        order = &#39;big&#39;
        mtype = Fmt.MACHO64BE
    elif magic == 0xFEEDFACE:
        mtype = Fmt.MACHO32LE
    elif magic == 0xFEEDFACF:
        mtype = Fmt.MACHO64BE
    elif magic == 0xCAFEBABE:
        mtype = Fmt.MACHOuvLE
        isfat = True
    elif magic == 0xBEBAFECA:
        mtype = Fmt.MACHOuvBE
        isfat = True
    else:
        return None
    if isfat:
        cpu = int.from_bytes(data[8:0xC], order)
    else:
        cpu = int.from_bytes(data[4:0x8], order)
    if cpu in (
        0x00000001, # vax
        0x00000002, # ROMP
        0x00000004, # NS32032
        0x00000005, # NS32332
        0x00000006, # mc680x0
        0x00000007, # x32
        0x01000007, # x64
        0x00000008, # mips
        0x00000009, # NS32352
        0x0000000A, # mc98000
        0x0000000B, # hppa
        0x0000000C, # arm32
        0x0100000C, # arm64
        0x0000000D, # mc880000
        0x0000000E, # sparc
        0x0000000F, # i860
        0x00000010, # alpha
        0x00000011, # RS/6000
        0x00000012, # ppc32
        0x01000012, # ppc64
    ):
        return mtype</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.get_executable_type"><code class="name flex">
<span>def <span class="ident">get_executable_type</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Determine the type of an executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L521-L537" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_executable_type(data: buf):
    &#34;&#34;&#34;
    Determine the type of an executable.
    &#34;&#34;&#34;
    if t := get_pe_type(data):
        return t
    if t := get_elf_type(data):
        return t
    if t := get_macho_type(data):
        return t
    if data[:4] == B&#39;PK\x03\x04&#39;:
        for marker in (
            B&#39;AndroidManifest.xml&#39;,
            B&#39;APK Sig Block 42&#39;,
        ):
            if buffer_contains(data, marker):
                return Fmt.APK</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.is_likely_pe"><code class="name flex">
<span>def <span class="ident">is_likely_pe</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Tests whether the input data is likely a PE file by checking the first two bytes and the magic
bytes at the beginning of what should be the NT header.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L540-L545" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_likely_pe(data: buf):
    &#34;&#34;&#34;
    Tests whether the input data is likely a PE file by checking the first two bytes and the magic
    bytes at the beginning of what should be the NT header.
    &#34;&#34;&#34;
    return get_pe_type(data) is not None</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.slice_offset"><code class="name flex">
<span>def <span class="ident">slice_offset</span></span>(<span>haystack, needle)</span>
</code></dt>
<dd>
<section class="desc"><p>Assuming that haystack and needle are used to slice the same buffer, this method determines the
offset of that needle in the haystack, or <code>-1</code> if the haystack would not contain the needle.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L548-L581" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def slice_offset(haystack: slice, needle: slice):
    &#34;&#34;&#34;
    Assuming that haystack and needle are used to slice the same buffer, this method determines the
    offset of that needle in the haystack, or `-1` if the haystack would not contain the needle.
    &#34;&#34;&#34;
    h_start = 0 if haystack.start is None else haystack.start
    h_stop = haystack.stop
    h_step = haystack.step or 1
    n_start = 0 if needle.start is None else needle.start
    n_stop = needle.stop
    n_step = needle.step or 1
    offset = n_start - h_start
    offset, remainder = divmod(offset, h_step)
    single_byte = False
    if h_stop is not None:
        if n_stop is None:
            return -1
        h_length, hr = divmod(h_stop - h_start, h_step)
        n_length, nr = divmod(n_stop - n_start, n_step)
        h_length += bool(hr)
        n_length += bool(nr)
        if n_length == 0:
            return 0
        if n_length + offset &gt; h_length:
            return -1
        if n_length == 1:
            single_byte = True
    if n_step != h_step and not single_byte:
        return -1
    if offset &lt; 0:
        return -1
    if remainder != 0:
        return -1
    return offset</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.buffer_offset"><code class="name flex">
<span>def <span class="ident">buffer_offset</span></span>(<span>haystack, needle, start=0, end=None, ncopy=256, back2front=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Performs a substring search of <code>needle</code> in <code>haystack</code>. If <code>haystack</code> is a <code>bytes</code>-like object,
it uses the standard method. If it is a <code>memoryview</code>, the function first checks whether it is
a view onto a bytes or bytearray object at offset 0: In this case, it can reduce to using the
underlying object's standard method. Otherwise, it uses a regular expression search. This fails
when the memoryview is not contiguous: In this case, a bytearray is constructed from the view
and searched instead.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L584-L654" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def buffer_offset(
    haystack: buf,
    needle: buf,
    start: int = 0,
    end: int | None = None,
    ncopy: int = 0x100,
    back2front: bool = False,
) -&gt; int:
    &#34;&#34;&#34;
    Performs a substring search of `needle` in `haystack`. If `haystack` is a `bytes`-like object,
    it uses the standard method. If it is a `memoryview`, the function first checks whether it is
    a view onto a bytes or bytearray object at offset 0: In this case, it can reduce to using the
    underlying object&#39;s standard method. Otherwise, it uses a regular expression search. This fails
    when the memoryview is not contiguous: In this case, a bytearray is constructed from the view
    and searched instead.
    &#34;&#34;&#34;
    if (nc := len(needle)) == 0:
        return 0
    if (hc := len(haystack)) == 0:
        return -1
    if isinstance(haystack, memoryview):
        hs: memoryview = haystack[start:end] # type:ignore
        hi = meminfo(hs)
        if hi and hi.start == 0 and isinstance((obj := hs.obj), (bytes, bytearray)):
            end = len(hs) if end is None else min(len(hs), end)
            return buffer_offset(obj, needle, start, end, ncopy=ncopy, back2front=back2front)
        elif back2front:
            nv = memoryview(needle)
            _s = 0 if end is None else hc - end
            _e = hc - start if start else None
            pos = buffer_offset(haystack[::-1], nv[::-1], _s, _e, ncopy)
            if pos &lt; 0:
                return -1
            return hc - pos - len(nv)
        if isinstance(needle, memoryview):
            if hi and haystack.obj is needle.obj and (ni := meminfo(needle)):
                if (offset := slice_offset(hi, ni)) &gt;= 0:
                    return offset
        if not hs.contiguous:
            haystack = bytearray(haystack)
        else:
            prefix = needle[:ncopy]
            if isinstance(prefix, memoryview):
                prefix = bytes(prefix)
            match_sufficient = True
            suffix = B&#39;&#39;
            pattern = re.escape(prefix)
            if rest := nc - len(prefix):
                if rest &gt; ncopy:
                    suffix = needle[-ncopy:]
                    match_sufficient = False
                    rest -= ncopy
                else:
                    suffix = needle[-rest:]
                if isinstance(suffix, memoryview):
                    suffix = bytes(suffix)
            if suffix:
                suffix = re.escape(suffix)
                if rest &gt; 0:
                    suffix = B&#39;.{%d}%s&#39; % (rest, suffix)
                pattern += suffix
            for m in re.finditer(pattern, hs):
                offset = start + m.start()
                if match_sufficient or haystack[offset:offset + nc] == needle:
                    return offset
            else:
                return -1
    if isinstance(needle, memoryview) and not needle.contiguous:
        needle = bytearray(needle)
    find = haystack.rfind if back2front else haystack.find
    return find(needle, start, end)</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.buffer_contains"><code class="name flex">
<span>def <span class="ident">buffer_contains</span></span>(<span>haystack, needle)</span>
</code></dt>
<dd>
<section class="desc"><p>Determines whether <code>haystack</code> contains <code>needle</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L657-L661" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def buffer_contains(haystack: buf, needle: buf):
    &#34;&#34;&#34;
    Determines whether `haystack` contains `needle`.
    &#34;&#34;&#34;
    return buffer_offset(haystack, needle) &gt;= 0</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.is_likely_pe_dotnet"><code class="name flex">
<span>def <span class="ident">is_likely_pe_dotnet</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Tests whether the input data is likely a .NET PE file by running <code><a title="refinery.lib.id.is_likely_pe" href="#refinery.lib.id.is_likely_pe">is_likely_pe()</a></code>
and also checking for the characteristic strings <code>BSJB</code>, <code>#Strings</code>, and <code>#Blob</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L664-L677" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_likely_pe_dotnet(data: buf):
    &#34;&#34;&#34;
    Tests whether the input data is likely a .NET PE file by running `refinery.lib.id.is_likely_pe`
    and also checking for the characteristic strings `BSJB`, `#Strings`, and `#Blob`.
    &#34;&#34;&#34;
    if not is_likely_pe(data):
        return False
    if not buffer_contains(data, b&#39;BSJB&#39;):
        return False
    if not buffer_contains(data, b&#39;#Strings&#39;):
        return False
    if not buffer_contains(data, b&#39;#Blob&#39;):
        return False
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.get_reg_export_type"><code class="name flex">
<span>def <span class="ident">get_reg_export_type</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Check whether the input data is a Windows registry file export.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L680-L688" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_structural_check
def get_reg_export_type(data: buf):
    &#34;&#34;&#34;
    Check whether the input data is a Windows registry file export.
    &#34;&#34;&#34;
    if data[:4] == b&#39;regf&#39;:
        return Fmt.REG_HIVE
    if data[:31] == b&#39;Windows Registry Editor Version&#39;:
        return Fmt.REG_TEXT</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.guess_text_encoding"><code class="name flex">
<span>def <span class="ident">guess_text_encoding</span></span>(<span>data, window_size=4096, ascii_ratio=0.98)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempts to determine whether the input data is likely printable text. The return value is None
if the input is unlikely to be text. Otherwise, the return value is a triple of integers: First
the offset after the byte order mark (<code>0</code> in case there is none), then the offset of the first
low byte of a character (odd for big endian encodings, even for others) and finally the size of
each encoded character in bytes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L698-L785" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def guess_text_encoding(
    data: buf,
    window_size: int = 0x1000,
    ascii_ratio: float = 0.98,
) -&gt; TextEncoding | None:
    &#34;&#34;&#34;
    Attempts to determine whether the input data is likely printable text. The return value is None
    if the input is unlikely to be text. Otherwise, the return value is a triple of integers: First
    the offset after the byte order mark (`0` in case there is none), then the offset of the first
    low byte of a character (odd for big endian encodings, even for others) and finally the size of
    each encoded character in bytes.
    &#34;&#34;&#34;
    def ascii_count(v: memoryview):
        count = 0
        ascii = range(0x20, 0x80)
        b = 0xFF
        for b in v:
            count += (b in ascii or b == 9 or b == 10 or b == 13)
        if b == 0 and count &gt; 0:
            # accept a terminating null byte
            count += 1
        return count

    view = memoryview(data)
    size = window_size
    step = 1
    maxbad = 1 - ascii_ratio
    bom = 0
    lsb = 0
    enc = None

    if data[:3] == B&#39;\xEF\xBB\xBF&#39;:
        bom = 3
        enc = &#39;utf8&#39;
    elif data[:4] == B&#39;\xFF\xFE\0\0&#39;:
        step = bom = lsb = 4
        enc = &#39;utf-32le&#39;
    elif data[:4] == B&#39;\0\0\xFE\xFF&#39;:
        step, bom, lsb = 4, 4, 7
        enc = &#39;utf-32be&#39;
    elif data[:2] == B&#39;\xFF\xFE&#39;:
        step = bom = lsb = 2
        enc = &#39;utf-16le&#39;
    elif data[:2] == B&#39;\xFE\xFF&#39;:
        step, bom, lsb = 2, 2, 3
        enc = &#39;utf-16be&#39;
    elif any(data[:4] == bom for bom in (
        b&#39;\x2B\x2F\x76\x38&#39;,
        b&#39;\x2B\x2F\x76\x39&#39;,
        b&#39;\x2B\x2F\x76\x2B&#39;,
        b&#39;\x2B\x2F\x76\x2F&#39;,
    )):
        bom = 4
        enc = &#39;utf7&#39;
    elif len(view) % 2 == 0:
        u16le = (win := view[1:size:2]) and ascii_count(win) / len(win) &lt;= maxbad
        u16be = (win := view[0:size:2]) and ascii_count(win) / len(win) &lt;= maxbad
        if u16le:
            if u16be:
                return None
            enc = &#39;utf-16le&#39;
            step, lsb = 2, 0
        elif u16be:
            enc = &#39;utf-16be&#39;
            step, lsb = 2, 1

    win = view[lsb:size:step]

    if len(data) &lt;= bom:
        return None

    if step &gt; 1:
        if len(data) % step != 0:
            return None
        if not win or ascii_count(win) / len(win) &lt; ascii_ratio:
            return None
        assert enc is not None
        return TextEncoding(enc, bom, lsb, step)

    for encoding in (enc and [enc] or ENCODINGS):
        try:
            decoded = codecs.decode(data, encoding)
        except UnicodeDecodeError:
            continue
        else:
            bad = sum(1 for c in decoded if unicode_category(c).startswith(&#39;C&#39;) and c not in &#39;\040\n\r\t&#39;)
            if bad / len(decoded) &lt;= maxbad:
                return TextEncoding(encoding, bom, lsb, step)</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.xml_or_html"><code class="name flex">
<span>def <span class="ident">xml_or_html</span></span>(<span>view)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an <code><a title="refinery.lib.id.Fmt" href="#refinery.lib.id.Fmt">Fmt</a></code> indicating either XML or HTML, or None if the data does not
look like either of these formats at all.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L788-L820" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def xml_or_html(view: buf):
    &#34;&#34;&#34;
    Returns an `refinery.lib.id.Fmt` indicating either XML or HTML, or None if the data does not
    look like either of these formats at all.
    &#34;&#34;&#34;
    if tag_match := re.search(BR&#39;&#39;&#39;(?x)
        ^               # at the very start of the document
        \s{0,10}        # allow for some leading white space
        &lt;               # a tag opens
        ([?!]?          # allow for question or exclamation mark
         [-:\w]{3,64})  # the tag name
        \s{0,20}        # white space after tag name
        (/?&gt;            # the tag may end here, or:
        |[-:\w]{3,32})  # we have an attribute.
    &#39;&#39;&#39;, view, flags=re.DOTALL):
        tag = tag_match[1].lower()
        end = tag_match[2].lower()
        # &lt;?xml...
        if tag == b&#39;?xml&#39;:
            return Fmt.XML
        # &lt;HTML&gt;
        # &lt;BODY&gt;
        if tag in (b&#39;html&#39;, b&#39;body&#39;):
            return Fmt.HTM
        # &lt;!DOCTYPE html
        if tag == b&#39;!doctype&#39; and end == b&#39;html&#39;:
            return Fmt.HTM
        # &lt;project xmlns:xsi=...
        if end.startswith(b&#39;xml&#39;):
            return Fmt.XML
        else:
            return Fmt.HTM
    return None</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.ascii_view"><code class="name flex">
<span>def <span class="ident">ascii_view</span></span>(<span>data, window_size=4096, ascii_ratio=0.98)</span>
</code></dt>
<dd>
<section class="desc"><p>If the input data looks like text, get a memoryview of the least significant bytes of each
encoded letter. Otherwise, return None. Whether or not the data looks like text is determined
using <code><a title="refinery.lib.id.guess_text_encoding" href="#refinery.lib.id.guess_text_encoding">guess_text_encoding()</a></code>; all parameters are forwarded to this function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L823-L834" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ascii_view(
    data: buf,
    window_size: int = 0x1000,
    ascii_ratio: float = 0.98,
):
    &#34;&#34;&#34;
    If the input data looks like text, get a memoryview of the least significant bytes of each
    encoded letter. Otherwise, return None. Whether or not the data looks like text is determined
    using `refinery.lib.id.guess_text_encoding`; all parameters are forwarded to this function.
    &#34;&#34;&#34;
    if encoding := guess_text_encoding(data, window_size=window_size, ascii_ratio=ascii_ratio):
        return memoryview(data)[encoding.lsb:len(data):encoding.step]</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.is_likely_eml"><code class="name flex">
<span>def <span class="ident">is_likely_eml</span></span>(<span>data, window_size=65536)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks the input for common strings that occur as email headers. If at least two are found,
the function returns True.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L837-L863" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_likely_eml(
    data: buf,
    window_size: int = 0x10000,
):
    &#34;&#34;&#34;
    Checks the input for common strings that occur as email headers. If at least two are found,
    the function returns True.
    &#34;&#34;&#34;
    hits = 0
    view = memoryview(data)[:window_size]
    for marker in (
        b&#39;\nReceived:\x20from&#39;,
        b&#39;\nSubject:\x20&#39;,
        b&#39;\nTo:\x20&#39;,
        b&#39;\nFrom:\x20&#39;,
        b&#39;\nMessage-ID:\x20&#39;,
        b&#39;\nBcc:\x20&#39;,
        b&#39;\nContent-Transfer-Encoding:\x20&#39;,
        b&#39;\nContent-Type:\x20&#39;,
        b&#39;\nReturn-Path:\x20&#39;,
    ):
        if not buffer_contains(view, marker):
            continue
        if (hits := hits + 1) &gt;= 2:
            return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.is_likely_vbe"><code class="name flex">
<span>def <span class="ident">is_likely_vbe</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks whether the input contains the known markers used by encoded Visual Basic scripts.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L866-L875" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_likely_vbe(data: buf):
    &#34;&#34;&#34;
    Checks whether the input contains the known markers used by encoded Visual Basic scripts.
    &#34;&#34;&#34;
    view = memoryview(data)
    if not buffer_contains(view[:+64], BR&#39;#@~^&#39;):
        return False
    if not buffer_contains(view[-64:], BR&#39;==^#~@&#39;):
        return False
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.is_likely_json"><code class="name flex">
<span>def <span class="ident">is_likely_json</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>A fast regular expression based check for whether the input looks like JSON. The expression
checks whether the input is a sequence of valid JSON tokens: quoted strings, constants,
integer and floating-point numbers, and control characters. To be explicit, note that this
function cannot check for correct nesting, regular expressions are insufficient for this.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L878-L899" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_likely_json(data: buf):
    &#34;&#34;&#34;
    A fast regular expression based check for whether the input looks like JSON. The expression
    checks whether the input is a sequence of valid JSON tokens: quoted strings, constants,
    integer and floating-point numbers, and control characters. To be explicit, note that this
    function cannot check for correct nesting, regular expressions are insufficient for this.
    &#34;&#34;&#34;
    _json = RB&#34;&#34;&#34;
        \s*((                               # a sequence of the following tokens:
           &#34;([^&#34;\\\r\n]|\\[^\r\n])*&#34;        # a quoted string literal
          | true                            # true
          | false                           # false
          | null                            # null
          | [-+]?([1-9]\d*|0)               # an integer
          | [-+]?\d*\.?\d+([eE][-+]?\d+)?   # a float
          | [\{\}\[\]:,]                    # a structural token
        # | //(.*?)\n                       # do not allow comments (line)
        # | /\*.*?\*/                       # do not allow comments (block)
        )\s*)*?
    &#34;&#34;&#34;
    _json = RB&#39;(?x)\s*(\{%s\})|(\[%s\])\s*&#39; % (_json, _json)
    return re.fullmatch(_json, data) is not None</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.get_microsoft_format"><code class="name flex">
<span>def <span class="ident">get_microsoft_format</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks for various Microsoft formats. This includes Access Database files and OneNote, but most
importantly it can distinguish between various compound document formats like MSI, Word, Excel,
PowerPoint, and Outlook.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L902-L962" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_structural_check
def get_microsoft_format(data: buf):
    &#34;&#34;&#34;
    Checks for various Microsoft formats. This includes Access Database files and OneNote, but most
    importantly it can distinguish between various compound document formats like MSI, Word, Excel,
    PowerPoint, and Outlook.
    &#34;&#34;&#34;
    if data[:19] == b&#39;\0\01\0\0Standard ACE DB&#39;:
        return Fmt.MDB
    if data[:19] == b&#39;\0\01\0\0Standard Jet DB&#39;:
        return Fmt.MDB
    if data[:4] != B&#39;\xD0\xCF\x11\xE0&#39;:
        return None
    if data[4:8] != B&#39;\xA1\xB1\x1A\xE1&#39; and any(data[4:12]):
        return None
    if buffer_contains(data, b&#39;\xE4\x52\x5C\x7B\x8C\xD8\xA7\x4D\xAE\xB1\x53\x78\xD0\x29\x96\xD3&#39;):
        return Fmt.ONE
    for k in range(0x200, 0x10000, 0x200):
        mark = int.from_bytes(data[k:k + 4], &#39;little&#39;)
        if mark == 0x00C1A5EC:
            return Fmt.DOC
        if mark == 0x00100809 and data[k + 4:k + 8] == B&#39;\x00\x06\x05\x00&#39;:
            return Fmt.XLS
        if mark == 0xF01D46A0:
            return Fmt.PPT
        if mark == 0xF01E6E00:
            return Fmt.PPT
        if mark == 0x03E8000F:
            return Fmt.PPT
    if buffer_contains(data, b&#39;W\0o\0r\0d\0D\0o\0c\0u\0m\0e\0n\0t\0&#39;):
        # WordDocument
        return Fmt.DOC
    if buffer_contains(data, b&#39;P\0o\0w\0e\0r\0P\0o\0i\0n\0t\0&#39;):
        # PowerPoint
        return Fmt.PPT
    if buffer_contains(data, b&#39;W\0o\0r\0k\0b\0o\0o\0k\0&#39;):
        # Workbook
        return Fmt.XLS
    if buffer_contains(data, b&#39;_\0_\0s\0u\0b\0s\0t\0g\01\0.\00\0_\0&#39;):
        # __substg1._
        return Fmt.MSG
    if buffer_contains(data, b&#39;_\0_\0n\0a\0m\0e\0i\0d\0_\0v\0e\0r\0s\0i\0o\0n\0&#39;):
        # __nameid_version
        return Fmt.MSG
    if buffer_contains(data, b&#39;_\0_\0r\0e\0c\0i\0p\0_\0v\0e\0r\0s\0i\0o\0n\0&#39;):
        # __recip_version
        return Fmt.MSG
    if buffer_contains(data, b&#39;_\0_\0p\0r\0o\0p\0e\0r\0t\0i\0e\0s\0_\0v\0e\0r\0s\0i\0o\0n\0&#39;):
        # __properties_version
        return Fmt.MSG
    if buffer_contains(data, b&#39;B\0o\0o\0k\0&#39;):
        # Book
        return Fmt.XLS
    if buffer_contains(data, B&#39;E\0n\0c\0r\0y\0p\0t\0e\0d\0P\0a\0c\0k\0a\0g\0e\0&#39;):
        return Fmt.OFFICECRYPT
    if re.search(b&#39;Property|ProductCode|UpgradeCode|PackageCode|InstallExecuteSequence|Component|Feature|File|Media&#39;, data):
        return Fmt.MSI
    if re.search(B&#39;Msi(?:[A-Z][a-z]{2,30}){2,5}&#39;, data):
        return Fmt.MSI
    else:
        return Fmt.CFF</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.get_office_xml_type"><code class="name flex">
<span>def <span class="ident">get_office_xml_type</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks for known XML-based Office document types like DOCX, XLSX, and PPTX.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L965-L990" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_structural_check
def get_office_xml_type(data: buf):
    &#34;&#34;&#34;
    Checks for known XML-based Office document types like DOCX, XLSX, and PPTX.
    &#34;&#34;&#34;
    if data[:2] != B&#39;PK&#39;:
        return None
    if buffer_contains(data, B&#39;application/vnd.oasis.opendocument.text&#39;):
        if buffer_contains(data, B&#39;settings.xml&#39;):
            return Fmt.ODT
        if buffer_contains(data, B&#39;META-INF/manifest.xml&#39;):
            return Fmt.ODT
    if not buffer_contains(data, B&#39;_rels/.rels&#39;):
        return None
    if not buffer_contains(data, B&#39;[Content_Types].xml&#39;):
        return None
    if buffer_contains(data, B&#39;word/document.xml&#39;):
        return Fmt.DOCX
    if buffer_contains(data, B&#39;xl/document.xml&#39;):
        return Fmt.XLSX
    if buffer_contains(data, B&#39;xl/workbook.xml&#39;):
        return Fmt.XLSX
    if buffer_contains(data, B&#39;xl/worksheets/&#39;):
        return Fmt.XLSX
    if buffer_contains(data, B&#39;ppt/presentation.xml&#39;):
        return Fmt.PPTX</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.get_compression_type"><code class="name flex">
<span>def <span class="ident">get_compression_type</span></span>(<span>data, entropy_minimum=0.7, entropy_look_at=8192)</span>
</code></dt>
<dd>
<section class="desc"><p>This method looks for any of a number of known magic signatures for compression and archive
formats. If one is find, the method selects a data window from the rest of the buffer and
computes its entropy. If the entropy exceeds the given threshold, the input is idenfied as
a known compression format.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L993-L1077" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_structural_check
def get_compression_type(
    data: buf,
    entropy_minimum: float = 0.7,
    entropy_look_at: int = 0x2000,
):
    &#34;&#34;&#34;
    This method looks for any of a number of known magic signatures for compression and archive
    formats. If one is find, the method selects a data window from the rest of the buffer and
    computes its entropy. If the entropy exceeds the given threshold, the input is idenfied as
    a known compression format.
    &#34;&#34;&#34;
    size = len(data)
    view = memoryview(data)
    T = True
    F = False

    if data[:4] == b&#39;\04\0\0\0&#39; and data[0x10:0x18] == B&#39;{&#34;files&#34;&#39;:
        return Fmt.ASAR

    for format, entropy_required, offset, signature in (
        (Fmt.APLIB       , T, 0, B&#39;AP32&#39;),                                      # noqa
        (Fmt.ACE         , F, 7, B&#39;**ACE**&#39;),                                   # noqa
        (Fmt.BZ2         , T, 0, B&#39;BZh&#39;),                                       # noqa
        (Fmt.JCALG       , T, 0, B&#39;JC&#39;),                                        # noqa
        (Fmt.LZMA        , T, 0, B&#39;\x5D\0\0\0&#39;),                                # noqa
        (Fmt.LZMA        , T, 0, B&#39;\xFD7zXZ&#39;),                                  # noqa
        (Fmt.RNC         , T, 0, B&#39;RNC\x01&#39;),                                   # noqa
        (Fmt.RNC         , T, 0, B&#39;RNC\x02&#39;),                                   # noqa
        (Fmt.LZF         , T, 0, B&#39;ZV&#39;),                                        # noqa
        (Fmt.LZG         , T, 0, B&#39;LZG&#39;),                                       # noqa
        (Fmt.LZIP        , T, 0, B&#39;LZIP&#39;),                                      # noqa
        (Fmt.LZ4         , T, 0, B&#39;\x04\x22\x4D\x18&#39;),                          # noqa
        (Fmt.LZO         , F, 0, B&#39;\x89\x4c\x5a\x4f\x00\x0d\x0a\x1a\x0a&#39;),      # noqa
        (Fmt.LZH         , T, 0, B&#39;\x1F\xA0&#39;),                                  # noqa
        (Fmt.LZW         , T, 0, B&#39;\x1F\x9D&#39;),                                  # noqa
        (Fmt.GZIP        , T, 0, B&#39;\x1F\x8B&#39;),                                  # noqa
        (Fmt.XZ          , F, 0, B&#39;\xFD\x37\x7A\x58\x5A\x00&#39;),                  # noqa
        (Fmt.MSCF        , T, 0, B&#39;\x0A\x51\xE5\xC0&#39;),                          # noqa
        (Fmt.RAR         , T, 0, B&#39;Rar!\x1A\x07&#39;),                              # noqa
        (Fmt.XAR         , T, 0, B&#39;xar!&#39;),                                      # noqa
        (Fmt.SZDD        , T, 0, B&#39;SZDD&#39;),                                      # noqa
        (Fmt.ZLIB0       , T, 0, B&#39;\x78\x01&#39;),                                  # noqa
        (Fmt.ZLIB1       , T, 0, B&#39;\x78\x5E&#39;),                                  # noqa
        (Fmt.ZLIB2       , T, 0, B&#39;\x78\x9C&#39;),                                  # noqa
        (Fmt.ZLIB3       , T, 0, B&#39;\x78\xDA&#39;),                                  # noqa
        (Fmt.ZLIB4       , T, 0, B&#39;\x78\x20&#39;),                                  # noqa
        (Fmt.ZLIB5       , T, 0, B&#39;\x78\x7D&#39;),                                  # noqa
        (Fmt.ZLIB6       , T, 0, B&#39;\x78\xBB&#39;),                                  # noqa
        (Fmt.ZLIB7       , T, 0, B&#39;\x78\xF9&#39;),                                  # noqa
        (Fmt.LZFSE       , T, 0, B&#39;bvx2&#39;),                                      # noqa
        (Fmt.ZSTD        , T, 0, B&#39;\x28\xB5\x2F\xFD&#39;),                          # noqa
        (Fmt.ZIP7        , T, 0, B&#39;7z\xBC\xAF\x27\x1C&#39;),                        # noqa
        (Fmt.CAB         , T, 0, B&#39;MSCF&#39;),                                      # noqa
        (Fmt.CHM         , T, 0, B&#39;ITSF&#39;),                                      # noqa
        (Fmt.CPIO        , F, 0, B&#39;070701&#39;),                                    # noqa
        (Fmt.CPIO        , F, 0, B&#39;070702&#39;),                                    # noqa
        (Fmt.CPIO        , F, 0, B&#39;070707&#39;),                                    # noqa
        (Fmt.ZIP         , T, 0, B&#39;PK\x03\x04&#39;),                                # noqa
        (Fmt.ZIP         , T, 0, B&#39;PK\x05\x06&#39;),                                # noqa
        (Fmt.ZIP         , T, 0, B&#39;PK\x07\x08&#39;),                                # noqa
        (Fmt.ISO         , F, 0x8001, B&#39;CD001&#39;),                                # noqa
        (Fmt.ISO         , F, 0x8801, B&#39;CD001&#39;),                                # noqa
        (Fmt.ISO         , F, 0x9001, B&#39;CD001&#39;),                                # noqa
        (Fmt.ISZ         , T, 0, B&#39;IsZ!&#39;),                                      # noqa
        (Fmt.TAR         , F, 257, B&#39;ustar&#39;),                                   # noqa
        (Fmt.OAR         , T, 0, B&#39;OAR&#39;),                                       # noqa
        (Fmt.ZPQ         , T, 0, B&#39;7kSt\xA01\x83\xD3\x8C\xB2\x28\xB0\xD3zPQ&#39;),  # noqa
        (Fmt.VMDK        , T, 0, B&#39;KDM&#39;),                                       # noqa
        (Fmt.VMDK        , T, 0, B&#39;# Disk Descripto&#39;),                          # noqa
        (Fmt.VHD         , T, 0, B&#39;conectix&#39;),                                  # noqa
        (Fmt.VHD         , T, 0, B&#39;vhdxfile&#39;),                                  # noqa
        (Fmt.DMG         , T, size - 512, B&#39;koly&#39;),                             # noqa
    ):
        if view[offset:offset + len(signature)] == signature:
            if not entropy_required or len(data) &lt; 0x100:
                return format
            for start in (0x1000, 0x400, 0x200, 0x100, 0x80, 0x40, 0x20, 0x10):
                if len(view) &gt;= start + entropy_look_at:
                    view = view[start:]
                    break
            else:
                return format
            if entropy(view[:entropy_look_at]) &gt;= entropy_minimum:
                return format</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.get_image_format"><code class="name flex">
<span>def <span class="ident">get_image_format</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Determine an image format based on known magic signatures or return None if there is no
match.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L1080-L1153" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_structural_check
def get_image_format(data: buf):
    &#34;&#34;&#34;
    Determine an image format based on known magic signatures or return None if there is no
    match.
    &#34;&#34;&#34;
    if data[:4] == B&#39;\0\0\x01\0&#39;:
        count = int.from_bytes(data[4:6], &#39;little&#39;)
        if not 1 &lt;= count &lt;= 100:
            return None
        w, h, _, r = data[6:10]
        if r != 0:
            return None
        p = int.from_bytes(data[10:12], &#39;little&#39;) # planes
        b = int.from_bytes(data[12:14], &#39;little&#39;) # bit count
        if not any((w == h, p == 1, b in (1, 2, 4, 8, 16, 24, 32, 64, 96, 128, 256))):
            return None
        return Fmt.ICO

    if data[:3] == B&#39;\xFF\xD8\xFF&#39;:
        if data[3] in (0xDB, 0xEE, 0xE0):
            return Fmt.JPG
        if data[3] == 0xE1 and data[6:12] == B&#39;Exif\0\0&#39;:
            return Fmt.JPG
        return None

    if data[:4] == b&#39;FORM&#39;:
        if data[8:12] in (
            B&#39;ILBM&#39;,
            B&#39;8SVX&#39;,
            B&#39;ACBM&#39;,
            B&#39;ANBM&#39;,
            B&#39;ANIM&#39;,
            B&#39;FAXX&#39;,
            B&#39;FTXT&#39;,
            B&#39;SMUS&#39;,
            B&#39;CMUS&#39;,
            B&#39;YUVN&#39;,
            B&#39;FANT&#39;,
            B&#39;AIFF&#39;,
        ):
            return Fmt.IFF
        else:
            return None

    for format, signature in (
        (Fmt.HIC, b&#39;ftypheic&#39;),
        (Fmt.GIF, B&#39;GIF87a&#39;),
        (Fmt.GIF, B&#39;GIF89a&#39;),
        (Fmt.TIF, B&#39;\x49\x49\x2A\x00&#39;),
        (Fmt.TIF, B&#39;\x4D\x4D\x00\x2A&#39;),
        (Fmt.TIF, B&#39;\x49\x49\x2B\x00&#39;),
        (Fmt.TIF, B&#39;\x4D\x4D\x00\x2B&#39;),
        (Fmt.CIN, B&#39;\x80\x2A\x5F\xD7&#39;),
        (Fmt.NUI, B&#39;NURUIMG&#39;),
        (Fmt.NUI, B&#39;NURUPAL&#39;),
        (Fmt.DPX, B&#39;SDPX&#39;),
        (Fmt.DPX, B&#39;XPDS&#39;),
        (Fmt.BPG, B&#39;BPG\xFB&#39;),
        (Fmt.EXR, B&#39;\x76\x2F\x31\x01&#39;),
        (Fmt.JP2, B&#39;\x00\x00\x00\x0C\x6A\x50\x20\x20\x0D\x0A\x87\x0A&#39;),
        (Fmt.JP2, B&#39;\xFF\x4F\xFF\x51&#39;),
        (Fmt.QOI, B&#39;\x71\x6f\x69\x66&#39;),
        (Fmt.PNG, B&#39;\x89\x50\x4E\x47\x0D\x0A\x1A\x0A&#39;),
        (Fmt.PSD, B&#39;8BPS&#39;),
        (Fmt.BMP, B&#39;BM&#39;),
        (Fmt.FIF, B&#39;FLIF&#39;),
        (Fmt.LEP, B&#39;\xCF\x84\x01&#39;),
        (Fmt.HDR, B&#39;#?RADIANCE\n&#39;),
        (Fmt.IDB, B&#39;IDA1&#39;),
        (Fmt.I64, B&#39;IDA2&#39;),
    ):
        if data[:len(signature)] == signature:
            return format</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.get_media_format"><code class="name flex">
<span>def <span class="ident">get_media_format</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Determine a multi-media format based on known magic signatures or return None if there is no
match.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L1156-L1200" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_structural_check
def get_media_format(data: buf):
    &#34;&#34;&#34;
    Determine a multi-media format based on known magic signatures or return None if there is no
    match.
    &#34;&#34;&#34;
    if data[:4] == B&#39;RIFF&#39;:
        if data[8:12] == b&#39;WAVE&#39;:
            return Fmt.WAV
        if data[8:12] == b&#39;AVI &#39;:
            return Fmt.AVI
        return None

    for format, signature in (
        (Fmt.OGG, B&#39;OggS&#39;),
        (Fmt.MP3, B&#39;\xFF\xFB&#39;),
        (Fmt.MP3, B&#39;\xFF\xF3&#39;),
        (Fmt.MP3, B&#39;\xFF\xF2&#39;),
        (Fmt.MP3, B&#39;ID3&#39;),
        (Fmt.M3U, B&#39;#EXTM3U&#39;),
        (Fmt.MPG, B&#39;\0\0\01\xBA&#39;),
        (Fmt.MPG, B&#39;\0\0\01\xB3&#39;),
        (Fmt.FLC, B&#39;fLaC&#39;),
        (Fmt.MID, B&#39;MThd&#39;),
        (Fmt.MKV, B&#39;\x1A\x45\xDF\xA3&#39;),
        (Fmt.SWF, B&#39;CWS&#39;),
        (Fmt.SWF, B&#39;FWS&#39;),
        (Fmt.SIL, B&#39;#!SILK\n&#39;),
    ):
        if data[:len(signature)] == signature:
            return format

    if data[4:12] in (B&#39;ftypisom&#39;, B&#39;ftypMSNV&#39;):
        return Fmt.MPG

    if data[4:10] == B&#39;ftypM4&#39;:
        return Fmt.MP4

    if len(data) &lt; 0x1000:
        return None

    stop = min(len(data), 0x10000)
    if all(data[i] == 0x47 for i in range(0, stop, 188)):
        if any(data[i - 1] != 0x47 for i in range(0, stop, 188)):
            return Fmt.MPG</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.get_serialization_format"><code class="name flex">
<span>def <span class="ident">get_serialization_format</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks for known data serialization formats.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L1203-L1212" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_structural_check
def get_serialization_format(data: buf):
    &#34;&#34;&#34;
    Checks for known data serialization formats.
    &#34;&#34;&#34;
    if data[:4] == B&#39;\xAC\xED\x00\x05&#39;:
        return Fmt.S_JAV
    if data[:17] == B&#39;\0\01\0\0\0\xFF\xFF\xFF\xFF\x01\0\0\0\0\0\0\0&#39;:
        if data[17] in range(18) or data[17] in range(0x14, 0x17):
            return Fmt.S_DOT</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.get_misc_binary_formats"><code class="name flex">
<span>def <span class="ident">get_misc_binary_formats</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks for various other binary formats that are not covered by other methods in this module.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L1215-L1250" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_structural_check
def get_misc_binary_formats(data: buf):
    &#34;&#34;&#34;
    Checks for various other binary formats that are not covered by other methods in this module.
    &#34;&#34;&#34;
    if len(data) &gt;= 0x30 and PycMagicPattern.fullmatch(data[:4]):
        if any(data[offset] &amp; 0x7F == 0x63 for offset in (8, 12, 16)):
            return Fmt.PYC

    for format, signature in (
        (Fmt.PDF, B&#39;%PDF-&#39;),
        (Fmt.A3X, B&#39;\xA3\x48\x4B\xBE\x98\x6C\x4A\xA9\x99\x4C\x53\x0A\x86\xD6\x48\x7D\x41\x55\x33\x21&#39;),
        (Fmt.CHM, B&#39;ITSF&#39;),
        (Fmt.DSS, B&#39;\0\0\0\01Bud1&#39;),
        (Fmt.DJV, B&#39;AT&amp;TFORM&#39;),
        (Fmt.DEX, B&#39;dex\n035\0&#39;),
        (Fmt.IFPS, B&#39;IFPS&#39;),
        (Fmt.JAVA, B&#39;\xCA\xFE\xBA\xBE&#39;),
        (Fmt.WASM, B&#39;\0asm&#39;),
        (Fmt.LUAC, B&#39;\x1BLua&#39;),
        (Fmt.LNK, B&#39;L\0\0\0\01\x14\02\0\0\0\0\0\xC0\0\0\0\0\0\0F&#39;),
        (Fmt.DMP, B&#39;MDMP&#39;),
        (Fmt.PCAP, B&#39;\xD4\xC3\xB2\xA1&#39;),
        (Fmt.PCAP, B&#39;\xA1\xB2\xC3\xD4&#39;),
        (Fmt.PCAP, B&#39;\x4D\x3C\xB2\xA1&#39;),
        (Fmt.PCAP, B&#39;\xA1\xB2\x3C\x4D&#39;),
        (Fmt.PCAPNG, B&#39;\n\r\n\r&#39;),
        (Fmt.SSP, B&#39;SMSNF200&#39;),
        (Fmt.SQLITE, B&#39;SQLite format 3\0&#39;),
        (Fmt.PPK, B&#39;PuTTY-User-Key-File-&#39;),
        (Fmt.WIM, B&#39;MSWIM\0\0\0\xD0\0\0\0\0&#39;),
        (Fmt.EVT, B&#39;LfLe&#39;),
        (Fmt.EVTX, B&#39;ElfFile&#39;),
    ):
        if data[:len(signature)] == signature:
            return format</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.get_text_format"><code class="name flex">
<span>def <span class="ident">get_text_format</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements a heuristic check for whether the input is likely XML data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L1253-L1287" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@_structural_check
def get_text_format(data: buf):
    &#34;&#34;&#34;
    Implements a heuristic check for whether the input is likely XML data.
    &#34;&#34;&#34;
    encoding = guess_text_encoding(data)

    if encoding is None:
        return None

    step = encoding.step
    view = memoryview(data)[encoding.lsb:len(data):step]

    if is_likely_vbe(view):
        return Fmt.VBE
    if buffer_contains(view[:200], BR&#39;{\rtf&#39;):
        return Fmt.RTF
    if step == 1 and is_likely_eml(data):
        return Fmt.EML
    if step &gt; 1:
        # The following checks require a contiguous buffer for the regular expression searches.
        view = bytearray(view)
    if format := xml_or_html(view):
        return format
    if is_likely_json(view):
        return Fmt.JSON
    if step == 1:
        if encoding.codec == &#39;utf8&#39;:
            return Fmt.UTF08
        else:
            return Fmt.ASCII
    if step == 2:
        return Fmt.UTF16
    if step == 4:
        return Fmt.UTF32</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.get_structured_data_type"><code class="name flex">
<span>def <span class="ident">get_structured_data_type</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempts to determine whether the input data is just a meaningless blob or whether it has
structure, i.e. adheres to a known file format. Returns an <code><a title="refinery.lib.id.Fmt" href="#refinery.lib.id.Fmt">Fmt</a></code> or <code>None</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L1290-L1297" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_structured_data_type(data: buf):
    &#34;&#34;&#34;
    Attempts to determine whether the input data is just a meaningless blob or whether it has
    structure, i.e. adheres to a known file format. Returns an `refinery.lib.id.Fmt` or `None`.
    &#34;&#34;&#34;
    for check in StructuralChecks:
        if t := check(data):
            return t</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.is_likely_xml"><code class="name flex">
<span>def <span class="ident">is_likely_xml</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks whether the input data is likely an XML document.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L1300-L1306" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_likely_xml(data: buf):
    &#34;&#34;&#34;
    Checks whether the input data is likely an XML document.
    &#34;&#34;&#34;
    if view := ascii_view(data, window_size=0):
        return xml_or_html(view) == Fmt.XML
    return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.is_likely_htm"><code class="name flex">
<span>def <span class="ident">is_likely_htm</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks whether the input data is likely an HTML document.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L1309-L1315" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_likely_htm(data: buf):
    &#34;&#34;&#34;
    Checks whether the input data is likely an HTML document.
    &#34;&#34;&#34;
    if view := ascii_view(data, window_size=0):
        return xml_or_html(view) == Fmt.HTM
    return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.is_likely_msi"><code class="name flex">
<span>def <span class="ident">is_likely_msi</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks whether the input data is likely an MSI.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L1318-L1322" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_likely_msi(data: buf):
    &#34;&#34;&#34;
    Checks whether the input data is likely an MSI.
    &#34;&#34;&#34;
    return get_microsoft_format(data) == Fmt.MSI</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.is_likely_email"><code class="name flex">
<span>def <span class="ident">is_likely_email</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks whether the input data is likely a plain-text or Outlook email document.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L1325-L1331" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_likely_email(data: buf):
    &#34;&#34;&#34;
    Checks whether the input data is likely a plain-text or Outlook email document.
    &#34;&#34;&#34;
    if is_likely_eml(data):
        return True
    return get_microsoft_format(data) == Fmt.MSG</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.is_likely_doc"><code class="name flex">
<span>def <span class="ident">is_likely_doc</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L1334-L1339" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_likely_doc(data: buf):
    if get_microsoft_format(data) == Fmt.DOC:
        return True
    if get_office_xml_type(data) in (Fmt.DOCX, Fmt.ODT):
        return True
    return False</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.id.Format"><code class="flex name class">
<span>class <span class="ident">Format</span></span>
<span>(</span><span>category, extension=None, mnemonic=None, details=None, mime=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L117-L170" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Format:
    __slots__ = &#39;category&#39;, &#39;extension&#39;, &#39;mime&#39;, &#39;mnemonic&#39;, &#39;details&#39;

    def __hash__(self):
        return hash((self.category, self.mnemonic))

    def __str__(self):
        return self.mnemonic

    def __le__(self, them):
        if not isinstance(them, Format):
            return False
        t1 = set(self.mnemonic.split(&#39;/&#39;))
        t2 = set(them.mnemonic.split(&#39;/&#39;))
        return t1 &lt;= t2

    def __eq__(self, them):
        if not isinstance(them, Format):
            return False
        return self.mnemonic == them.mnemonic

    def __ne__(self, them):
        return not self.__eq__(them)

    def __iter__(self):
        yield self.category
        yield self.extension
        yield self.mnemonic
        yield self.details
        yield self.mime

    def __init__(
        self,
        category: FormatCategory,
        extension: str | None = None,
        mnemonic: str | None = None,
        details: str | None = None,
        mime: str | None = None,
    ) -&gt; None:
        self.category = category
        self.extension = extension or &#39;bin&#39;
        self.mnemonic = mnemonic or self.extension.upper()
        self.details = details or self.mnemonic

        if mime is None:
            try:
                mime = MimeByExtension[self.extension]
            except KeyError:
                if category == FormatCategory.Text:
                    mime = &#39;text/plain&#39;
                else:
                    mime = &#39;application/ocet-stream&#39;

        self.mime = mime</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.id.Fmt" href="#refinery.lib.id.Fmt">Fmt</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.id.Format.category"><code class="name">var <span class="ident">category</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L117-L170" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Format:
    __slots__ = &#39;category&#39;, &#39;extension&#39;, &#39;mime&#39;, &#39;mnemonic&#39;, &#39;details&#39;

    def __hash__(self):
        return hash((self.category, self.mnemonic))

    def __str__(self):
        return self.mnemonic

    def __le__(self, them):
        if not isinstance(them, Format):
            return False
        t1 = set(self.mnemonic.split(&#39;/&#39;))
        t2 = set(them.mnemonic.split(&#39;/&#39;))
        return t1 &lt;= t2

    def __eq__(self, them):
        if not isinstance(them, Format):
            return False
        return self.mnemonic == them.mnemonic

    def __ne__(self, them):
        return not self.__eq__(them)

    def __iter__(self):
        yield self.category
        yield self.extension
        yield self.mnemonic
        yield self.details
        yield self.mime

    def __init__(
        self,
        category: FormatCategory,
        extension: str | None = None,
        mnemonic: str | None = None,
        details: str | None = None,
        mime: str | None = None,
    ) -&gt; None:
        self.category = category
        self.extension = extension or &#39;bin&#39;
        self.mnemonic = mnemonic or self.extension.upper()
        self.details = details or self.mnemonic

        if mime is None:
            try:
                mime = MimeByExtension[self.extension]
            except KeyError:
                if category == FormatCategory.Text:
                    mime = &#39;text/plain&#39;
                else:
                    mime = &#39;application/ocet-stream&#39;

        self.mime = mime</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.Format.details"><code class="name">var <span class="ident">details</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L117-L170" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Format:
    __slots__ = &#39;category&#39;, &#39;extension&#39;, &#39;mime&#39;, &#39;mnemonic&#39;, &#39;details&#39;

    def __hash__(self):
        return hash((self.category, self.mnemonic))

    def __str__(self):
        return self.mnemonic

    def __le__(self, them):
        if not isinstance(them, Format):
            return False
        t1 = set(self.mnemonic.split(&#39;/&#39;))
        t2 = set(them.mnemonic.split(&#39;/&#39;))
        return t1 &lt;= t2

    def __eq__(self, them):
        if not isinstance(them, Format):
            return False
        return self.mnemonic == them.mnemonic

    def __ne__(self, them):
        return not self.__eq__(them)

    def __iter__(self):
        yield self.category
        yield self.extension
        yield self.mnemonic
        yield self.details
        yield self.mime

    def __init__(
        self,
        category: FormatCategory,
        extension: str | None = None,
        mnemonic: str | None = None,
        details: str | None = None,
        mime: str | None = None,
    ) -&gt; None:
        self.category = category
        self.extension = extension or &#39;bin&#39;
        self.mnemonic = mnemonic or self.extension.upper()
        self.details = details or self.mnemonic

        if mime is None:
            try:
                mime = MimeByExtension[self.extension]
            except KeyError:
                if category == FormatCategory.Text:
                    mime = &#39;text/plain&#39;
                else:
                    mime = &#39;application/ocet-stream&#39;

        self.mime = mime</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.Format.extension"><code class="name">var <span class="ident">extension</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L117-L170" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Format:
    __slots__ = &#39;category&#39;, &#39;extension&#39;, &#39;mime&#39;, &#39;mnemonic&#39;, &#39;details&#39;

    def __hash__(self):
        return hash((self.category, self.mnemonic))

    def __str__(self):
        return self.mnemonic

    def __le__(self, them):
        if not isinstance(them, Format):
            return False
        t1 = set(self.mnemonic.split(&#39;/&#39;))
        t2 = set(them.mnemonic.split(&#39;/&#39;))
        return t1 &lt;= t2

    def __eq__(self, them):
        if not isinstance(them, Format):
            return False
        return self.mnemonic == them.mnemonic

    def __ne__(self, them):
        return not self.__eq__(them)

    def __iter__(self):
        yield self.category
        yield self.extension
        yield self.mnemonic
        yield self.details
        yield self.mime

    def __init__(
        self,
        category: FormatCategory,
        extension: str | None = None,
        mnemonic: str | None = None,
        details: str | None = None,
        mime: str | None = None,
    ) -&gt; None:
        self.category = category
        self.extension = extension or &#39;bin&#39;
        self.mnemonic = mnemonic or self.extension.upper()
        self.details = details or self.mnemonic

        if mime is None:
            try:
                mime = MimeByExtension[self.extension]
            except KeyError:
                if category == FormatCategory.Text:
                    mime = &#39;text/plain&#39;
                else:
                    mime = &#39;application/ocet-stream&#39;

        self.mime = mime</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.Format.mime"><code class="name">var <span class="ident">mime</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L117-L170" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Format:
    __slots__ = &#39;category&#39;, &#39;extension&#39;, &#39;mime&#39;, &#39;mnemonic&#39;, &#39;details&#39;

    def __hash__(self):
        return hash((self.category, self.mnemonic))

    def __str__(self):
        return self.mnemonic

    def __le__(self, them):
        if not isinstance(them, Format):
            return False
        t1 = set(self.mnemonic.split(&#39;/&#39;))
        t2 = set(them.mnemonic.split(&#39;/&#39;))
        return t1 &lt;= t2

    def __eq__(self, them):
        if not isinstance(them, Format):
            return False
        return self.mnemonic == them.mnemonic

    def __ne__(self, them):
        return not self.__eq__(them)

    def __iter__(self):
        yield self.category
        yield self.extension
        yield self.mnemonic
        yield self.details
        yield self.mime

    def __init__(
        self,
        category: FormatCategory,
        extension: str | None = None,
        mnemonic: str | None = None,
        details: str | None = None,
        mime: str | None = None,
    ) -&gt; None:
        self.category = category
        self.extension = extension or &#39;bin&#39;
        self.mnemonic = mnemonic or self.extension.upper()
        self.details = details or self.mnemonic

        if mime is None:
            try:
                mime = MimeByExtension[self.extension]
            except KeyError:
                if category == FormatCategory.Text:
                    mime = &#39;text/plain&#39;
                else:
                    mime = &#39;application/ocet-stream&#39;

        self.mime = mime</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.Format.mnemonic"><code class="name">var <span class="ident">mnemonic</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L117-L170" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Format:
    __slots__ = &#39;category&#39;, &#39;extension&#39;, &#39;mime&#39;, &#39;mnemonic&#39;, &#39;details&#39;

    def __hash__(self):
        return hash((self.category, self.mnemonic))

    def __str__(self):
        return self.mnemonic

    def __le__(self, them):
        if not isinstance(them, Format):
            return False
        t1 = set(self.mnemonic.split(&#39;/&#39;))
        t2 = set(them.mnemonic.split(&#39;/&#39;))
        return t1 &lt;= t2

    def __eq__(self, them):
        if not isinstance(them, Format):
            return False
        return self.mnemonic == them.mnemonic

    def __ne__(self, them):
        return not self.__eq__(them)

    def __iter__(self):
        yield self.category
        yield self.extension
        yield self.mnemonic
        yield self.details
        yield self.mime

    def __init__(
        self,
        category: FormatCategory,
        extension: str | None = None,
        mnemonic: str | None = None,
        details: str | None = None,
        mime: str | None = None,
    ) -&gt; None:
        self.category = category
        self.extension = extension or &#39;bin&#39;
        self.mnemonic = mnemonic or self.extension.upper()
        self.details = details or self.mnemonic

        if mime is None:
            try:
                mime = MimeByExtension[self.extension]
            except KeyError:
                if category == FormatCategory.Text:
                    mime = &#39;text/plain&#39;
                else:
                    mime = &#39;application/ocet-stream&#39;

        self.mime = mime</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.id.FormatCategory"><code class="flex name class">
<span>class <span class="ident">FormatCategory</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L173-L182" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class FormatCategory(enum.IntEnum):
    Executable = enum.auto()
    Text = enum.auto()
    Document = enum.auto()
    Image = enum.auto()
    Binary = enum.auto()
    Media = enum.auto()
    Archive = enum.auto()
    Compression = enum.auto()
    Serialized = enum.auto()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.id.FormatCategory.Executable"><code class="name">var <span class="ident">Executable</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Text"><code class="name">var <span class="ident">Text</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Document"><code class="name">var <span class="ident">Document</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Image"><code class="name">var <span class="ident">Image</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Binary"><code class="name">var <span class="ident">Binary</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Media"><code class="name">var <span class="ident">Media</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Archive"><code class="name">var <span class="ident">Archive</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Compression"><code class="name">var <span class="ident">Compression</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Serialized"><code class="name">var <span class="ident">Serialized</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.id.FormatCategory"><code class="flex name class">
<span>class <span class="ident">FC</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L173-L182" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class FormatCategory(enum.IntEnum):
    Executable = enum.auto()
    Text = enum.auto()
    Document = enum.auto()
    Image = enum.auto()
    Binary = enum.auto()
    Media = enum.auto()
    Archive = enum.auto()
    Compression = enum.auto()
    Serialized = enum.auto()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.id.FormatCategory.Executable"><code class="name">var <span class="ident">Executable</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Text"><code class="name">var <span class="ident">Text</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Document"><code class="name">var <span class="ident">Document</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Image"><code class="name">var <span class="ident">Image</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Binary"><code class="name">var <span class="ident">Binary</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Media"><code class="name">var <span class="ident">Media</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Archive"><code class="name">var <span class="ident">Archive</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Compression"><code class="name">var <span class="ident">Compression</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.FormatCategory.Serialized"><code class="name">var <span class="ident">Serialized</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.id.Fmt"><code class="flex name class">
<span>class <span class="ident">Fmt</span></span>
<span>(</span><span>category, extension=None, mnemonic=None, details=None, mime=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration of all known file formats that can be returned by
<code><a title="refinery.lib.id.get_structured_data_type" href="#refinery.lib.id.get_structured_data_type">get_structured_data_type()</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L219-L390" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Fmt(Format, enum.Enum):
    &#34;&#34;&#34;
    An enumeration of all known file formats that can be returned by
     `refinery.lib.id.get_structured_data_type`.
    &#34;&#34;&#34;
    ELF = (FC.Executable, &#39;elf&#39;, &#39;ELF&#39;)
    MACHO = (FC.Executable, &#39;macho&#39;, &#39;MachO&#39;)
    PE = (FC.Executable, &#39;exe&#39;, &#39;PE&#39;)

    PE32GUI = (FC.Executable, &#39;exe&#39;, &#39;PE/32/GUI&#39;)
    PE32CUI = (FC.Executable, &#39;exe&#39;, &#39;PE/32/CUI&#39;)
    PE32DLL = (FC.Executable, &#39;dll&#39;, &#39;PE/32/DLL&#39;)
    PE32SYS = (FC.Executable, &#39;sys&#39;, &#39;PE/32/SYS&#39;)
    PE64GUI = (FC.Executable, &#39;exe&#39;, &#39;PE/64/GUI&#39;)
    PE64CUI = (FC.Executable, &#39;exe&#39;, &#39;PE/64/CUI&#39;)
    PE64DLL = (FC.Executable, &#39;dll&#39;, &#39;PE/64/DLL&#39;)
    PE64SYS = (FC.Executable, &#39;sys&#39;, &#39;PE/64/SYS&#39;)

    ELF32LE = (FC.Executable, &#39;elf&#39;, &#39;ELF/32/LE&#39;)
    ELF64LE = (FC.Executable, &#39;elf&#39;, &#39;ELF/64/LE&#39;)
    ELF32BE = (FC.Executable, &#39;elf&#39;, &#39;ELF/32/BE&#39;)
    ELF64BE = (FC.Executable, &#39;elf&#39;, &#39;ELF/64/BE&#39;)

    MACHOuvLE = (FC.Executable, &#39;macho&#39;, &#39;MachO/Fat/LE&#39;)
    MACHOuvBE = (FC.Executable, &#39;macho&#39;, &#39;MachO/Fat/BE&#39;)
    MACHO32LE = (FC.Executable, &#39;macho&#39;, &#39;MachO/32/LE&#39;)
    MACHO64LE = (FC.Executable, &#39;macho&#39;, &#39;MachO/64/LE&#39;)
    MACHO32BE = (FC.Executable, &#39;macho&#39;, &#39;MachO/32/BE&#39;)
    MACHO64BE = (FC.Executable, &#39;macho&#39;, &#39;MachO/64/BE&#39;)

    JAVA = (FC.Executable, &#39;class&#39;, &#39;JavaClass&#39;)
    DEX = (FC.Executable, &#39;dex&#39;, &#39;Dalvik&#39;)
    WASM = (FC.Executable, &#39;wasm&#39;, &#39;WASM&#39;, &#39;Web Assembly&#39;)
    LUAC = (FC.Executable, &#39;luac&#39;, &#39;LUAC&#39;, &#39;LUA Bytecode&#39;)
    PYC = (FC.Executable, &#39;pyc&#39;, &#39;PYC&#39;, &#39;Python Bytecode&#39;)
    APK = (FC.Executable, &#39;apk&#39;, &#39;ZIP/APK&#39;, &#39;Android Package&#39;)

    PDF = (FC.Document, &#39;pdf&#39;, &#39;PDF&#39;, &#39;PDF Document&#39;)
    CHM = (FC.Document, &#39;chm&#39;, &#39;CHM&#39;, &#39;Microsoft Windows HtmlHelp Data&#39;)
    DJV = (FC.Document, &#39;djvu&#39;, &#39;DJVU&#39;, &#39;DJVu Document&#39;)

    PCAP = (FC.Binary, &#39;pcap&#39;, &#39;PCAP&#39;, &#39;Network Packet Capture&#39;)
    PCAPNG = (FC.Binary, &#39;pcapng&#39;, &#39;PCAP/NG&#39;, &#39;Next-Generation Network Packet Capture&#39;)
    SSP = (FC.Binary, &#39;ssp&#39;, &#39;SmartSniff&#39;, &#39;SmartSniff Packets File&#39;)
    SQLITE = (FC.Binary, &#39;db&#39;, &#39;SQLite&#39;, &#39;SQLite Database&#39;)
    DSS = (FC.Binary, &#39;DS_Store&#39;, &#39;DSS&#39;, &#39;MacOS DS Store&#39;)
    A3X = (FC.Binary, &#39;a3x&#39;, &#39;A3X&#39;, &#39;Compiled AutoIt3&#39;)
    IFPS = (FC.Binary, &#39;ifps&#39;, &#39;IFPS&#39;, &#39;InnerFuse PascalScript&#39;)
    PPK = (FC.Binary, &#39;ppk&#39;, &#39;PuTTY&#39;, &#39;PuTTY Private Key File&#39;)
    WIM = (FC.Binary, &#39;wim&#39;, &#39;WIM&#39;, &#39;Windows Imaging Format&#39;)
    EVT = (FC.Binary, &#39;evt&#39;, &#39;EVT&#39;, &#39;Windows Event Viewer&#39;)
    EVTX = (FC.Binary, &#39;evtx&#39;, &#39;EVTX&#39;, &#39;Windows Event Viewer XML&#39;)
    LNK = (FC.Binary, &#39;lnk&#39;, &#39;LNK&#39;, &#39;Windows Shortcut&#39;)
    DMP = (FC.Binary, &#39;dmp&#39;, &#39;MDMP&#39;, &#39;Mini DuMP Crash Report&#39;)

    REG = (FC.Binary, &#39;reg&#39;, &#39;WinReg&#39;, &#39;A Windows Registry Script or Hive File&#39;)
    REG_HIVE = (FC.Binary, &#39;reg&#39;, &#39;WinReg/Hive&#39;, &#39;Windows Registry Hive File&#39;, &#39;text/plain&#39;)
    REG_TEXT = (FC.Binary, &#39;reg&#39;, &#39;WinReg/Text&#39;, &#39;Windows Registry Script&#39;)

    OFFICE = (FC.Document, &#39;bin&#39;, &#39;OFFICE&#39;, &#39;A Microsoft Office Document&#39;)
    OFFICECRYPT = (FC.Document, &#39;bin&#39;, &#39;OFFICE/ENCRYPTED&#39;, &#39;Encrypted Microsoft Office Document&#39;)
    MDB = (FC.Document, &#39;accdb&#39;, &#39;OFFICE/MDB&#39;, &#39;Microsoft Access Database&#39;)
    DOC = (FC.Document, &#39;doc&#39;, &#39;OFFICE/DOC&#39;, &#39;Microsoft Word Document&#39;)
    ONE = (FC.Document, &#39;one&#39;, &#39;OFFICE/ONE&#39;, &#39;Microsoft OneNote Document&#39;)
    XLS = (FC.Document, &#39;xls&#39;, &#39;OFFICE/XLS&#39;, &#39;Microsoft Excel Document&#39;)
    PPT = (FC.Document, &#39;ppt&#39;, &#39;OFFICE/PPT&#39;, &#39;Microsoft PowerPoint Document&#39;)
    MSG = (FC.Document, &#39;msg&#39;, &#39;MSG&#39;, &#39;Microsoft Outlook EMail Message&#39;)
    MSI = (FC.Archive, &#39;msi&#39;, &#39;MSI&#39;, &#39;Microsoft Installer Archive (MSI)&#39;)
    CFF = (FC.Binary, &#39;ole&#39;, &#39;OLE&#39;, &#39;Compound File Format&#39;)
    IDB = (FC.Document, &#39;idb&#39;, &#39;IDB/32&#39;, &#39;IDA Database (32 Bit)&#39;)
    I64 = (FC.Document, &#39;i64&#39;, &#39;IDB/64&#39;, &#39;IDA Database (64 Bit)&#39;)

    DOCX = (FC.Document, &#39;docx&#39;, &#39;OFFICE/ZIP/DOCX&#39;, &#39;Microsoft ZIP/XML Document for Word&#39;)
    XLSX = (FC.Document, &#39;xlsx&#39;, &#39;OFFICE/ZIP/XLSX&#39;, &#39;Microsoft ZIP/XML Document for Excel&#39;)
    PPTX = (FC.Document, &#39;pptx&#39;, &#39;OFFICE/ZIP/PPTX&#39;, &#39;Microsoft ZIP/XML Document for PowerPoint&#39;)

    ODT = (FC.Document, &#39;odt&#39;, &#39;ZIP/ODT&#39;, &#39;Open Document Format&#39;)

    TEXT = (FC.Text, &#39;txt&#39;, &#39;Text&#39;, &#39;Plain Text Data&#39;)
    ASCII = (FC.Text, &#39;txt&#39;, &#39;Text/ASCII&#39;, &#39;Plain Text, Single Byte Encoding&#39;)
    UTF08 = (FC.Text, &#39;txt&#39;, &#39;Text/UTF08&#39;, &#39;Plain Text, UTF-08 Encoding&#39;)
    UTF16 = (FC.Text, &#39;txt&#39;, &#39;Text/UTF16&#39;, &#39;Plain Text, UTF-16 Encoding&#39;)
    UTF32 = (FC.Text, &#39;txt&#39;, &#39;Text/UTF32&#39;, &#39;Plain Text, UTF-32 Encoding&#39;)

    JSON = (FC.Text, &#39;json&#39;, &#39;Text/JSON&#39;)
    XML = (FC.Text, &#39;xml&#39;, &#39;Text/XML&#39;)
    HTM = (FC.Text, &#39;html&#39;, &#39;Text/HTML&#39;)
    RTF = (FC.Text, &#39;rtf&#39;, &#39;RTF&#39;)
    VBE = (FC.Text, &#39;vbe&#39;, &#39;VBE&#39;, &#39;Encoded VBScript&#39;)
    EML = (FC.Text, &#39;eml&#39;, &#39;EML&#39;, &#39;Plain-Text EMail Document&#39;)

    HIC = (FC.Image, &#39;heic&#39;, &#39;HEIC&#39;, &#39;High Efficiency Image Container&#39;)
    ICO = (FC.Image, r&#39;ico&#39;, r&#39;ICO&#39;, &#39;Icon&#39;)
    GIF = (FC.Image, r&#39;gif&#39;, r&#39;GIF&#39;, &#39;Graphics Interchange Format&#39;)
    TIF = (FC.Image, r&#39;tif&#39;, r&#39;TIF&#39;, &#39;Tagged Image File Format&#39;)
    CIN = (FC.Image, r&#39;cin&#39;, r&#39;CIN&#39;, &#39;Kodak Cineon Image&#39;)
    NUI = (FC.Image, r&#39;nui&#39;, r&#39;NUI&#39;, &#39;Nuru ASCI/ANSI Image or Palette&#39;)
    DPX = (FC.Image, r&#39;dpx&#39;, r&#39;DPX&#39;, &#39;SMPTE DPX Image&#39;)
    BPG = (FC.Image, r&#39;bpg&#39;, r&#39;BPG&#39;, &#39;Better Portable Graphics&#39;)
    EXR = (FC.Image, r&#39;exr&#39;, r&#39;EXR&#39;, &#39;OpenEXR Image&#39;)
    JPG = (FC.Image, r&#39;jpg&#39;, r&#39;JPG&#39;, &#39;Joint Photographic Experts Group Image&#39;)
    JP2 = (FC.Image, r&#39;jp2&#39;, r&#39;JP2&#39;, &#39;JPEG 2000&#39;)
    QOI = (FC.Image, r&#39;qoi&#39;, r&#39;QOI&#39;, &#39;Quite OK Image Format&#39;)
    IFF = (FC.Image, r&#39;iff&#39;, r&#39;IFF&#39;, &#39;IFF or Amiga Image&#39;)
    PNG = (FC.Image, r&#39;png&#39;, r&#39;PNG&#39;, &#39;Portable Network Graphics&#39;)
    PSD = (FC.Image, r&#39;psd&#39;, r&#39;PSD&#39;, &#39;Adobe Photoshop Document&#39;)
    BMP = (FC.Image, r&#39;bmp&#39;, r&#39;BMP&#39;, &#39;Bitmap&#39;)
    FIF = (FC.Image, &#39;flif&#39;, &#39;FLIF&#39;, &#39;Free Lossless Image Format&#39;)
    LEP = (FC.Image, r&#39;lep&#39;, r&#39;LEP&#39;, &#39;Lepton Compressed JPEG Image&#39;)
    HDR = (FC.Image, r&#39;hdr&#39;, r&#39;HDR&#39;, &#39;Radiance High Dynamic Range Image&#39;)

    OGG = (FC.Media, &#39;ogg&#39;)
    WAV = (FC.Media, &#39;wav&#39;)
    AVI = (FC.Media, &#39;avi&#39;)
    MP3 = (FC.Media, &#39;mp3&#39;)
    M3U = (FC.Media, &#39;m3u&#39;, &#39;M3U&#39;, &#39;Multimedia Playlist&#39;)
    MP4 = (FC.Media, &#39;mp4&#39;)
    MPG = (FC.Media, &#39;mpg&#39;)
    FLC = (FC.Media, &#39;flac&#39;)
    MID = (FC.Media, &#39;mid&#39;)
    MKV = (FC.Media, &#39;mkv&#39;)
    SWF = (FC.Media, &#39;swf&#39;)
    SIL = (FC.Media, &#39;sil&#39;)

    ACE = (FC.Archive, &#39;ace&#39;)
    ASAR = (FC.Archive, &#39;asar&#39;)
    VHD = (FC.Archive, &#39;vhd&#39;)
    VMDK = (FC.Archive, &#39;vmdk&#39;)
    ISO = (FC.Archive, &#39;iso&#39;)
    ISZ = (FC.Archive, &#39;isz&#39;, &#39;ISZ&#39;, &#39;Compressed ISO Image&#39;)
    DMG = (FC.Archive, &#39;dmg&#39;)
    XAR = (FC.Archive, &#39;xar&#39;, &#39;XAR&#39;, &#39;eXtensible ARchive Format&#39;)
    TAR = (FC.Archive, &#39;tar&#39;)
    OAR = (FC.Archive, &#39;oar&#39;)
    ZIP7 = (FC.Archive, &#39;7z&#39;, &#39;7Zip&#39;)
    ZIP = (FC.Archive, &#39;zip&#39;, &#39;ZIP&#39;)
    RAR = (FC.Archive, &#39;rar&#39;)
    CAB = (FC.Archive, &#39;cab&#39;)
    CPIO = (FC.Archive, &#39;cpio&#39;)
    ZPQ = (FC.Archive, &#39;zpq&#39;)

    S_JAV = (FC.Serialized, &#39;bin&#39;, &#39;Serialized/Java&#39;)
    S_DOT = (FC.Serialized, &#39;bin&#39;, &#39;Serialized/DotNet&#39;)
    S_PHP = (FC.Serialized, &#39;bin&#39;, &#39;Serialized/PHP&#39;)

    APLIB = (FC.Compression, &#39;ap&#39;, &#39;apLib&#39;)
    BZ2 = (FC.Compression, &#39;bz2&#39;, &#39;BZIP&#39;)
    JCALG = (FC.Compression, &#39;bin&#39;, &#39;jcAlg&#39;)
    LZMA = (FC.Compression, &#39;lzma&#39;)
    LZF = (FC.Compression, &#39;lzf&#39;)
    LZH = (FC.Compression, &#39;lzh&#39;)
    LZG = (FC.Compression, &#39;lzg&#39;)
    RNC = (FC.Compression, &#39;rnc&#39;, &#39;RNC&#39;, &#39;Rob Northern Compression&#39;)
    LZIP = (FC.Compression, &#39;lzip&#39;)
    LZO = (FC.Compression, &#39;lzo&#39;)
    LZ4 = (FC.Compression, &#39;lz4&#39;)
    LZW = (FC.Compression, &#39;lzw&#39;)
    LZFSE = (FC.Compression, &#39;lzfse&#39;)
    MSCF = (FC.Compression, &#39;mscf&#39;)
    SZDD = (FC.Compression, &#39;szdd&#39;)
    GZIP = (FC.Compression, &#39;gz&#39;)
    XZ = (FC.Compression, &#39;xz&#39;, &#39;XZ/LZMA2&#39;)
    ZLIB = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB&#39;)
    ZLIB0 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/0&#39;)
    ZLIB1 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/1&#39;)
    ZLIB2 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/2&#39;)
    ZLIB3 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/3&#39;)
    ZLIB4 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/4&#39;)
    ZLIB5 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/5&#39;)
    ZLIB6 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/6&#39;)
    ZLIB7 = (FC.Compression, &#39;zlib&#39;, &#39;ZLIB/7&#39;)
    ZSTD = (FC.Compression, &#39;zstd&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.id.Format" href="#refinery.lib.id.Format">Format</a></li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.id.Fmt.ELF"><code class="name">var <span class="ident">ELF</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MACHO"><code class="name">var <span class="ident">MACHO</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PE"><code class="name">var <span class="ident">PE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PE32GUI"><code class="name">var <span class="ident">PE32GUI</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PE32CUI"><code class="name">var <span class="ident">PE32CUI</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PE32DLL"><code class="name">var <span class="ident">PE32DLL</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PE32SYS"><code class="name">var <span class="ident">PE32SYS</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PE64GUI"><code class="name">var <span class="ident">PE64GUI</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PE64CUI"><code class="name">var <span class="ident">PE64CUI</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PE64DLL"><code class="name">var <span class="ident">PE64DLL</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PE64SYS"><code class="name">var <span class="ident">PE64SYS</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ELF32LE"><code class="name">var <span class="ident">ELF32LE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ELF64LE"><code class="name">var <span class="ident">ELF64LE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ELF32BE"><code class="name">var <span class="ident">ELF32BE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ELF64BE"><code class="name">var <span class="ident">ELF64BE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MACHOuvLE"><code class="name">var <span class="ident">MACHOuvLE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MACHOuvBE"><code class="name">var <span class="ident">MACHOuvBE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MACHO32LE"><code class="name">var <span class="ident">MACHO32LE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MACHO64LE"><code class="name">var <span class="ident">MACHO64LE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MACHO32BE"><code class="name">var <span class="ident">MACHO32BE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MACHO64BE"><code class="name">var <span class="ident">MACHO64BE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.JAVA"><code class="name">var <span class="ident">JAVA</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.DEX"><code class="name">var <span class="ident">DEX</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.WASM"><code class="name">var <span class="ident">WASM</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.LUAC"><code class="name">var <span class="ident">LUAC</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PYC"><code class="name">var <span class="ident">PYC</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.APK"><code class="name">var <span class="ident">APK</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PDF"><code class="name">var <span class="ident">PDF</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.CHM"><code class="name">var <span class="ident">CHM</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.DJV"><code class="name">var <span class="ident">DJV</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PCAP"><code class="name">var <span class="ident">PCAP</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PCAPNG"><code class="name">var <span class="ident">PCAPNG</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.SSP"><code class="name">var <span class="ident">SSP</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.SQLITE"><code class="name">var <span class="ident">SQLITE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.DSS"><code class="name">var <span class="ident">DSS</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.A3X"><code class="name">var <span class="ident">A3X</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.IFPS"><code class="name">var <span class="ident">IFPS</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PPK"><code class="name">var <span class="ident">PPK</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.WIM"><code class="name">var <span class="ident">WIM</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.EVT"><code class="name">var <span class="ident">EVT</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.EVTX"><code class="name">var <span class="ident">EVTX</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.LNK"><code class="name">var <span class="ident">LNK</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.DMP"><code class="name">var <span class="ident">DMP</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.REG"><code class="name">var <span class="ident">REG</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.REG_HIVE"><code class="name">var <span class="ident">REG_HIVE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.REG_TEXT"><code class="name">var <span class="ident">REG_TEXT</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.OFFICE"><code class="name">var <span class="ident">OFFICE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.OFFICECRYPT"><code class="name">var <span class="ident">OFFICECRYPT</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MDB"><code class="name">var <span class="ident">MDB</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.DOC"><code class="name">var <span class="ident">DOC</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ONE"><code class="name">var <span class="ident">ONE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.XLS"><code class="name">var <span class="ident">XLS</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PPT"><code class="name">var <span class="ident">PPT</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MSG"><code class="name">var <span class="ident">MSG</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MSI"><code class="name">var <span class="ident">MSI</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.CFF"><code class="name">var <span class="ident">CFF</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.IDB"><code class="name">var <span class="ident">IDB</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.I64"><code class="name">var <span class="ident">I64</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.DOCX"><code class="name">var <span class="ident">DOCX</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.XLSX"><code class="name">var <span class="ident">XLSX</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PPTX"><code class="name">var <span class="ident">PPTX</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ODT"><code class="name">var <span class="ident">ODT</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.TEXT"><code class="name">var <span class="ident">TEXT</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ASCII"><code class="name">var <span class="ident">ASCII</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.UTF08"><code class="name">var <span class="ident">UTF08</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.UTF16"><code class="name">var <span class="ident">UTF16</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.UTF32"><code class="name">var <span class="ident">UTF32</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.JSON"><code class="name">var <span class="ident">JSON</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.XML"><code class="name">var <span class="ident">XML</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.HTM"><code class="name">var <span class="ident">HTM</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.RTF"><code class="name">var <span class="ident">RTF</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.VBE"><code class="name">var <span class="ident">VBE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.EML"><code class="name">var <span class="ident">EML</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.HIC"><code class="name">var <span class="ident">HIC</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ICO"><code class="name">var <span class="ident">ICO</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.GIF"><code class="name">var <span class="ident">GIF</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.TIF"><code class="name">var <span class="ident">TIF</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.CIN"><code class="name">var <span class="ident">CIN</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.NUI"><code class="name">var <span class="ident">NUI</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.DPX"><code class="name">var <span class="ident">DPX</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.BPG"><code class="name">var <span class="ident">BPG</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.EXR"><code class="name">var <span class="ident">EXR</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.JPG"><code class="name">var <span class="ident">JPG</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.JP2"><code class="name">var <span class="ident">JP2</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.QOI"><code class="name">var <span class="ident">QOI</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.IFF"><code class="name">var <span class="ident">IFF</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PNG"><code class="name">var <span class="ident">PNG</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.PSD"><code class="name">var <span class="ident">PSD</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.BMP"><code class="name">var <span class="ident">BMP</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.FIF"><code class="name">var <span class="ident">FIF</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.LEP"><code class="name">var <span class="ident">LEP</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.HDR"><code class="name">var <span class="ident">HDR</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.OGG"><code class="name">var <span class="ident">OGG</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.WAV"><code class="name">var <span class="ident">WAV</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.AVI"><code class="name">var <span class="ident">AVI</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MP3"><code class="name">var <span class="ident">MP3</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.M3U"><code class="name">var <span class="ident">M3U</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MP4"><code class="name">var <span class="ident">MP4</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MPG"><code class="name">var <span class="ident">MPG</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.FLC"><code class="name">var <span class="ident">FLC</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MID"><code class="name">var <span class="ident">MID</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MKV"><code class="name">var <span class="ident">MKV</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.SWF"><code class="name">var <span class="ident">SWF</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.SIL"><code class="name">var <span class="ident">SIL</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ACE"><code class="name">var <span class="ident">ACE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ASAR"><code class="name">var <span class="ident">ASAR</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.VHD"><code class="name">var <span class="ident">VHD</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.VMDK"><code class="name">var <span class="ident">VMDK</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ISO"><code class="name">var <span class="ident">ISO</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ISZ"><code class="name">var <span class="ident">ISZ</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.DMG"><code class="name">var <span class="ident">DMG</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.XAR"><code class="name">var <span class="ident">XAR</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.TAR"><code class="name">var <span class="ident">TAR</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.OAR"><code class="name">var <span class="ident">OAR</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ZIP7"><code class="name">var <span class="ident">ZIP7</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ZIP"><code class="name">var <span class="ident">ZIP</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.RAR"><code class="name">var <span class="ident">RAR</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.CAB"><code class="name">var <span class="ident">CAB</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.CPIO"><code class="name">var <span class="ident">CPIO</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ZPQ"><code class="name">var <span class="ident">ZPQ</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.S_JAV"><code class="name">var <span class="ident">S_JAV</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.S_DOT"><code class="name">var <span class="ident">S_DOT</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.S_PHP"><code class="name">var <span class="ident">S_PHP</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.APLIB"><code class="name">var <span class="ident">APLIB</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.BZ2"><code class="name">var <span class="ident">BZ2</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.JCALG"><code class="name">var <span class="ident">JCALG</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.LZMA"><code class="name">var <span class="ident">LZMA</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.LZF"><code class="name">var <span class="ident">LZF</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.LZH"><code class="name">var <span class="ident">LZH</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.LZG"><code class="name">var <span class="ident">LZG</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.RNC"><code class="name">var <span class="ident">RNC</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.LZIP"><code class="name">var <span class="ident">LZIP</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.LZO"><code class="name">var <span class="ident">LZO</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.LZ4"><code class="name">var <span class="ident">LZ4</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.LZW"><code class="name">var <span class="ident">LZW</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.LZFSE"><code class="name">var <span class="ident">LZFSE</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.MSCF"><code class="name">var <span class="ident">MSCF</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.SZDD"><code class="name">var <span class="ident">SZDD</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.GZIP"><code class="name">var <span class="ident">GZIP</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.XZ"><code class="name">var <span class="ident">XZ</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ZLIB"><code class="name">var <span class="ident">ZLIB</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ZLIB0"><code class="name">var <span class="ident">ZLIB0</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ZLIB1"><code class="name">var <span class="ident">ZLIB1</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ZLIB2"><code class="name">var <span class="ident">ZLIB2</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ZLIB3"><code class="name">var <span class="ident">ZLIB3</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ZLIB4"><code class="name">var <span class="ident">ZLIB4</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ZLIB5"><code class="name">var <span class="ident">ZLIB5</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ZLIB6"><code class="name">var <span class="ident">ZLIB6</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ZLIB7"><code class="name">var <span class="ident">ZLIB7</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.id.Fmt.ZSTD"><code class="name">var <span class="ident">ZSTD</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.id.TextEncoding"><code class="flex name class">
<span>class <span class="ident">TextEncoding</span></span>
<span>(</span><span>codec, bom=0, lsb=0, step=1)</span>
</code></dt>
<dd>
<section class="desc"><p>TextEncoding(codec, bom, lsb, step)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L691-L695" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TextEncoding(NamedTuple):
    codec: str
    bom: int = 0
    lsb: int = 0
    step: int = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.id.TextEncoding.codec"><code class="name">var <span class="ident">codec</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L691-L695" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TextEncoding(NamedTuple):
    codec: str
    bom: int = 0
    lsb: int = 0
    step: int = 1</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.TextEncoding.bom"><code class="name">var <span class="ident">bom</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L691-L695" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TextEncoding(NamedTuple):
    codec: str
    bom: int = 0
    lsb: int = 0
    step: int = 1</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.TextEncoding.lsb"><code class="name">var <span class="ident">lsb</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L691-L695" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TextEncoding(NamedTuple):
    codec: str
    bom: int = 0
    lsb: int = 0
    step: int = 1</code></pre>
</details>
</dd>
<dt id="refinery.lib.id.TextEncoding.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/id.py#L691-L695" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TextEncoding(NamedTuple):
    codec: str
    bom: int = 0
    lsb: int = 0
    step: int = 1</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.id.meminfo" href="#refinery.lib.id.meminfo">meminfo</a></code></li>
<li><code><a title="refinery.lib.id.get_pe_type" href="#refinery.lib.id.get_pe_type">get_pe_type</a></code></li>
<li><code><a title="refinery.lib.id.get_elf_type" href="#refinery.lib.id.get_elf_type">get_elf_type</a></code></li>
<li><code><a title="refinery.lib.id.get_macho_type" href="#refinery.lib.id.get_macho_type">get_macho_type</a></code></li>
<li><code><a title="refinery.lib.id.get_executable_type" href="#refinery.lib.id.get_executable_type">get_executable_type</a></code></li>
<li><code><a title="refinery.lib.id.is_likely_pe" href="#refinery.lib.id.is_likely_pe">is_likely_pe</a></code></li>
<li><code><a title="refinery.lib.id.slice_offset" href="#refinery.lib.id.slice_offset">slice_offset</a></code></li>
<li><code><a title="refinery.lib.id.buffer_offset" href="#refinery.lib.id.buffer_offset">buffer_offset</a></code></li>
<li><code><a title="refinery.lib.id.buffer_contains" href="#refinery.lib.id.buffer_contains">buffer_contains</a></code></li>
<li><code><a title="refinery.lib.id.is_likely_pe_dotnet" href="#refinery.lib.id.is_likely_pe_dotnet">is_likely_pe_dotnet</a></code></li>
<li><code><a title="refinery.lib.id.get_reg_export_type" href="#refinery.lib.id.get_reg_export_type">get_reg_export_type</a></code></li>
<li><code><a title="refinery.lib.id.guess_text_encoding" href="#refinery.lib.id.guess_text_encoding">guess_text_encoding</a></code></li>
<li><code><a title="refinery.lib.id.xml_or_html" href="#refinery.lib.id.xml_or_html">xml_or_html</a></code></li>
<li><code><a title="refinery.lib.id.ascii_view" href="#refinery.lib.id.ascii_view">ascii_view</a></code></li>
<li><code><a title="refinery.lib.id.is_likely_eml" href="#refinery.lib.id.is_likely_eml">is_likely_eml</a></code></li>
<li><code><a title="refinery.lib.id.is_likely_vbe" href="#refinery.lib.id.is_likely_vbe">is_likely_vbe</a></code></li>
<li><code><a title="refinery.lib.id.is_likely_json" href="#refinery.lib.id.is_likely_json">is_likely_json</a></code></li>
<li><code><a title="refinery.lib.id.get_microsoft_format" href="#refinery.lib.id.get_microsoft_format">get_microsoft_format</a></code></li>
<li><code><a title="refinery.lib.id.get_office_xml_type" href="#refinery.lib.id.get_office_xml_type">get_office_xml_type</a></code></li>
<li><code><a title="refinery.lib.id.get_compression_type" href="#refinery.lib.id.get_compression_type">get_compression_type</a></code></li>
<li><code><a title="refinery.lib.id.get_image_format" href="#refinery.lib.id.get_image_format">get_image_format</a></code></li>
<li><code><a title="refinery.lib.id.get_media_format" href="#refinery.lib.id.get_media_format">get_media_format</a></code></li>
<li><code><a title="refinery.lib.id.get_serialization_format" href="#refinery.lib.id.get_serialization_format">get_serialization_format</a></code></li>
<li><code><a title="refinery.lib.id.get_misc_binary_formats" href="#refinery.lib.id.get_misc_binary_formats">get_misc_binary_formats</a></code></li>
<li><code><a title="refinery.lib.id.get_text_format" href="#refinery.lib.id.get_text_format">get_text_format</a></code></li>
<li><code><a title="refinery.lib.id.get_structured_data_type" href="#refinery.lib.id.get_structured_data_type">get_structured_data_type</a></code></li>
<li><code><a title="refinery.lib.id.is_likely_xml" href="#refinery.lib.id.is_likely_xml">is_likely_xml</a></code></li>
<li><code><a title="refinery.lib.id.is_likely_htm" href="#refinery.lib.id.is_likely_htm">is_likely_htm</a></code></li>
<li><code><a title="refinery.lib.id.is_likely_msi" href="#refinery.lib.id.is_likely_msi">is_likely_msi</a></code></li>
<li><code><a title="refinery.lib.id.is_likely_email" href="#refinery.lib.id.is_likely_email">is_likely_email</a></code></li>
<li><code><a title="refinery.lib.id.is_likely_doc" href="#refinery.lib.id.is_likely_doc">is_likely_doc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.id.Format" href="#refinery.lib.id.Format">Format</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.id.FormatCategory" href="#refinery.lib.id.FormatCategory">FormatCategory</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.id.FormatCategory" href="#refinery.lib.id.FormatCategory">FormatCategory</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.id.Fmt" href="#refinery.lib.id.Fmt">Fmt</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.id.TextEncoding" href="#refinery.lib.id.TextEncoding">TextEncoding</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
