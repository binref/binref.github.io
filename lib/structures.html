<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.structures documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.structures</code></h1>
</header>
<section id="section-intro">
<p>Interfaces and classes to read structured data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L1-L909" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Interfaces and classes to read structured data.
&#34;&#34;&#34;
from __future__ import annotations

import codecs
import contextlib
import enum
import functools
import io
import itertools
import re
import struct
import weakref

from typing import (
    TYPE_CHECKING,
    Any,
    Generic,
    Iterable,
    Sized,
    TypeVar,
    Union,
    cast,
    overload,
)
from uuid import UUID

if TYPE_CHECKING:
    from collections.abc import Buffer

    from refinery.lib.types import buf

    T = TypeVar(&#39;T&#39;, bound=Union[bytearray, bytes, memoryview])
    B = TypeVar(&#39;B&#39;, bound=Union[bytearray, bytes, memoryview], default=T)
    C = TypeVar(&#39;C&#39;, bound=Union[bytearray, bytes, memoryview])
    R = TypeVar(&#39;R&#39;, bound=io.IOBase)
else:
    T = TypeVar(&#39;T&#39;)
    B = TypeVar(&#39;B&#39;)
    C = TypeVar(&#39;C&#39;)
    R = TypeVar(&#39;R&#39;)


UnpackType = Union[int, bool, float, bytes]


def signed(k: int, bitsize: int):
    &#34;&#34;&#34;
    If `k` is an integer of the given bit size, cast it to a signed one.
    &#34;&#34;&#34;
    M = 1 &lt;&lt; bitsize
    k = k &amp; (M - 1)
    return k - M if k &gt;&gt; (bitsize - 1) else k


class EOF(EOFError):
    &#34;&#34;&#34;
    While reading from a `refinery.lib.structures.MemoryFile`, less bytes were available than
    requested. The exception contains the data from the incomplete read.
    &#34;&#34;&#34;
    def __init__(self, rest: buf = B&#39;&#39;):
        super().__init__(&#39;Unexpected end of buffer.&#39;)
        self.rest = rest

    def __bytes__(self):
        return bytes(self.rest)


class StreamDetour(Generic[R]):
    &#34;&#34;&#34;
    A stream detour is used as a context manager to temporarily read from a different location
    in the stream and then return to the original offset when the context ends.
    &#34;&#34;&#34;
    def __init__(self, stream: R, offset: int | None = None, whence: int = io.SEEK_SET):
        self.stream = stream
        self.offset = offset
        self.whence = whence

    def __enter__(self):
        self.cursor = self.stream.tell()
        if self.offset is not None:
            self.stream.seek(self.offset, self.whence)
        return self

    def __exit__(self, *args):
        self.stream.seek(self.cursor, io.SEEK_SET)


class MemoryFileMethods(Generic[T, B]):
    &#34;&#34;&#34;
    A thin wrapper around (potentially mutable) byte sequences which gives it the features of a
    file-like object.
    &#34;&#34;&#34;
    _data: T
    _output: type[B]
    _cursor: int
    _closed: bool

    class SEEK(int, enum.Enum):
        CUR = io.SEEK_CUR
        END = io.SEEK_END
        SET = io.SEEK_SET

    def __bytes__(self):
        return bytes(self._data)

    def __init__(
        self,
        data: T | None = None,
        output: type[B] | None = None,
        fileno: int | None = None,
        size_limit: int | None = None,
    ) -&gt; None:
        if data is None:
            if TYPE_CHECKING:
                data = cast(T, bytearray())
            else:
                data = bytearray()
        if output is None:
            if TYPE_CHECKING:
                output = cast(type[B], type(data))
            else:
                output = type(data)
        if size_limit is not None and len(data) &gt; size_limit:
            raise ValueError(&#39;Initial data exceeds size limit&#39;)
        self._output = output
        self._cursor = 0
        self._closed = False
        self._fileno = fileno
        self._size_limit = size_limit
        self._data = data

    def close(self) -&gt; None:
        self._closed = True

    @property
    def closed(self) -&gt; bool:
        return self._closed

    def __enter__(self):
        return self

    def __exit__(self, ex_type, ex_value, trace) -&gt; bool:
        return False

    def flush(self) -&gt; None:
        pass

    def isatty(self) -&gt; bool:
        return False

    def __iter__(self):
        return self

    def __len__(self):
        return len(self._data)

    def __next__(self):
        line = self.readline()
        if not line:
            raise StopIteration
        return line

    def fileno(self) -&gt; int:
        if self._fileno is None:
            raise OSError
        return self._fileno

    def readable(self) -&gt; bool:
        return not self._closed

    def seekable(self) -&gt; bool:
        return not self._closed

    @property
    def eof(self) -&gt; bool:
        return self._closed or self._cursor &gt;= len(self._data)

    @property
    def remaining_bytes(self) -&gt; int:
        return len(self._data) - self.tell()

    def detour(self, offset: int | None = None, whence: int = io.SEEK_SET):
        return StreamDetour(cast(io.IOBase, self), offset, whence=whence)

    def detour_absolute(self, offset: int | None = None):
        return self.detour(offset, io.SEEK_SET)

    def detour_relative(self, offset: int | None = None):
        return self.detour(offset, io.SEEK_CUR)

    def detour_from_end(self, offset: int | None = None):
        return self.detour(offset, io.SEEK_END)

    def writable(self) -&gt; bool:
        if self._closed:
            return False
        if isinstance(self._data, memoryview):
            return not self._data.readonly
        return isinstance(self._data, bytearray)

    def read_as(self, cast: type[C], size: int = -1, peek: bool = False) -&gt; C:
        out = self.read(size, peek)
        if not isinstance(out, cast):
            out = cast(out)
        return out

    def read(self, size: int | None = None, peek: bool = False) -&gt; B:
        beginning = self._cursor
        if size is None or size &lt; 0:
            end = len(self._data)
        else:
            end = min(self._cursor + size, len(self._data))
        result = self._data[beginning:end]
        if not isinstance(result, t := self._output):
            result = t(result)
        if not peek:
            self._cursor = end
        return result

    def readif(self, value: bytes) -&gt; bool:
        size = len(value)
        stop = self._cursor + size
        mv = memoryview(self._data)
        if match := mv[self._cursor:stop] == value:
            self._cursor = stop
        return match

    def peek(self, size: int | None = None) -&gt; memoryview:
        cursor = self._cursor
        mv = memoryview(self._data)
        if size is None or size &lt; 0:
            return mv[cursor:]
        return mv[cursor:cursor + size]

    def read1(self, size: int | None = None, peek: bool = False) -&gt; B:
        return self.read(size, peek)

    def _find_linebreak(self, beginning: int, end: int) -&gt; int:
        if not isinstance(self._data, memoryview):
            return self._data.find(B&#39;\n&#39;, beginning, end)
        for k in range(beginning, end):
            if self._data[k] == 0xA: return k
        return -1

    def readline(self, size: int | None = None) -&gt; B:
        beginning, end = self._cursor, len(self._data)
        if size is not None and size &gt;= 0:
            end = beginning + size
        p = self._find_linebreak(beginning, end)
        self._cursor = end if p &lt; 0 else p + 1
        result = self._data[beginning:self._cursor]
        if not isinstance(result, t := self._output):
            result = t(result)
        return result

    def readlines_iter(self, hint: int | None = None) -&gt; Iterable[B]:
        if hint is None or hint &lt; 0:
            yield from self
        else:
            total = 0
            while total &lt; hint:
                line = next(self)
                total += len(line)
                yield line

    def readlines(self, hint: int | None = None) -&gt; list[bytes]:
        it = self.readlines_iter(hint)
        if issubclass(self._output, bytes):
            return list(it)
        return [bytes(t) for t in it]

    def readinto1(self, b) -&gt; int:
        data = self.read(len(b))
        size = len(data)
        b[:size] = data
        return size

    def readinto(self, b) -&gt; int:
        return self.readinto1(b)

    def tell(self) -&gt; int:
        return self._cursor

    def skip(self, n: int):
        self._cursor += n

    def seekrel(self, offset: int) -&gt; int:
        return self.seek(offset, io.SEEK_CUR)

    def seekset(self, offset: int) -&gt; int:
        if offset &lt; 0:
            return self.seek(offset, io.SEEK_END)
        else:
            return self.seek(offset, io.SEEK_SET)

    def getbuffer(self) -&gt; memoryview:
        return memoryview(self._data)

    def getvalue(self) -&gt; T:
        return self._data

    def seek(self, offset: int, whence=io.SEEK_SET) -&gt; int:
        if whence == io.SEEK_SET:
            if offset &lt; 0:
                raise ValueError(&#39;no negative offsets allowed for SEEK_SET.&#39;)
            self._cursor = offset
        elif whence == io.SEEK_CUR:
            self._cursor += offset
        elif whence == io.SEEK_END:
            self._cursor = len(self._data) + offset
        self._cursor = max(self._cursor, 0)
        self._cursor = min(self._cursor, len(self._data))
        return self._cursor

    def writelines(self, lines: Iterable[Iterable[int]] | Iterable[Buffer]) -&gt; None:
        for line in lines:
            self.write(line)

    def truncate(self, size: int | None = None) -&gt; int:
        if not isinstance(self._data, bytearray):
            raise TypeError
        if size is not None:
            if not (0 &lt;= size &lt;= len(self._data)):
                raise ValueError(&#39;invalid size value&#39;)
            self._cursor = size
        del self._data[self._cursor:]
        return self.tell()

    def write_byte(self, byte: int) -&gt; None:
        if isinstance(self._data, bytes):
            raise TypeError
        if isinstance(self._data, memoryview):
            raise NotImplementedError
        limit = self._size_limit
        cc = self._cursor
        nc = cc + 1
        if limit and nc &gt; limit:
            raise EOF(bytes((byte,)))
        try:
            if cc &lt; len(self._data):
                self._data[cc] = byte
            else:
                self._data.append(byte)
        except Exception as T:
            raise OSError(str(T)) from T
        else:
            self._cursor = nc

    def write(self, _data: Buffer | Iterable[int]) -&gt; int:
        out = self._data
        end = len(out)

        if isinstance(out, memoryview):
            if out.readonly:
                raise PermissionError
            out = out.obj
        if not isinstance(out, bytearray):
            raise PermissionError

        try:
            getbuf = cast(&#39;Buffer&#39;, _data).__buffer__
        except AttributeError:
            data = cast(&#39;Iterable[int]&#39;, _data)
        else:
            data = getbuf(0)

        beginning = self._cursor
        limit = self._size_limit

        if limit is None and beginning == end:
            out[end:] = data
            self._cursor = end = len(out)
            return end - beginning
        try:
            size = len(cast(Sized, data))
        except Exception:
            it = iter(data)
            cursor = 0
            for cursor, b in enumerate(it, beginning):
                out[cursor] = b
                if cursor &gt;= end - 1:
                    break
            else:
                cursor += 1
                self._cursor = cursor
                return cursor - beginning
            if limit is None:
                out[end:] = bytes(it)
            else:
                out[end:limit] = bytes(itertools.islice(it, 0, limit - end))
                try:
                    b = next(it)
                except StopIteration:
                    self._cursor = limit
                    return limit - beginning
                else:
                    rest = bytearray((b,))
                    rest[1:] = it
                    raise EOF(rest)
        else:
            if limit and size + beginning &gt; limit:
                raise EOF(bytes(data))
            self._cursor += size
            try:
                out[beginning:self._cursor] = data
            except Exception as T:
                self._cursor = beginning
                raise OSError(str(T)) from T
            return size
        self._cursor = end = len(out)
        return end - beginning

    def __getitem__(self, slice):
        result = self._data[slice]
        if not isinstance(result, t := self._output):
            result = t(result)
        return result

    def replay(self, offset: int, length: int):
        cursor = self._cursor
        if offset not in range(cursor + 1):
            raise ValueError(F&#39;The supplied delta {offset} is not in the valid range [0,{self._cursor}].&#39;)
        rep, r = divmod(length, offset)
        offset = cursor - offset
        replay = self._data[offset:offset + r]
        if rep &gt; 0:
            # While this is technically a copy, it is faster than repeated calls to write.
            replay = bytes(self._data[offset:cursor]) * rep + replay
        self.write(replay)


class MemoryFile(MemoryFileMethods[T, B], io.BytesIO):
    pass


class order(str, enum.Enum):
    big = &#39;&gt;&#39;
    little = &#39;&lt;&#39;


class StructReader(MemoryFile[T, T]):
    &#34;&#34;&#34;
    An extension of a `refinery.lib.structures.MemoryFile` which provides methods to read
    structured data.
    &#34;&#34;&#34;

    class Unaligned(RuntimeError):
        pass

    def __init__(self, data: T, bigendian: bool = False):
        super().__init__(data)
        self._bbits = 0
        self._nbits = 0
        self.bigendian = bigendian

    def __enter__(self) -&gt; StructReader:
        return super().__enter__()

    @property
    @contextlib.contextmanager
    def be(self):
        self.bigendian = True
        try:
            yield self
        finally:
            self.bigendian = False

    @property
    def byteorder_format(self) -&gt; str:
        return &#39;&gt;&#39; if self.bigendian else &#39;&lt;&#39;

    @property
    def byteorder_name(self):
        return &#39;big&#39; if self.bigendian else &#39;little&#39;

    def seek(self, offset, whence=io.SEEK_SET) -&gt; int:
        self._bbits = 0
        self._nbits = 0
        return super().seek(offset, whence)

    def read_exactly(self, size: int | None = None, peek: bool = False) -&gt; T:
        &#34;&#34;&#34;
        Read bytes from the underlying stream. Raises a `RuntimeError` when the stream is not currently
        byte-aligned, i.e. when `refinery.lib.structures.StructReader.byte_aligned` is `False`. Raises
        an exception of type `refinery.lib.structures.EOF` when fewer data is available in the stream than
        requested via the `size` parameter. The remaining data can be extracted from the exception.
        Use `refinery.lib.structures.StructReader.read_bytes` to read bytes from the stream when it is
        not byte-aligned.
        &#34;&#34;&#34;
        if not self.byte_aligned:
            raise StructReader.Unaligned(&#39;buffer is not byte-aligned&#39;)
        data = self.read1(size, peek)
        if size and len(data) &lt; size:
            raise EOF(data)
        return data

    @property
    def byte_aligned(self) -&gt; bool:
        &#34;&#34;&#34;
        This property is `True` if and only if there are currently no bits still waiting in the internal
        bit buffer.
        &#34;&#34;&#34;
        return not self._nbits

    def byte_align(self, blocksize: int = 1) -&gt; tuple[int, int]:
        &#34;&#34;&#34;
        This method clears the internal bit buffer and moves the cursor to the next byte. It returns a
        tuple containing the size and contents of the bit buffer.
        &#34;&#34;&#34;
        nbits = self._nbits
        bbits = self._bbits
        self._nbits = 0
        self._bbits = 0
        mod = self._cursor % blocksize
        if mod:
            self.seekrel(blocksize - mod)
        return nbits, bbits

    @property
    def remaining_bits(self) -&gt; int:
        return 8 * self.remaining_bytes + self._nbits

    def read_integer(self, length: int | None = None, peek: bool = False, bigendian: bool | None = None) -&gt; int:
        &#34;&#34;&#34;
        Read `length` many bits from the underlying stream as an integer.
        &#34;&#34;&#34;
        if length is None:
            length = self.remaining_bits
        if bigendian is None:
            bigendian = self.bigendian
        if length &lt; self._nbits:
            new_count = self._nbits - length
            if bigendian:
                result = self._bbits &gt;&gt; new_count
                if not peek:
                    self._bbits ^= result &lt;&lt; new_count
            else:
                result = self._bbits &amp; 2 ** length - 1
                if not peek:
                    self._bbits &gt;&gt;= length
            if not peek:
                self._nbits = new_count
            return result

        nbits, bbits = self._nbits, self._bbits
        number_of_missing_bits = length - nbits
        bytecount, rest = divmod(number_of_missing_bits, 8)
        if rest:
            bytecount += 1
            rest = 8 - rest
        bb = self.read1(bytecount, True)
        if len(bb) != bytecount:
            raise EOFError
        if not peek:
            self.seekrel(bytecount)
        if bytecount == 1:
            result, = bb
        else:
            result = int.from_bytes(bb, self.byteorder_name)
        if not nbits and not rest:
            return result
        if bigendian:
            rbmask   = 2 ** rest - 1       # noqa
            excess   = result &amp; rbmask     # noqa
            result &gt;&gt;= rest                # noqa
            result  ^= bbits &lt;&lt; number_of_missing_bits   # noqa
        else:
            excess   = result &gt;&gt; number_of_missing_bits  # noqa
            result  ^= excess &lt;&lt; number_of_missing_bits  # noqa
            result &lt;&lt;= nbits               # noqa
            result  |= bbits               # noqa
        assert excess.bit_length() &lt;= rest
        if not peek:
            self._nbits = rest
            self._bbits = excess
        return result

    def read_bytes(self, size: int, peek: bool = False) -&gt; bytes:
        &#34;&#34;&#34;
        The method reads `size` many bytes from the underlying stream starting at the current bit.
        &#34;&#34;&#34;
        if self.byte_aligned:
            data = self.read_exactly(size, peek)
            if not isinstance(data, bytes):
                data = bytes(data)
            return data
        else:
            return self.read_integer(size * 8, peek).to_bytes(size, self.byteorder_name)

    def read_bit(self) -&gt; int:
        &#34;&#34;&#34;
        This function is a shortcut for calling `refinery.lib.structures.StructReader.read_integer` with
        an argument of `1`, i.e. this reads the next bit from the stream. The bits of any byte in the stream
        are read from least significant to most significant.
        &#34;&#34;&#34;
        return self.read_integer(1)

    def read_bits(self, nbits: int, bigendian: bool | None = None) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        This method returns the bits of `refinery.lib.structures.StructReader.read_integer` one by one.
        &#34;&#34;&#34;
        if bigendian is None:
            bigendian = self.bigendian
        chunk = self.read_integer(nbits, bigendian=bigendian)
        it = range(nbits - 1, -1, -1) if bigendian else range(nbits)
        for k in it:
            yield chunk &gt;&gt; k &amp; 1

    def read_flags(self, nbits: int, reverse=False) -&gt; Iterable[bool]:
        &#34;&#34;&#34;
        Identical to `refinery.lib.structures.StructReader.read_bits` with every bit value cast to a boolean.
        &#34;&#34;&#34;
        bits = list(self.read_bits(nbits))
        if reverse:
            bits.reverse()
        for bit in bits:
            yield bool(bit)

    def read_one_struct(self, spec: str, peek=False) -&gt; UnpackType:
        item, = self.read_struct(spec, peek=peek)
        return item

    def read_struct(self, spec: str, peek=False) -&gt; list[UnpackType]:
        &#34;&#34;&#34;
        Read structured data from the stream in any format supported by the `struct` module. The `format`
        argument can be used to override the current byte ordering. If the `unwrap` parameter is `True`, a
        single unpacked value will be returned as a scalar, not as a tuple with one element.
        &#34;&#34;&#34;
        if not spec:
            raise ValueError(&#39;no format specified&#39;)
        byteorder = spec[:1]
        if byteorder in &#39;&lt;!=@&gt;&#39;:
            spec = spec[1:]
        else:
            byteorder = self.byteorder_format
        data = []
        current_cursor = self.tell()

        # reserved struct characters: xcbB?hHiIlLqQnNefdspP
        for k, part in enumerate(re.split(&#39;(\\d*[auwgk])&#39;, spec)):
            if k % 2 == 1:
                count = 1 if len(part) == 1 else int(part[:~0])
                part = part[~0]
                for _ in range(count):
                    if part == &#39;a&#39;:
                        data.append(self.read_c_string())
                    elif part == &#39;g&#39;:
                        data.append(str(self.read_guid()))
                    elif part == &#39;u&#39;:
                        data.append(self.read_w_string())
                    elif part == &#39;w&#39;:
                        data.append(codecs.decode(self.read_w_string(), &#39;utf-16le&#39;))
                    elif part == &#39;k&#39;:
                        data.append(self.read_7bit_encoded_int())
                continue
            else:
                part = F&#39;{byteorder}{part}&#39;
                data.extend(struct.unpack(part, self.read_bytes(struct.calcsize(part))))
        if peek:
            self.seekset(current_cursor)
        return data

    def read_nibble(self, peek: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Calls `refinery.lib.structures.StructReader.read_integer` with an argument of `4`.
        &#34;&#34;&#34;
        return self.read_integer(4, peek)

    def u8(self, peek: bool = False) -&gt; int: return self.read_integer(8, peek)
    def i8(self, peek: bool = False) -&gt; int: return signed(self.read_integer(8, peek), 8)

    def u16(self, peek: bool = False) -&gt; int: return self.read_integer(16, peek)
    def u32(self, peek: bool = False) -&gt; int: return self.read_integer(32, peek)
    def u64(self, peek: bool = False) -&gt; int: return self.read_integer(64, peek)
    def i16(self, peek: bool = False) -&gt; int: return signed(self.read_integer(16, peek), 16)
    def i32(self, peek: bool = False) -&gt; int: return signed(self.read_integer(32, peek), 32)
    def i64(self, peek: bool = False) -&gt; int: return signed(self.read_integer(64, peek), 64)

    def f32(self, peek: bool = False) -&gt; float: return cast(float, self.read_one_struct(&#39;f&#39;, peek=peek))
    def f64(self, peek: bool = False) -&gt; float: return cast(float, self.read_one_struct(&#39;d&#39;, peek=peek))

    def u8fast(self):
        try:
            b = self._data[self._cursor]
        except IndexError:
            raise EOFError
        else:
            self._cursor += 1
            return b

    def read_byte(self, peek: bool = False) -&gt; int: return self.read_integer(8, peek)
    def read_char(self, peek: bool = False) -&gt; int: return signed(self.read_integer(8, peek), 8)

    def read_terminated_array(self, terminator: bytes, alignment: int = 1) -&gt; bytearray:
        buf = self.getvalue()
        pos = self.tell()
        n = len(terminator)

        if isinstance(buf, memoryview):
            def find(whence: int):
                for k in range(whence, len(buf)):
                    if buf[k:k + n] == terminator:
                        return k
                return -1
        else:
            def find(whence: int):
                return buf.find(terminator, whence)
        try:
            end = pos - 1
            while True:
                end = find(end + 1)
                if end &lt; 0 or not (end - pos) % alignment:
                    break
        except AttributeError:
            result = bytearray()
            while not self.eof:
                result.extend(self.read_exactly(alignment))
                if result.endswith(terminator):
                    return result[:-n]
            self.seek(pos)
            raise EOF
        else:
            data = self.read_exactly(end - pos)
            self.skip(n)
            return bytearray(data)

    def read_guid(self) -&gt; UUID:
        return UUID(bytes_le=self.read_bytes(16))

    def read_uuid(self) -&gt; UUID:
        return UUID(bytes=self.read_bytes(16))

    @overload
    def read_c_string(self) -&gt; bytearray:
        ...

    @overload
    def read_c_string(self, encoding: str) -&gt; str:
        ...

    def read_c_string(self, encoding=None) -&gt; str | bytearray:
        data = self.read_terminated_array(B&#39;\0&#39;)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    @overload
    def read_w_string(self) -&gt; bytearray:
        ...

    @overload
    def read_w_string(self, encoding: str) -&gt; str:
        ...

    def read_w_string(self, encoding=None) -&gt; str | bytearray:
        data = self.read_terminated_array(B&#39;\0\0&#39;, 2)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    def read_length_prefixed_ascii(self, prefix_size: int = 32):
        return self.read_length_prefixed(prefix_size, &#39;latin1&#39;)

    def read_length_prefixed_utf8(self, prefix_size: int = 32):
        return self.read_length_prefixed(prefix_size, &#39;utf8&#39;)

    def read_length_prefixed_utf16(self, prefix_size: int = 32, bytecount: bool = False):
        block_size = 1 if bytecount else 2
        return self.read_length_prefixed(prefix_size, &#39;utf-16le&#39;, block_size)

    @overload
    def read_length_prefixed(self, *, encoding: str, prefix_size: int = 32, block_size: int = 1) -&gt; str:
        ...

    @overload
    def read_length_prefixed(self, prefix_size: int, encoding: str, block_size: int = 1) -&gt; str:
        ...

    @overload
    def read_length_prefixed(self, *, prefix_size: int = 32, block_size: int = 1) -&gt; T:
        ...

    @overload
    def read_length_prefixed(self, prefix_size: int, *, block_size: int = 1) -&gt; T:
        ...

    def read_length_prefixed(self, prefix_size: int = 32, encoding: str | None = None, block_size: int = 1) -&gt; T | str:
        prefix = self.read_integer(prefix_size) * block_size
        data = self.read(prefix)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    def read_7bit_encoded_int(self, max_bits: int = 0, bigendian: bool | None = None) -&gt; int:
        value = 0
        shift = 0
        if bigendian is None:
            bigendian = self.bigendian
        while True:
            b = self.u8fast()
            if bigendian:
                value &lt;&lt;= 7
                value |= (b &amp; 0x7F)
            else:
                value |= (b &amp; 0x7F) &lt;&lt; shift
            if not b &amp; 0x80:
                return value
            if (shift := shift + 7) &gt; max_bits &gt; 0:
                raise OverflowError(&#39;Maximum bits were exceeded by encoded integer.&#39;)


class StructMeta(type):
    &#34;&#34;&#34;
    A metaclass to facilitate the behavior outlined for `refinery.lib.structures.Struct`.
    &#34;&#34;&#34;
    def __new__(mcls, name, bases, nmspc, parser=StructReader):
        return type.__new__(mcls, name, bases, nmspc)

    def __init__(cls, name, bases, nmspc, parser=StructReader):
        super().__init__(name, bases, nmspc)
        original__init__ = cls.__init__

        @functools.wraps(original__init__)
        def wrapped__init__(self: Struct, reader, *args, **kwargs):
            if not isinstance(reader, parser):
                if issubclass(parser, reader.__class__):
                    raise ValueError(
                        F&#39;A reader of type {reader.__class__.__name__} was passed to {cls.__name__}, &#39;
                        F&#39;but a {parser.__name__} is required.&#39;)
                reader = parser(reader)
            start = reader.tell()
            view = reader.getbuffer()
            original__init__(self, reader, *args, **kwargs)
            self._data = view[start:reader.tell()]
            del view

        setattr(cls, &#39;__init__&#39;, wrapped__init__)


class Struct(Generic[T], metaclass=StructMeta):
    &#34;&#34;&#34;
    A class to parse structured data. A `refinery.lib.structures.Struct` class can be instantiated
    as follows:

        foo = Struct(data, bar=29)

    The initialization routine of the structure will be called with a single argument `reader`. If
    the object `data` is already a `refinery.lib.structures.StructReader`, then it will be passed
    as `reader`. Otherwise, the argument will be wrapped in a `refinery.lib.structures.StructReader`.
    Additional arguments to the struct are passed through.
    &#34;&#34;&#34;
    _data: memoryview | bytearray

    @classmethod
    def Parse(cls, reader: T | StructReader[T], *args, **kwargs):
        if not isinstance(reader, StructReader):
            reader = StructReader(reader)
        start = reader.tell()
        view = reader.getbuffer()
        result = cls(reader, *args, **kwargs)
        result._data = view[start:reader.tell()]
        return result

    def __len__(self):
        return len(self._data)

    def __bytes__(self):
        return bytes(self._data)

    def get_data(self, decouple=False):
        if decouple and isinstance(self._data, memoryview):
            self._data = bytearray(self._data)
        return self._data

    def __init__(self, reader: StructReader[T], *args, **kwargs):
        pass


AttrType = TypeVar(&#39;AttrType&#39;)


class PerInstanceAttribute(Generic[AttrType]):
    def resolve(self, parent, value: Any) -&gt; AttrType:
        return value

    def __init__(self):
        self.__set: dict[int, Any] = {}
        self.__get: dict[int, AttrType] = {}

    def __set__(self, parent: Any, value: Any) -&gt; None:
        pid = id(parent)
        if pid not in self.__set:
            def cleanup(self, pid):
                self.__set.pop(pid, None)
                self.__get.pop(pid, None)
            self.__set[pid] = value
            weakref.finalize(parent, cleanup, self, id(parent))

    def __get__(self, parent, tp=None) -&gt; AttrType:
        pid = id(parent)
        if pid not in self.__get:
            try:
                seed = self.__set[pid]
            except KeyError as K:
                raise AttributeError from K
            self.__get[pid] = self.resolve(parent, seed)
        return self.__get[pid]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.structures.signed"><code class="name flex">
<span>def <span class="ident">signed</span></span>(<span>k, bitsize)</span>
</code></dt>
<dd>
<section class="desc"><p>If <code>k</code> is an integer of the given bit size, cast it to a signed one.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L48-L54" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def signed(k: int, bitsize: int):
    &#34;&#34;&#34;
    If `k` is an integer of the given bit size, cast it to a signed one.
    &#34;&#34;&#34;
    M = 1 &lt;&lt; bitsize
    k = k &amp; (M - 1)
    return k - M if k &gt;&gt; (bitsize - 1) else k</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.structures.EOF"><code class="flex name class">
<span>class <span class="ident">EOF</span></span>
<span>(</span><span>rest=b'')</span>
</code></dt>
<dd>
<section class="desc"><p>While reading from a <code><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></code>, less bytes were available than
requested. The exception contains the data from the incomplete read.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L57-L67" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class EOF(EOFError):
    &#34;&#34;&#34;
    While reading from a `refinery.lib.structures.MemoryFile`, less bytes were available than
    requested. The exception contains the data from the incomplete read.
    &#34;&#34;&#34;
    def __init__(self, rest: buf = B&#39;&#39;):
        super().__init__(&#39;Unexpected end of buffer.&#39;)
        self.rest = rest

    def __bytes__(self):
        return bytes(self.rest)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.EOFError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.structures.StreamDetour"><code class="flex name class">
<span>class <span class="ident">StreamDetour</span></span>
<span>(</span><span>stream, offset=None, whence=0)</span>
</code></dt>
<dd>
<section class="desc"><p>A stream detour is used as a context manager to temporarily read from a different location
in the stream and then return to the original offset when the context ends.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L70-L87" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StreamDetour(Generic[R]):
    &#34;&#34;&#34;
    A stream detour is used as a context manager to temporarily read from a different location
    in the stream and then return to the original offset when the context ends.
    &#34;&#34;&#34;
    def __init__(self, stream: R, offset: int | None = None, whence: int = io.SEEK_SET):
        self.stream = stream
        self.offset = offset
        self.whence = whence

    def __enter__(self):
        self.cursor = self.stream.tell()
        if self.offset is not None:
            self.stream.seek(self.offset, self.whence)
        return self

    def __exit__(self, *args):
        self.stream.seek(self.cursor, io.SEEK_SET)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods"><code class="flex name class">
<span>class <span class="ident">MemoryFileMethods</span></span>
<span>(</span><span>data=None, output=None, fileno=None, size_limit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A thin wrapper around (potentially mutable) byte sequences which gives it the features of a
file-like object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L90-L431" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MemoryFileMethods(Generic[T, B]):
    &#34;&#34;&#34;
    A thin wrapper around (potentially mutable) byte sequences which gives it the features of a
    file-like object.
    &#34;&#34;&#34;
    _data: T
    _output: type[B]
    _cursor: int
    _closed: bool

    class SEEK(int, enum.Enum):
        CUR = io.SEEK_CUR
        END = io.SEEK_END
        SET = io.SEEK_SET

    def __bytes__(self):
        return bytes(self._data)

    def __init__(
        self,
        data: T | None = None,
        output: type[B] | None = None,
        fileno: int | None = None,
        size_limit: int | None = None,
    ) -&gt; None:
        if data is None:
            if TYPE_CHECKING:
                data = cast(T, bytearray())
            else:
                data = bytearray()
        if output is None:
            if TYPE_CHECKING:
                output = cast(type[B], type(data))
            else:
                output = type(data)
        if size_limit is not None and len(data) &gt; size_limit:
            raise ValueError(&#39;Initial data exceeds size limit&#39;)
        self._output = output
        self._cursor = 0
        self._closed = False
        self._fileno = fileno
        self._size_limit = size_limit
        self._data = data

    def close(self) -&gt; None:
        self._closed = True

    @property
    def closed(self) -&gt; bool:
        return self._closed

    def __enter__(self):
        return self

    def __exit__(self, ex_type, ex_value, trace) -&gt; bool:
        return False

    def flush(self) -&gt; None:
        pass

    def isatty(self) -&gt; bool:
        return False

    def __iter__(self):
        return self

    def __len__(self):
        return len(self._data)

    def __next__(self):
        line = self.readline()
        if not line:
            raise StopIteration
        return line

    def fileno(self) -&gt; int:
        if self._fileno is None:
            raise OSError
        return self._fileno

    def readable(self) -&gt; bool:
        return not self._closed

    def seekable(self) -&gt; bool:
        return not self._closed

    @property
    def eof(self) -&gt; bool:
        return self._closed or self._cursor &gt;= len(self._data)

    @property
    def remaining_bytes(self) -&gt; int:
        return len(self._data) - self.tell()

    def detour(self, offset: int | None = None, whence: int = io.SEEK_SET):
        return StreamDetour(cast(io.IOBase, self), offset, whence=whence)

    def detour_absolute(self, offset: int | None = None):
        return self.detour(offset, io.SEEK_SET)

    def detour_relative(self, offset: int | None = None):
        return self.detour(offset, io.SEEK_CUR)

    def detour_from_end(self, offset: int | None = None):
        return self.detour(offset, io.SEEK_END)

    def writable(self) -&gt; bool:
        if self._closed:
            return False
        if isinstance(self._data, memoryview):
            return not self._data.readonly
        return isinstance(self._data, bytearray)

    def read_as(self, cast: type[C], size: int = -1, peek: bool = False) -&gt; C:
        out = self.read(size, peek)
        if not isinstance(out, cast):
            out = cast(out)
        return out

    def read(self, size: int | None = None, peek: bool = False) -&gt; B:
        beginning = self._cursor
        if size is None or size &lt; 0:
            end = len(self._data)
        else:
            end = min(self._cursor + size, len(self._data))
        result = self._data[beginning:end]
        if not isinstance(result, t := self._output):
            result = t(result)
        if not peek:
            self._cursor = end
        return result

    def readif(self, value: bytes) -&gt; bool:
        size = len(value)
        stop = self._cursor + size
        mv = memoryview(self._data)
        if match := mv[self._cursor:stop] == value:
            self._cursor = stop
        return match

    def peek(self, size: int | None = None) -&gt; memoryview:
        cursor = self._cursor
        mv = memoryview(self._data)
        if size is None or size &lt; 0:
            return mv[cursor:]
        return mv[cursor:cursor + size]

    def read1(self, size: int | None = None, peek: bool = False) -&gt; B:
        return self.read(size, peek)

    def _find_linebreak(self, beginning: int, end: int) -&gt; int:
        if not isinstance(self._data, memoryview):
            return self._data.find(B&#39;\n&#39;, beginning, end)
        for k in range(beginning, end):
            if self._data[k] == 0xA: return k
        return -1

    def readline(self, size: int | None = None) -&gt; B:
        beginning, end = self._cursor, len(self._data)
        if size is not None and size &gt;= 0:
            end = beginning + size
        p = self._find_linebreak(beginning, end)
        self._cursor = end if p &lt; 0 else p + 1
        result = self._data[beginning:self._cursor]
        if not isinstance(result, t := self._output):
            result = t(result)
        return result

    def readlines_iter(self, hint: int | None = None) -&gt; Iterable[B]:
        if hint is None or hint &lt; 0:
            yield from self
        else:
            total = 0
            while total &lt; hint:
                line = next(self)
                total += len(line)
                yield line

    def readlines(self, hint: int | None = None) -&gt; list[bytes]:
        it = self.readlines_iter(hint)
        if issubclass(self._output, bytes):
            return list(it)
        return [bytes(t) for t in it]

    def readinto1(self, b) -&gt; int:
        data = self.read(len(b))
        size = len(data)
        b[:size] = data
        return size

    def readinto(self, b) -&gt; int:
        return self.readinto1(b)

    def tell(self) -&gt; int:
        return self._cursor

    def skip(self, n: int):
        self._cursor += n

    def seekrel(self, offset: int) -&gt; int:
        return self.seek(offset, io.SEEK_CUR)

    def seekset(self, offset: int) -&gt; int:
        if offset &lt; 0:
            return self.seek(offset, io.SEEK_END)
        else:
            return self.seek(offset, io.SEEK_SET)

    def getbuffer(self) -&gt; memoryview:
        return memoryview(self._data)

    def getvalue(self) -&gt; T:
        return self._data

    def seek(self, offset: int, whence=io.SEEK_SET) -&gt; int:
        if whence == io.SEEK_SET:
            if offset &lt; 0:
                raise ValueError(&#39;no negative offsets allowed for SEEK_SET.&#39;)
            self._cursor = offset
        elif whence == io.SEEK_CUR:
            self._cursor += offset
        elif whence == io.SEEK_END:
            self._cursor = len(self._data) + offset
        self._cursor = max(self._cursor, 0)
        self._cursor = min(self._cursor, len(self._data))
        return self._cursor

    def writelines(self, lines: Iterable[Iterable[int]] | Iterable[Buffer]) -&gt; None:
        for line in lines:
            self.write(line)

    def truncate(self, size: int | None = None) -&gt; int:
        if not isinstance(self._data, bytearray):
            raise TypeError
        if size is not None:
            if not (0 &lt;= size &lt;= len(self._data)):
                raise ValueError(&#39;invalid size value&#39;)
            self._cursor = size
        del self._data[self._cursor:]
        return self.tell()

    def write_byte(self, byte: int) -&gt; None:
        if isinstance(self._data, bytes):
            raise TypeError
        if isinstance(self._data, memoryview):
            raise NotImplementedError
        limit = self._size_limit
        cc = self._cursor
        nc = cc + 1
        if limit and nc &gt; limit:
            raise EOF(bytes((byte,)))
        try:
            if cc &lt; len(self._data):
                self._data[cc] = byte
            else:
                self._data.append(byte)
        except Exception as T:
            raise OSError(str(T)) from T
        else:
            self._cursor = nc

    def write(self, _data: Buffer | Iterable[int]) -&gt; int:
        out = self._data
        end = len(out)

        if isinstance(out, memoryview):
            if out.readonly:
                raise PermissionError
            out = out.obj
        if not isinstance(out, bytearray):
            raise PermissionError

        try:
            getbuf = cast(&#39;Buffer&#39;, _data).__buffer__
        except AttributeError:
            data = cast(&#39;Iterable[int]&#39;, _data)
        else:
            data = getbuf(0)

        beginning = self._cursor
        limit = self._size_limit

        if limit is None and beginning == end:
            out[end:] = data
            self._cursor = end = len(out)
            return end - beginning
        try:
            size = len(cast(Sized, data))
        except Exception:
            it = iter(data)
            cursor = 0
            for cursor, b in enumerate(it, beginning):
                out[cursor] = b
                if cursor &gt;= end - 1:
                    break
            else:
                cursor += 1
                self._cursor = cursor
                return cursor - beginning
            if limit is None:
                out[end:] = bytes(it)
            else:
                out[end:limit] = bytes(itertools.islice(it, 0, limit - end))
                try:
                    b = next(it)
                except StopIteration:
                    self._cursor = limit
                    return limit - beginning
                else:
                    rest = bytearray((b,))
                    rest[1:] = it
                    raise EOF(rest)
        else:
            if limit and size + beginning &gt; limit:
                raise EOF(bytes(data))
            self._cursor += size
            try:
                out[beginning:self._cursor] = data
            except Exception as T:
                self._cursor = beginning
                raise OSError(str(T)) from T
            return size
        self._cursor = end = len(out)
        return end - beginning

    def __getitem__(self, slice):
        result = self._data[slice]
        if not isinstance(result, t := self._output):
            result = t(result)
        return result

    def replay(self, offset: int, length: int):
        cursor = self._cursor
        if offset not in range(cursor + 1):
            raise ValueError(F&#39;The supplied delta {offset} is not in the valid range [0,{self._cursor}].&#39;)
        rep, r = divmod(length, offset)
        offset = cursor - offset
        replay = self._data[offset:offset + r]
        if rep &gt; 0:
            # While this is technically a copy, it is faster than repeated calls to write.
            replay = bytes(self._data[offset:cursor]) * rep + replay
        self.write(replay)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.structures.MemoryFileMethods.SEEK"><code class="name">var <span class="ident">SEEK</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating-point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.structures.MemoryFileMethods.closed"><code class="name">var <span class="ident">closed</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L137-L139" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def closed(self) -&gt; bool:
    return self._closed</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.eof"><code class="name">var <span class="ident">eof</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L176-L178" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eof(self) -&gt; bool:
    return self._closed or self._cursor &gt;= len(self._data)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.remaining_bytes"><code class="name">var <span class="ident">remaining_bytes</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L180-L182" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def remaining_bytes(self) -&gt; int:
    return len(self._data) - self.tell()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.structures.MemoryFileMethods.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L134-L135" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    self._closed = True</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L147-L148" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flush(self) -&gt; None:
    pass</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.isatty"><code class="name flex">
<span>def <span class="ident">isatty</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L150-L151" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isatty(self) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.fileno"><code class="name flex">
<span>def <span class="ident">fileno</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L165-L168" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fileno(self) -&gt; int:
    if self._fileno is None:
        raise OSError
    return self._fileno</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readable"><code class="name flex">
<span>def <span class="ident">readable</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L170-L171" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readable(self) -&gt; bool:
    return not self._closed</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.seekable"><code class="name flex">
<span>def <span class="ident">seekable</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L173-L174" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seekable(self) -&gt; bool:
    return not self._closed</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.detour"><code class="name flex">
<span>def <span class="ident">detour</span></span>(<span>self, offset=None, whence=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L184-L185" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def detour(self, offset: int | None = None, whence: int = io.SEEK_SET):
    return StreamDetour(cast(io.IOBase, self), offset, whence=whence)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.detour_absolute"><code class="name flex">
<span>def <span class="ident">detour_absolute</span></span>(<span>self, offset=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L187-L188" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def detour_absolute(self, offset: int | None = None):
    return self.detour(offset, io.SEEK_SET)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.detour_relative"><code class="name flex">
<span>def <span class="ident">detour_relative</span></span>(<span>self, offset=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L190-L191" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def detour_relative(self, offset: int | None = None):
    return self.detour(offset, io.SEEK_CUR)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.detour_from_end"><code class="name flex">
<span>def <span class="ident">detour_from_end</span></span>(<span>self, offset=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L193-L194" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def detour_from_end(self, offset: int | None = None):
    return self.detour(offset, io.SEEK_END)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.writable"><code class="name flex">
<span>def <span class="ident">writable</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L196-L201" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def writable(self) -&gt; bool:
    if self._closed:
        return False
    if isinstance(self._data, memoryview):
        return not self._data.readonly
    return isinstance(self._data, bytearray)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.read_as"><code class="name flex">
<span>def <span class="ident">read_as</span></span>(<span>self, cast, size=-1, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L203-L207" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_as(self, cast: type[C], size: int = -1, peek: bool = False) -&gt; C:
    out = self.read(size, peek)
    if not isinstance(out, cast):
        out = cast(out)
    return out</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, size=None, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L209-L220" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read(self, size: int | None = None, peek: bool = False) -&gt; B:
    beginning = self._cursor
    if size is None or size &lt; 0:
        end = len(self._data)
    else:
        end = min(self._cursor + size, len(self._data))
    result = self._data[beginning:end]
    if not isinstance(result, t := self._output):
        result = t(result)
    if not peek:
        self._cursor = end
    return result</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readif"><code class="name flex">
<span>def <span class="ident">readif</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L222-L228" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readif(self, value: bytes) -&gt; bool:
    size = len(value)
    stop = self._cursor + size
    mv = memoryview(self._data)
    if match := mv[self._cursor:stop] == value:
        self._cursor = stop
    return match</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.peek"><code class="name flex">
<span>def <span class="ident">peek</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L230-L235" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def peek(self, size: int | None = None) -&gt; memoryview:
    cursor = self._cursor
    mv = memoryview(self._data)
    if size is None or size &lt; 0:
        return mv[cursor:]
    return mv[cursor:cursor + size]</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.read1"><code class="name flex">
<span>def <span class="ident">read1</span></span>(<span>self, size=None, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L237-L238" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read1(self, size: int | None = None, peek: bool = False) -&gt; B:
    return self.read(size, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readline"><code class="name flex">
<span>def <span class="ident">readline</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L247-L256" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readline(self, size: int | None = None) -&gt; B:
    beginning, end = self._cursor, len(self._data)
    if size is not None and size &gt;= 0:
        end = beginning + size
    p = self._find_linebreak(beginning, end)
    self._cursor = end if p &lt; 0 else p + 1
    result = self._data[beginning:self._cursor]
    if not isinstance(result, t := self._output):
        result = t(result)
    return result</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readlines_iter"><code class="name flex">
<span>def <span class="ident">readlines_iter</span></span>(<span>self, hint=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L258-L266" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readlines_iter(self, hint: int | None = None) -&gt; Iterable[B]:
    if hint is None or hint &lt; 0:
        yield from self
    else:
        total = 0
        while total &lt; hint:
            line = next(self)
            total += len(line)
            yield line</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readlines"><code class="name flex">
<span>def <span class="ident">readlines</span></span>(<span>self, hint=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L268-L272" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readlines(self, hint: int | None = None) -&gt; list[bytes]:
    it = self.readlines_iter(hint)
    if issubclass(self._output, bytes):
        return list(it)
    return [bytes(t) for t in it]</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readinto1"><code class="name flex">
<span>def <span class="ident">readinto1</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L274-L278" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readinto1(self, b) -&gt; int:
    data = self.read(len(b))
    size = len(data)
    b[:size] = data
    return size</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readinto"><code class="name flex">
<span>def <span class="ident">readinto</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L280-L281" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readinto(self, b) -&gt; int:
    return self.readinto1(b)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.tell"><code class="name flex">
<span>def <span class="ident">tell</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L283-L284" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tell(self) -&gt; int:
    return self._cursor</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.skip"><code class="name flex">
<span>def <span class="ident">skip</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L286-L287" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def skip(self, n: int):
    self._cursor += n</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.seekrel"><code class="name flex">
<span>def <span class="ident">seekrel</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L289-L290" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seekrel(self, offset: int) -&gt; int:
    return self.seek(offset, io.SEEK_CUR)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.seekset"><code class="name flex">
<span>def <span class="ident">seekset</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L292-L296" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seekset(self, offset: int) -&gt; int:
    if offset &lt; 0:
        return self.seek(offset, io.SEEK_END)
    else:
        return self.seek(offset, io.SEEK_SET)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.getbuffer"><code class="name flex">
<span>def <span class="ident">getbuffer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L298-L299" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getbuffer(self) -&gt; memoryview:
    return memoryview(self._data)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.getvalue"><code class="name flex">
<span>def <span class="ident">getvalue</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L301-L302" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getvalue(self) -&gt; T:
    return self._data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.seek"><code class="name flex">
<span>def <span class="ident">seek</span></span>(<span>self, offset, whence=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L304-L315" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seek(self, offset: int, whence=io.SEEK_SET) -&gt; int:
    if whence == io.SEEK_SET:
        if offset &lt; 0:
            raise ValueError(&#39;no negative offsets allowed for SEEK_SET.&#39;)
        self._cursor = offset
    elif whence == io.SEEK_CUR:
        self._cursor += offset
    elif whence == io.SEEK_END:
        self._cursor = len(self._data) + offset
    self._cursor = max(self._cursor, 0)
    self._cursor = min(self._cursor, len(self._data))
    return self._cursor</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.writelines"><code class="name flex">
<span>def <span class="ident">writelines</span></span>(<span>self, lines)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L317-L319" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def writelines(self, lines: Iterable[Iterable[int]] | Iterable[Buffer]) -&gt; None:
    for line in lines:
        self.write(line)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L321-L329" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def truncate(self, size: int | None = None) -&gt; int:
    if not isinstance(self._data, bytearray):
        raise TypeError
    if size is not None:
        if not (0 &lt;= size &lt;= len(self._data)):
            raise ValueError(&#39;invalid size value&#39;)
        self._cursor = size
    del self._data[self._cursor:]
    return self.tell()</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.write_byte"><code class="name flex">
<span>def <span class="ident">write_byte</span></span>(<span>self, byte)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L331-L349" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def write_byte(self, byte: int) -&gt; None:
    if isinstance(self._data, bytes):
        raise TypeError
    if isinstance(self._data, memoryview):
        raise NotImplementedError
    limit = self._size_limit
    cc = self._cursor
    nc = cc + 1
    if limit and nc &gt; limit:
        raise EOF(bytes((byte,)))
    try:
        if cc &lt; len(self._data):
            self._data[cc] = byte
        else:
            self._data.append(byte)
    except Exception as T:
        raise OSError(str(T)) from T
    else:
        self._cursor = nc</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, _data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L351-L413" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def write(self, _data: Buffer | Iterable[int]) -&gt; int:
    out = self._data
    end = len(out)

    if isinstance(out, memoryview):
        if out.readonly:
            raise PermissionError
        out = out.obj
    if not isinstance(out, bytearray):
        raise PermissionError

    try:
        getbuf = cast(&#39;Buffer&#39;, _data).__buffer__
    except AttributeError:
        data = cast(&#39;Iterable[int]&#39;, _data)
    else:
        data = getbuf(0)

    beginning = self._cursor
    limit = self._size_limit

    if limit is None and beginning == end:
        out[end:] = data
        self._cursor = end = len(out)
        return end - beginning
    try:
        size = len(cast(Sized, data))
    except Exception:
        it = iter(data)
        cursor = 0
        for cursor, b in enumerate(it, beginning):
            out[cursor] = b
            if cursor &gt;= end - 1:
                break
        else:
            cursor += 1
            self._cursor = cursor
            return cursor - beginning
        if limit is None:
            out[end:] = bytes(it)
        else:
            out[end:limit] = bytes(itertools.islice(it, 0, limit - end))
            try:
                b = next(it)
            except StopIteration:
                self._cursor = limit
                return limit - beginning
            else:
                rest = bytearray((b,))
                rest[1:] = it
                raise EOF(rest)
    else:
        if limit and size + beginning &gt; limit:
            raise EOF(bytes(data))
        self._cursor += size
        try:
            out[beginning:self._cursor] = data
        except Exception as T:
            self._cursor = beginning
            raise OSError(str(T)) from T
        return size
    self._cursor = end = len(out)
    return end - beginning</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.replay"><code class="name flex">
<span>def <span class="ident">replay</span></span>(<span>self, offset, length)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L421-L431" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def replay(self, offset: int, length: int):
    cursor = self._cursor
    if offset not in range(cursor + 1):
        raise ValueError(F&#39;The supplied delta {offset} is not in the valid range [0,{self._cursor}].&#39;)
    rep, r = divmod(length, offset)
    offset = cursor - offset
    replay = self._data[offset:offset + r]
    if rep &gt; 0:
        # While this is technically a copy, it is faster than repeated calls to write.
        replay = bytes(self._data[offset:cursor]) * rep + replay
    self.write(replay)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.structures.MemoryFile"><code class="flex name class">
<span>class <span class="ident">MemoryFile</span></span>
<span>(</span><span>data=None, output=None, fileno=None, size_limit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A thin wrapper around (potentially mutable) byte sequences which gives it the features of a
file-like object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L434-L435" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MemoryFile(MemoryFileMethods[T, B], io.BytesIO):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.MemoryFileMethods" href="#refinery.lib.structures.MemoryFileMethods">MemoryFileMethods</a></li>
<li>typing.Generic</li>
<li>_io.BytesIO</li>
<li>_io._BufferedIOBase</li>
<li>_io._IOBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.StructReader" href="#refinery.lib.structures.StructReader">StructReader</a></li>
<li><a title="refinery.units.formats.httpresponse.SockWrapper" href="../units/formats/httpresponse.html#refinery.units.formats.httpresponse.SockWrapper">SockWrapper</a></li>
<li><a title="refinery.units.pattern.carve_7z.MemoryFileRecorder" href="../units/pattern/carve_7z.html#refinery.units.pattern.carve_7z.MemoryFileRecorder">MemoryFileRecorder</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.structures.MemoryFileMethods" href="#refinery.lib.structures.MemoryFileMethods">MemoryFileMethods</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.structures.MemoryFileMethods.SEEK" href="#refinery.lib.structures.MemoryFileMethods.SEEK">SEEK</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.structures.order"><code class="flex name class">
<span>class <span class="ident">order</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L438-L440" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class order(str, enum.Enum):
    big = &#39;&gt;&#39;
    little = &#39;&lt;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.structures.order.big"><code class="name">var <span class="ident">big</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.structures.order.little"><code class="name">var <span class="ident">little</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.structures.StructReader"><code class="flex name class">
<span>class <span class="ident">StructReader</span></span>
<span>(</span><span>data, bigendian=False)</span>
</code></dt>
<dd>
<section class="desc"><p>An extension of a <code><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></code> which provides methods to read
structured data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L443-L811" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StructReader(MemoryFile[T, T]):
    &#34;&#34;&#34;
    An extension of a `refinery.lib.structures.MemoryFile` which provides methods to read
    structured data.
    &#34;&#34;&#34;

    class Unaligned(RuntimeError):
        pass

    def __init__(self, data: T, bigendian: bool = False):
        super().__init__(data)
        self._bbits = 0
        self._nbits = 0
        self.bigendian = bigendian

    def __enter__(self) -&gt; StructReader:
        return super().__enter__()

    @property
    @contextlib.contextmanager
    def be(self):
        self.bigendian = True
        try:
            yield self
        finally:
            self.bigendian = False

    @property
    def byteorder_format(self) -&gt; str:
        return &#39;&gt;&#39; if self.bigendian else &#39;&lt;&#39;

    @property
    def byteorder_name(self):
        return &#39;big&#39; if self.bigendian else &#39;little&#39;

    def seek(self, offset, whence=io.SEEK_SET) -&gt; int:
        self._bbits = 0
        self._nbits = 0
        return super().seek(offset, whence)

    def read_exactly(self, size: int | None = None, peek: bool = False) -&gt; T:
        &#34;&#34;&#34;
        Read bytes from the underlying stream. Raises a `RuntimeError` when the stream is not currently
        byte-aligned, i.e. when `refinery.lib.structures.StructReader.byte_aligned` is `False`. Raises
        an exception of type `refinery.lib.structures.EOF` when fewer data is available in the stream than
        requested via the `size` parameter. The remaining data can be extracted from the exception.
        Use `refinery.lib.structures.StructReader.read_bytes` to read bytes from the stream when it is
        not byte-aligned.
        &#34;&#34;&#34;
        if not self.byte_aligned:
            raise StructReader.Unaligned(&#39;buffer is not byte-aligned&#39;)
        data = self.read1(size, peek)
        if size and len(data) &lt; size:
            raise EOF(data)
        return data

    @property
    def byte_aligned(self) -&gt; bool:
        &#34;&#34;&#34;
        This property is `True` if and only if there are currently no bits still waiting in the internal
        bit buffer.
        &#34;&#34;&#34;
        return not self._nbits

    def byte_align(self, blocksize: int = 1) -&gt; tuple[int, int]:
        &#34;&#34;&#34;
        This method clears the internal bit buffer and moves the cursor to the next byte. It returns a
        tuple containing the size and contents of the bit buffer.
        &#34;&#34;&#34;
        nbits = self._nbits
        bbits = self._bbits
        self._nbits = 0
        self._bbits = 0
        mod = self._cursor % blocksize
        if mod:
            self.seekrel(blocksize - mod)
        return nbits, bbits

    @property
    def remaining_bits(self) -&gt; int:
        return 8 * self.remaining_bytes + self._nbits

    def read_integer(self, length: int | None = None, peek: bool = False, bigendian: bool | None = None) -&gt; int:
        &#34;&#34;&#34;
        Read `length` many bits from the underlying stream as an integer.
        &#34;&#34;&#34;
        if length is None:
            length = self.remaining_bits
        if bigendian is None:
            bigendian = self.bigendian
        if length &lt; self._nbits:
            new_count = self._nbits - length
            if bigendian:
                result = self._bbits &gt;&gt; new_count
                if not peek:
                    self._bbits ^= result &lt;&lt; new_count
            else:
                result = self._bbits &amp; 2 ** length - 1
                if not peek:
                    self._bbits &gt;&gt;= length
            if not peek:
                self._nbits = new_count
            return result

        nbits, bbits = self._nbits, self._bbits
        number_of_missing_bits = length - nbits
        bytecount, rest = divmod(number_of_missing_bits, 8)
        if rest:
            bytecount += 1
            rest = 8 - rest
        bb = self.read1(bytecount, True)
        if len(bb) != bytecount:
            raise EOFError
        if not peek:
            self.seekrel(bytecount)
        if bytecount == 1:
            result, = bb
        else:
            result = int.from_bytes(bb, self.byteorder_name)
        if not nbits and not rest:
            return result
        if bigendian:
            rbmask   = 2 ** rest - 1       # noqa
            excess   = result &amp; rbmask     # noqa
            result &gt;&gt;= rest                # noqa
            result  ^= bbits &lt;&lt; number_of_missing_bits   # noqa
        else:
            excess   = result &gt;&gt; number_of_missing_bits  # noqa
            result  ^= excess &lt;&lt; number_of_missing_bits  # noqa
            result &lt;&lt;= nbits               # noqa
            result  |= bbits               # noqa
        assert excess.bit_length() &lt;= rest
        if not peek:
            self._nbits = rest
            self._bbits = excess
        return result

    def read_bytes(self, size: int, peek: bool = False) -&gt; bytes:
        &#34;&#34;&#34;
        The method reads `size` many bytes from the underlying stream starting at the current bit.
        &#34;&#34;&#34;
        if self.byte_aligned:
            data = self.read_exactly(size, peek)
            if not isinstance(data, bytes):
                data = bytes(data)
            return data
        else:
            return self.read_integer(size * 8, peek).to_bytes(size, self.byteorder_name)

    def read_bit(self) -&gt; int:
        &#34;&#34;&#34;
        This function is a shortcut for calling `refinery.lib.structures.StructReader.read_integer` with
        an argument of `1`, i.e. this reads the next bit from the stream. The bits of any byte in the stream
        are read from least significant to most significant.
        &#34;&#34;&#34;
        return self.read_integer(1)

    def read_bits(self, nbits: int, bigendian: bool | None = None) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        This method returns the bits of `refinery.lib.structures.StructReader.read_integer` one by one.
        &#34;&#34;&#34;
        if bigendian is None:
            bigendian = self.bigendian
        chunk = self.read_integer(nbits, bigendian=bigendian)
        it = range(nbits - 1, -1, -1) if bigendian else range(nbits)
        for k in it:
            yield chunk &gt;&gt; k &amp; 1

    def read_flags(self, nbits: int, reverse=False) -&gt; Iterable[bool]:
        &#34;&#34;&#34;
        Identical to `refinery.lib.structures.StructReader.read_bits` with every bit value cast to a boolean.
        &#34;&#34;&#34;
        bits = list(self.read_bits(nbits))
        if reverse:
            bits.reverse()
        for bit in bits:
            yield bool(bit)

    def read_one_struct(self, spec: str, peek=False) -&gt; UnpackType:
        item, = self.read_struct(spec, peek=peek)
        return item

    def read_struct(self, spec: str, peek=False) -&gt; list[UnpackType]:
        &#34;&#34;&#34;
        Read structured data from the stream in any format supported by the `struct` module. The `format`
        argument can be used to override the current byte ordering. If the `unwrap` parameter is `True`, a
        single unpacked value will be returned as a scalar, not as a tuple with one element.
        &#34;&#34;&#34;
        if not spec:
            raise ValueError(&#39;no format specified&#39;)
        byteorder = spec[:1]
        if byteorder in &#39;&lt;!=@&gt;&#39;:
            spec = spec[1:]
        else:
            byteorder = self.byteorder_format
        data = []
        current_cursor = self.tell()

        # reserved struct characters: xcbB?hHiIlLqQnNefdspP
        for k, part in enumerate(re.split(&#39;(\\d*[auwgk])&#39;, spec)):
            if k % 2 == 1:
                count = 1 if len(part) == 1 else int(part[:~0])
                part = part[~0]
                for _ in range(count):
                    if part == &#39;a&#39;:
                        data.append(self.read_c_string())
                    elif part == &#39;g&#39;:
                        data.append(str(self.read_guid()))
                    elif part == &#39;u&#39;:
                        data.append(self.read_w_string())
                    elif part == &#39;w&#39;:
                        data.append(codecs.decode(self.read_w_string(), &#39;utf-16le&#39;))
                    elif part == &#39;k&#39;:
                        data.append(self.read_7bit_encoded_int())
                continue
            else:
                part = F&#39;{byteorder}{part}&#39;
                data.extend(struct.unpack(part, self.read_bytes(struct.calcsize(part))))
        if peek:
            self.seekset(current_cursor)
        return data

    def read_nibble(self, peek: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Calls `refinery.lib.structures.StructReader.read_integer` with an argument of `4`.
        &#34;&#34;&#34;
        return self.read_integer(4, peek)

    def u8(self, peek: bool = False) -&gt; int: return self.read_integer(8, peek)
    def i8(self, peek: bool = False) -&gt; int: return signed(self.read_integer(8, peek), 8)

    def u16(self, peek: bool = False) -&gt; int: return self.read_integer(16, peek)
    def u32(self, peek: bool = False) -&gt; int: return self.read_integer(32, peek)
    def u64(self, peek: bool = False) -&gt; int: return self.read_integer(64, peek)
    def i16(self, peek: bool = False) -&gt; int: return signed(self.read_integer(16, peek), 16)
    def i32(self, peek: bool = False) -&gt; int: return signed(self.read_integer(32, peek), 32)
    def i64(self, peek: bool = False) -&gt; int: return signed(self.read_integer(64, peek), 64)

    def f32(self, peek: bool = False) -&gt; float: return cast(float, self.read_one_struct(&#39;f&#39;, peek=peek))
    def f64(self, peek: bool = False) -&gt; float: return cast(float, self.read_one_struct(&#39;d&#39;, peek=peek))

    def u8fast(self):
        try:
            b = self._data[self._cursor]
        except IndexError:
            raise EOFError
        else:
            self._cursor += 1
            return b

    def read_byte(self, peek: bool = False) -&gt; int: return self.read_integer(8, peek)
    def read_char(self, peek: bool = False) -&gt; int: return signed(self.read_integer(8, peek), 8)

    def read_terminated_array(self, terminator: bytes, alignment: int = 1) -&gt; bytearray:
        buf = self.getvalue()
        pos = self.tell()
        n = len(terminator)

        if isinstance(buf, memoryview):
            def find(whence: int):
                for k in range(whence, len(buf)):
                    if buf[k:k + n] == terminator:
                        return k
                return -1
        else:
            def find(whence: int):
                return buf.find(terminator, whence)
        try:
            end = pos - 1
            while True:
                end = find(end + 1)
                if end &lt; 0 or not (end - pos) % alignment:
                    break
        except AttributeError:
            result = bytearray()
            while not self.eof:
                result.extend(self.read_exactly(alignment))
                if result.endswith(terminator):
                    return result[:-n]
            self.seek(pos)
            raise EOF
        else:
            data = self.read_exactly(end - pos)
            self.skip(n)
            return bytearray(data)

    def read_guid(self) -&gt; UUID:
        return UUID(bytes_le=self.read_bytes(16))

    def read_uuid(self) -&gt; UUID:
        return UUID(bytes=self.read_bytes(16))

    @overload
    def read_c_string(self) -&gt; bytearray:
        ...

    @overload
    def read_c_string(self, encoding: str) -&gt; str:
        ...

    def read_c_string(self, encoding=None) -&gt; str | bytearray:
        data = self.read_terminated_array(B&#39;\0&#39;)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    @overload
    def read_w_string(self) -&gt; bytearray:
        ...

    @overload
    def read_w_string(self, encoding: str) -&gt; str:
        ...

    def read_w_string(self, encoding=None) -&gt; str | bytearray:
        data = self.read_terminated_array(B&#39;\0\0&#39;, 2)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    def read_length_prefixed_ascii(self, prefix_size: int = 32):
        return self.read_length_prefixed(prefix_size, &#39;latin1&#39;)

    def read_length_prefixed_utf8(self, prefix_size: int = 32):
        return self.read_length_prefixed(prefix_size, &#39;utf8&#39;)

    def read_length_prefixed_utf16(self, prefix_size: int = 32, bytecount: bool = False):
        block_size = 1 if bytecount else 2
        return self.read_length_prefixed(prefix_size, &#39;utf-16le&#39;, block_size)

    @overload
    def read_length_prefixed(self, *, encoding: str, prefix_size: int = 32, block_size: int = 1) -&gt; str:
        ...

    @overload
    def read_length_prefixed(self, prefix_size: int, encoding: str, block_size: int = 1) -&gt; str:
        ...

    @overload
    def read_length_prefixed(self, *, prefix_size: int = 32, block_size: int = 1) -&gt; T:
        ...

    @overload
    def read_length_prefixed(self, prefix_size: int, *, block_size: int = 1) -&gt; T:
        ...

    def read_length_prefixed(self, prefix_size: int = 32, encoding: str | None = None, block_size: int = 1) -&gt; T | str:
        prefix = self.read_integer(prefix_size) * block_size
        data = self.read(prefix)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    def read_7bit_encoded_int(self, max_bits: int = 0, bigendian: bool | None = None) -&gt; int:
        value = 0
        shift = 0
        if bigendian is None:
            bigendian = self.bigendian
        while True:
            b = self.u8fast()
            if bigendian:
                value &lt;&lt;= 7
                value |= (b &amp; 0x7F)
            else:
                value |= (b &amp; 0x7F) &lt;&lt; shift
            if not b &amp; 0x80:
                return value
            if (shift := shift + 7) &gt; max_bits &gt; 0:
                raise OverflowError(&#39;Maximum bits were exceeded by encoded integer.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></li>
<li><a title="refinery.lib.structures.MemoryFileMethods" href="#refinery.lib.structures.MemoryFileMethods">MemoryFileMethods</a></li>
<li>typing.Generic</li>
<li>_io.BytesIO</li>
<li>_io._BufferedIOBase</li>
<li>_io._IOBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.py.Marshal" href="py.html#refinery.lib.py.Marshal">Marshal</a></li>
<li><a title="refinery.units.compression.lz4.LZ4Reader" href="../units/compression/lz4.html#refinery.units.compression.lz4.LZ4Reader">LZ4Reader</a></li>
<li><a title="refinery.units.formats.a3x.A3xReader" href="../units/formats/a3x.html#refinery.units.formats.a3x.A3xReader">A3xReader</a></li>
<li><a title="refinery.units.formats.archive.xtiss.ISSReader" href="../units/formats/archive/xtiss.html#refinery.units.formats.archive.xtiss.ISSReader">ISSReader</a></li>
<li><a title="refinery.units.formats.archive.xtnode.JSONReader" href="../units/formats/archive/xtnode.html#refinery.units.formats.archive.xtnode.JSONReader">JSONReader</a></li>
<li><a title="refinery.units.formats.pbuf.ProtoBufReader" href="../units/formats/pbuf.html#refinery.units.formats.pbuf.ProtoBufReader">ProtoBufReader</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.structures.StructReader.Unaligned"><code class="name">var <span class="ident">Unaligned</span></code></dt>
<dd>
<section class="desc"><p>Unspecified run-time error.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.structures.StructReader.be"><code class="name">var <span class="ident">be</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L461-L468" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
@contextlib.contextmanager
def be(self):
    self.bigendian = True
    try:
        yield self
    finally:
        self.bigendian = False</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.byteorder_format"><code class="name">var <span class="ident">byteorder_format</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L470-L472" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def byteorder_format(self) -&gt; str:
    return &#39;&gt;&#39; if self.bigendian else &#39;&lt;&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.byteorder_name"><code class="name">var <span class="ident">byteorder_name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L474-L476" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def byteorder_name(self):
    return &#39;big&#39; if self.bigendian else &#39;little&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.byte_aligned"><code class="name">var <span class="ident">byte_aligned</span></code></dt>
<dd>
<section class="desc"><p>This property is <code>True</code> if and only if there are currently no bits still waiting in the internal
bit buffer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L499-L505" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def byte_aligned(self) -&gt; bool:
    &#34;&#34;&#34;
    This property is `True` if and only if there are currently no bits still waiting in the internal
    bit buffer.
    &#34;&#34;&#34;
    return not self._nbits</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.remaining_bits"><code class="name">var <span class="ident">remaining_bits</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L521-L523" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def remaining_bits(self) -&gt; int:
    return 8 * self.remaining_bytes + self._nbits</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.structures.StructReader.seek"><code class="name flex">
<span>def <span class="ident">seek</span></span>(<span>self, offset, whence=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Change stream position.</p>
<p>Seek to byte offset pos relative to position indicated by whence:
0
Start of stream (the default).
pos should be &gt;= 0;
1
Current position - pos may be negative;
2
End of stream - pos usually negative.
Returns the new absolute position.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L478-L481" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seek(self, offset, whence=io.SEEK_SET) -&gt; int:
    self._bbits = 0
    self._nbits = 0
    return super().seek(offset, whence)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_exactly"><code class="name flex">
<span>def <span class="ident">read_exactly</span></span>(<span>self, size=None, peek=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Read bytes from the underlying stream. Raises a <code>RuntimeError</code> when the stream is not currently
byte-aligned, i.e. when <code><a title="refinery.lib.structures.StructReader.byte_aligned" href="#refinery.lib.structures.StructReader.byte_aligned">StructReader.byte_aligned</a></code> is <code>False</code>. Raises
an exception of type <code><a title="refinery.lib.structures.EOF" href="#refinery.lib.structures.EOF">EOF</a></code> when fewer data is available in the stream than
requested via the <code>size</code> parameter. The remaining data can be extracted from the exception.
Use <code><a title="refinery.lib.structures.StructReader.read_bytes" href="#refinery.lib.structures.StructReader.read_bytes">StructReader.read_bytes()</a></code> to read bytes from the stream when it is
not byte-aligned.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L483-L497" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_exactly(self, size: int | None = None, peek: bool = False) -&gt; T:
    &#34;&#34;&#34;
    Read bytes from the underlying stream. Raises a `RuntimeError` when the stream is not currently
    byte-aligned, i.e. when `refinery.lib.structures.StructReader.byte_aligned` is `False`. Raises
    an exception of type `refinery.lib.structures.EOF` when fewer data is available in the stream than
    requested via the `size` parameter. The remaining data can be extracted from the exception.
    Use `refinery.lib.structures.StructReader.read_bytes` to read bytes from the stream when it is
    not byte-aligned.
    &#34;&#34;&#34;
    if not self.byte_aligned:
        raise StructReader.Unaligned(&#39;buffer is not byte-aligned&#39;)
    data = self.read1(size, peek)
    if size and len(data) &lt; size:
        raise EOF(data)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.byte_align"><code class="name flex">
<span>def <span class="ident">byte_align</span></span>(<span>self, blocksize=1)</span>
</code></dt>
<dd>
<section class="desc"><p>This method clears the internal bit buffer and moves the cursor to the next byte. It returns a
tuple containing the size and contents of the bit buffer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L507-L519" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def byte_align(self, blocksize: int = 1) -&gt; tuple[int, int]:
    &#34;&#34;&#34;
    This method clears the internal bit buffer and moves the cursor to the next byte. It returns a
    tuple containing the size and contents of the bit buffer.
    &#34;&#34;&#34;
    nbits = self._nbits
    bbits = self._bbits
    self._nbits = 0
    self._bbits = 0
    mod = self._cursor % blocksize
    if mod:
        self.seekrel(blocksize - mod)
    return nbits, bbits</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_integer"><code class="name flex">
<span>def <span class="ident">read_integer</span></span>(<span>self, length=None, peek=False, bigendian=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Read <code>length</code> many bits from the underlying stream as an integer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L525-L578" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_integer(self, length: int | None = None, peek: bool = False, bigendian: bool | None = None) -&gt; int:
    &#34;&#34;&#34;
    Read `length` many bits from the underlying stream as an integer.
    &#34;&#34;&#34;
    if length is None:
        length = self.remaining_bits
    if bigendian is None:
        bigendian = self.bigendian
    if length &lt; self._nbits:
        new_count = self._nbits - length
        if bigendian:
            result = self._bbits &gt;&gt; new_count
            if not peek:
                self._bbits ^= result &lt;&lt; new_count
        else:
            result = self._bbits &amp; 2 ** length - 1
            if not peek:
                self._bbits &gt;&gt;= length
        if not peek:
            self._nbits = new_count
        return result

    nbits, bbits = self._nbits, self._bbits
    number_of_missing_bits = length - nbits
    bytecount, rest = divmod(number_of_missing_bits, 8)
    if rest:
        bytecount += 1
        rest = 8 - rest
    bb = self.read1(bytecount, True)
    if len(bb) != bytecount:
        raise EOFError
    if not peek:
        self.seekrel(bytecount)
    if bytecount == 1:
        result, = bb
    else:
        result = int.from_bytes(bb, self.byteorder_name)
    if not nbits and not rest:
        return result
    if bigendian:
        rbmask   = 2 ** rest - 1       # noqa
        excess   = result &amp; rbmask     # noqa
        result &gt;&gt;= rest                # noqa
        result  ^= bbits &lt;&lt; number_of_missing_bits   # noqa
    else:
        excess   = result &gt;&gt; number_of_missing_bits  # noqa
        result  ^= excess &lt;&lt; number_of_missing_bits  # noqa
        result &lt;&lt;= nbits               # noqa
        result  |= bbits               # noqa
    assert excess.bit_length() &lt;= rest
    if not peek:
        self._nbits = rest
        self._bbits = excess
    return result</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_bytes"><code class="name flex">
<span>def <span class="ident">read_bytes</span></span>(<span>self, size, peek=False)</span>
</code></dt>
<dd>
<section class="desc"><p>The method reads <code>size</code> many bytes from the underlying stream starting at the current bit.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L580-L590" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_bytes(self, size: int, peek: bool = False) -&gt; bytes:
    &#34;&#34;&#34;
    The method reads `size` many bytes from the underlying stream starting at the current bit.
    &#34;&#34;&#34;
    if self.byte_aligned:
        data = self.read_exactly(size, peek)
        if not isinstance(data, bytes):
            data = bytes(data)
        return data
    else:
        return self.read_integer(size * 8, peek).to_bytes(size, self.byteorder_name)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_bit"><code class="name flex">
<span>def <span class="ident">read_bit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This function is a shortcut for calling <code><a title="refinery.lib.structures.StructReader.read_integer" href="#refinery.lib.structures.StructReader.read_integer">StructReader.read_integer()</a></code> with
an argument of <code>1</code>, i.e. this reads the next bit from the stream. The bits of any byte in the stream
are read from least significant to most significant.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L592-L598" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_bit(self) -&gt; int:
    &#34;&#34;&#34;
    This function is a shortcut for calling `refinery.lib.structures.StructReader.read_integer` with
    an argument of `1`, i.e. this reads the next bit from the stream. The bits of any byte in the stream
    are read from least significant to most significant.
    &#34;&#34;&#34;
    return self.read_integer(1)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_bits"><code class="name flex">
<span>def <span class="ident">read_bits</span></span>(<span>self, nbits, bigendian=None)</span>
</code></dt>
<dd>
<section class="desc"><p>This method returns the bits of <code><a title="refinery.lib.structures.StructReader.read_integer" href="#refinery.lib.structures.StructReader.read_integer">StructReader.read_integer()</a></code> one by one.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L600-L609" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_bits(self, nbits: int, bigendian: bool | None = None) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    This method returns the bits of `refinery.lib.structures.StructReader.read_integer` one by one.
    &#34;&#34;&#34;
    if bigendian is None:
        bigendian = self.bigendian
    chunk = self.read_integer(nbits, bigendian=bigendian)
    it = range(nbits - 1, -1, -1) if bigendian else range(nbits)
    for k in it:
        yield chunk &gt;&gt; k &amp; 1</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_flags"><code class="name flex">
<span>def <span class="ident">read_flags</span></span>(<span>self, nbits, reverse=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Identical to <code><a title="refinery.lib.structures.StructReader.read_bits" href="#refinery.lib.structures.StructReader.read_bits">StructReader.read_bits()</a></code> with every bit value cast to a boolean.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L611-L619" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_flags(self, nbits: int, reverse=False) -&gt; Iterable[bool]:
    &#34;&#34;&#34;
    Identical to `refinery.lib.structures.StructReader.read_bits` with every bit value cast to a boolean.
    &#34;&#34;&#34;
    bits = list(self.read_bits(nbits))
    if reverse:
        bits.reverse()
    for bit in bits:
        yield bool(bit)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_one_struct"><code class="name flex">
<span>def <span class="ident">read_one_struct</span></span>(<span>self, spec, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L621-L623" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_one_struct(self, spec: str, peek=False) -&gt; UnpackType:
    item, = self.read_struct(spec, peek=peek)
    return item</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_struct"><code class="name flex">
<span>def <span class="ident">read_struct</span></span>(<span>self, spec, peek=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Read structured data from the stream in any format supported by the <code>struct</code> module. The <code>format</code>
argument can be used to override the current byte ordering. If the <code>unwrap</code> parameter is <code>True</code>, a
single unpacked value will be returned as a scalar, not as a tuple with one element.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L625-L663" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_struct(self, spec: str, peek=False) -&gt; list[UnpackType]:
    &#34;&#34;&#34;
    Read structured data from the stream in any format supported by the `struct` module. The `format`
    argument can be used to override the current byte ordering. If the `unwrap` parameter is `True`, a
    single unpacked value will be returned as a scalar, not as a tuple with one element.
    &#34;&#34;&#34;
    if not spec:
        raise ValueError(&#39;no format specified&#39;)
    byteorder = spec[:1]
    if byteorder in &#39;&lt;!=@&gt;&#39;:
        spec = spec[1:]
    else:
        byteorder = self.byteorder_format
    data = []
    current_cursor = self.tell()

    # reserved struct characters: xcbB?hHiIlLqQnNefdspP
    for k, part in enumerate(re.split(&#39;(\\d*[auwgk])&#39;, spec)):
        if k % 2 == 1:
            count = 1 if len(part) == 1 else int(part[:~0])
            part = part[~0]
            for _ in range(count):
                if part == &#39;a&#39;:
                    data.append(self.read_c_string())
                elif part == &#39;g&#39;:
                    data.append(str(self.read_guid()))
                elif part == &#39;u&#39;:
                    data.append(self.read_w_string())
                elif part == &#39;w&#39;:
                    data.append(codecs.decode(self.read_w_string(), &#39;utf-16le&#39;))
                elif part == &#39;k&#39;:
                    data.append(self.read_7bit_encoded_int())
            continue
        else:
            part = F&#39;{byteorder}{part}&#39;
            data.extend(struct.unpack(part, self.read_bytes(struct.calcsize(part))))
    if peek:
        self.seekset(current_cursor)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_nibble"><code class="name flex">
<span>def <span class="ident">read_nibble</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Calls <code><a title="refinery.lib.structures.StructReader.read_integer" href="#refinery.lib.structures.StructReader.read_integer">StructReader.read_integer()</a></code> with an argument of <code>4</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L665-L669" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_nibble(self, peek: bool = False) -&gt; int:
    &#34;&#34;&#34;
    Calls `refinery.lib.structures.StructReader.read_integer` with an argument of `4`.
    &#34;&#34;&#34;
    return self.read_integer(4, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.u8"><code class="name flex">
<span>def <span class="ident">u8</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L671-L671" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def u8(self, peek: bool = False) -&gt; int: return self.read_integer(8, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.i8"><code class="name flex">
<span>def <span class="ident">i8</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L672-L672" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def i8(self, peek: bool = False) -&gt; int: return signed(self.read_integer(8, peek), 8)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.u16"><code class="name flex">
<span>def <span class="ident">u16</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L674-L674" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def u16(self, peek: bool = False) -&gt; int: return self.read_integer(16, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.u32"><code class="name flex">
<span>def <span class="ident">u32</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L675-L675" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def u32(self, peek: bool = False) -&gt; int: return self.read_integer(32, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.u64"><code class="name flex">
<span>def <span class="ident">u64</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L676-L676" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def u64(self, peek: bool = False) -&gt; int: return self.read_integer(64, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.i16"><code class="name flex">
<span>def <span class="ident">i16</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L677-L677" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def i16(self, peek: bool = False) -&gt; int: return signed(self.read_integer(16, peek), 16)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.i32"><code class="name flex">
<span>def <span class="ident">i32</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L678-L678" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def i32(self, peek: bool = False) -&gt; int: return signed(self.read_integer(32, peek), 32)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.i64"><code class="name flex">
<span>def <span class="ident">i64</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L679-L679" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def i64(self, peek: bool = False) -&gt; int: return signed(self.read_integer(64, peek), 64)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.f32"><code class="name flex">
<span>def <span class="ident">f32</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L681-L681" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def f32(self, peek: bool = False) -&gt; float: return cast(float, self.read_one_struct(&#39;f&#39;, peek=peek))</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.f64"><code class="name flex">
<span>def <span class="ident">f64</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L682-L682" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def f64(self, peek: bool = False) -&gt; float: return cast(float, self.read_one_struct(&#39;d&#39;, peek=peek))</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.u8fast"><code class="name flex">
<span>def <span class="ident">u8fast</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L684-L691" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def u8fast(self):
    try:
        b = self._data[self._cursor]
    except IndexError:
        raise EOFError
    else:
        self._cursor += 1
        return b</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_byte"><code class="name flex">
<span>def <span class="ident">read_byte</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L693-L693" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_byte(self, peek: bool = False) -&gt; int: return self.read_integer(8, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_char"><code class="name flex">
<span>def <span class="ident">read_char</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L694-L694" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_char(self, peek: bool = False) -&gt; int: return signed(self.read_integer(8, peek), 8)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_terminated_array"><code class="name flex">
<span>def <span class="ident">read_terminated_array</span></span>(<span>self, terminator, alignment=1)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L696-L727" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_terminated_array(self, terminator: bytes, alignment: int = 1) -&gt; bytearray:
    buf = self.getvalue()
    pos = self.tell()
    n = len(terminator)

    if isinstance(buf, memoryview):
        def find(whence: int):
            for k in range(whence, len(buf)):
                if buf[k:k + n] == terminator:
                    return k
            return -1
    else:
        def find(whence: int):
            return buf.find(terminator, whence)
    try:
        end = pos - 1
        while True:
            end = find(end + 1)
            if end &lt; 0 or not (end - pos) % alignment:
                break
    except AttributeError:
        result = bytearray()
        while not self.eof:
            result.extend(self.read_exactly(alignment))
            if result.endswith(terminator):
                return result[:-n]
        self.seek(pos)
        raise EOF
    else:
        data = self.read_exactly(end - pos)
        self.skip(n)
        return bytearray(data)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_guid"><code class="name flex">
<span>def <span class="ident">read_guid</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L729-L730" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_guid(self) -&gt; UUID:
    return UUID(bytes_le=self.read_bytes(16))</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_uuid"><code class="name flex">
<span>def <span class="ident">read_uuid</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L732-L733" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_uuid(self) -&gt; UUID:
    return UUID(bytes=self.read_bytes(16))</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_c_string"><code class="name flex">
<span>def <span class="ident">read_c_string</span></span>(<span>self, encoding=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L743-L747" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_c_string(self, encoding=None) -&gt; str | bytearray:
    data = self.read_terminated_array(B&#39;\0&#39;)
    if encoding is not None:
        data = codecs.decode(data, encoding)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_w_string"><code class="name flex">
<span>def <span class="ident">read_w_string</span></span>(<span>self, encoding=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L757-L761" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_w_string(self, encoding=None) -&gt; str | bytearray:
    data = self.read_terminated_array(B&#39;\0\0&#39;, 2)
    if encoding is not None:
        data = codecs.decode(data, encoding)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_length_prefixed_ascii"><code class="name flex">
<span>def <span class="ident">read_length_prefixed_ascii</span></span>(<span>self, prefix_size=32)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L763-L764" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_length_prefixed_ascii(self, prefix_size: int = 32):
    return self.read_length_prefixed(prefix_size, &#39;latin1&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_length_prefixed_utf8"><code class="name flex">
<span>def <span class="ident">read_length_prefixed_utf8</span></span>(<span>self, prefix_size=32)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L766-L767" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_length_prefixed_utf8(self, prefix_size: int = 32):
    return self.read_length_prefixed(prefix_size, &#39;utf8&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_length_prefixed_utf16"><code class="name flex">
<span>def <span class="ident">read_length_prefixed_utf16</span></span>(<span>self, prefix_size=32, bytecount=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L769-L771" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_length_prefixed_utf16(self, prefix_size: int = 32, bytecount: bool = False):
    block_size = 1 if bytecount else 2
    return self.read_length_prefixed(prefix_size, &#39;utf-16le&#39;, block_size)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_length_prefixed"><code class="name flex">
<span>def <span class="ident">read_length_prefixed</span></span>(<span>self, prefix_size=32, encoding=None, block_size=1)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L789-L794" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_length_prefixed(self, prefix_size: int = 32, encoding: str | None = None, block_size: int = 1) -&gt; T | str:
    prefix = self.read_integer(prefix_size) * block_size
    data = self.read(prefix)
    if encoding is not None:
        data = codecs.decode(data, encoding)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_7bit_encoded_int"><code class="name flex">
<span>def <span class="ident">read_7bit_encoded_int</span></span>(<span>self, max_bits=0, bigendian=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L796-L811" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_7bit_encoded_int(self, max_bits: int = 0, bigendian: bool | None = None) -&gt; int:
    value = 0
    shift = 0
    if bigendian is None:
        bigendian = self.bigendian
    while True:
        b = self.u8fast()
        if bigendian:
            value &lt;&lt;= 7
            value |= (b &amp; 0x7F)
        else:
            value |= (b &amp; 0x7F) &lt;&lt; shift
        if not b &amp; 0x80:
            return value
        if (shift := shift + 7) &gt; max_bits &gt; 0:
            raise OverflowError(&#39;Maximum bits were exceeded by encoded integer.&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.structures.MemoryFile.SEEK" href="#refinery.lib.structures.MemoryFileMethods.SEEK">SEEK</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.structures.StructMeta"><code class="flex name class">
<span>class <span class="ident">StructMeta</span></span>
<span>(</span><span>name, bases, nmspc, parser=refinery.lib.structures.StructReader)</span>
</code></dt>
<dd>
<section class="desc"><p>A metaclass to facilitate the behavior outlined for <code><a title="refinery.lib.structures.Struct" href="#refinery.lib.structures.Struct">Struct</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L814-L839" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StructMeta(type):
    &#34;&#34;&#34;
    A metaclass to facilitate the behavior outlined for `refinery.lib.structures.Struct`.
    &#34;&#34;&#34;
    def __new__(mcls, name, bases, nmspc, parser=StructReader):
        return type.__new__(mcls, name, bases, nmspc)

    def __init__(cls, name, bases, nmspc, parser=StructReader):
        super().__init__(name, bases, nmspc)
        original__init__ = cls.__init__

        @functools.wraps(original__init__)
        def wrapped__init__(self: Struct, reader, *args, **kwargs):
            if not isinstance(reader, parser):
                if issubclass(parser, reader.__class__):
                    raise ValueError(
                        F&#39;A reader of type {reader.__class__.__name__} was passed to {cls.__name__}, &#39;
                        F&#39;but a {parser.__name__} is required.&#39;)
                reader = parser(reader)
            start = reader.tell()
            view = reader.getbuffer()
            original__init__(self, reader, *args, **kwargs)
            self._data = view[start:reader.tell()]
            del view

        setattr(cls, &#39;__init__&#39;, wrapped__init__)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
</dd>
<dt id="refinery.lib.structures.Struct"><code class="flex name class">
<span>class <span class="ident">Struct</span></span>
<span>(</span><span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L842-L878" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Struct(Generic[T], metaclass=StructMeta):
    &#34;&#34;&#34;
    A class to parse structured data. A `refinery.lib.structures.Struct` class can be instantiated
    as follows:

        foo = Struct(data, bar=29)

    The initialization routine of the structure will be called with a single argument `reader`. If
    the object `data` is already a `refinery.lib.structures.StructReader`, then it will be passed
    as `reader`. Otherwise, the argument will be wrapped in a `refinery.lib.structures.StructReader`.
    Additional arguments to the struct are passed through.
    &#34;&#34;&#34;
    _data: memoryview | bytearray

    @classmethod
    def Parse(cls, reader: T | StructReader[T], *args, **kwargs):
        if not isinstance(reader, StructReader):
            reader = StructReader(reader)
        start = reader.tell()
        view = reader.getbuffer()
        result = cls(reader, *args, **kwargs)
        result._data = view[start:reader.tell()]
        return result

    def __len__(self):
        return len(self._data)

    def __bytes__(self):
        return bytes(self._data)

    def get_data(self, decouple=False):
        if decouple and isinstance(self._data, memoryview):
            self._data = bytearray(self._data)
        return self._data

    def __init__(self, reader: StructReader[T], *args, **kwargs):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.cab.CabCompressedBlock" href="cab.html#refinery.lib.cab.CabCompressedBlock">CabCompressedBlock</a></li>
<li><a title="refinery.lib.cab.CabDisk" href="cab.html#refinery.lib.cab.CabDisk">CabDisk</a></li>
<li><a title="refinery.lib.cab.CabFile" href="cab.html#refinery.lib.cab.CabFile">CabFile</a></li>
<li><a title="refinery.lib.cab.CabFolder" href="cab.html#refinery.lib.cab.CabFolder">CabFolder</a></li>
<li><a title="refinery.lib.chm.CHM" href="chm.html#refinery.lib.chm.CHM">CHM</a></li>
<li><a title="refinery.lib.chm.ChmStruct" href="chm.html#refinery.lib.chm.ChmStruct">ChmStruct</a></li>
<li><a title="refinery.lib.chm.ContentSections" href="chm.html#refinery.lib.chm.ContentSections">ContentSections</a></li>
<li><a title="refinery.lib.chm.ContentSectionsName" href="chm.html#refinery.lib.chm.ContentSectionsName">ContentSectionsName</a></li>
<li><a title="refinery.lib.chm.ContentSectionsResetTable" href="chm.html#refinery.lib.chm.ContentSectionsResetTable">ContentSectionsResetTable</a></li>
<li><a title="refinery.lib.chm.DirectoryListingEntry" href="chm.html#refinery.lib.chm.DirectoryListingEntry">DirectoryListingEntry</a></li>
<li><a title="refinery.lib.chm.QuickRefArea" href="chm.html#refinery.lib.chm.QuickRefArea">QuickRefArea</a></li>
<li><a title="refinery.lib.chm.SectionHeader" href="chm.html#refinery.lib.chm.SectionHeader">SectionHeader</a></li>
<li><a title="refinery.lib.dex.DexFile" href="dex.html#refinery.lib.dex.DexFile">DexFile</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="inno/archive.html#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.inno.archive.TSetupOffsets" href="inno/archive.html#refinery.lib.inno.archive.TSetupOffsets">TSetupOffsets</a></li>
<li><a title="refinery.lib.inno.ifps.IFPSFile" href="inno/ifps.html#refinery.lib.inno.ifps.IFPSFile">IFPSFile</a></li>
<li><a title="refinery.lib.java.JvAccessFlags" href="java.html#refinery.lib.java.JvAccessFlags">JvAccessFlags</a></li>
<li><a title="refinery.lib.java.JvClassFile" href="java.html#refinery.lib.java.JvClassFile">JvClassFile</a></li>
<li><a title="refinery.lib.java.JvCode" href="java.html#refinery.lib.java.JvCode">JvCode</a></li>
<li><a title="refinery.lib.java.JvException" href="java.html#refinery.lib.java.JvException">JvException</a></li>
<li><a title="refinery.lib.java.JvOpCode" href="java.html#refinery.lib.java.JvOpCode">JvOpCode</a></li>
<li>refinery.lib.java._HasPoolAndTag</li>
<li><a title="refinery.lib.mscrypto.BCRYPT_RSAKEY_BLOB" href="mscrypto.html#refinery.lib.mscrypto.BCRYPT_RSAKEY_BLOB">BCRYPT_RSAKEY_BLOB</a></li>
<li><a title="refinery.lib.mscrypto.BLOBHEADER" href="mscrypto.html#refinery.lib.mscrypto.BLOBHEADER">BLOBHEADER</a></li>
<li><a title="refinery.lib.mscrypto.CRYPTOKEY" href="mscrypto.html#refinery.lib.mscrypto.CRYPTOKEY">CRYPTOKEY</a></li>
<li><a title="refinery.lib.mscrypto.DHPUBKEY" href="mscrypto.html#refinery.lib.mscrypto.DHPUBKEY">DHPUBKEY</a></li>
<li><a title="refinery.lib.mscrypto.PLAINTEXTKEYBLOB" href="mscrypto.html#refinery.lib.mscrypto.PLAINTEXTKEYBLOB">PLAINTEXTKEYBLOB</a></li>
<li><a title="refinery.lib.mscrypto.PRIVATEKEYBLOB" href="mscrypto.html#refinery.lib.mscrypto.PRIVATEKEYBLOB">PRIVATEKEYBLOB</a></li>
<li><a title="refinery.lib.mscrypto.RSAPUBKEY" href="mscrypto.html#refinery.lib.mscrypto.RSAPUBKEY">RSAPUBKEY</a></li>
<li><a title="refinery.lib.mscrypto.SIMPLEBLOB" href="mscrypto.html#refinery.lib.mscrypto.SIMPLEBLOB">SIMPLEBLOB</a></li>
<li><a title="refinery.units.compression.lzf.LZFHeader" href="../units/compression/lzf.html#refinery.units.compression.lzf.LZFHeader">LZFHeader</a></li>
<li><a title="refinery.units.compression.lzg.LZGStream" href="../units/compression/lzg.html#refinery.units.compression.lzg.LZGStream">LZGStream</a></li>
<li><a title="refinery.units.compression.lzip.RangeDecoder" href="../units/compression/lzip.html#refinery.units.compression.lzip.RangeDecoder">RangeDecoder</a></li>
<li><a title="refinery.units.compression.lzo.LZO" href="../units/compression/lzo.html#refinery.units.compression.lzo.LZO">LZO</a></li>
<li><a title="refinery.units.compression.lzo.LZOChunk" href="../units/compression/lzo.html#refinery.units.compression.lzo.LZOChunk">LZOChunk</a></li>
<li><a title="refinery.units.formats.a3x.A3xRecord" href="../units/formats/a3x.html#refinery.units.formats.a3x.A3xRecord">A3xRecord</a></li>
<li><a title="refinery.units.formats.a3x.A3xScript" href="../units/formats/a3x.html#refinery.units.formats.a3x.A3xScript">A3xScript</a></li>
<li><a title="refinery.units.formats.archive.xtasar.AsarHeader" href="../units/formats/archive/xtasar.html#refinery.units.formats.archive.xtasar.AsarHeader">AsarHeader</a></li>
<li><a title="refinery.units.formats.archive.xtcpio.CPIOEntry" href="../units/formats/archive/xtcpio.html#refinery.units.formats.archive.xtcpio.CPIOEntry">CPIOEntry</a></li>
<li><a title="refinery.units.formats.archive.xtgz.GzipHeader" href="../units/formats/archive/xtgz.html#refinery.units.formats.archive.xtgz.GzipHeader">GzipHeader</a></li>
<li><a title="refinery.units.formats.archive.xtmacho.FatArch" href="../units/formats/archive/xtmacho.html#refinery.units.formats.archive.xtmacho.FatArch">FatArch</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSArchive" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSArchive">NSArchive</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSBlockHeaderOffset" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSBlockHeaderOffset">NSBlockHeaderOffset</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSHeader" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSHeader">NSHeader</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSScriptExtendedInstruction" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSScriptExtendedInstruction">NSScriptExtendedInstruction</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSScriptInstruction" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSScriptInstruction">NSScriptInstruction</a></li>
<li><a title="refinery.units.formats.archive.xtpyi.PYZ" href="../units/formats/archive/xtpyi.html#refinery.units.formats.archive.xtpyi.PYZ">PYZ</a></li>
<li><a title="refinery.units.formats.archive.xtpyi.PiTOCEntry" href="../units/formats/archive/xtpyi.html#refinery.units.formats.archive.xtpyi.PiTOCEntry">PiTOCEntry</a></li>
<li><a title="refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue" href="../units/formats/archive/xtpyi.html#refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue">PyInstallerArchiveEpilogue</a></li>
<li>refinery.units.formats.archive.xtzip._FileRecord</li>
<li><a title="refinery.units.formats.macho.machometa.BlobIndex" href="../units/formats/macho/machometa.html#refinery.units.formats.macho.machometa.BlobIndex">BlobIndex</a></li>
<li><a title="refinery.units.formats.macho.machometa.CodeDirectoryBlob" href="../units/formats/macho/machometa.html#refinery.units.formats.macho.machometa.CodeDirectoryBlob">CodeDirectoryBlob</a></li>
<li><a title="refinery.units.formats.macho.machometa.SuperBlob" href="../units/formats/macho/machometa.html#refinery.units.formats.macho.machometa.SuperBlob">SuperBlob</a></li>
<li><a title="refinery.units.formats.pe.perc.GRPICONDIR" href="../units/formats/pe/perc.html#refinery.units.formats.pe.perc.GRPICONDIR">GRPICONDIR</a></li>
<li><a title="refinery.units.formats.pe.perc.GRPICONDIRENTRY" href="../units/formats/pe/perc.html#refinery.units.formats.pe.perc.GRPICONDIRENTRY">GRPICONDIRENTRY</a></li>
<li><a title="refinery.units.pattern.carve_zip.ZipCentralDirectory" href="../units/pattern/carve_zip.html#refinery.units.pattern.carve_zip.ZipCentralDirectory">ZipCentralDirectory</a></li>
<li><a title="refinery.units.pattern.carve_zip.ZipEndOfCentralDirectory" href="../units/pattern/carve_zip.html#refinery.units.pattern.carve_zip.ZipEndOfCentralDirectory">ZipEndOfCentralDirectory</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.structures.Struct.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.structures.Struct.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self, decouple=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L872-L875" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_data(self, decouple=False):
    if decouple and isinstance(self._data, memoryview):
        self._data = bytearray(self._data)
    return self._data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.structures.PerInstanceAttribute"><code class="flex name class">
<span>class <span class="ident">PerInstanceAttribute</span></span>
</code></dt>
<dd>
<section class="desc"><p>Abstract base class for generic types.</p>
<p>On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::</p>
<pre><code>class Mapping[KT, VT]:
    def __getitem__(self, key: KT) -&gt; VT:
        ...
    # Etc.
</code></pre>
<p>On older versions of Python, however, generic classes have to
explicitly inherit from Generic.</p>
<p>After a class has been declared to be generic, it can then be used as
follows::</p>
<pre><code>def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
    try:
        return mapping[key]
    except KeyError:
        return default
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L901-L909" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def __get__(self, parent, tp=None) -&gt; AttrType:
    pid = id(parent)
    if pid not in self.__get:
        try:
            seed = self.__set[pid]
        except KeyError as K:
            raise AttributeError from K
        self.__get[pid] = self.resolve(parent, seed)
    return self.__get[pid]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>refinery.lib.java.Index</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.structures.PerInstanceAttribute.resolve"><code class="name flex">
<span>def <span class="ident">resolve</span></span>(<span>self, parent, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/structures.py#L885-L886" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resolve(self, parent, value: Any) -&gt; AttrType:
    return value</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.structures.signed" href="#refinery.lib.structures.signed">signed</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.structures.EOF" href="#refinery.lib.structures.EOF">EOF</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.StreamDetour" href="#refinery.lib.structures.StreamDetour">StreamDetour</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.MemoryFileMethods" href="#refinery.lib.structures.MemoryFileMethods">MemoryFileMethods</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.lib.structures.MemoryFileMethods.close" href="#refinery.lib.structures.MemoryFileMethods.close">close</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.flush" href="#refinery.lib.structures.MemoryFileMethods.flush">flush</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.isatty" href="#refinery.lib.structures.MemoryFileMethods.isatty">isatty</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.fileno" href="#refinery.lib.structures.MemoryFileMethods.fileno">fileno</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readable" href="#refinery.lib.structures.MemoryFileMethods.readable">readable</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.seekable" href="#refinery.lib.structures.MemoryFileMethods.seekable">seekable</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.detour" href="#refinery.lib.structures.MemoryFileMethods.detour">detour</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.detour_absolute" href="#refinery.lib.structures.MemoryFileMethods.detour_absolute">detour_absolute</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.detour_relative" href="#refinery.lib.structures.MemoryFileMethods.detour_relative">detour_relative</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.detour_from_end" href="#refinery.lib.structures.MemoryFileMethods.detour_from_end">detour_from_end</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.writable" href="#refinery.lib.structures.MemoryFileMethods.writable">writable</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.read_as" href="#refinery.lib.structures.MemoryFileMethods.read_as">read_as</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.read" href="#refinery.lib.structures.MemoryFileMethods.read">read</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readif" href="#refinery.lib.structures.MemoryFileMethods.readif">readif</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.peek" href="#refinery.lib.structures.MemoryFileMethods.peek">peek</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.read1" href="#refinery.lib.structures.MemoryFileMethods.read1">read1</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readline" href="#refinery.lib.structures.MemoryFileMethods.readline">readline</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readlines_iter" href="#refinery.lib.structures.MemoryFileMethods.readlines_iter">readlines_iter</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readlines" href="#refinery.lib.structures.MemoryFileMethods.readlines">readlines</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readinto1" href="#refinery.lib.structures.MemoryFileMethods.readinto1">readinto1</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readinto" href="#refinery.lib.structures.MemoryFileMethods.readinto">readinto</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.tell" href="#refinery.lib.structures.MemoryFileMethods.tell">tell</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.skip" href="#refinery.lib.structures.MemoryFileMethods.skip">skip</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.seekrel" href="#refinery.lib.structures.MemoryFileMethods.seekrel">seekrel</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.seekset" href="#refinery.lib.structures.MemoryFileMethods.seekset">seekset</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.getbuffer" href="#refinery.lib.structures.MemoryFileMethods.getbuffer">getbuffer</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.getvalue" href="#refinery.lib.structures.MemoryFileMethods.getvalue">getvalue</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.seek" href="#refinery.lib.structures.MemoryFileMethods.seek">seek</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.writelines" href="#refinery.lib.structures.MemoryFileMethods.writelines">writelines</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.truncate" href="#refinery.lib.structures.MemoryFileMethods.truncate">truncate</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.write_byte" href="#refinery.lib.structures.MemoryFileMethods.write_byte">write_byte</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.write" href="#refinery.lib.structures.MemoryFileMethods.write">write</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.replay" href="#refinery.lib.structures.MemoryFileMethods.replay">replay</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.order" href="#refinery.lib.structures.order">order</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.StructReader" href="#refinery.lib.structures.StructReader">StructReader</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.structures.StructReader.seek" href="#refinery.lib.structures.StructReader.seek">seek</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_exactly" href="#refinery.lib.structures.StructReader.read_exactly">read_exactly</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.byte_align" href="#refinery.lib.structures.StructReader.byte_align">byte_align</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_integer" href="#refinery.lib.structures.StructReader.read_integer">read_integer</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bytes" href="#refinery.lib.structures.StructReader.read_bytes">read_bytes</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bit" href="#refinery.lib.structures.StructReader.read_bit">read_bit</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bits" href="#refinery.lib.structures.StructReader.read_bits">read_bits</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_flags" href="#refinery.lib.structures.StructReader.read_flags">read_flags</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_one_struct" href="#refinery.lib.structures.StructReader.read_one_struct">read_one_struct</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_struct" href="#refinery.lib.structures.StructReader.read_struct">read_struct</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_nibble" href="#refinery.lib.structures.StructReader.read_nibble">read_nibble</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.u8" href="#refinery.lib.structures.StructReader.u8">u8</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.i8" href="#refinery.lib.structures.StructReader.i8">i8</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.u16" href="#refinery.lib.structures.StructReader.u16">u16</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.u32" href="#refinery.lib.structures.StructReader.u32">u32</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.u64" href="#refinery.lib.structures.StructReader.u64">u64</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.i16" href="#refinery.lib.structures.StructReader.i16">i16</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.i32" href="#refinery.lib.structures.StructReader.i32">i32</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.i64" href="#refinery.lib.structures.StructReader.i64">i64</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.f32" href="#refinery.lib.structures.StructReader.f32">f32</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.f64" href="#refinery.lib.structures.StructReader.f64">f64</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.u8fast" href="#refinery.lib.structures.StructReader.u8fast">u8fast</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_byte" href="#refinery.lib.structures.StructReader.read_byte">read_byte</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_char" href="#refinery.lib.structures.StructReader.read_char">read_char</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_terminated_array" href="#refinery.lib.structures.StructReader.read_terminated_array">read_terminated_array</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_guid" href="#refinery.lib.structures.StructReader.read_guid">read_guid</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_uuid" href="#refinery.lib.structures.StructReader.read_uuid">read_uuid</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_c_string" href="#refinery.lib.structures.StructReader.read_c_string">read_c_string</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_w_string" href="#refinery.lib.structures.StructReader.read_w_string">read_w_string</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_length_prefixed_ascii" href="#refinery.lib.structures.StructReader.read_length_prefixed_ascii">read_length_prefixed_ascii</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_length_prefixed_utf8" href="#refinery.lib.structures.StructReader.read_length_prefixed_utf8">read_length_prefixed_utf8</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_length_prefixed_utf16" href="#refinery.lib.structures.StructReader.read_length_prefixed_utf16">read_length_prefixed_utf16</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_length_prefixed" href="#refinery.lib.structures.StructReader.read_length_prefixed">read_length_prefixed</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_7bit_encoded_int" href="#refinery.lib.structures.StructReader.read_7bit_encoded_int">read_7bit_encoded_int</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.structures.StructMeta" href="#refinery.lib.structures.StructMeta">StructMeta</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.Struct" href="#refinery.lib.structures.Struct">Struct</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.structures.Struct.Parse" href="#refinery.lib.structures.Struct.Parse">Parse</a></code></li>
<li><code><a title="refinery.lib.structures.Struct.get_data" href="#refinery.lib.structures.Struct.get_data">get_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.structures.PerInstanceAttribute" href="#refinery.lib.structures.PerInstanceAttribute">PerInstanceAttribute</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.structures.PerInstanceAttribute.resolve" href="#refinery.lib.structures.PerInstanceAttribute.resolve">resolve</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
