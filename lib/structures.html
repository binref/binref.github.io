<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.structures documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.structures</code></h1>
</header>
<section id="section-intro">
<p>Interfaces and classes to read structured data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L1-L1177" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Interfaces and classes to read structured data.
&#34;&#34;&#34;
from __future__ import annotations

import abc
import codecs
import contextlib
import enum
import functools
import inspect
import io
import itertools
import re
import struct
import sys
import weakref

from typing import (
    TYPE_CHECKING,
    Any,
    Generic,
    Iterable,
    NamedTuple,
    Sized,
    TypeVar,
    Union,
    cast,
    get_origin,
    overload,
)
from uuid import UUID

from refinery.lib.id import buffer_offset

if TYPE_CHECKING:
    from typing import Generator, Protocol, Self

    from refinery.lib.types import JSON, buf

    T = TypeVar(&#39;T&#39;, bound=Union[bytearray, bytes, memoryview])
    B = TypeVar(&#39;B&#39;, bound=Union[bytearray, bytes, memoryview], default=T)
    C = TypeVar(&#39;C&#39;, bound=Union[bytearray, bytes, memoryview])
    R = TypeVar(&#39;R&#39;, bound=io.IOBase)
else:
    Protocol = abc.ABC
    T = TypeVar(&#39;T&#39;)
    B = TypeVar(&#39;B&#39;)
    C = TypeVar(&#39;C&#39;)
    R = TypeVar(&#39;R&#39;)

if sys.version_info &gt;= (3, 12):
    from collections.abc import Buffer
else:
    Buffer = object


class ToJSON(Protocol):
    @abc.abstractmethod
    def __json__(self) -&gt; JSON:
        raise NotImplementedError


UnpackType = Union[int, bool, float, bytes]


def signed(k: int, bitsize: int):
    &#34;&#34;&#34;
    If `k` is an integer of the given bit size, cast it to a signed one.
    &#34;&#34;&#34;
    M = 1 &lt;&lt; bitsize
    k = k &amp; (M - 1)
    return k - M if k &gt;&gt; (bitsize - 1) else k


class EOF(EOFError):
    &#34;&#34;&#34;
    While reading from a `refinery.lib.structures.MemoryFile`, less bytes were available than
    requested. The exception contains the data from the incomplete read.
    &#34;&#34;&#34;
    def __init__(self, size: int, rest: buf = B&#39;&#39;):
        super().__init__(F&#39;Unexpected end of buffer; attempted to read {size} bytes, but got only {len(rest)}.&#39;)
        self.rest = rest
        self.size = size

    def __bytes__(self):
        return bytes(self.rest)


class LimitExceeded(EOFError):
    &#34;&#34;&#34;
    While writing to a `refinery.lib.structures.MemoryFile`, the buffer limit was exceeded.
    &#34;&#34;&#34;
    def __init__(self, rest: buf = B&#39;&#39;):
        super().__init__(F&#39;Unable to write {len(rest)} data to stream due to limit.&#39;)
        self.rest = rest

    def __bytes__(self):
        return bytes(self.rest)


class StreamDetour(Generic[R]):
    &#34;&#34;&#34;
    A stream detour is used as a context manager to temporarily read from a different location
    in the stream and then return to the original offset when the context ends.
    &#34;&#34;&#34;
    def __init__(self, stream: R, offset: int | None = None, whence: int = io.SEEK_SET):
        self.stream = stream
        self.offset = offset
        self.whence = whence

    def __enter__(self):
        self.cursor = self.stream.tell()
        if self.offset is not None:
            self.stream.seek(self.offset, self.whence)
        return self

    def __exit__(self, *args):
        self.stream.seek(self.cursor, io.SEEK_SET)


class MemoryFileMethods(Generic[T, B]):
    &#34;&#34;&#34;
    A thin wrapper around (potentially mutable) byte sequences which gives it the features of a
    file-like object.
    &#34;&#34;&#34;
    # TODO: This sadly breaks everything. It would provide minor performance gains for e.g.
    #       decompression routines where tight loops with access to a binary reader dominate
    #       the runtime; so it is a nice to have, not a must.
    # __slots__ = (
    #     &#39;_data&#39;,
    #     &#39;_name&#39;,
    #     &#39;_output&#39;,
    #     &#39;_cursor&#39;,
    #     &#39;_closed&#39;,
    #     &#39;_maxlen&#39;,
    #     &#39;_fileno&#39;,
    # )

    _data: T
    _name: str

    _output: type[B]
    _cursor: int
    _closed: bool
    _fileno: int | None
    _maxlen: int | None

    class SEEK(int, enum.Enum):
        CUR = io.SEEK_CUR
        END = io.SEEK_END
        SET = io.SEEK_SET

    def __bytes__(self):
        return bytes(self._data)

    def __init__(
        self,
        data: T | MemoryFileMethods[T, B] | type[T] = bytearray,
        output: type[B] | None = None,
        fileno: int | None = None,
        maxlen: int | None = None,
        name: str = &#39;&#39;,
    ) -&gt; None:
        if isinstance(data, type):
            if not issubclass(data, bytearray):
                raise TypeError(data.__name__)
            _data = data()
        else:
            _data = data
        if isinstance(_data, (bytearray, bytes, memoryview)):
            if output is None:
                if TYPE_CHECKING:
                    output = cast(type[B], type(_data))
                else:
                    output = type(_data)
            if maxlen is not None and len(_data) &gt; maxlen:
                raise ValueError(&#39;Initial data exceeds size limit&#39;)
            self._output = output
            self._cursor = 0
            self._closed = False
            self._fileno = fileno
            self._maxlen = maxlen
            self._data = _data
            self._name = name
        elif isinstance(_data, MemoryFileMethods):
            self._output = output or _data._output
            self._cursor = _data._cursor
            self._closed = _data._closed
            self._fileno = fileno or _data._fileno
            self._maxlen = maxlen or _data._maxlen
            self._data = _data._data
            self._name = _data._name
        else:
            raise TypeError(F&#39;Invalid input: {data!r}.&#39;)

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, name: str):
        self._name = name

    @property
    def mode(self):
        return &#39;r+b&#39;

    def close(self) -&gt; None:
        self._closed = True

    @property
    def closed(self) -&gt; bool:
        return self._closed

    def __enter__(self):
        return self

    def __exit__(self, ex_type, ex_value, trace) -&gt; bool:
        return False

    def flush(self) -&gt; None:
        pass

    def isatty(self) -&gt; bool:
        return False

    def __iter__(self):
        return self

    def __len__(self):
        return len(self._data)

    def __next__(self):
        line = self.readline()
        if not line:
            raise StopIteration
        return line

    def fileno(self) -&gt; int:
        if self._fileno is None:
            raise OSError
        return self._fileno

    def readable(self) -&gt; bool:
        return not self._closed

    def seekable(self) -&gt; bool:
        return not self._closed

    @property
    def eof(self) -&gt; bool:
        return self._closed or self._cursor &gt;= len(self._data)

    @property
    def remaining_bytes(self) -&gt; int:
        return len(self._data) - self.tell()

    def detour(self, offset: int | None = None, whence: int = io.SEEK_SET):
        return StreamDetour(cast(io.IOBase, self), offset, whence=whence)

    def detour_absolute(self, offset: int | None = None):
        return self.detour(offset, io.SEEK_SET)

    def detour_relative(self, offset: int | None = None):
        return self.detour(offset, io.SEEK_CUR)

    def detour_from_end(self, offset: int | None = None):
        return self.detour(offset, io.SEEK_END)

    def writable(self) -&gt; bool:
        if self._closed:
            return False
        if isinstance(self._data, memoryview):
            return not self._data.readonly
        return isinstance(self._data, bytearray)

    def read_as(self, cast: type[C], size: int = -1, peek: bool = False) -&gt; C:
        out = self.read(size, peek)
        if not isinstance(out, cast):
            out = cast(out)
        return out

    def read(self, size: int | None = None, peek: bool = False) -&gt; B:
        beginning = self._cursor
        if size is None or size &lt; 0:
            end = len(self._data)
        else:
            end = min(self._cursor + size, len(self._data))
        result = self._data[beginning:end]
        if not isinstance(result, t := self._output):
            result = t(result)
        if not peek:
            self._cursor = end
        return result

    def readif(self, value: bytes) -&gt; bool:
        size = len(value)
        stop = self._cursor + size
        mv = memoryview(self._data)
        if match := mv[self._cursor:stop] == value:
            self._cursor = stop
        return match

    def peek(self, size: int | None = None) -&gt; memoryview:
        cursor = self._cursor
        mv = memoryview(self._data)
        if size is None or size &lt; 0:
            return mv[cursor:]
        return mv[cursor:cursor + size]

    def read1(self, size: int | None = None, peek: bool = False) -&gt; B:
        return self.read(size, peek)

    def readline(self, size: int | None = None) -&gt; B:
        beginning, end = self._cursor, len(self._data)
        if size is not None and size &gt;= 0:
            end = beginning + size
        p = buffer_offset(self._data, B&#39;\n&#39;, beginning, end)
        self._cursor = end if p &lt; 0 else p + 1
        result = self._data[beginning:self._cursor]
        if not isinstance(result, t := self._output):
            result = t(result)
        return result

    def readlines_iter(self, hint: int | None = None) -&gt; Iterable[B]:
        if hint is None or hint &lt; 0:
            yield from self
        else:
            total = 0
            while total &lt; hint:
                line = next(self)
                total += len(line)
                yield line

    def readlines(self, hint: int | None = None) -&gt; list[bytes]:
        it = self.readlines_iter(hint)
        if issubclass(self._output, bytes):
            return list(it)
        return [bytes(t) for t in it]

    def readinto1(self, b) -&gt; int:
        data = self.read(len(b))
        size = len(data)
        b[:size] = data
        return size

    def readinto(self, b) -&gt; int:
        return self.readinto1(b)

    def tell(self) -&gt; int:
        return self._cursor

    def skip(self, n: int):
        self._cursor += n

    def seekrel(self, offset: int) -&gt; int:
        return self.seek(offset, io.SEEK_CUR)

    def seekend(self, offset: int) -&gt; int:
        return self.seek(offset, io.SEEK_END)

    def seekset(self, offset: int) -&gt; int:
        if offset &lt; 0:
            return self.seek(offset, io.SEEK_END)
        else:
            return self.seek(offset, io.SEEK_SET)

    def getbuffer(self) -&gt; memoryview:
        return memoryview(self._data)

    def getvalue(self) -&gt; T:
        return self._data

    def seek(self, offset: int, whence=io.SEEK_SET) -&gt; int:
        if whence == io.SEEK_SET:
            if offset &lt; 0:
                raise ValueError(&#39;no negative offsets allowed for SEEK_SET.&#39;)
            self._cursor = offset
        elif whence == io.SEEK_CUR:
            self._cursor += offset
        elif whence == io.SEEK_END:
            self._cursor = len(self._data) + offset
        self._cursor = max(self._cursor, 0)
        self._cursor = min(self._cursor, len(self._data))
        return self._cursor

    def writelines(self, lines: Iterable[Iterable[int]] | Iterable[Buffer]) -&gt; None:
        for line in lines:
            self.write(line)

    def truncate(self, size: int | None = None) -&gt; int:
        if not isinstance(self._data, bytearray):
            raise TypeError
        if size is not None:
            if not (0 &lt;= size &lt;= len(self._data)):
                raise ValueError(&#39;invalid size value&#39;)
            self._cursor = size
        del self._data[self._cursor:]
        return self.tell()

    def write_byte(self, byte: int) -&gt; None:
        if isinstance(self._data, bytes):
            raise TypeError
        if isinstance(self._data, memoryview):
            raise NotImplementedError
        limit = self._maxlen
        cc = self._cursor
        nc = cc + 1
        if limit and nc &gt; limit:
            raise LimitExceeded(bytes((byte,)))
        try:
            if cc &lt; len(self._data):
                self._data[cc] = byte
            else:
                self._data.append(byte)
        except Exception as T:
            raise OSError(str(T)) from T
        else:
            self._cursor = nc

    def write(self, _data: Buffer | Iterable[int]) -&gt; int:
        out = self._data
        end = len(out)

        if isinstance(out, memoryview):
            if out.readonly:
                raise PermissionError
            out = out.obj
        if not isinstance(out, bytearray):
            raise PermissionError

        try:
            getbuf = cast(&#39;Buffer&#39;, _data).__buffer__
        except AttributeError:
            data = cast(&#39;Iterable[int]&#39;, _data)
        else:
            data = getbuf(0)

        beginning = self._cursor
        limit = self._maxlen

        if limit is None and beginning == end:
            out[end:] = data
            self._cursor = end = len(out)
            return end - beginning
        try:
            size = len(cast(Sized, data))
        except Exception:
            it = iter(data)
            cursor = 0
            for cursor, b in enumerate(it, beginning):
                out[cursor] = b
                if cursor &gt;= end - 1:
                    break
            else:
                cursor += 1
                self._cursor = cursor
                return cursor - beginning
            if limit is None:
                out[end:] = bytes(it)
            else:
                out[end:limit] = bytes(itertools.islice(it, 0, limit - end))
                try:
                    b = next(it)
                except StopIteration:
                    self._cursor = limit
                    return limit - beginning
                else:
                    rest = bytearray((b,))
                    rest[1:] = it
                    raise LimitExceeded(rest)
        else:
            if limit and size + beginning &gt; limit:
                raise LimitExceeded(bytes(data))
            self._cursor += size
            try:
                out[beginning:self._cursor] = data
            except Exception as T:
                self._cursor = beginning
                raise OSError(str(T)) from T
            return size
        self._cursor = end = len(out)
        return end - beginning

    def __getitem__(self, slice):
        result = self._data[slice]
        if not isinstance(result, t := self._output):
            result = t(result)
        return result

    def replay(self, offset: int, length: int):
        cursor = self._cursor
        if offset not in range(cursor + 1):
            raise ValueError(F&#39;The supplied delta {offset} is not in the valid range [0,{self._cursor}].&#39;)
        rep, r = divmod(length, offset)
        offset = cursor - offset
        replay = self._data[offset:offset + r]
        if rep &gt; 0:
            # While this is technically a copy, it is faster than repeated calls to write.
            replay = bytes(self._data[offset:cursor]) * rep + replay
        self.write(replay)


class MemoryFile(MemoryFileMethods[T, B], io.BytesIO):
    pass


class order(str, enum.Enum):
    big = &#39;&gt;&#39;
    little = &#39;&lt;&#39;


class StructReader(MemoryFile[T, T]):
    &#34;&#34;&#34;
    An extension of a `refinery.lib.structures.MemoryFile` which provides methods to read
    structured data.
    &#34;&#34;&#34;
    __slots__ = &#39;bigendian&#39;,

    class Unaligned(RuntimeError):
        pass

    def __init__(self, data: T | StructReader[T], bigendian: bool | None = None):
        super().__init__(data)
        if bigendian is None:
            if isinstance(data, StructReader):
                bigendian = data.bigendian
            else:
                bigendian = False
        self.bigendian = bigendian

    def __enter__(self) -&gt; StructReader:
        return super().__enter__()

    @property
    @contextlib.contextmanager
    def be(self):
        self.bigendian = True
        try:
            yield self
        finally:
            self.bigendian = False

    @property
    def byteorder_format(self) -&gt; str:
        return &#39;&gt;&#39; if self.bigendian else &#39;&lt;&#39;

    @property
    def byteorder_name(self):
        return &#39;big&#39; if self.bigendian else &#39;little&#39;

    def read_exactly(self, size: int | None = None, peek: bool = False) -&gt; T:
        &#34;&#34;&#34;
        Read bytes from the underlying stream. Raises a `RuntimeError` when the stream is not currently
        byte-aligned, i.e. when `refinery.lib.structures.StructReader.bits_in_buffer` is positive. Raises
        an exception of type `refinery.lib.structures.EOF` when fewer data is available in the stream than
        requested via the `size` parameter. The remaining data can be extracted from the exception.
        Use `refinery.lib.structures.StructReader.read_bytes` to read bytes from the stream when it is
        not byte-aligned.
        &#34;&#34;&#34;
        data = self.read(size, peek)
        if size and len(data) &lt; size:
            raise EOF(size, data)
        return data

    def read_bit_field(self, *sizes: int, peek: bool = False):
        &#34;&#34;&#34;
        Read multiple integers that form a bit field. This method can be used to read bit fields without
        having to use a `refinery.lib.structures.StructReaderBits` when the bit count sums to a multiple
        of 8.
        &#34;&#34;&#34;
        data = self.read_integer(sum(sizes))
        if self.bigendian:
            sizes = sizes[::-1]
        fields = []
        for size in sizes:
            fields.append(data &amp; ~(-1 &lt;&lt; size))
            data &gt;&gt;= size
        if self.bigendian:
            fields.reverse()
        return fields

    def read_integer(
        self,
        size: int,
        peek: bool = False,
        signed: bool = False
    ) -&gt; int:
        &#34;&#34;&#34;
        Read an integer of the given size (in bytes) from the stream.
        &#34;&#34;&#34;
        nbytes, rest = divmod(size, 8)
        if rest &gt; 0:
            raise ValueError(
                F&#39;A {self.__class__.__name__} cannot read {size} bit{&#34;s&#34; * (size &gt; 1)}, only multiples of 8 are possible.&#39;)
        data = self.read(nbytes, peek)
        if len(data) &lt; nbytes:
            raise EOF(nbytes, data)
        return int.from_bytes(data, self.byteorder_name, signed=signed)

    def byte_align(self, blocksize: int = 1):
        &#34;&#34;&#34;
        Align the cursor at the given block size boundary.
        &#34;&#34;&#34;
        if mod := -self._cursor % blocksize:
            self.seekrel(mod)

    def read_bytes(self, size: int, peek: bool = False) -&gt; bytes:
        &#34;&#34;&#34;
        The method reads `size` many bytes from the underlying stream starting at the current bit.
        &#34;&#34;&#34;
        data = self.read_exactly(size, peek)
        if not isinstance(data, bytes):
            data = bytes(data)
        return data

    def read_one_struct(self, spec: str, peek=False) -&gt; UnpackType:
        item, = self.read_struct(spec, peek=peek)
        return item

    def read_struct(self, spec: str, peek=False) -&gt; list[UnpackType]:
        &#34;&#34;&#34;
        Read structured data from the stream in any format supported by the `struct` module. The `format`
        argument can be used to override the current byte ordering. If the `unwrap` parameter is `True`, a
        single unpacked value will be returned as a scalar, not as a tuple with one element.
        &#34;&#34;&#34;
        if not spec:
            raise ValueError(&#39;no format specified&#39;)
        byteorder = spec[:1]
        if byteorder in &#39;&lt;!=@&gt;&#39;:
            spec = spec[1:]
        else:
            byteorder = self.byteorder_format
        data = []
        current_cursor = self.tell()

        # reserved struct characters: xcbB?hHiIlLqQnNefdspP
        for k, part in enumerate(re.split(&#39;(\\d*[auwgk])&#39;, spec)):
            if k % 2 == 1:
                count = 1 if len(part) == 1 else int(part[:~0])
                part = part[~0]
                for _ in range(count):
                    if part == &#39;a&#39;:
                        data.append(self.read_c_string())
                    elif part == &#39;g&#39;:
                        data.append(str(self.read_guid()))
                    elif part == &#39;u&#39;:
                        data.append(self.read_w_string())
                    elif part == &#39;w&#39;:
                        data.append(codecs.decode(self.read_w_string(), &#39;utf-16le&#39;))
                    elif part == &#39;k&#39;:
                        data.append(self.read_7bit_encoded_int())
                continue
            else:
                part = F&#39;{byteorder}{part}&#39;
                data.extend(struct.unpack(part, self.read_bytes(struct.calcsize(part))))
        if peek:
            self.seekset(current_cursor)
        return data

    def read_bool_byte(self, strict=False):
        value = self.u8()
        if strict and value not in (0, 1):
            raise ValueError(F&#39;Invalid boolean byte value {value:#02x}.&#39;)
        return bool(value)

    def read_regex(
        self,
        pattern: bytes | bytearray | memoryview | re.Pattern[bytes],
        dotall: bool = True
    ):
        if isinstance(pattern, (bytes, bytearray, memoryview)):
            flags = re.DOTALL if dotall else re.NOFLAG
            pattern = re.compile(bytes(pattern), flags=flags)
        elif dotall and not re.DOTALL | pattern.flags:
            pattern = re.compile(pattern.pattern, flags=re.DOTALL)
        data = self._data
        if isinstance(data, memoryview) and not data.contiguous:
            raise NotImplementedError(&#39;Cannot perform regex-based read on non-contiguous buffer.&#39;)
        if result := pattern.match(data, self._cursor):
            self._cursor = result.end()
            return result

    def read_byte(self, peek: bool = False) -&gt; int:
        try:
            b = self._data[self._cursor]
        except IndexError:
            raise EOF(1)
        if not peek:
            self._cursor += 1
        return b

    def read_char(self, peek: bool = False) -&gt; str:
        try:
            b = self._data[self._cursor]
        except IndexError:
            raise EOF(1)
        if not peek:
            self._cursor += 1
        return chr(b)

    def u8fast(self):
        c = self._cursor
        b = self._data[c]
        self._cursor = c + 1
        return b

    u8 = read_byte

    def i8(self, peek: bool = False) -&gt; int:
        return signed(self.u8(peek), 8)

    def u16(self, peek: bool = False) -&gt; int:
        return self.read_integer(16, peek, signed=False)

    def u32(self, peek: bool = False) -&gt; int:
        return self.read_integer(32, peek, signed=False)

    def u64(self, peek: bool = False) -&gt; int:
        return self.read_integer(64, peek, signed=False)

    def i16(self, peek: bool = False) -&gt; int:
        return self.read_integer(16, peek, signed=True)

    def i32(self, peek: bool = False) -&gt; int:
        return self.read_integer(32, peek, signed=True)

    def i64(self, peek: bool = False) -&gt; int:
        return self.read_integer(64, peek, signed=True)

    def f32(self, peek: bool = False) -&gt; float:
        return cast(float, self.read_one_struct(&#39;f&#39;, peek=peek))

    def f64(self, peek: bool = False) -&gt; float:
        return cast(float, self.read_one_struct(&#39;d&#39;, peek=peek))

    def read_terminated_array(self, terminator: bytes, alignment: int = 1) -&gt; T:
        buf = self.getvalue()
        pos = self.tell()
        end = pos - 1
        n = len(terminator)
        while True:
            end = buffer_offset(buf, terminator, end + 1)
            if end &lt; 0 or not (end - pos) % alignment:
                break
        if end &gt;= pos:
            result = self.read_exactly(end - pos)
            self.skip(n)
            return result
        raise EOF(len(buf) - pos + n)

    def read_guid(self) -&gt; UUID:
        return UUID(bytes_le=self.read_bytes(16))

    def read_uuid(self) -&gt; UUID:
        return UUID(bytes=self.read_bytes(16))

    @overload
    def read_c_string(self) -&gt; T:
        ...

    @overload
    def read_c_string(self, encoding: str) -&gt; str:
        ...

    def read_c_string(self, encoding=None) -&gt; str | T:
        data = self.read_terminated_array(B&#39;\0&#39;)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    @overload
    def read_w_string(self) -&gt; T:
        ...

    @overload
    def read_w_string(self, encoding: str) -&gt; str:
        ...

    def read_w_string(self, encoding=None) -&gt; str | T:
        data = self.read_terminated_array(B&#39;\0\0&#39;, 2)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    def read_length_prefixed_ascii(self, prefix_size: int = 32):
        return self.read_length_prefixed(prefix_size, &#39;latin1&#39;)

    def read_length_prefixed_utf8(self, prefix_size: int = 32):
        return self.read_length_prefixed(prefix_size, &#39;utf8&#39;)

    def read_length_prefixed_utf16(self, prefix_size: int = 32, bytecount: bool = False):
        block_size = 1 if bytecount else 2
        return self.read_length_prefixed(prefix_size, &#39;utf-16le&#39;, block_size)

    @overload
    def read_length_prefixed(self, *, encoding: str, prefix_size: int = 32, block_size: int = 1) -&gt; str:
        ...

    @overload
    def read_length_prefixed(self, prefix_size: int, encoding: str, block_size: int = 1) -&gt; str:
        ...

    @overload
    def read_length_prefixed(self, *, prefix_size: int = 32, block_size: int = 1) -&gt; T:
        ...

    @overload
    def read_length_prefixed(self, prefix_size: int, *, block_size: int = 1) -&gt; T:
        ...

    def read_length_prefixed(self, prefix_size: int = 32, encoding: str | None = None, block_size: int = 1) -&gt; T | str:
        prefix = self.read_integer(prefix_size) * block_size
        data = self.read(prefix)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    def read_7bit_encoded_int(self, max_bits: int = 0, bigendian: bool | None = None) -&gt; int:
        value = 0
        shift = 0
        if bigendian is None:
            bigendian = self.bigendian
        while True:
            b = self.u8()
            if bigendian:
                value &lt;&lt;= 7
                value |= (b &amp; 0x7F)
            else:
                value |= (b &amp; 0x7F) &lt;&lt; shift
            if not b &amp; 0x80:
                return value
            if (shift := shift + 7) &gt; max_bits &gt; 0:
                raise OverflowError(&#39;Maximum bits were exceeded by encoded integer.&#39;)

    def read_bits(self, nbits: int) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        This method returns the bits of `refinery.lib.structures.StructReader.read_integer` one by one.
        &#34;&#34;&#34;
        chunk = self.read_integer(nbits)
        it = range(nbits - 1, -1, -1) if self.bigendian else range(nbits)
        for k in it:
            yield chunk &gt;&gt; k &amp; 1

    def read_flags(self, nbits: int, reverse=False) -&gt; Iterable[bool]:
        &#34;&#34;&#34;
        Identical to `refinery.lib.structures.StructReader.read_bits` with every bit value cast to a boolean.
        &#34;&#34;&#34;
        bits = self.read_bits(nbits)
        if reverse:
            bits = list(bits)
            bits.reverse()
        for bit in bits:
            yield bool(bit)


class StructReaderBits(StructReader[T]):
    __slots__ = &#39;_bbits&#39;, &#39;_nbits&#39;

    def __init__(self, data: T | StructReader[T], bigendian: bool | None = None):
        super().__init__(data, bigendian)
        if isinstance(data, StructReaderBits):
            self._bbits = data._bbits
            self._nbits = data._nbits
        else:
            self._bbits = 0
            self._nbits = 0

    @property
    def remaining_bits(self) -&gt; int:
        return 8 * self.remaining_bytes + self._nbits

    @property
    def bits_in_buffer(self) -&gt; int:
        &#34;&#34;&#34;
        This property is `True` if and only if there are currently no bits still waiting in the internal
        bit buffer.
        &#34;&#34;&#34;
        return self._nbits

    def read_bytes(self, size: int, peek: bool = False) -&gt; bytes:
        &#34;&#34;&#34;
        The method reads `size` many bytes from the underlying stream starting at the current bit.
        &#34;&#34;&#34;
        if self.bits_in_buffer:
            return self.read_integer(size * 8, peek).to_bytes(size, self.byteorder_name)
        return super().read_bytes(size, peek)

    def byte_align(self, blocksize: int = 1):
        &#34;&#34;&#34;
        This method clears the internal bit buffer and moves the cursor to the next byte. It returns a
        tuple containing the size and contents of the bit buffer.
        &#34;&#34;&#34;
        self._nbits = 0
        self._bbits = 0
        super().byte_align(blocksize)

    def read_exactly(self, size: int | None = None, peek: bool = False) -&gt; T:
        if self.bits_in_buffer:
            raise StructReader.Unaligned(&#39;The bit buffer is not empty.&#39;)
        return super().read_exactly(size, peek)

    def seek(self, offset, whence=io.SEEK_SET) -&gt; int:
        self._bbits = 0
        self._nbits = 0
        return super().seek(offset, whence)

    def read_integer(
        self,
        size: int | None = None,
        peek: bool = False,
        signed: bool = False,
    ) -&gt; int:
        &#34;&#34;&#34;
        Read `size` many bits from the underlying stream as an integer.
        &#34;&#34;&#34;
        if size is None:
            size = self.remaining_bits
        if size &lt; self._nbits:
            new_count = self._nbits - size
            if self.bigendian:
                result = self._bbits &gt;&gt; new_count
                if not peek:
                    self._bbits ^= result &lt;&lt; new_count
            else:
                result = self._bbits &amp; 2 ** size - 1
                if not peek:
                    self._bbits &gt;&gt;= size
            if not peek:
                self._nbits = new_count
        else:
            nbits, bbits = self._nbits, self._bbits
            needed = size - nbits
            bytecount, rest = divmod(needed, 8)
            if rest:
                bytecount += 1
                rest = 8 - rest
            bb = self.read(bytecount, True)
            if len(bb) != bytecount:
                raise EOF(bytecount, bb)
            if not peek:
                self._cursor += bytecount
            if bytecount == 1:
                result, = bb
            else:
                result = int.from_bytes(bb, self.byteorder_name)
            if nbits or rest:
                if self.bigendian:
                    rbmask   = 2 ** rest - 1        # noqa
                    excess   = result &amp; rbmask      # noqa
                    result &gt;&gt;= rest                 # noqa
                    result  ^= bbits &lt;&lt; needed      # noqa
                else:
                    excess   = result &gt;&gt; needed     # noqa
                    result  ^= excess &lt;&lt; needed     # noqa
                    result &lt;&lt;= nbits                # noqa
                    result  |= bbits                # noqa
                assert excess.bit_length() &lt;= rest
                if not peek:
                    self._nbits = rest
                    self._bbits = excess
        if signed and (result &amp; (msb := 1 &lt;&lt; (size - 1))):
            result &amp;= msb - 1
            result -= msb
        return result

    def read_bit(self) -&gt; int:
        &#34;&#34;&#34;
        This function is a shortcut for calling `refinery.lib.structures.StructReader.read_integer` with
        an argument of `1`, i.e. this reads the next bit from the stream. The bits of any byte in the stream
        are read from least significant to most significant.
        &#34;&#34;&#34;
        return self.read_integer(1)

    def read_nibble(self, peek: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Calls `refinery.lib.structures.StructReader.read_integer` with an argument of `4`.
        &#34;&#34;&#34;
        return self.read_integer(4, peek)

    def read_byte(self, peek: bool = False) -&gt; int:
        return self.read_integer(8, peek)

    def read_char(self, peek: bool = False) -&gt; str:
        return chr(self.read_integer(8, peek))


class StructMeta(abc.ABCMeta):
    &#34;&#34;&#34;
    A metaclass to facilitate the behavior outlined for `refinery.lib.structures.Struct`.
    &#34;&#34;&#34;
    def __new__(mcls, name, bases, namespace: dict, interface: type[StructReader] | None = None):
        if interface is None:
            if init := namespace.get(&#39;__init__&#39;):
                args = iter(inspect.signature(init).parameters.values())
                next(args)
                interface = next(args).annotation
                if isinstance(interface, str):
                    try:
                        module = sys.modules[namespace[&#39;__module__&#39;]]
                        interface = eval(interface, module.__dict__)
                    except Exception:
                        interface = None
                if not isinstance(interface, type):
                    interface = get_origin(interface)
                if not isinstance(interface, type) or not issubclass(interface, StructReader):
                    raise RuntimeError
            else:
                interface = StructReader

        def parse(cls, reader: T | StructReader[T], *args, **kwargs):
            if not isinstance(reader, interface):
                reader = interface(reader)
            return cls(reader, *args, **kwargs)

        namespace.update(Parse=classmethod(parse))
        return super().__new__(mcls, name, bases, namespace)

    def __init__(cls, name, bases, nmspc, **_):
        super().__init__(name, bases, nmspc)
        original__init__ = cls.__init__

        @functools.wraps(original__init__)
        def wrapped__init__(self: Struct, reader: StructReader, *args, **kwargs):
            start = reader.tell()
            view = reader.getbuffer()
            original__init__(self, reader, *args, **kwargs)
            self._data = view[start:reader.tell()]
            del view

        setattr(cls, &#39;__init__&#39;, wrapped__init__)


class Struct(Generic[T], Buffer, metaclass=StructMeta):
    &#34;&#34;&#34;
    A class to parse structured data. A `refinery.lib.structures.Struct` class can be instantiated
    as follows:

        foo = Struct(data, bar=29)

    The initialization routine of the structure will be called with a single argument `reader`. If
    the object `data` is already a `refinery.lib.structures.StructReader`, then it will be passed
    as `reader`. Otherwise, the argument will be wrapped in a `refinery.lib.structures.StructReader`.
    Additional arguments to the struct are passed through.
    &#34;&#34;&#34;
    _data: memoryview | bytearray

    @classmethod
    def Parse(cls, reader: T | StructReader[T], *args, **kwargs) -&gt; Self:
        ...

    def __len__(self):
        return len(self._data)

    def __bytes__(self):
        return bytes(self._data)

    def __buffer__(self, flags: int, /):
        return memoryview(self._data)

    def __init__(self, reader: StructReader[T], *args, **kwargs):
        pass


AttrType = TypeVar(&#39;AttrType&#39;)


class PerInstanceAttribute(Generic[AttrType]):
    def resolve(self, parent, value: Any) -&gt; AttrType:
        return value

    def __init__(self):
        self.__set: dict[int, Any] = {}
        self.__get: dict[int, AttrType] = {}

    def __set__(self, parent: Any, value: Any) -&gt; None:
        pid = id(parent)
        if pid not in self.__set:
            def cleanup(self, pid):
                self.__set.pop(pid, None)
                self.__get.pop(pid, None)
            self.__set[pid] = value
            weakref.finalize(parent, cleanup, self, id(parent))

    def __get__(self, parent, tp=None) -&gt; AttrType:
        pid = id(parent)
        if pid not in self.__get:
            try:
                seed = self.__set[pid]
            except KeyError as K:
                raise AttributeError from K
            self.__get[pid] = self.resolve(parent, seed)
        return self.__get[pid]


def struct_to_json(o: dict | list | enum.IntFlag | enum.IntEnum | Struct | ToJSON | NamedTuple | None, codec: str | None = None) -&gt; JSON:
    &#34;&#34;&#34;
    Attempt to convert a `refinery.lib.structures.Struct` to a JSON representation.
    &#34;&#34;&#34;
    if o is None:
        return o
    if isinstance(o, Struct):
        return {k: struct_to_json(v) for k, v in o.__dict__.items() if not k.startswith(&#39;_&#39;)}
    if isinstance(o, tuple):
        o = o._asdict()
    if isinstance(o, dict):
        for k, v in o.items():
            o[k] = struct_to_json(v, codec)
    elif isinstance(o, list):
        for k, v in enumerate(o):
            o[k] = struct_to_json(v, codec)
    elif isinstance(o, enum.IntFlag):
        return [option.name for option in o.__class__ if o &amp; option == option]
    elif isinstance(o, enum.IntEnum):
        return o.name
    elif isinstance(o, int) and o.bit_length() &gt; 64:
        return hex(o)
    elif codec is not None and isinstance(o, (memoryview, bytes, bytearray)):
        return codecs.decode(o, codec)
    else:
        try:
            return o.__json__()
        except AttributeError:
            pass
    return cast(&#39;JSON&#39;, o)


class FlagAccessMixin:
    &#34;&#34;&#34;
    This class can be mixed into an `enum.IntFlag` for some quality of life improvements. Firstly,
    you can now access flags as follows:

        class Flags(FlagAccessMixin, enum.IntFlag):
            IsBinary = 1
            IsCompressed = 2

        flag = Flags(3)

        if flag.IsCompressed:
            decompress()

    Furthermore, flag values can be enumerated:

        &gt;&gt;&gt; list(flag)
        [IsBinary, IsCompressed]
        &gt;&gt;&gt; flag
        IsBinary|IsCompressed

    And finally, as visible from the above output, flag values are represented by their name by
    default.
    &#34;&#34;&#34;
    def __getattribute__(self, name: str):
        if not isinstance(self, enum.IntFlag):
            raise RuntimeError
        if not name.startswith(&#39;_&#39;):
            try:
                flag = self.__class__[name]
            except KeyError:
                pass
            else:
                return flag in self
        return super().__getattribute__(name)

    def __iter__(self) -&gt; Generator[Self]:
        if not isinstance(self, enum.IntFlag):
            raise RuntimeError
        for flag in self.__class__:
            if flag in self:
                yield flag

    def __repr__(self):
        if not isinstance(self, enum.IntFlag):
            raise RuntimeError
        if name := self.name:
            return name
        return enum.IntFlag.__repr__(self)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.structures.signed"><code class="name flex">
<span>def <span class="ident">signed</span></span>(<span>k, bitsize)</span>
</code></dt>
<dd>
<section class="desc"><p>If <code>k</code> is an integer of the given bit size, cast it to a signed one.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L67-L73" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def signed(k: int, bitsize: int):
    &#34;&#34;&#34;
    If `k` is an integer of the given bit size, cast it to a signed one.
    &#34;&#34;&#34;
    M = 1 &lt;&lt; bitsize
    k = k &amp; (M - 1)
    return k - M if k &gt;&gt; (bitsize - 1) else k</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.struct_to_json"><code class="name flex">
<span>def <span class="ident">struct_to_json</span></span>(<span>o, codec=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempt to convert a <code><a title="refinery.lib.structures.Struct" href="#refinery.lib.structures.Struct">Struct</a></code> to a JSON representation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L1097-L1126" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def struct_to_json(o: dict | list | enum.IntFlag | enum.IntEnum | Struct | ToJSON | NamedTuple | None, codec: str | None = None) -&gt; JSON:
    &#34;&#34;&#34;
    Attempt to convert a `refinery.lib.structures.Struct` to a JSON representation.
    &#34;&#34;&#34;
    if o is None:
        return o
    if isinstance(o, Struct):
        return {k: struct_to_json(v) for k, v in o.__dict__.items() if not k.startswith(&#39;_&#39;)}
    if isinstance(o, tuple):
        o = o._asdict()
    if isinstance(o, dict):
        for k, v in o.items():
            o[k] = struct_to_json(v, codec)
    elif isinstance(o, list):
        for k, v in enumerate(o):
            o[k] = struct_to_json(v, codec)
    elif isinstance(o, enum.IntFlag):
        return [option.name for option in o.__class__ if o &amp; option == option]
    elif isinstance(o, enum.IntEnum):
        return o.name
    elif isinstance(o, int) and o.bit_length() &gt; 64:
        return hex(o)
    elif codec is not None and isinstance(o, (memoryview, bytes, bytearray)):
        return codecs.decode(o, codec)
    else:
        try:
            return o.__json__()
        except AttributeError:
            pass
    return cast(&#39;JSON&#39;, o)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.structures.ToJSON"><code class="flex name class">
<span>class <span class="ident">ToJSON</span></span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L58-L61" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ToJSON(Protocol):
    @abc.abstractmethod
    def __json__(self) -&gt; JSON:
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
</dd>
<dt id="refinery.lib.structures.EOF"><code class="flex name class">
<span>class <span class="ident">EOF</span></span>
<span>(</span><span>size, rest=b'')</span>
</code></dt>
<dd>
<section class="desc"><p>While reading from a <code><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></code>, less bytes were available than
requested. The exception contains the data from the incomplete read.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L76-L87" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class EOF(EOFError):
    &#34;&#34;&#34;
    While reading from a `refinery.lib.structures.MemoryFile`, less bytes were available than
    requested. The exception contains the data from the incomplete read.
    &#34;&#34;&#34;
    def __init__(self, size: int, rest: buf = B&#39;&#39;):
        super().__init__(F&#39;Unexpected end of buffer; attempted to read {size} bytes, but got only {len(rest)}.&#39;)
        self.rest = rest
        self.size = size

    def __bytes__(self):
        return bytes(self.rest)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.EOFError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.structures.LimitExceeded"><code class="flex name class">
<span>class <span class="ident">LimitExceeded</span></span>
<span>(</span><span>rest=b'')</span>
</code></dt>
<dd>
<section class="desc"><p>While writing to a <code><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></code>, the buffer limit was exceeded.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L90-L99" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LimitExceeded(EOFError):
    &#34;&#34;&#34;
    While writing to a `refinery.lib.structures.MemoryFile`, the buffer limit was exceeded.
    &#34;&#34;&#34;
    def __init__(self, rest: buf = B&#39;&#39;):
        super().__init__(F&#39;Unable to write {len(rest)} data to stream due to limit.&#39;)
        self.rest = rest

    def __bytes__(self):
        return bytes(self.rest)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.EOFError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.structures.StreamDetour"><code class="flex name class">
<span>class <span class="ident">StreamDetour</span></span>
<span>(</span><span>stream, offset=None, whence=0)</span>
</code></dt>
<dd>
<section class="desc"><p>A stream detour is used as a context manager to temporarily read from a different location
in the stream and then return to the original offset when the context ends.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L102-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StreamDetour(Generic[R]):
    &#34;&#34;&#34;
    A stream detour is used as a context manager to temporarily read from a different location
    in the stream and then return to the original offset when the context ends.
    &#34;&#34;&#34;
    def __init__(self, stream: R, offset: int | None = None, whence: int = io.SEEK_SET):
        self.stream = stream
        self.offset = offset
        self.whence = whence

    def __enter__(self):
        self.cursor = self.stream.tell()
        if self.offset is not None:
            self.stream.seek(self.offset, self.whence)
        return self

    def __exit__(self, *args):
        self.stream.seek(self.cursor, io.SEEK_SET)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods"><code class="flex name class">
<span>class <span class="ident">MemoryFileMethods</span></span>
<span>(</span><span>data=builtins.bytearray, output=None, fileno=None, maxlen=None, name='')</span>
</code></dt>
<dd>
<section class="desc"><p>A thin wrapper around (potentially mutable) byte sequences which gives it the features of a
file-like object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L122-L502" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MemoryFileMethods(Generic[T, B]):
    &#34;&#34;&#34;
    A thin wrapper around (potentially mutable) byte sequences which gives it the features of a
    file-like object.
    &#34;&#34;&#34;
    # TODO: This sadly breaks everything. It would provide minor performance gains for e.g.
    #       decompression routines where tight loops with access to a binary reader dominate
    #       the runtime; so it is a nice to have, not a must.
    # __slots__ = (
    #     &#39;_data&#39;,
    #     &#39;_name&#39;,
    #     &#39;_output&#39;,
    #     &#39;_cursor&#39;,
    #     &#39;_closed&#39;,
    #     &#39;_maxlen&#39;,
    #     &#39;_fileno&#39;,
    # )

    _data: T
    _name: str

    _output: type[B]
    _cursor: int
    _closed: bool
    _fileno: int | None
    _maxlen: int | None

    class SEEK(int, enum.Enum):
        CUR = io.SEEK_CUR
        END = io.SEEK_END
        SET = io.SEEK_SET

    def __bytes__(self):
        return bytes(self._data)

    def __init__(
        self,
        data: T | MemoryFileMethods[T, B] | type[T] = bytearray,
        output: type[B] | None = None,
        fileno: int | None = None,
        maxlen: int | None = None,
        name: str = &#39;&#39;,
    ) -&gt; None:
        if isinstance(data, type):
            if not issubclass(data, bytearray):
                raise TypeError(data.__name__)
            _data = data()
        else:
            _data = data
        if isinstance(_data, (bytearray, bytes, memoryview)):
            if output is None:
                if TYPE_CHECKING:
                    output = cast(type[B], type(_data))
                else:
                    output = type(_data)
            if maxlen is not None and len(_data) &gt; maxlen:
                raise ValueError(&#39;Initial data exceeds size limit&#39;)
            self._output = output
            self._cursor = 0
            self._closed = False
            self._fileno = fileno
            self._maxlen = maxlen
            self._data = _data
            self._name = name
        elif isinstance(_data, MemoryFileMethods):
            self._output = output or _data._output
            self._cursor = _data._cursor
            self._closed = _data._closed
            self._fileno = fileno or _data._fileno
            self._maxlen = maxlen or _data._maxlen
            self._data = _data._data
            self._name = _data._name
        else:
            raise TypeError(F&#39;Invalid input: {data!r}.&#39;)

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, name: str):
        self._name = name

    @property
    def mode(self):
        return &#39;r+b&#39;

    def close(self) -&gt; None:
        self._closed = True

    @property
    def closed(self) -&gt; bool:
        return self._closed

    def __enter__(self):
        return self

    def __exit__(self, ex_type, ex_value, trace) -&gt; bool:
        return False

    def flush(self) -&gt; None:
        pass

    def isatty(self) -&gt; bool:
        return False

    def __iter__(self):
        return self

    def __len__(self):
        return len(self._data)

    def __next__(self):
        line = self.readline()
        if not line:
            raise StopIteration
        return line

    def fileno(self) -&gt; int:
        if self._fileno is None:
            raise OSError
        return self._fileno

    def readable(self) -&gt; bool:
        return not self._closed

    def seekable(self) -&gt; bool:
        return not self._closed

    @property
    def eof(self) -&gt; bool:
        return self._closed or self._cursor &gt;= len(self._data)

    @property
    def remaining_bytes(self) -&gt; int:
        return len(self._data) - self.tell()

    def detour(self, offset: int | None = None, whence: int = io.SEEK_SET):
        return StreamDetour(cast(io.IOBase, self), offset, whence=whence)

    def detour_absolute(self, offset: int | None = None):
        return self.detour(offset, io.SEEK_SET)

    def detour_relative(self, offset: int | None = None):
        return self.detour(offset, io.SEEK_CUR)

    def detour_from_end(self, offset: int | None = None):
        return self.detour(offset, io.SEEK_END)

    def writable(self) -&gt; bool:
        if self._closed:
            return False
        if isinstance(self._data, memoryview):
            return not self._data.readonly
        return isinstance(self._data, bytearray)

    def read_as(self, cast: type[C], size: int = -1, peek: bool = False) -&gt; C:
        out = self.read(size, peek)
        if not isinstance(out, cast):
            out = cast(out)
        return out

    def read(self, size: int | None = None, peek: bool = False) -&gt; B:
        beginning = self._cursor
        if size is None or size &lt; 0:
            end = len(self._data)
        else:
            end = min(self._cursor + size, len(self._data))
        result = self._data[beginning:end]
        if not isinstance(result, t := self._output):
            result = t(result)
        if not peek:
            self._cursor = end
        return result

    def readif(self, value: bytes) -&gt; bool:
        size = len(value)
        stop = self._cursor + size
        mv = memoryview(self._data)
        if match := mv[self._cursor:stop] == value:
            self._cursor = stop
        return match

    def peek(self, size: int | None = None) -&gt; memoryview:
        cursor = self._cursor
        mv = memoryview(self._data)
        if size is None or size &lt; 0:
            return mv[cursor:]
        return mv[cursor:cursor + size]

    def read1(self, size: int | None = None, peek: bool = False) -&gt; B:
        return self.read(size, peek)

    def readline(self, size: int | None = None) -&gt; B:
        beginning, end = self._cursor, len(self._data)
        if size is not None and size &gt;= 0:
            end = beginning + size
        p = buffer_offset(self._data, B&#39;\n&#39;, beginning, end)
        self._cursor = end if p &lt; 0 else p + 1
        result = self._data[beginning:self._cursor]
        if not isinstance(result, t := self._output):
            result = t(result)
        return result

    def readlines_iter(self, hint: int | None = None) -&gt; Iterable[B]:
        if hint is None or hint &lt; 0:
            yield from self
        else:
            total = 0
            while total &lt; hint:
                line = next(self)
                total += len(line)
                yield line

    def readlines(self, hint: int | None = None) -&gt; list[bytes]:
        it = self.readlines_iter(hint)
        if issubclass(self._output, bytes):
            return list(it)
        return [bytes(t) for t in it]

    def readinto1(self, b) -&gt; int:
        data = self.read(len(b))
        size = len(data)
        b[:size] = data
        return size

    def readinto(self, b) -&gt; int:
        return self.readinto1(b)

    def tell(self) -&gt; int:
        return self._cursor

    def skip(self, n: int):
        self._cursor += n

    def seekrel(self, offset: int) -&gt; int:
        return self.seek(offset, io.SEEK_CUR)

    def seekend(self, offset: int) -&gt; int:
        return self.seek(offset, io.SEEK_END)

    def seekset(self, offset: int) -&gt; int:
        if offset &lt; 0:
            return self.seek(offset, io.SEEK_END)
        else:
            return self.seek(offset, io.SEEK_SET)

    def getbuffer(self) -&gt; memoryview:
        return memoryview(self._data)

    def getvalue(self) -&gt; T:
        return self._data

    def seek(self, offset: int, whence=io.SEEK_SET) -&gt; int:
        if whence == io.SEEK_SET:
            if offset &lt; 0:
                raise ValueError(&#39;no negative offsets allowed for SEEK_SET.&#39;)
            self._cursor = offset
        elif whence == io.SEEK_CUR:
            self._cursor += offset
        elif whence == io.SEEK_END:
            self._cursor = len(self._data) + offset
        self._cursor = max(self._cursor, 0)
        self._cursor = min(self._cursor, len(self._data))
        return self._cursor

    def writelines(self, lines: Iterable[Iterable[int]] | Iterable[Buffer]) -&gt; None:
        for line in lines:
            self.write(line)

    def truncate(self, size: int | None = None) -&gt; int:
        if not isinstance(self._data, bytearray):
            raise TypeError
        if size is not None:
            if not (0 &lt;= size &lt;= len(self._data)):
                raise ValueError(&#39;invalid size value&#39;)
            self._cursor = size
        del self._data[self._cursor:]
        return self.tell()

    def write_byte(self, byte: int) -&gt; None:
        if isinstance(self._data, bytes):
            raise TypeError
        if isinstance(self._data, memoryview):
            raise NotImplementedError
        limit = self._maxlen
        cc = self._cursor
        nc = cc + 1
        if limit and nc &gt; limit:
            raise LimitExceeded(bytes((byte,)))
        try:
            if cc &lt; len(self._data):
                self._data[cc] = byte
            else:
                self._data.append(byte)
        except Exception as T:
            raise OSError(str(T)) from T
        else:
            self._cursor = nc

    def write(self, _data: Buffer | Iterable[int]) -&gt; int:
        out = self._data
        end = len(out)

        if isinstance(out, memoryview):
            if out.readonly:
                raise PermissionError
            out = out.obj
        if not isinstance(out, bytearray):
            raise PermissionError

        try:
            getbuf = cast(&#39;Buffer&#39;, _data).__buffer__
        except AttributeError:
            data = cast(&#39;Iterable[int]&#39;, _data)
        else:
            data = getbuf(0)

        beginning = self._cursor
        limit = self._maxlen

        if limit is None and beginning == end:
            out[end:] = data
            self._cursor = end = len(out)
            return end - beginning
        try:
            size = len(cast(Sized, data))
        except Exception:
            it = iter(data)
            cursor = 0
            for cursor, b in enumerate(it, beginning):
                out[cursor] = b
                if cursor &gt;= end - 1:
                    break
            else:
                cursor += 1
                self._cursor = cursor
                return cursor - beginning
            if limit is None:
                out[end:] = bytes(it)
            else:
                out[end:limit] = bytes(itertools.islice(it, 0, limit - end))
                try:
                    b = next(it)
                except StopIteration:
                    self._cursor = limit
                    return limit - beginning
                else:
                    rest = bytearray((b,))
                    rest[1:] = it
                    raise LimitExceeded(rest)
        else:
            if limit and size + beginning &gt; limit:
                raise LimitExceeded(bytes(data))
            self._cursor += size
            try:
                out[beginning:self._cursor] = data
            except Exception as T:
                self._cursor = beginning
                raise OSError(str(T)) from T
            return size
        self._cursor = end = len(out)
        return end - beginning

    def __getitem__(self, slice):
        result = self._data[slice]
        if not isinstance(result, t := self._output):
            result = t(result)
        return result

    def replay(self, offset: int, length: int):
        cursor = self._cursor
        if offset not in range(cursor + 1):
            raise ValueError(F&#39;The supplied delta {offset} is not in the valid range [0,{self._cursor}].&#39;)
        rep, r = divmod(length, offset)
        offset = cursor - offset
        replay = self._data[offset:offset + r]
        if rep &gt; 0:
            # While this is technically a copy, it is faster than repeated calls to write.
            replay = bytes(self._data[offset:cursor]) * rep + replay
        self.write(replay)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.structures.MemoryFileMethods.SEEK"><code class="name">var <span class="ident">SEEK</span></code></dt>
<dd>
<section class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating-point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.structures.MemoryFileMethods.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L197-L199" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def name(self):
    return self._name</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.mode"><code class="name">var <span class="ident">mode</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L205-L207" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def mode(self):
    return &#39;r+b&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.closed"><code class="name">var <span class="ident">closed</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L212-L214" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def closed(self) -&gt; bool:
    return self._closed</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.eof"><code class="name">var <span class="ident">eof</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L251-L253" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def eof(self) -&gt; bool:
    return self._closed or self._cursor &gt;= len(self._data)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.remaining_bytes"><code class="name">var <span class="ident">remaining_bytes</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L255-L257" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def remaining_bytes(self) -&gt; int:
    return len(self._data) - self.tell()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.structures.MemoryFileMethods.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L209-L210" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    self._closed = True</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L222-L223" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flush(self) -&gt; None:
    pass</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.isatty"><code class="name flex">
<span>def <span class="ident">isatty</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L225-L226" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isatty(self) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.fileno"><code class="name flex">
<span>def <span class="ident">fileno</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L240-L243" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fileno(self) -&gt; int:
    if self._fileno is None:
        raise OSError
    return self._fileno</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readable"><code class="name flex">
<span>def <span class="ident">readable</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L245-L246" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readable(self) -&gt; bool:
    return not self._closed</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.seekable"><code class="name flex">
<span>def <span class="ident">seekable</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L248-L249" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seekable(self) -&gt; bool:
    return not self._closed</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.detour"><code class="name flex">
<span>def <span class="ident">detour</span></span>(<span>self, offset=None, whence=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L259-L260" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def detour(self, offset: int | None = None, whence: int = io.SEEK_SET):
    return StreamDetour(cast(io.IOBase, self), offset, whence=whence)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.detour_absolute"><code class="name flex">
<span>def <span class="ident">detour_absolute</span></span>(<span>self, offset=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L262-L263" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def detour_absolute(self, offset: int | None = None):
    return self.detour(offset, io.SEEK_SET)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.detour_relative"><code class="name flex">
<span>def <span class="ident">detour_relative</span></span>(<span>self, offset=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L265-L266" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def detour_relative(self, offset: int | None = None):
    return self.detour(offset, io.SEEK_CUR)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.detour_from_end"><code class="name flex">
<span>def <span class="ident">detour_from_end</span></span>(<span>self, offset=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L268-L269" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def detour_from_end(self, offset: int | None = None):
    return self.detour(offset, io.SEEK_END)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.writable"><code class="name flex">
<span>def <span class="ident">writable</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L271-L276" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def writable(self) -&gt; bool:
    if self._closed:
        return False
    if isinstance(self._data, memoryview):
        return not self._data.readonly
    return isinstance(self._data, bytearray)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.read_as"><code class="name flex">
<span>def <span class="ident">read_as</span></span>(<span>self, cast, size=-1, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L278-L282" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_as(self, cast: type[C], size: int = -1, peek: bool = False) -&gt; C:
    out = self.read(size, peek)
    if not isinstance(out, cast):
        out = cast(out)
    return out</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, size=None, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L284-L295" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read(self, size: int | None = None, peek: bool = False) -&gt; B:
    beginning = self._cursor
    if size is None or size &lt; 0:
        end = len(self._data)
    else:
        end = min(self._cursor + size, len(self._data))
    result = self._data[beginning:end]
    if not isinstance(result, t := self._output):
        result = t(result)
    if not peek:
        self._cursor = end
    return result</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readif"><code class="name flex">
<span>def <span class="ident">readif</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L297-L303" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readif(self, value: bytes) -&gt; bool:
    size = len(value)
    stop = self._cursor + size
    mv = memoryview(self._data)
    if match := mv[self._cursor:stop] == value:
        self._cursor = stop
    return match</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.peek"><code class="name flex">
<span>def <span class="ident">peek</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L305-L310" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def peek(self, size: int | None = None) -&gt; memoryview:
    cursor = self._cursor
    mv = memoryview(self._data)
    if size is None or size &lt; 0:
        return mv[cursor:]
    return mv[cursor:cursor + size]</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.read1"><code class="name flex">
<span>def <span class="ident">read1</span></span>(<span>self, size=None, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L312-L313" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read1(self, size: int | None = None, peek: bool = False) -&gt; B:
    return self.read(size, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readline"><code class="name flex">
<span>def <span class="ident">readline</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L315-L324" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readline(self, size: int | None = None) -&gt; B:
    beginning, end = self._cursor, len(self._data)
    if size is not None and size &gt;= 0:
        end = beginning + size
    p = buffer_offset(self._data, B&#39;\n&#39;, beginning, end)
    self._cursor = end if p &lt; 0 else p + 1
    result = self._data[beginning:self._cursor]
    if not isinstance(result, t := self._output):
        result = t(result)
    return result</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readlines_iter"><code class="name flex">
<span>def <span class="ident">readlines_iter</span></span>(<span>self, hint=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L326-L334" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readlines_iter(self, hint: int | None = None) -&gt; Iterable[B]:
    if hint is None or hint &lt; 0:
        yield from self
    else:
        total = 0
        while total &lt; hint:
            line = next(self)
            total += len(line)
            yield line</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readlines"><code class="name flex">
<span>def <span class="ident">readlines</span></span>(<span>self, hint=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L336-L340" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readlines(self, hint: int | None = None) -&gt; list[bytes]:
    it = self.readlines_iter(hint)
    if issubclass(self._output, bytes):
        return list(it)
    return [bytes(t) for t in it]</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readinto1"><code class="name flex">
<span>def <span class="ident">readinto1</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L342-L346" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readinto1(self, b) -&gt; int:
    data = self.read(len(b))
    size = len(data)
    b[:size] = data
    return size</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.readinto"><code class="name flex">
<span>def <span class="ident">readinto</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L348-L349" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readinto(self, b) -&gt; int:
    return self.readinto1(b)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.tell"><code class="name flex">
<span>def <span class="ident">tell</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L351-L352" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tell(self) -&gt; int:
    return self._cursor</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.skip"><code class="name flex">
<span>def <span class="ident">skip</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L354-L355" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def skip(self, n: int):
    self._cursor += n</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.seekrel"><code class="name flex">
<span>def <span class="ident">seekrel</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L357-L358" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seekrel(self, offset: int) -&gt; int:
    return self.seek(offset, io.SEEK_CUR)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.seekend"><code class="name flex">
<span>def <span class="ident">seekend</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L360-L361" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seekend(self, offset: int) -&gt; int:
    return self.seek(offset, io.SEEK_END)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.seekset"><code class="name flex">
<span>def <span class="ident">seekset</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L363-L367" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seekset(self, offset: int) -&gt; int:
    if offset &lt; 0:
        return self.seek(offset, io.SEEK_END)
    else:
        return self.seek(offset, io.SEEK_SET)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.getbuffer"><code class="name flex">
<span>def <span class="ident">getbuffer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L369-L370" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getbuffer(self) -&gt; memoryview:
    return memoryview(self._data)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.getvalue"><code class="name flex">
<span>def <span class="ident">getvalue</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L372-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getvalue(self) -&gt; T:
    return self._data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.seek"><code class="name flex">
<span>def <span class="ident">seek</span></span>(<span>self, offset, whence=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L375-L386" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seek(self, offset: int, whence=io.SEEK_SET) -&gt; int:
    if whence == io.SEEK_SET:
        if offset &lt; 0:
            raise ValueError(&#39;no negative offsets allowed for SEEK_SET.&#39;)
        self._cursor = offset
    elif whence == io.SEEK_CUR:
        self._cursor += offset
    elif whence == io.SEEK_END:
        self._cursor = len(self._data) + offset
    self._cursor = max(self._cursor, 0)
    self._cursor = min(self._cursor, len(self._data))
    return self._cursor</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.writelines"><code class="name flex">
<span>def <span class="ident">writelines</span></span>(<span>self, lines)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L388-L390" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def writelines(self, lines: Iterable[Iterable[int]] | Iterable[Buffer]) -&gt; None:
    for line in lines:
        self.write(line)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L392-L400" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def truncate(self, size: int | None = None) -&gt; int:
    if not isinstance(self._data, bytearray):
        raise TypeError
    if size is not None:
        if not (0 &lt;= size &lt;= len(self._data)):
            raise ValueError(&#39;invalid size value&#39;)
        self._cursor = size
    del self._data[self._cursor:]
    return self.tell()</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.write_byte"><code class="name flex">
<span>def <span class="ident">write_byte</span></span>(<span>self, byte)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L402-L420" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def write_byte(self, byte: int) -&gt; None:
    if isinstance(self._data, bytes):
        raise TypeError
    if isinstance(self._data, memoryview):
        raise NotImplementedError
    limit = self._maxlen
    cc = self._cursor
    nc = cc + 1
    if limit and nc &gt; limit:
        raise LimitExceeded(bytes((byte,)))
    try:
        if cc &lt; len(self._data):
            self._data[cc] = byte
        else:
            self._data.append(byte)
    except Exception as T:
        raise OSError(str(T)) from T
    else:
        self._cursor = nc</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, _data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L422-L484" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def write(self, _data: Buffer | Iterable[int]) -&gt; int:
    out = self._data
    end = len(out)

    if isinstance(out, memoryview):
        if out.readonly:
            raise PermissionError
        out = out.obj
    if not isinstance(out, bytearray):
        raise PermissionError

    try:
        getbuf = cast(&#39;Buffer&#39;, _data).__buffer__
    except AttributeError:
        data = cast(&#39;Iterable[int]&#39;, _data)
    else:
        data = getbuf(0)

    beginning = self._cursor
    limit = self._maxlen

    if limit is None and beginning == end:
        out[end:] = data
        self._cursor = end = len(out)
        return end - beginning
    try:
        size = len(cast(Sized, data))
    except Exception:
        it = iter(data)
        cursor = 0
        for cursor, b in enumerate(it, beginning):
            out[cursor] = b
            if cursor &gt;= end - 1:
                break
        else:
            cursor += 1
            self._cursor = cursor
            return cursor - beginning
        if limit is None:
            out[end:] = bytes(it)
        else:
            out[end:limit] = bytes(itertools.islice(it, 0, limit - end))
            try:
                b = next(it)
            except StopIteration:
                self._cursor = limit
                return limit - beginning
            else:
                rest = bytearray((b,))
                rest[1:] = it
                raise LimitExceeded(rest)
    else:
        if limit and size + beginning &gt; limit:
            raise LimitExceeded(bytes(data))
        self._cursor += size
        try:
            out[beginning:self._cursor] = data
        except Exception as T:
            self._cursor = beginning
            raise OSError(str(T)) from T
        return size
    self._cursor = end = len(out)
    return end - beginning</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.MemoryFileMethods.replay"><code class="name flex">
<span>def <span class="ident">replay</span></span>(<span>self, offset, length)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L492-L502" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def replay(self, offset: int, length: int):
    cursor = self._cursor
    if offset not in range(cursor + 1):
        raise ValueError(F&#39;The supplied delta {offset} is not in the valid range [0,{self._cursor}].&#39;)
    rep, r = divmod(length, offset)
    offset = cursor - offset
    replay = self._data[offset:offset + r]
    if rep &gt; 0:
        # While this is technically a copy, it is faster than repeated calls to write.
        replay = bytes(self._data[offset:cursor]) * rep + replay
    self.write(replay)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.structures.MemoryFile"><code class="flex name class">
<span>class <span class="ident">MemoryFile</span></span>
<span>(</span><span>data=builtins.bytearray, output=None, fileno=None, maxlen=None, name='')</span>
</code></dt>
<dd>
<section class="desc"><p>A thin wrapper around (potentially mutable) byte sequences which gives it the features of a
file-like object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L505-L506" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MemoryFile(MemoryFileMethods[T, B], io.BytesIO):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.MemoryFileMethods" href="#refinery.lib.structures.MemoryFileMethods">MemoryFileMethods</a></li>
<li>typing.Generic</li>
<li>_io.BytesIO</li>
<li>_io._BufferedIOBase</li>
<li>_io._IOBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.StructReader" href="#refinery.lib.structures.StructReader">StructReader</a></li>
<li><a title="refinery.units.formats.httpresponse.SockWrapper" href="../units/formats/httpresponse.html#refinery.units.formats.httpresponse.SockWrapper">SockWrapper</a></li>
<li><a title="refinery.units.pattern.carve_7z.MemoryFileRecorder" href="../units/pattern/carve_7z.html#refinery.units.pattern.carve_7z.MemoryFileRecorder">MemoryFileRecorder</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.structures.MemoryFileMethods" href="#refinery.lib.structures.MemoryFileMethods">MemoryFileMethods</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.structures.MemoryFileMethods.SEEK" href="#refinery.lib.structures.MemoryFileMethods.SEEK">SEEK</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.structures.order"><code class="flex name class">
<span>class <span class="ident">order</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to 'utf-8'.
errors defaults to 'strict'.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L509-L511" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class order(str, enum.Enum):
    big = &#39;&gt;&#39;
    little = &#39;&lt;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.structures.order.big"><code class="name">var <span class="ident">big</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.structures.order.little"><code class="name">var <span class="ident">little</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.structures.StructReader"><code class="flex name class">
<span>class <span class="ident">StructReader</span></span>
<span>(</span><span>data, bigendian=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An extension of a <code><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></code> which provides methods to read
structured data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L514-L855" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StructReader(MemoryFile[T, T]):
    &#34;&#34;&#34;
    An extension of a `refinery.lib.structures.MemoryFile` which provides methods to read
    structured data.
    &#34;&#34;&#34;
    __slots__ = &#39;bigendian&#39;,

    class Unaligned(RuntimeError):
        pass

    def __init__(self, data: T | StructReader[T], bigendian: bool | None = None):
        super().__init__(data)
        if bigendian is None:
            if isinstance(data, StructReader):
                bigendian = data.bigendian
            else:
                bigendian = False
        self.bigendian = bigendian

    def __enter__(self) -&gt; StructReader:
        return super().__enter__()

    @property
    @contextlib.contextmanager
    def be(self):
        self.bigendian = True
        try:
            yield self
        finally:
            self.bigendian = False

    @property
    def byteorder_format(self) -&gt; str:
        return &#39;&gt;&#39; if self.bigendian else &#39;&lt;&#39;

    @property
    def byteorder_name(self):
        return &#39;big&#39; if self.bigendian else &#39;little&#39;

    def read_exactly(self, size: int | None = None, peek: bool = False) -&gt; T:
        &#34;&#34;&#34;
        Read bytes from the underlying stream. Raises a `RuntimeError` when the stream is not currently
        byte-aligned, i.e. when `refinery.lib.structures.StructReader.bits_in_buffer` is positive. Raises
        an exception of type `refinery.lib.structures.EOF` when fewer data is available in the stream than
        requested via the `size` parameter. The remaining data can be extracted from the exception.
        Use `refinery.lib.structures.StructReader.read_bytes` to read bytes from the stream when it is
        not byte-aligned.
        &#34;&#34;&#34;
        data = self.read(size, peek)
        if size and len(data) &lt; size:
            raise EOF(size, data)
        return data

    def read_bit_field(self, *sizes: int, peek: bool = False):
        &#34;&#34;&#34;
        Read multiple integers that form a bit field. This method can be used to read bit fields without
        having to use a `refinery.lib.structures.StructReaderBits` when the bit count sums to a multiple
        of 8.
        &#34;&#34;&#34;
        data = self.read_integer(sum(sizes))
        if self.bigendian:
            sizes = sizes[::-1]
        fields = []
        for size in sizes:
            fields.append(data &amp; ~(-1 &lt;&lt; size))
            data &gt;&gt;= size
        if self.bigendian:
            fields.reverse()
        return fields

    def read_integer(
        self,
        size: int,
        peek: bool = False,
        signed: bool = False
    ) -&gt; int:
        &#34;&#34;&#34;
        Read an integer of the given size (in bytes) from the stream.
        &#34;&#34;&#34;
        nbytes, rest = divmod(size, 8)
        if rest &gt; 0:
            raise ValueError(
                F&#39;A {self.__class__.__name__} cannot read {size} bit{&#34;s&#34; * (size &gt; 1)}, only multiples of 8 are possible.&#39;)
        data = self.read(nbytes, peek)
        if len(data) &lt; nbytes:
            raise EOF(nbytes, data)
        return int.from_bytes(data, self.byteorder_name, signed=signed)

    def byte_align(self, blocksize: int = 1):
        &#34;&#34;&#34;
        Align the cursor at the given block size boundary.
        &#34;&#34;&#34;
        if mod := -self._cursor % blocksize:
            self.seekrel(mod)

    def read_bytes(self, size: int, peek: bool = False) -&gt; bytes:
        &#34;&#34;&#34;
        The method reads `size` many bytes from the underlying stream starting at the current bit.
        &#34;&#34;&#34;
        data = self.read_exactly(size, peek)
        if not isinstance(data, bytes):
            data = bytes(data)
        return data

    def read_one_struct(self, spec: str, peek=False) -&gt; UnpackType:
        item, = self.read_struct(spec, peek=peek)
        return item

    def read_struct(self, spec: str, peek=False) -&gt; list[UnpackType]:
        &#34;&#34;&#34;
        Read structured data from the stream in any format supported by the `struct` module. The `format`
        argument can be used to override the current byte ordering. If the `unwrap` parameter is `True`, a
        single unpacked value will be returned as a scalar, not as a tuple with one element.
        &#34;&#34;&#34;
        if not spec:
            raise ValueError(&#39;no format specified&#39;)
        byteorder = spec[:1]
        if byteorder in &#39;&lt;!=@&gt;&#39;:
            spec = spec[1:]
        else:
            byteorder = self.byteorder_format
        data = []
        current_cursor = self.tell()

        # reserved struct characters: xcbB?hHiIlLqQnNefdspP
        for k, part in enumerate(re.split(&#39;(\\d*[auwgk])&#39;, spec)):
            if k % 2 == 1:
                count = 1 if len(part) == 1 else int(part[:~0])
                part = part[~0]
                for _ in range(count):
                    if part == &#39;a&#39;:
                        data.append(self.read_c_string())
                    elif part == &#39;g&#39;:
                        data.append(str(self.read_guid()))
                    elif part == &#39;u&#39;:
                        data.append(self.read_w_string())
                    elif part == &#39;w&#39;:
                        data.append(codecs.decode(self.read_w_string(), &#39;utf-16le&#39;))
                    elif part == &#39;k&#39;:
                        data.append(self.read_7bit_encoded_int())
                continue
            else:
                part = F&#39;{byteorder}{part}&#39;
                data.extend(struct.unpack(part, self.read_bytes(struct.calcsize(part))))
        if peek:
            self.seekset(current_cursor)
        return data

    def read_bool_byte(self, strict=False):
        value = self.u8()
        if strict and value not in (0, 1):
            raise ValueError(F&#39;Invalid boolean byte value {value:#02x}.&#39;)
        return bool(value)

    def read_regex(
        self,
        pattern: bytes | bytearray | memoryview | re.Pattern[bytes],
        dotall: bool = True
    ):
        if isinstance(pattern, (bytes, bytearray, memoryview)):
            flags = re.DOTALL if dotall else re.NOFLAG
            pattern = re.compile(bytes(pattern), flags=flags)
        elif dotall and not re.DOTALL | pattern.flags:
            pattern = re.compile(pattern.pattern, flags=re.DOTALL)
        data = self._data
        if isinstance(data, memoryview) and not data.contiguous:
            raise NotImplementedError(&#39;Cannot perform regex-based read on non-contiguous buffer.&#39;)
        if result := pattern.match(data, self._cursor):
            self._cursor = result.end()
            return result

    def read_byte(self, peek: bool = False) -&gt; int:
        try:
            b = self._data[self._cursor]
        except IndexError:
            raise EOF(1)
        if not peek:
            self._cursor += 1
        return b

    def read_char(self, peek: bool = False) -&gt; str:
        try:
            b = self._data[self._cursor]
        except IndexError:
            raise EOF(1)
        if not peek:
            self._cursor += 1
        return chr(b)

    def u8fast(self):
        c = self._cursor
        b = self._data[c]
        self._cursor = c + 1
        return b

    u8 = read_byte

    def i8(self, peek: bool = False) -&gt; int:
        return signed(self.u8(peek), 8)

    def u16(self, peek: bool = False) -&gt; int:
        return self.read_integer(16, peek, signed=False)

    def u32(self, peek: bool = False) -&gt; int:
        return self.read_integer(32, peek, signed=False)

    def u64(self, peek: bool = False) -&gt; int:
        return self.read_integer(64, peek, signed=False)

    def i16(self, peek: bool = False) -&gt; int:
        return self.read_integer(16, peek, signed=True)

    def i32(self, peek: bool = False) -&gt; int:
        return self.read_integer(32, peek, signed=True)

    def i64(self, peek: bool = False) -&gt; int:
        return self.read_integer(64, peek, signed=True)

    def f32(self, peek: bool = False) -&gt; float:
        return cast(float, self.read_one_struct(&#39;f&#39;, peek=peek))

    def f64(self, peek: bool = False) -&gt; float:
        return cast(float, self.read_one_struct(&#39;d&#39;, peek=peek))

    def read_terminated_array(self, terminator: bytes, alignment: int = 1) -&gt; T:
        buf = self.getvalue()
        pos = self.tell()
        end = pos - 1
        n = len(terminator)
        while True:
            end = buffer_offset(buf, terminator, end + 1)
            if end &lt; 0 or not (end - pos) % alignment:
                break
        if end &gt;= pos:
            result = self.read_exactly(end - pos)
            self.skip(n)
            return result
        raise EOF(len(buf) - pos + n)

    def read_guid(self) -&gt; UUID:
        return UUID(bytes_le=self.read_bytes(16))

    def read_uuid(self) -&gt; UUID:
        return UUID(bytes=self.read_bytes(16))

    @overload
    def read_c_string(self) -&gt; T:
        ...

    @overload
    def read_c_string(self, encoding: str) -&gt; str:
        ...

    def read_c_string(self, encoding=None) -&gt; str | T:
        data = self.read_terminated_array(B&#39;\0&#39;)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    @overload
    def read_w_string(self) -&gt; T:
        ...

    @overload
    def read_w_string(self, encoding: str) -&gt; str:
        ...

    def read_w_string(self, encoding=None) -&gt; str | T:
        data = self.read_terminated_array(B&#39;\0\0&#39;, 2)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    def read_length_prefixed_ascii(self, prefix_size: int = 32):
        return self.read_length_prefixed(prefix_size, &#39;latin1&#39;)

    def read_length_prefixed_utf8(self, prefix_size: int = 32):
        return self.read_length_prefixed(prefix_size, &#39;utf8&#39;)

    def read_length_prefixed_utf16(self, prefix_size: int = 32, bytecount: bool = False):
        block_size = 1 if bytecount else 2
        return self.read_length_prefixed(prefix_size, &#39;utf-16le&#39;, block_size)

    @overload
    def read_length_prefixed(self, *, encoding: str, prefix_size: int = 32, block_size: int = 1) -&gt; str:
        ...

    @overload
    def read_length_prefixed(self, prefix_size: int, encoding: str, block_size: int = 1) -&gt; str:
        ...

    @overload
    def read_length_prefixed(self, *, prefix_size: int = 32, block_size: int = 1) -&gt; T:
        ...

    @overload
    def read_length_prefixed(self, prefix_size: int, *, block_size: int = 1) -&gt; T:
        ...

    def read_length_prefixed(self, prefix_size: int = 32, encoding: str | None = None, block_size: int = 1) -&gt; T | str:
        prefix = self.read_integer(prefix_size) * block_size
        data = self.read(prefix)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    def read_7bit_encoded_int(self, max_bits: int = 0, bigendian: bool | None = None) -&gt; int:
        value = 0
        shift = 0
        if bigendian is None:
            bigendian = self.bigendian
        while True:
            b = self.u8()
            if bigendian:
                value &lt;&lt;= 7
                value |= (b &amp; 0x7F)
            else:
                value |= (b &amp; 0x7F) &lt;&lt; shift
            if not b &amp; 0x80:
                return value
            if (shift := shift + 7) &gt; max_bits &gt; 0:
                raise OverflowError(&#39;Maximum bits were exceeded by encoded integer.&#39;)

    def read_bits(self, nbits: int) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        This method returns the bits of `refinery.lib.structures.StructReader.read_integer` one by one.
        &#34;&#34;&#34;
        chunk = self.read_integer(nbits)
        it = range(nbits - 1, -1, -1) if self.bigendian else range(nbits)
        for k in it:
            yield chunk &gt;&gt; k &amp; 1

    def read_flags(self, nbits: int, reverse=False) -&gt; Iterable[bool]:
        &#34;&#34;&#34;
        Identical to `refinery.lib.structures.StructReader.read_bits` with every bit value cast to a boolean.
        &#34;&#34;&#34;
        bits = self.read_bits(nbits)
        if reverse:
            bits = list(bits)
            bits.reverse()
        for bit in bits:
            yield bool(bit)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></li>
<li><a title="refinery.lib.structures.MemoryFileMethods" href="#refinery.lib.structures.MemoryFileMethods">MemoryFileMethods</a></li>
<li>typing.Generic</li>
<li>_io.BytesIO</li>
<li>_io._BufferedIOBase</li>
<li>_io._IOBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.asn1.reader.ASN1Reader" href="asn1/reader.html#refinery.lib.asn1.reader.ASN1Reader">ASN1Reader</a></li>
<li><a title="refinery.lib.dotnet.header.DotNetStructReader" href="dotnet/header.html#refinery.lib.dotnet.header.DotNetStructReader">DotNetStructReader</a></li>
<li><a title="refinery.lib.py.Marshal" href="py.html#refinery.lib.py.Marshal">Marshal</a></li>
<li><a title="refinery.lib.structures.StructReaderBits" href="#refinery.lib.structures.StructReaderBits">StructReaderBits</a></li>
<li><a title="refinery.units.formats.a3x.A3xReader" href="../units/formats/a3x.html#refinery.units.formats.a3x.A3xReader">A3xReader</a></li>
<li><a title="refinery.units.formats.archive.xtiss.ISSReader" href="../units/formats/archive/xtiss.html#refinery.units.formats.archive.xtiss.ISSReader">ISSReader</a></li>
<li><a title="refinery.units.formats.archive.xtnode.JSONReader" href="../units/formats/archive/xtnode.html#refinery.units.formats.archive.xtnode.JSONReader">JSONReader</a></li>
<li><a title="refinery.units.formats.cbor.CBORReader" href="../units/formats/cbor.html#refinery.units.formats.cbor.CBORReader">CBORReader</a></li>
<li><a title="refinery.units.formats.pbuf.ProtoBufReader" href="../units/formats/pbuf.html#refinery.units.formats.pbuf.ProtoBufReader">ProtoBufReader</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.structures.StructReader.Unaligned"><code class="name">var <span class="ident">Unaligned</span></code></dt>
<dd>
<section class="desc"><p>Unspecified run-time error.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.structures.StructReader.be"><code class="name">var <span class="ident">be</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L536-L543" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
@contextlib.contextmanager
def be(self):
    self.bigendian = True
    try:
        yield self
    finally:
        self.bigendian = False</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.byteorder_format"><code class="name">var <span class="ident">byteorder_format</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L545-L547" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def byteorder_format(self) -&gt; str:
    return &#39;&gt;&#39; if self.bigendian else &#39;&lt;&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.byteorder_name"><code class="name">var <span class="ident">byteorder_name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L549-L551" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def byteorder_name(self):
    return &#39;big&#39; if self.bigendian else &#39;little&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.bigendian"><code class="name">var <span class="ident">bigendian</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L514-L855" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StructReader(MemoryFile[T, T]):
    &#34;&#34;&#34;
    An extension of a `refinery.lib.structures.MemoryFile` which provides methods to read
    structured data.
    &#34;&#34;&#34;
    __slots__ = &#39;bigendian&#39;,

    class Unaligned(RuntimeError):
        pass

    def __init__(self, data: T | StructReader[T], bigendian: bool | None = None):
        super().__init__(data)
        if bigendian is None:
            if isinstance(data, StructReader):
                bigendian = data.bigendian
            else:
                bigendian = False
        self.bigendian = bigendian

    def __enter__(self) -&gt; StructReader:
        return super().__enter__()

    @property
    @contextlib.contextmanager
    def be(self):
        self.bigendian = True
        try:
            yield self
        finally:
            self.bigendian = False

    @property
    def byteorder_format(self) -&gt; str:
        return &#39;&gt;&#39; if self.bigendian else &#39;&lt;&#39;

    @property
    def byteorder_name(self):
        return &#39;big&#39; if self.bigendian else &#39;little&#39;

    def read_exactly(self, size: int | None = None, peek: bool = False) -&gt; T:
        &#34;&#34;&#34;
        Read bytes from the underlying stream. Raises a `RuntimeError` when the stream is not currently
        byte-aligned, i.e. when `refinery.lib.structures.StructReader.bits_in_buffer` is positive. Raises
        an exception of type `refinery.lib.structures.EOF` when fewer data is available in the stream than
        requested via the `size` parameter. The remaining data can be extracted from the exception.
        Use `refinery.lib.structures.StructReader.read_bytes` to read bytes from the stream when it is
        not byte-aligned.
        &#34;&#34;&#34;
        data = self.read(size, peek)
        if size and len(data) &lt; size:
            raise EOF(size, data)
        return data

    def read_bit_field(self, *sizes: int, peek: bool = False):
        &#34;&#34;&#34;
        Read multiple integers that form a bit field. This method can be used to read bit fields without
        having to use a `refinery.lib.structures.StructReaderBits` when the bit count sums to a multiple
        of 8.
        &#34;&#34;&#34;
        data = self.read_integer(sum(sizes))
        if self.bigendian:
            sizes = sizes[::-1]
        fields = []
        for size in sizes:
            fields.append(data &amp; ~(-1 &lt;&lt; size))
            data &gt;&gt;= size
        if self.bigendian:
            fields.reverse()
        return fields

    def read_integer(
        self,
        size: int,
        peek: bool = False,
        signed: bool = False
    ) -&gt; int:
        &#34;&#34;&#34;
        Read an integer of the given size (in bytes) from the stream.
        &#34;&#34;&#34;
        nbytes, rest = divmod(size, 8)
        if rest &gt; 0:
            raise ValueError(
                F&#39;A {self.__class__.__name__} cannot read {size} bit{&#34;s&#34; * (size &gt; 1)}, only multiples of 8 are possible.&#39;)
        data = self.read(nbytes, peek)
        if len(data) &lt; nbytes:
            raise EOF(nbytes, data)
        return int.from_bytes(data, self.byteorder_name, signed=signed)

    def byte_align(self, blocksize: int = 1):
        &#34;&#34;&#34;
        Align the cursor at the given block size boundary.
        &#34;&#34;&#34;
        if mod := -self._cursor % blocksize:
            self.seekrel(mod)

    def read_bytes(self, size: int, peek: bool = False) -&gt; bytes:
        &#34;&#34;&#34;
        The method reads `size` many bytes from the underlying stream starting at the current bit.
        &#34;&#34;&#34;
        data = self.read_exactly(size, peek)
        if not isinstance(data, bytes):
            data = bytes(data)
        return data

    def read_one_struct(self, spec: str, peek=False) -&gt; UnpackType:
        item, = self.read_struct(spec, peek=peek)
        return item

    def read_struct(self, spec: str, peek=False) -&gt; list[UnpackType]:
        &#34;&#34;&#34;
        Read structured data from the stream in any format supported by the `struct` module. The `format`
        argument can be used to override the current byte ordering. If the `unwrap` parameter is `True`, a
        single unpacked value will be returned as a scalar, not as a tuple with one element.
        &#34;&#34;&#34;
        if not spec:
            raise ValueError(&#39;no format specified&#39;)
        byteorder = spec[:1]
        if byteorder in &#39;&lt;!=@&gt;&#39;:
            spec = spec[1:]
        else:
            byteorder = self.byteorder_format
        data = []
        current_cursor = self.tell()

        # reserved struct characters: xcbB?hHiIlLqQnNefdspP
        for k, part in enumerate(re.split(&#39;(\\d*[auwgk])&#39;, spec)):
            if k % 2 == 1:
                count = 1 if len(part) == 1 else int(part[:~0])
                part = part[~0]
                for _ in range(count):
                    if part == &#39;a&#39;:
                        data.append(self.read_c_string())
                    elif part == &#39;g&#39;:
                        data.append(str(self.read_guid()))
                    elif part == &#39;u&#39;:
                        data.append(self.read_w_string())
                    elif part == &#39;w&#39;:
                        data.append(codecs.decode(self.read_w_string(), &#39;utf-16le&#39;))
                    elif part == &#39;k&#39;:
                        data.append(self.read_7bit_encoded_int())
                continue
            else:
                part = F&#39;{byteorder}{part}&#39;
                data.extend(struct.unpack(part, self.read_bytes(struct.calcsize(part))))
        if peek:
            self.seekset(current_cursor)
        return data

    def read_bool_byte(self, strict=False):
        value = self.u8()
        if strict and value not in (0, 1):
            raise ValueError(F&#39;Invalid boolean byte value {value:#02x}.&#39;)
        return bool(value)

    def read_regex(
        self,
        pattern: bytes | bytearray | memoryview | re.Pattern[bytes],
        dotall: bool = True
    ):
        if isinstance(pattern, (bytes, bytearray, memoryview)):
            flags = re.DOTALL if dotall else re.NOFLAG
            pattern = re.compile(bytes(pattern), flags=flags)
        elif dotall and not re.DOTALL | pattern.flags:
            pattern = re.compile(pattern.pattern, flags=re.DOTALL)
        data = self._data
        if isinstance(data, memoryview) and not data.contiguous:
            raise NotImplementedError(&#39;Cannot perform regex-based read on non-contiguous buffer.&#39;)
        if result := pattern.match(data, self._cursor):
            self._cursor = result.end()
            return result

    def read_byte(self, peek: bool = False) -&gt; int:
        try:
            b = self._data[self._cursor]
        except IndexError:
            raise EOF(1)
        if not peek:
            self._cursor += 1
        return b

    def read_char(self, peek: bool = False) -&gt; str:
        try:
            b = self._data[self._cursor]
        except IndexError:
            raise EOF(1)
        if not peek:
            self._cursor += 1
        return chr(b)

    def u8fast(self):
        c = self._cursor
        b = self._data[c]
        self._cursor = c + 1
        return b

    u8 = read_byte

    def i8(self, peek: bool = False) -&gt; int:
        return signed(self.u8(peek), 8)

    def u16(self, peek: bool = False) -&gt; int:
        return self.read_integer(16, peek, signed=False)

    def u32(self, peek: bool = False) -&gt; int:
        return self.read_integer(32, peek, signed=False)

    def u64(self, peek: bool = False) -&gt; int:
        return self.read_integer(64, peek, signed=False)

    def i16(self, peek: bool = False) -&gt; int:
        return self.read_integer(16, peek, signed=True)

    def i32(self, peek: bool = False) -&gt; int:
        return self.read_integer(32, peek, signed=True)

    def i64(self, peek: bool = False) -&gt; int:
        return self.read_integer(64, peek, signed=True)

    def f32(self, peek: bool = False) -&gt; float:
        return cast(float, self.read_one_struct(&#39;f&#39;, peek=peek))

    def f64(self, peek: bool = False) -&gt; float:
        return cast(float, self.read_one_struct(&#39;d&#39;, peek=peek))

    def read_terminated_array(self, terminator: bytes, alignment: int = 1) -&gt; T:
        buf = self.getvalue()
        pos = self.tell()
        end = pos - 1
        n = len(terminator)
        while True:
            end = buffer_offset(buf, terminator, end + 1)
            if end &lt; 0 or not (end - pos) % alignment:
                break
        if end &gt;= pos:
            result = self.read_exactly(end - pos)
            self.skip(n)
            return result
        raise EOF(len(buf) - pos + n)

    def read_guid(self) -&gt; UUID:
        return UUID(bytes_le=self.read_bytes(16))

    def read_uuid(self) -&gt; UUID:
        return UUID(bytes=self.read_bytes(16))

    @overload
    def read_c_string(self) -&gt; T:
        ...

    @overload
    def read_c_string(self, encoding: str) -&gt; str:
        ...

    def read_c_string(self, encoding=None) -&gt; str | T:
        data = self.read_terminated_array(B&#39;\0&#39;)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    @overload
    def read_w_string(self) -&gt; T:
        ...

    @overload
    def read_w_string(self, encoding: str) -&gt; str:
        ...

    def read_w_string(self, encoding=None) -&gt; str | T:
        data = self.read_terminated_array(B&#39;\0\0&#39;, 2)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    def read_length_prefixed_ascii(self, prefix_size: int = 32):
        return self.read_length_prefixed(prefix_size, &#39;latin1&#39;)

    def read_length_prefixed_utf8(self, prefix_size: int = 32):
        return self.read_length_prefixed(prefix_size, &#39;utf8&#39;)

    def read_length_prefixed_utf16(self, prefix_size: int = 32, bytecount: bool = False):
        block_size = 1 if bytecount else 2
        return self.read_length_prefixed(prefix_size, &#39;utf-16le&#39;, block_size)

    @overload
    def read_length_prefixed(self, *, encoding: str, prefix_size: int = 32, block_size: int = 1) -&gt; str:
        ...

    @overload
    def read_length_prefixed(self, prefix_size: int, encoding: str, block_size: int = 1) -&gt; str:
        ...

    @overload
    def read_length_prefixed(self, *, prefix_size: int = 32, block_size: int = 1) -&gt; T:
        ...

    @overload
    def read_length_prefixed(self, prefix_size: int, *, block_size: int = 1) -&gt; T:
        ...

    def read_length_prefixed(self, prefix_size: int = 32, encoding: str | None = None, block_size: int = 1) -&gt; T | str:
        prefix = self.read_integer(prefix_size) * block_size
        data = self.read(prefix)
        if encoding is not None:
            data = codecs.decode(data, encoding)
        return data

    def read_7bit_encoded_int(self, max_bits: int = 0, bigendian: bool | None = None) -&gt; int:
        value = 0
        shift = 0
        if bigendian is None:
            bigendian = self.bigendian
        while True:
            b = self.u8()
            if bigendian:
                value &lt;&lt;= 7
                value |= (b &amp; 0x7F)
            else:
                value |= (b &amp; 0x7F) &lt;&lt; shift
            if not b &amp; 0x80:
                return value
            if (shift := shift + 7) &gt; max_bits &gt; 0:
                raise OverflowError(&#39;Maximum bits were exceeded by encoded integer.&#39;)

    def read_bits(self, nbits: int) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        This method returns the bits of `refinery.lib.structures.StructReader.read_integer` one by one.
        &#34;&#34;&#34;
        chunk = self.read_integer(nbits)
        it = range(nbits - 1, -1, -1) if self.bigendian else range(nbits)
        for k in it:
            yield chunk &gt;&gt; k &amp; 1

    def read_flags(self, nbits: int, reverse=False) -&gt; Iterable[bool]:
        &#34;&#34;&#34;
        Identical to `refinery.lib.structures.StructReader.read_bits` with every bit value cast to a boolean.
        &#34;&#34;&#34;
        bits = self.read_bits(nbits)
        if reverse:
            bits = list(bits)
            bits.reverse()
        for bit in bits:
            yield bool(bit)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.structures.StructReader.read_exactly"><code class="name flex">
<span>def <span class="ident">read_exactly</span></span>(<span>self, size=None, peek=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Read bytes from the underlying stream. Raises a <code>RuntimeError</code> when the stream is not currently
byte-aligned, i.e. when <code>refinery.lib.structures.StructReader.bits_in_buffer</code> is positive. Raises
an exception of type <code><a title="refinery.lib.structures.EOF" href="#refinery.lib.structures.EOF">EOF</a></code> when fewer data is available in the stream than
requested via the <code>size</code> parameter. The remaining data can be extracted from the exception.
Use <code><a title="refinery.lib.structures.StructReader.read_bytes" href="#refinery.lib.structures.StructReader.read_bytes">StructReader.read_bytes()</a></code> to read bytes from the stream when it is
not byte-aligned.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L553-L565" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_exactly(self, size: int | None = None, peek: bool = False) -&gt; T:
    &#34;&#34;&#34;
    Read bytes from the underlying stream. Raises a `RuntimeError` when the stream is not currently
    byte-aligned, i.e. when `refinery.lib.structures.StructReader.bits_in_buffer` is positive. Raises
    an exception of type `refinery.lib.structures.EOF` when fewer data is available in the stream than
    requested via the `size` parameter. The remaining data can be extracted from the exception.
    Use `refinery.lib.structures.StructReader.read_bytes` to read bytes from the stream when it is
    not byte-aligned.
    &#34;&#34;&#34;
    data = self.read(size, peek)
    if size and len(data) &lt; size:
        raise EOF(size, data)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_bit_field"><code class="name flex">
<span>def <span class="ident">read_bit_field</span></span>(<span>self, *sizes, peek=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Read multiple integers that form a bit field. This method can be used to read bit fields without
having to use a <code><a title="refinery.lib.structures.StructReaderBits" href="#refinery.lib.structures.StructReaderBits">StructReaderBits</a></code> when the bit count sums to a multiple
of 8.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L567-L582" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_bit_field(self, *sizes: int, peek: bool = False):
    &#34;&#34;&#34;
    Read multiple integers that form a bit field. This method can be used to read bit fields without
    having to use a `refinery.lib.structures.StructReaderBits` when the bit count sums to a multiple
    of 8.
    &#34;&#34;&#34;
    data = self.read_integer(sum(sizes))
    if self.bigendian:
        sizes = sizes[::-1]
    fields = []
    for size in sizes:
        fields.append(data &amp; ~(-1 &lt;&lt; size))
        data &gt;&gt;= size
    if self.bigendian:
        fields.reverse()
    return fields</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_integer"><code class="name flex">
<span>def <span class="ident">read_integer</span></span>(<span>self, size, peek=False, signed=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Read an integer of the given size (in bytes) from the stream.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L584-L600" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_integer(
    self,
    size: int,
    peek: bool = False,
    signed: bool = False
) -&gt; int:
    &#34;&#34;&#34;
    Read an integer of the given size (in bytes) from the stream.
    &#34;&#34;&#34;
    nbytes, rest = divmod(size, 8)
    if rest &gt; 0:
        raise ValueError(
            F&#39;A {self.__class__.__name__} cannot read {size} bit{&#34;s&#34; * (size &gt; 1)}, only multiples of 8 are possible.&#39;)
    data = self.read(nbytes, peek)
    if len(data) &lt; nbytes:
        raise EOF(nbytes, data)
    return int.from_bytes(data, self.byteorder_name, signed=signed)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.byte_align"><code class="name flex">
<span>def <span class="ident">byte_align</span></span>(<span>self, blocksize=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Align the cursor at the given block size boundary.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L602-L607" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def byte_align(self, blocksize: int = 1):
    &#34;&#34;&#34;
    Align the cursor at the given block size boundary.
    &#34;&#34;&#34;
    if mod := -self._cursor % blocksize:
        self.seekrel(mod)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_bytes"><code class="name flex">
<span>def <span class="ident">read_bytes</span></span>(<span>self, size, peek=False)</span>
</code></dt>
<dd>
<section class="desc"><p>The method reads <code>size</code> many bytes from the underlying stream starting at the current bit.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L609-L616" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_bytes(self, size: int, peek: bool = False) -&gt; bytes:
    &#34;&#34;&#34;
    The method reads `size` many bytes from the underlying stream starting at the current bit.
    &#34;&#34;&#34;
    data = self.read_exactly(size, peek)
    if not isinstance(data, bytes):
        data = bytes(data)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_one_struct"><code class="name flex">
<span>def <span class="ident">read_one_struct</span></span>(<span>self, spec, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L618-L620" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_one_struct(self, spec: str, peek=False) -&gt; UnpackType:
    item, = self.read_struct(spec, peek=peek)
    return item</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_struct"><code class="name flex">
<span>def <span class="ident">read_struct</span></span>(<span>self, spec, peek=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Read structured data from the stream in any format supported by the <code>struct</code> module. The <code>format</code>
argument can be used to override the current byte ordering. If the <code>unwrap</code> parameter is <code>True</code>, a
single unpacked value will be returned as a scalar, not as a tuple with one element.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L622-L660" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_struct(self, spec: str, peek=False) -&gt; list[UnpackType]:
    &#34;&#34;&#34;
    Read structured data from the stream in any format supported by the `struct` module. The `format`
    argument can be used to override the current byte ordering. If the `unwrap` parameter is `True`, a
    single unpacked value will be returned as a scalar, not as a tuple with one element.
    &#34;&#34;&#34;
    if not spec:
        raise ValueError(&#39;no format specified&#39;)
    byteorder = spec[:1]
    if byteorder in &#39;&lt;!=@&gt;&#39;:
        spec = spec[1:]
    else:
        byteorder = self.byteorder_format
    data = []
    current_cursor = self.tell()

    # reserved struct characters: xcbB?hHiIlLqQnNefdspP
    for k, part in enumerate(re.split(&#39;(\\d*[auwgk])&#39;, spec)):
        if k % 2 == 1:
            count = 1 if len(part) == 1 else int(part[:~0])
            part = part[~0]
            for _ in range(count):
                if part == &#39;a&#39;:
                    data.append(self.read_c_string())
                elif part == &#39;g&#39;:
                    data.append(str(self.read_guid()))
                elif part == &#39;u&#39;:
                    data.append(self.read_w_string())
                elif part == &#39;w&#39;:
                    data.append(codecs.decode(self.read_w_string(), &#39;utf-16le&#39;))
                elif part == &#39;k&#39;:
                    data.append(self.read_7bit_encoded_int())
            continue
        else:
            part = F&#39;{byteorder}{part}&#39;
            data.extend(struct.unpack(part, self.read_bytes(struct.calcsize(part))))
    if peek:
        self.seekset(current_cursor)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_bool_byte"><code class="name flex">
<span>def <span class="ident">read_bool_byte</span></span>(<span>self, strict=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L662-L666" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_bool_byte(self, strict=False):
    value = self.u8()
    if strict and value not in (0, 1):
        raise ValueError(F&#39;Invalid boolean byte value {value:#02x}.&#39;)
    return bool(value)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_regex"><code class="name flex">
<span>def <span class="ident">read_regex</span></span>(<span>self, pattern, dotall=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L668-L683" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_regex(
    self,
    pattern: bytes | bytearray | memoryview | re.Pattern[bytes],
    dotall: bool = True
):
    if isinstance(pattern, (bytes, bytearray, memoryview)):
        flags = re.DOTALL if dotall else re.NOFLAG
        pattern = re.compile(bytes(pattern), flags=flags)
    elif dotall and not re.DOTALL | pattern.flags:
        pattern = re.compile(pattern.pattern, flags=re.DOTALL)
    data = self._data
    if isinstance(data, memoryview) and not data.contiguous:
        raise NotImplementedError(&#39;Cannot perform regex-based read on non-contiguous buffer.&#39;)
    if result := pattern.match(data, self._cursor):
        self._cursor = result.end()
        return result</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_byte"><code class="name flex">
<span>def <span class="ident">read_byte</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L685-L692" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_byte(self, peek: bool = False) -&gt; int:
    try:
        b = self._data[self._cursor]
    except IndexError:
        raise EOF(1)
    if not peek:
        self._cursor += 1
    return b</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_char"><code class="name flex">
<span>def <span class="ident">read_char</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L694-L701" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_char(self, peek: bool = False) -&gt; str:
    try:
        b = self._data[self._cursor]
    except IndexError:
        raise EOF(1)
    if not peek:
        self._cursor += 1
    return chr(b)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.u8fast"><code class="name flex">
<span>def <span class="ident">u8fast</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L703-L707" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def u8fast(self):
    c = self._cursor
    b = self._data[c]
    self._cursor = c + 1
    return b</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.u8"><code class="name flex">
<span>def <span class="ident">u8</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L685-L692" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_byte(self, peek: bool = False) -&gt; int:
    try:
        b = self._data[self._cursor]
    except IndexError:
        raise EOF(1)
    if not peek:
        self._cursor += 1
    return b</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.i8"><code class="name flex">
<span>def <span class="ident">i8</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L711-L712" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def i8(self, peek: bool = False) -&gt; int:
    return signed(self.u8(peek), 8)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.u16"><code class="name flex">
<span>def <span class="ident">u16</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L714-L715" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def u16(self, peek: bool = False) -&gt; int:
    return self.read_integer(16, peek, signed=False)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.u32"><code class="name flex">
<span>def <span class="ident">u32</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L717-L718" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def u32(self, peek: bool = False) -&gt; int:
    return self.read_integer(32, peek, signed=False)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.u64"><code class="name flex">
<span>def <span class="ident">u64</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L720-L721" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def u64(self, peek: bool = False) -&gt; int:
    return self.read_integer(64, peek, signed=False)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.i16"><code class="name flex">
<span>def <span class="ident">i16</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L723-L724" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def i16(self, peek: bool = False) -&gt; int:
    return self.read_integer(16, peek, signed=True)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.i32"><code class="name flex">
<span>def <span class="ident">i32</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L726-L727" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def i32(self, peek: bool = False) -&gt; int:
    return self.read_integer(32, peek, signed=True)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.i64"><code class="name flex">
<span>def <span class="ident">i64</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L729-L730" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def i64(self, peek: bool = False) -&gt; int:
    return self.read_integer(64, peek, signed=True)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.f32"><code class="name flex">
<span>def <span class="ident">f32</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L732-L733" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def f32(self, peek: bool = False) -&gt; float:
    return cast(float, self.read_one_struct(&#39;f&#39;, peek=peek))</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.f64"><code class="name flex">
<span>def <span class="ident">f64</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L735-L736" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def f64(self, peek: bool = False) -&gt; float:
    return cast(float, self.read_one_struct(&#39;d&#39;, peek=peek))</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_terminated_array"><code class="name flex">
<span>def <span class="ident">read_terminated_array</span></span>(<span>self, terminator, alignment=1)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L738-L751" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_terminated_array(self, terminator: bytes, alignment: int = 1) -&gt; T:
    buf = self.getvalue()
    pos = self.tell()
    end = pos - 1
    n = len(terminator)
    while True:
        end = buffer_offset(buf, terminator, end + 1)
        if end &lt; 0 or not (end - pos) % alignment:
            break
    if end &gt;= pos:
        result = self.read_exactly(end - pos)
        self.skip(n)
        return result
    raise EOF(len(buf) - pos + n)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_guid"><code class="name flex">
<span>def <span class="ident">read_guid</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L753-L754" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_guid(self) -&gt; UUID:
    return UUID(bytes_le=self.read_bytes(16))</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_uuid"><code class="name flex">
<span>def <span class="ident">read_uuid</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L756-L757" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_uuid(self) -&gt; UUID:
    return UUID(bytes=self.read_bytes(16))</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_c_string"><code class="name flex">
<span>def <span class="ident">read_c_string</span></span>(<span>self, encoding=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L767-L771" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_c_string(self, encoding=None) -&gt; str | T:
    data = self.read_terminated_array(B&#39;\0&#39;)
    if encoding is not None:
        data = codecs.decode(data, encoding)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_w_string"><code class="name flex">
<span>def <span class="ident">read_w_string</span></span>(<span>self, encoding=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L781-L785" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_w_string(self, encoding=None) -&gt; str | T:
    data = self.read_terminated_array(B&#39;\0\0&#39;, 2)
    if encoding is not None:
        data = codecs.decode(data, encoding)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_length_prefixed_ascii"><code class="name flex">
<span>def <span class="ident">read_length_prefixed_ascii</span></span>(<span>self, prefix_size=32)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L787-L788" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_length_prefixed_ascii(self, prefix_size: int = 32):
    return self.read_length_prefixed(prefix_size, &#39;latin1&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_length_prefixed_utf8"><code class="name flex">
<span>def <span class="ident">read_length_prefixed_utf8</span></span>(<span>self, prefix_size=32)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L790-L791" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_length_prefixed_utf8(self, prefix_size: int = 32):
    return self.read_length_prefixed(prefix_size, &#39;utf8&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_length_prefixed_utf16"><code class="name flex">
<span>def <span class="ident">read_length_prefixed_utf16</span></span>(<span>self, prefix_size=32, bytecount=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L793-L795" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_length_prefixed_utf16(self, prefix_size: int = 32, bytecount: bool = False):
    block_size = 1 if bytecount else 2
    return self.read_length_prefixed(prefix_size, &#39;utf-16le&#39;, block_size)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_length_prefixed"><code class="name flex">
<span>def <span class="ident">read_length_prefixed</span></span>(<span>self, prefix_size=32, encoding=None, block_size=1)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L813-L818" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_length_prefixed(self, prefix_size: int = 32, encoding: str | None = None, block_size: int = 1) -&gt; T | str:
    prefix = self.read_integer(prefix_size) * block_size
    data = self.read(prefix)
    if encoding is not None:
        data = codecs.decode(data, encoding)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_7bit_encoded_int"><code class="name flex">
<span>def <span class="ident">read_7bit_encoded_int</span></span>(<span>self, max_bits=0, bigendian=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L820-L835" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_7bit_encoded_int(self, max_bits: int = 0, bigendian: bool | None = None) -&gt; int:
    value = 0
    shift = 0
    if bigendian is None:
        bigendian = self.bigendian
    while True:
        b = self.u8()
        if bigendian:
            value &lt;&lt;= 7
            value |= (b &amp; 0x7F)
        else:
            value |= (b &amp; 0x7F) &lt;&lt; shift
        if not b &amp; 0x80:
            return value
        if (shift := shift + 7) &gt; max_bits &gt; 0:
            raise OverflowError(&#39;Maximum bits were exceeded by encoded integer.&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_bits"><code class="name flex">
<span>def <span class="ident">read_bits</span></span>(<span>self, nbits)</span>
</code></dt>
<dd>
<section class="desc"><p>This method returns the bits of <code><a title="refinery.lib.structures.StructReader.read_integer" href="#refinery.lib.structures.StructReader.read_integer">StructReader.read_integer()</a></code> one by one.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L837-L844" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_bits(self, nbits: int) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    This method returns the bits of `refinery.lib.structures.StructReader.read_integer` one by one.
    &#34;&#34;&#34;
    chunk = self.read_integer(nbits)
    it = range(nbits - 1, -1, -1) if self.bigendian else range(nbits)
    for k in it:
        yield chunk &gt;&gt; k &amp; 1</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReader.read_flags"><code class="name flex">
<span>def <span class="ident">read_flags</span></span>(<span>self, nbits, reverse=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Identical to <code><a title="refinery.lib.structures.StructReader.read_bits" href="#refinery.lib.structures.StructReader.read_bits">StructReader.read_bits()</a></code> with every bit value cast to a boolean.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L846-L855" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_flags(self, nbits: int, reverse=False) -&gt; Iterable[bool]:
    &#34;&#34;&#34;
    Identical to `refinery.lib.structures.StructReader.read_bits` with every bit value cast to a boolean.
    &#34;&#34;&#34;
    bits = self.read_bits(nbits)
    if reverse:
        bits = list(bits)
        bits.reverse()
    for bit in bits:
        yield bool(bit)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.structures.MemoryFile.SEEK" href="#refinery.lib.structures.MemoryFileMethods.SEEK">SEEK</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.structures.StructReaderBits"><code class="flex name class">
<span>class <span class="ident">StructReaderBits</span></span>
<span>(</span><span>data, bigendian=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An extension of a <code><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></code> which provides methods to read
structured data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L858-L986" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StructReaderBits(StructReader[T]):
    __slots__ = &#39;_bbits&#39;, &#39;_nbits&#39;

    def __init__(self, data: T | StructReader[T], bigendian: bool | None = None):
        super().__init__(data, bigendian)
        if isinstance(data, StructReaderBits):
            self._bbits = data._bbits
            self._nbits = data._nbits
        else:
            self._bbits = 0
            self._nbits = 0

    @property
    def remaining_bits(self) -&gt; int:
        return 8 * self.remaining_bytes + self._nbits

    @property
    def bits_in_buffer(self) -&gt; int:
        &#34;&#34;&#34;
        This property is `True` if and only if there are currently no bits still waiting in the internal
        bit buffer.
        &#34;&#34;&#34;
        return self._nbits

    def read_bytes(self, size: int, peek: bool = False) -&gt; bytes:
        &#34;&#34;&#34;
        The method reads `size` many bytes from the underlying stream starting at the current bit.
        &#34;&#34;&#34;
        if self.bits_in_buffer:
            return self.read_integer(size * 8, peek).to_bytes(size, self.byteorder_name)
        return super().read_bytes(size, peek)

    def byte_align(self, blocksize: int = 1):
        &#34;&#34;&#34;
        This method clears the internal bit buffer and moves the cursor to the next byte. It returns a
        tuple containing the size and contents of the bit buffer.
        &#34;&#34;&#34;
        self._nbits = 0
        self._bbits = 0
        super().byte_align(blocksize)

    def read_exactly(self, size: int | None = None, peek: bool = False) -&gt; T:
        if self.bits_in_buffer:
            raise StructReader.Unaligned(&#39;The bit buffer is not empty.&#39;)
        return super().read_exactly(size, peek)

    def seek(self, offset, whence=io.SEEK_SET) -&gt; int:
        self._bbits = 0
        self._nbits = 0
        return super().seek(offset, whence)

    def read_integer(
        self,
        size: int | None = None,
        peek: bool = False,
        signed: bool = False,
    ) -&gt; int:
        &#34;&#34;&#34;
        Read `size` many bits from the underlying stream as an integer.
        &#34;&#34;&#34;
        if size is None:
            size = self.remaining_bits
        if size &lt; self._nbits:
            new_count = self._nbits - size
            if self.bigendian:
                result = self._bbits &gt;&gt; new_count
                if not peek:
                    self._bbits ^= result &lt;&lt; new_count
            else:
                result = self._bbits &amp; 2 ** size - 1
                if not peek:
                    self._bbits &gt;&gt;= size
            if not peek:
                self._nbits = new_count
        else:
            nbits, bbits = self._nbits, self._bbits
            needed = size - nbits
            bytecount, rest = divmod(needed, 8)
            if rest:
                bytecount += 1
                rest = 8 - rest
            bb = self.read(bytecount, True)
            if len(bb) != bytecount:
                raise EOF(bytecount, bb)
            if not peek:
                self._cursor += bytecount
            if bytecount == 1:
                result, = bb
            else:
                result = int.from_bytes(bb, self.byteorder_name)
            if nbits or rest:
                if self.bigendian:
                    rbmask   = 2 ** rest - 1        # noqa
                    excess   = result &amp; rbmask      # noqa
                    result &gt;&gt;= rest                 # noqa
                    result  ^= bbits &lt;&lt; needed      # noqa
                else:
                    excess   = result &gt;&gt; needed     # noqa
                    result  ^= excess &lt;&lt; needed     # noqa
                    result &lt;&lt;= nbits                # noqa
                    result  |= bbits                # noqa
                assert excess.bit_length() &lt;= rest
                if not peek:
                    self._nbits = rest
                    self._bbits = excess
        if signed and (result &amp; (msb := 1 &lt;&lt; (size - 1))):
            result &amp;= msb - 1
            result -= msb
        return result

    def read_bit(self) -&gt; int:
        &#34;&#34;&#34;
        This function is a shortcut for calling `refinery.lib.structures.StructReader.read_integer` with
        an argument of `1`, i.e. this reads the next bit from the stream. The bits of any byte in the stream
        are read from least significant to most significant.
        &#34;&#34;&#34;
        return self.read_integer(1)

    def read_nibble(self, peek: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Calls `refinery.lib.structures.StructReader.read_integer` with an argument of `4`.
        &#34;&#34;&#34;
        return self.read_integer(4, peek)

    def read_byte(self, peek: bool = False) -&gt; int:
        return self.read_integer(8, peek)

    def read_char(self, peek: bool = False) -&gt; str:
        return chr(self.read_integer(8, peek))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.StructReader" href="#refinery.lib.structures.StructReader">StructReader</a></li>
<li><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></li>
<li><a title="refinery.lib.structures.MemoryFileMethods" href="#refinery.lib.structures.MemoryFileMethods">MemoryFileMethods</a></li>
<li>typing.Generic</li>
<li>_io.BytesIO</li>
<li>_io._BufferedIOBase</li>
<li>_io._IOBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.compression.lz4.LZ4Reader" href="../units/compression/lz4.html#refinery.units.compression.lz4.LZ4Reader">LZ4Reader</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.structures.StructReaderBits.remaining_bits"><code class="name">var <span class="ident">remaining_bits</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L870-L872" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def remaining_bits(self) -&gt; int:
    return 8 * self.remaining_bytes + self._nbits</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReaderBits.bits_in_buffer"><code class="name">var <span class="ident">bits_in_buffer</span></code></dt>
<dd>
<section class="desc"><p>This property is <code>True</code> if and only if there are currently no bits still waiting in the internal
bit buffer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L874-L880" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def bits_in_buffer(self) -&gt; int:
    &#34;&#34;&#34;
    This property is `True` if and only if there are currently no bits still waiting in the internal
    bit buffer.
    &#34;&#34;&#34;
    return self._nbits</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.structures.StructReaderBits.byte_align"><code class="name flex">
<span>def <span class="ident">byte_align</span></span>(<span>self, blocksize=1)</span>
</code></dt>
<dd>
<section class="desc"><p>This method clears the internal bit buffer and moves the cursor to the next byte. It returns a
tuple containing the size and contents of the bit buffer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L890-L897" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def byte_align(self, blocksize: int = 1):
    &#34;&#34;&#34;
    This method clears the internal bit buffer and moves the cursor to the next byte. It returns a
    tuple containing the size and contents of the bit buffer.
    &#34;&#34;&#34;
    self._nbits = 0
    self._bbits = 0
    super().byte_align(blocksize)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReaderBits.seek"><code class="name flex">
<span>def <span class="ident">seek</span></span>(<span>self, offset, whence=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Change stream position.</p>
<p>Seek to byte offset pos relative to position indicated by whence:
0
Start of stream (the default).
pos should be &gt;= 0;
1
Current position - pos may be negative;
2
End of stream - pos usually negative.
Returns the new absolute position.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L904-L907" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seek(self, offset, whence=io.SEEK_SET) -&gt; int:
    self._bbits = 0
    self._nbits = 0
    return super().seek(offset, whence)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReaderBits.read_integer"><code class="name flex">
<span>def <span class="ident">read_integer</span></span>(<span>self, size=None, peek=False, signed=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Read <code>size</code> many bits from the underlying stream as an integer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L909-L966" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_integer(
    self,
    size: int | None = None,
    peek: bool = False,
    signed: bool = False,
) -&gt; int:
    &#34;&#34;&#34;
    Read `size` many bits from the underlying stream as an integer.
    &#34;&#34;&#34;
    if size is None:
        size = self.remaining_bits
    if size &lt; self._nbits:
        new_count = self._nbits - size
        if self.bigendian:
            result = self._bbits &gt;&gt; new_count
            if not peek:
                self._bbits ^= result &lt;&lt; new_count
        else:
            result = self._bbits &amp; 2 ** size - 1
            if not peek:
                self._bbits &gt;&gt;= size
        if not peek:
            self._nbits = new_count
    else:
        nbits, bbits = self._nbits, self._bbits
        needed = size - nbits
        bytecount, rest = divmod(needed, 8)
        if rest:
            bytecount += 1
            rest = 8 - rest
        bb = self.read(bytecount, True)
        if len(bb) != bytecount:
            raise EOF(bytecount, bb)
        if not peek:
            self._cursor += bytecount
        if bytecount == 1:
            result, = bb
        else:
            result = int.from_bytes(bb, self.byteorder_name)
        if nbits or rest:
            if self.bigendian:
                rbmask   = 2 ** rest - 1        # noqa
                excess   = result &amp; rbmask      # noqa
                result &gt;&gt;= rest                 # noqa
                result  ^= bbits &lt;&lt; needed      # noqa
            else:
                excess   = result &gt;&gt; needed     # noqa
                result  ^= excess &lt;&lt; needed     # noqa
                result &lt;&lt;= nbits                # noqa
                result  |= bbits                # noqa
            assert excess.bit_length() &lt;= rest
            if not peek:
                self._nbits = rest
                self._bbits = excess
    if signed and (result &amp; (msb := 1 &lt;&lt; (size - 1))):
        result &amp;= msb - 1
        result -= msb
    return result</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReaderBits.read_bit"><code class="name flex">
<span>def <span class="ident">read_bit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>This function is a shortcut for calling <code><a title="refinery.lib.structures.StructReader.read_integer" href="#refinery.lib.structures.StructReader.read_integer">StructReader.read_integer()</a></code> with
an argument of <code>1</code>, i.e. this reads the next bit from the stream. The bits of any byte in the stream
are read from least significant to most significant.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L968-L974" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_bit(self) -&gt; int:
    &#34;&#34;&#34;
    This function is a shortcut for calling `refinery.lib.structures.StructReader.read_integer` with
    an argument of `1`, i.e. this reads the next bit from the stream. The bits of any byte in the stream
    are read from least significant to most significant.
    &#34;&#34;&#34;
    return self.read_integer(1)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReaderBits.read_nibble"><code class="name flex">
<span>def <span class="ident">read_nibble</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Calls <code><a title="refinery.lib.structures.StructReader.read_integer" href="#refinery.lib.structures.StructReader.read_integer">StructReader.read_integer()</a></code> with an argument of <code>4</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L976-L980" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_nibble(self, peek: bool = False) -&gt; int:
    &#34;&#34;&#34;
    Calls `refinery.lib.structures.StructReader.read_integer` with an argument of `4`.
    &#34;&#34;&#34;
    return self.read_integer(4, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReaderBits.read_byte"><code class="name flex">
<span>def <span class="ident">read_byte</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L982-L983" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_byte(self, peek: bool = False) -&gt; int:
    return self.read_integer(8, peek)</code></pre>
</details>
</dd>
<dt id="refinery.lib.structures.StructReaderBits.read_char"><code class="name flex">
<span>def <span class="ident">read_char</span></span>(<span>self, peek=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L985-L986" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_char(self, peek: bool = False) -&gt; str:
    return chr(self.read_integer(8, peek))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.structures.StructReader" href="#refinery.lib.structures.StructReader">StructReader</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.structures.StructReader.SEEK" href="#refinery.lib.structures.MemoryFileMethods.SEEK">SEEK</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.Unaligned" href="#refinery.lib.structures.StructReader.Unaligned">Unaligned</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bit_field" href="#refinery.lib.structures.StructReader.read_bit_field">read_bit_field</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bits" href="#refinery.lib.structures.StructReader.read_bits">read_bits</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bytes" href="#refinery.lib.structures.StructReader.read_bytes">read_bytes</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_exactly" href="#refinery.lib.structures.StructReader.read_exactly">read_exactly</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_flags" href="#refinery.lib.structures.StructReader.read_flags">read_flags</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_struct" href="#refinery.lib.structures.StructReader.read_struct">read_struct</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.structures.StructMeta"><code class="flex name class">
<span>class <span class="ident">StructMeta</span></span>
<span>(</span><span>name, bases, nmspc, **_)</span>
</code></dt>
<dd>
<section class="desc"><p>A metaclass to facilitate the behavior outlined for <code><a title="refinery.lib.structures.Struct" href="#refinery.lib.structures.Struct">Struct</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L989-L1032" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StructMeta(abc.ABCMeta):
    &#34;&#34;&#34;
    A metaclass to facilitate the behavior outlined for `refinery.lib.structures.Struct`.
    &#34;&#34;&#34;
    def __new__(mcls, name, bases, namespace: dict, interface: type[StructReader] | None = None):
        if interface is None:
            if init := namespace.get(&#39;__init__&#39;):
                args = iter(inspect.signature(init).parameters.values())
                next(args)
                interface = next(args).annotation
                if isinstance(interface, str):
                    try:
                        module = sys.modules[namespace[&#39;__module__&#39;]]
                        interface = eval(interface, module.__dict__)
                    except Exception:
                        interface = None
                if not isinstance(interface, type):
                    interface = get_origin(interface)
                if not isinstance(interface, type) or not issubclass(interface, StructReader):
                    raise RuntimeError
            else:
                interface = StructReader

        def parse(cls, reader: T | StructReader[T], *args, **kwargs):
            if not isinstance(reader, interface):
                reader = interface(reader)
            return cls(reader, *args, **kwargs)

        namespace.update(Parse=classmethod(parse))
        return super().__new__(mcls, name, bases, namespace)

    def __init__(cls, name, bases, nmspc, **_):
        super().__init__(name, bases, nmspc)
        original__init__ = cls.__init__

        @functools.wraps(original__init__)
        def wrapped__init__(self: Struct, reader: StructReader, *args, **kwargs):
            start = reader.tell()
            view = reader.getbuffer()
            original__init__(self, reader, *args, **kwargs)
            self._data = view[start:reader.tell()]
            del view

        setattr(cls, &#39;__init__&#39;, wrapped__init__)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABCMeta</li>
<li>builtins.type</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.dotnet.header.TypeRepresentedByName" href="dotnet/header.html#refinery.lib.dotnet.header.TypeRepresentedByName">TypeRepresentedByName</a></li>
</ul>
</dd>
<dt id="refinery.lib.structures.Struct"><code class="flex name class">
<span>class <span class="ident">Struct</span></span>
<span>(</span><span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L1035-L1063" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Struct(Generic[T], Buffer, metaclass=StructMeta):
    &#34;&#34;&#34;
    A class to parse structured data. A `refinery.lib.structures.Struct` class can be instantiated
    as follows:

        foo = Struct(data, bar=29)

    The initialization routine of the structure will be called with a single argument `reader`. If
    the object `data` is already a `refinery.lib.structures.StructReader`, then it will be passed
    as `reader`. Otherwise, the argument will be wrapped in a `refinery.lib.structures.StructReader`.
    Additional arguments to the struct are passed through.
    &#34;&#34;&#34;
    _data: memoryview | bytearray

    @classmethod
    def Parse(cls, reader: T | StructReader[T], *args, **kwargs) -&gt; Self:
        ...

    def __len__(self):
        return len(self._data)

    def __bytes__(self):
        return bytes(self._data)

    def __buffer__(self, flags: int, /):
        return memoryview(self._data)

    def __init__(self, reader: StructReader[T], *args, **kwargs):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
<li>collections.abc.Buffer</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.cab.CabCompressedBlock" href="cab.html#refinery.lib.cab.CabCompressedBlock">CabCompressedBlock</a></li>
<li><a title="refinery.lib.cab.CabDisk" href="cab.html#refinery.lib.cab.CabDisk">CabDisk</a></li>
<li><a title="refinery.lib.cab.CabFile" href="cab.html#refinery.lib.cab.CabFile">CabFile</a></li>
<li><a title="refinery.lib.cab.CabFolder" href="cab.html#refinery.lib.cab.CabFolder">CabFolder</a></li>
<li><a title="refinery.lib.chm.CHM" href="chm.html#refinery.lib.chm.CHM">CHM</a></li>
<li><a title="refinery.lib.chm.ChmStruct" href="chm.html#refinery.lib.chm.ChmStruct">ChmStruct</a></li>
<li><a title="refinery.lib.chm.ContentSections" href="chm.html#refinery.lib.chm.ContentSections">ContentSections</a></li>
<li><a title="refinery.lib.chm.ContentSectionsName" href="chm.html#refinery.lib.chm.ContentSectionsName">ContentSectionsName</a></li>
<li><a title="refinery.lib.chm.ContentSectionsResetTable" href="chm.html#refinery.lib.chm.ContentSectionsResetTable">ContentSectionsResetTable</a></li>
<li><a title="refinery.lib.chm.DirectoryListingEntry" href="chm.html#refinery.lib.chm.DirectoryListingEntry">DirectoryListingEntry</a></li>
<li><a title="refinery.lib.chm.QuickRefArea" href="chm.html#refinery.lib.chm.QuickRefArea">QuickRefArea</a></li>
<li><a title="refinery.lib.chm.SectionHeader" href="chm.html#refinery.lib.chm.SectionHeader">SectionHeader</a></li>
<li><a title="refinery.lib.dex.DexFile" href="dex.html#refinery.lib.dex.DexFile">DexFile</a></li>
<li><a title="refinery.lib.dotnet.header.DotNetStruct" href="dotnet/header.html#refinery.lib.dotnet.header.DotNetStruct">DotNetStruct</a></li>
<li><a title="refinery.lib.dotnet.header.NetMetaDataStreams" href="dotnet/header.html#refinery.lib.dotnet.header.NetMetaDataStreams">NetMetaDataStreams</a></li>
<li><a title="refinery.lib.inno.archive.CrcCompressedBlock" href="inno/archive.html#refinery.lib.inno.archive.CrcCompressedBlock">CrcCompressedBlock</a></li>
<li><a title="refinery.lib.inno.archive.InnoStruct" href="inno/archive.html#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.LanguageId" href="inno/archive.html#refinery.lib.inno.archive.LanguageId">LanguageId</a></li>
<li><a title="refinery.lib.inno.archive.SetupEncryptionHeaderV1" href="inno/archive.html#refinery.lib.inno.archive.SetupEncryptionHeaderV1">SetupEncryptionHeaderV1</a></li>
<li><a title="refinery.lib.inno.archive.SetupEncryptionHeaderV2" href="inno/archive.html#refinery.lib.inno.archive.SetupEncryptionHeaderV2">SetupEncryptionHeaderV2</a></li>
<li><a title="refinery.lib.inno.archive.SetupEncryptionHeaderV3" href="inno/archive.html#refinery.lib.inno.archive.SetupEncryptionHeaderV3">SetupEncryptionHeaderV3</a></li>
<li><a title="refinery.lib.inno.archive.SetupEncryptionNonce" href="inno/archive.html#refinery.lib.inno.archive.SetupEncryptionNonce">SetupEncryptionNonce</a></li>
<li><a title="refinery.lib.inno.archive.TSetupLdrOffsetTable" href="inno/archive.html#refinery.lib.inno.archive.TSetupLdrOffsetTable">TSetupLdrOffsetTable</a></li>
<li><a title="refinery.lib.inno.archive.XChaChaParams" href="inno/archive.html#refinery.lib.inno.archive.XChaChaParams">XChaChaParams</a></li>
<li><a title="refinery.lib.inno.ifps.IFPSFile" href="inno/ifps.html#refinery.lib.inno.ifps.IFPSFile">IFPSFile</a></li>
<li><a title="refinery.lib.java.JvAccessFlags" href="java.html#refinery.lib.java.JvAccessFlags">JvAccessFlags</a></li>
<li><a title="refinery.lib.java.JvClassFile" href="java.html#refinery.lib.java.JvClassFile">JvClassFile</a></li>
<li><a title="refinery.lib.java.JvCode" href="java.html#refinery.lib.java.JvCode">JvCode</a></li>
<li><a title="refinery.lib.java.JvException" href="java.html#refinery.lib.java.JvException">JvException</a></li>
<li><a title="refinery.lib.java.JvOpCode" href="java.html#refinery.lib.java.JvOpCode">JvOpCode</a></li>
<li>refinery.lib.java._HasPoolAndTag</li>
<li><a title="refinery.lib.mscrypto.BCRYPT_RSAKEY_BLOB" href="mscrypto.html#refinery.lib.mscrypto.BCRYPT_RSAKEY_BLOB">BCRYPT_RSAKEY_BLOB</a></li>
<li><a title="refinery.lib.mscrypto.BLOBHEADER" href="mscrypto.html#refinery.lib.mscrypto.BLOBHEADER">BLOBHEADER</a></li>
<li><a title="refinery.lib.mscrypto.CRYPTOKEY" href="mscrypto.html#refinery.lib.mscrypto.CRYPTOKEY">CRYPTOKEY</a></li>
<li><a title="refinery.lib.mscrypto.DHPUBKEY" href="mscrypto.html#refinery.lib.mscrypto.DHPUBKEY">DHPUBKEY</a></li>
<li><a title="refinery.lib.mscrypto.PLAINTEXTKEYBLOB" href="mscrypto.html#refinery.lib.mscrypto.PLAINTEXTKEYBLOB">PLAINTEXTKEYBLOB</a></li>
<li><a title="refinery.lib.mscrypto.PRIVATEKEYBLOB" href="mscrypto.html#refinery.lib.mscrypto.PRIVATEKEYBLOB">PRIVATEKEYBLOB</a></li>
<li><a title="refinery.lib.mscrypto.RSAPUBKEY" href="mscrypto.html#refinery.lib.mscrypto.RSAPUBKEY">RSAPUBKEY</a></li>
<li><a title="refinery.lib.mscrypto.SIMPLEBLOB" href="mscrypto.html#refinery.lib.mscrypto.SIMPLEBLOB">SIMPLEBLOB</a></li>
<li><a title="refinery.lib.zip.AExCrypto" href="zip.html#refinery.lib.zip.AExCrypto">AExCrypto</a></li>
<li><a title="refinery.lib.zip.PkgSigningBlock" href="zip.html#refinery.lib.zip.PkgSigningBlock">PkgSigningBlock</a></li>
<li><a title="refinery.lib.zip.SigningBlock42Entry" href="zip.html#refinery.lib.zip.SigningBlock42Entry">SigningBlock42Entry</a></li>
<li><a title="refinery.lib.zip.ZipArchiveExtraDataRecord" href="zip.html#refinery.lib.zip.ZipArchiveExtraDataRecord">ZipArchiveExtraDataRecord</a></li>
<li><a title="refinery.lib.zip.ZipCrypto" href="zip.html#refinery.lib.zip.ZipCrypto">ZipCrypto</a></li>
<li><a title="refinery.lib.zip.ZipDataDescriptor" href="zip.html#refinery.lib.zip.ZipDataDescriptor">ZipDataDescriptor</a></li>
<li><a title="refinery.lib.zip.ZipDigitalSignature" href="zip.html#refinery.lib.zip.ZipDigitalSignature">ZipDigitalSignature</a></li>
<li><a title="refinery.lib.zip.ZipDirEntry" href="zip.html#refinery.lib.zip.ZipDirEntry">ZipDirEntry</a></li>
<li><a title="refinery.lib.zip.ZipEncryptionHeader" href="zip.html#refinery.lib.zip.ZipEncryptionHeader">ZipEncryptionHeader</a></li>
<li><a title="refinery.lib.zip.ZipEndOfCentralDirectory" href="zip.html#refinery.lib.zip.ZipEndOfCentralDirectory">ZipEndOfCentralDirectory</a></li>
<li><a title="refinery.lib.zip.ZipEndOfCentralDirectory64" href="zip.html#refinery.lib.zip.ZipEndOfCentralDirectory64">ZipEndOfCentralDirectory64</a></li>
<li><a title="refinery.lib.zip.ZipEocdLocator64" href="zip.html#refinery.lib.zip.ZipEocdLocator64">ZipEocdLocator64</a></li>
<li><a title="refinery.lib.zip.ZipExt" href="zip.html#refinery.lib.zip.ZipExt">ZipExt</a></li>
<li><a title="refinery.lib.zip.ZipExtraField" href="zip.html#refinery.lib.zip.ZipExtraField">ZipExtraField</a></li>
<li><a title="refinery.lib.zip.ZipFileRecord" href="zip.html#refinery.lib.zip.ZipFileRecord">ZipFileRecord</a></li>
<li><a title="refinery.units.compression.lzf.LZFHeader" href="../units/compression/lzf.html#refinery.units.compression.lzf.LZFHeader">LZFHeader</a></li>
<li><a title="refinery.units.compression.lzg.LZGStream" href="../units/compression/lzg.html#refinery.units.compression.lzg.LZGStream">LZGStream</a></li>
<li><a title="refinery.units.compression.lzip.RangeDecoder" href="../units/compression/lzip.html#refinery.units.compression.lzip.RangeDecoder">RangeDecoder</a></li>
<li><a title="refinery.units.compression.lzo.LZO" href="../units/compression/lzo.html#refinery.units.compression.lzo.LZO">LZO</a></li>
<li><a title="refinery.units.compression.lzo.LZOChunk" href="../units/compression/lzo.html#refinery.units.compression.lzo.LZOChunk">LZOChunk</a></li>
<li><a title="refinery.units.formats.a3x.A3xRecord" href="../units/formats/a3x.html#refinery.units.formats.a3x.A3xRecord">A3xRecord</a></li>
<li><a title="refinery.units.formats.a3x.A3xScript" href="../units/formats/a3x.html#refinery.units.formats.a3x.A3xScript">A3xScript</a></li>
<li><a title="refinery.units.formats.archive.xtasar.AsarHeader" href="../units/formats/archive/xtasar.html#refinery.units.formats.archive.xtasar.AsarHeader">AsarHeader</a></li>
<li><a title="refinery.units.formats.archive.xtcpio.CPIOEntry" href="../units/formats/archive/xtcpio.html#refinery.units.formats.archive.xtcpio.CPIOEntry">CPIOEntry</a></li>
<li><a title="refinery.units.formats.archive.xtgz.GzipHeader" href="../units/formats/archive/xtgz.html#refinery.units.formats.archive.xtgz.GzipHeader">GzipHeader</a></li>
<li><a title="refinery.units.formats.archive.xtmacho.FatArch" href="../units/formats/archive/xtmacho.html#refinery.units.formats.archive.xtmacho.FatArch">FatArch</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSArchive" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSArchive">NSArchive</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSBlockHeaderOffset" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSBlockHeaderOffset">NSBlockHeaderOffset</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSHeader" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSHeader">NSHeader</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSScriptExtendedInstruction" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSScriptExtendedInstruction">NSScriptExtendedInstruction</a></li>
<li><a title="refinery.units.formats.archive.xtnsis.NSScriptInstruction" href="../units/formats/archive/xtnsis.html#refinery.units.formats.archive.xtnsis.NSScriptInstruction">NSScriptInstruction</a></li>
<li><a title="refinery.units.formats.archive.xtpyi.PYZ" href="../units/formats/archive/xtpyi.html#refinery.units.formats.archive.xtpyi.PYZ">PYZ</a></li>
<li><a title="refinery.units.formats.archive.xtpyi.PiTOCEntry" href="../units/formats/archive/xtpyi.html#refinery.units.formats.archive.xtpyi.PiTOCEntry">PiTOCEntry</a></li>
<li><a title="refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue" href="../units/formats/archive/xtpyi.html#refinery.units.formats.archive.xtpyi.PyInstallerArchiveEpilogue">PyInstallerArchiveEpilogue</a></li>
<li><a title="refinery.units.formats.archive.xtrpa.RPA" href="../units/formats/archive/xtrpa.html#refinery.units.formats.archive.xtrpa.RPA">RPA</a></li>
<li><a title="refinery.units.formats.idbmeta.IdbUserData" href="../units/formats/idbmeta.html#refinery.units.formats.idbmeta.IdbUserData">IdbUserData</a></li>
<li><a title="refinery.units.formats.jpeg.Jpeg" href="../units/formats/jpeg.html#refinery.units.formats.jpeg.Jpeg">Jpeg</a></li>
<li><a title="refinery.units.formats.jpeg.JpegSOF" href="../units/formats/jpeg.html#refinery.units.formats.jpeg.JpegSOF">JpegSOF</a></li>
<li><a title="refinery.units.formats.jpeg.JpegSOFComponent" href="../units/formats/jpeg.html#refinery.units.formats.jpeg.JpegSOFComponent">JpegSOFComponent</a></li>
<li><a title="refinery.units.formats.jpeg.JpegStream" href="../units/formats/jpeg.html#refinery.units.formats.jpeg.JpegStream">JpegStream</a></li>
<li><a title="refinery.units.formats.macho.machometa.BlobIndex" href="../units/formats/macho/machometa.html#refinery.units.formats.macho.machometa.BlobIndex">BlobIndex</a></li>
<li><a title="refinery.units.formats.macho.machometa.CodeDirectoryBlob" href="../units/formats/macho/machometa.html#refinery.units.formats.macho.machometa.CodeDirectoryBlob">CodeDirectoryBlob</a></li>
<li><a title="refinery.units.formats.macho.machometa.SuperBlob" href="../units/formats/macho/machometa.html#refinery.units.formats.macho.machometa.SuperBlob">SuperBlob</a></li>
<li><a title="refinery.units.formats.pe.perc.GRPICONDIR" href="../units/formats/pe/perc.html#refinery.units.formats.pe.perc.GRPICONDIR">GRPICONDIR</a></li>
<li><a title="refinery.units.formats.pe.perc.GRPICONDIRENTRY" href="../units/formats/pe/perc.html#refinery.units.formats.pe.perc.GRPICONDIRENTRY">GRPICONDIRENTRY</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.structures.Struct.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.structures.PerInstanceAttribute"><code class="flex name class">
<span>class <span class="ident">PerInstanceAttribute</span></span>
</code></dt>
<dd>
<section class="desc"><p>Abstract base class for generic types.</p>
<p>On Python 3.12 and newer, generic classes implicitly inherit from
Generic when they declare a parameter list after the class's name::</p>
<pre><code>class Mapping[KT, VT]:
    def __getitem__(self, key: KT) -&gt; VT:
        ...
    # Etc.
</code></pre>
<p>On older versions of Python, however, generic classes have to
explicitly inherit from Generic.</p>
<p>After a class has been declared to be generic, it can then be used as
follows::</p>
<pre><code>def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
    try:
        return mapping[key]
    except KeyError:
        return default
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L1086-L1094" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def __get__(self, parent, tp=None) -&gt; AttrType:
    pid = id(parent)
    if pid not in self.__get:
        try:
            seed = self.__set[pid]
        except KeyError as K:
            raise AttributeError from K
        self.__get[pid] = self.resolve(parent, seed)
    return self.__get[pid]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>refinery.lib.java.Index</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.structures.PerInstanceAttribute.resolve"><code class="name flex">
<span>def <span class="ident">resolve</span></span>(<span>self, parent, value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L1070-L1071" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resolve(self, parent, value: Any) -&gt; AttrType:
    return value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.structures.FlagAccessMixin"><code class="flex name class">
<span>class <span class="ident">FlagAccessMixin</span></span>
</code></dt>
<dd>
<section class="desc"><p>This class can be mixed into an <code>enum.IntFlag</code> for some quality of life improvements. Firstly,
you can now access flags as follows:</p>
<pre><code>class Flags(FlagAccessMixin, enum.IntFlag):
    IsBinary = 1
    IsCompressed = 2

flag = Flags(3)

if flag.IsCompressed:
    decompress()
</code></pre>
<p>Furthermore, flag values can be enumerated:</p>
<pre><code>&gt;&gt;&gt; list(flag)
[IsBinary, IsCompressed]
&gt;&gt;&gt; flag
IsBinary|IsCompressed
</code></pre>
<p>And finally, as visible from the above output, flag values are represented by their name by
default.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/structures.py#L1129-L1177" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class FlagAccessMixin:
    &#34;&#34;&#34;
    This class can be mixed into an `enum.IntFlag` for some quality of life improvements. Firstly,
    you can now access flags as follows:

        class Flags(FlagAccessMixin, enum.IntFlag):
            IsBinary = 1
            IsCompressed = 2

        flag = Flags(3)

        if flag.IsCompressed:
            decompress()

    Furthermore, flag values can be enumerated:

        &gt;&gt;&gt; list(flag)
        [IsBinary, IsCompressed]
        &gt;&gt;&gt; flag
        IsBinary|IsCompressed

    And finally, as visible from the above output, flag values are represented by their name by
    default.
    &#34;&#34;&#34;
    def __getattribute__(self, name: str):
        if not isinstance(self, enum.IntFlag):
            raise RuntimeError
        if not name.startswith(&#39;_&#39;):
            try:
                flag = self.__class__[name]
            except KeyError:
                pass
            else:
                return flag in self
        return super().__getattribute__(name)

    def __iter__(self) -&gt; Generator[Self]:
        if not isinstance(self, enum.IntFlag):
            raise RuntimeError
        for flag in self.__class__:
            if flag in self:
                yield flag

    def __repr__(self):
        if not isinstance(self, enum.IntFlag):
            raise RuntimeError
        if name := self.name:
            return name
        return enum.IntFlag.__repr__(self)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.batch.model.ArgVarFlags" href="batch/model.html#refinery.lib.batch.model.ArgVarFlags">ArgVarFlags</a></li>
<li><a title="refinery.lib.dotnet.header.FieldFlags" href="dotnet/header.html#refinery.lib.dotnet.header.FieldFlags">FieldFlags</a></li>
<li><a title="refinery.lib.dotnet.header.NetDirectoryFlags" href="dotnet/header.html#refinery.lib.dotnet.header.NetDirectoryFlags">NetDirectoryFlags</a></li>
<li><a title="refinery.lib.dotnet.header.NetMetaFlags" href="dotnet/header.html#refinery.lib.dotnet.header.NetMetaFlags">NetMetaFlags</a></li>
<li><a title="refinery.lib.emulator.abstract.Hook" href="emulator/abstract.html#refinery.lib.emulator.abstract.Hook">Hook</a></li>
<li><a title="refinery.lib.emulator.abstract.MemAccess" href="emulator/abstract.html#refinery.lib.emulator.abstract.MemAccess">MemAccess</a></li>
<li><a title="refinery.lib.zip.ZipEncryptionFlags" href="zip.html#refinery.lib.zip.ZipEncryptionFlags">ZipEncryptionFlags</a></li>
<li><a title="refinery.lib.zip.ZipExtTimestampFlags" href="zip.html#refinery.lib.zip.ZipExtTimestampFlags">ZipExtTimestampFlags</a></li>
<li><a title="refinery.lib.zip.ZipFlags" href="zip.html#refinery.lib.zip.ZipFlags">ZipFlags</a></li>
<li><a title="refinery.lib.zip.ZipInternalFileAttributes" href="zip.html#refinery.lib.zip.ZipInternalFileAttributes">ZipInternalFileAttributes</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.structures.signed" href="#refinery.lib.structures.signed">signed</a></code></li>
<li><code><a title="refinery.lib.structures.struct_to_json" href="#refinery.lib.structures.struct_to_json">struct_to_json</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.structures.ToJSON" href="#refinery.lib.structures.ToJSON">ToJSON</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.EOF" href="#refinery.lib.structures.EOF">EOF</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.LimitExceeded" href="#refinery.lib.structures.LimitExceeded">LimitExceeded</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.StreamDetour" href="#refinery.lib.structures.StreamDetour">StreamDetour</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.MemoryFileMethods" href="#refinery.lib.structures.MemoryFileMethods">MemoryFileMethods</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.lib.structures.MemoryFileMethods.close" href="#refinery.lib.structures.MemoryFileMethods.close">close</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.flush" href="#refinery.lib.structures.MemoryFileMethods.flush">flush</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.isatty" href="#refinery.lib.structures.MemoryFileMethods.isatty">isatty</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.fileno" href="#refinery.lib.structures.MemoryFileMethods.fileno">fileno</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readable" href="#refinery.lib.structures.MemoryFileMethods.readable">readable</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.seekable" href="#refinery.lib.structures.MemoryFileMethods.seekable">seekable</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.detour" href="#refinery.lib.structures.MemoryFileMethods.detour">detour</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.detour_absolute" href="#refinery.lib.structures.MemoryFileMethods.detour_absolute">detour_absolute</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.detour_relative" href="#refinery.lib.structures.MemoryFileMethods.detour_relative">detour_relative</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.detour_from_end" href="#refinery.lib.structures.MemoryFileMethods.detour_from_end">detour_from_end</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.writable" href="#refinery.lib.structures.MemoryFileMethods.writable">writable</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.read_as" href="#refinery.lib.structures.MemoryFileMethods.read_as">read_as</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.read" href="#refinery.lib.structures.MemoryFileMethods.read">read</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readif" href="#refinery.lib.structures.MemoryFileMethods.readif">readif</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.peek" href="#refinery.lib.structures.MemoryFileMethods.peek">peek</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.read1" href="#refinery.lib.structures.MemoryFileMethods.read1">read1</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readline" href="#refinery.lib.structures.MemoryFileMethods.readline">readline</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readlines_iter" href="#refinery.lib.structures.MemoryFileMethods.readlines_iter">readlines_iter</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readlines" href="#refinery.lib.structures.MemoryFileMethods.readlines">readlines</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readinto1" href="#refinery.lib.structures.MemoryFileMethods.readinto1">readinto1</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.readinto" href="#refinery.lib.structures.MemoryFileMethods.readinto">readinto</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.tell" href="#refinery.lib.structures.MemoryFileMethods.tell">tell</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.skip" href="#refinery.lib.structures.MemoryFileMethods.skip">skip</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.seekrel" href="#refinery.lib.structures.MemoryFileMethods.seekrel">seekrel</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.seekend" href="#refinery.lib.structures.MemoryFileMethods.seekend">seekend</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.seekset" href="#refinery.lib.structures.MemoryFileMethods.seekset">seekset</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.getbuffer" href="#refinery.lib.structures.MemoryFileMethods.getbuffer">getbuffer</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.getvalue" href="#refinery.lib.structures.MemoryFileMethods.getvalue">getvalue</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.seek" href="#refinery.lib.structures.MemoryFileMethods.seek">seek</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.writelines" href="#refinery.lib.structures.MemoryFileMethods.writelines">writelines</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.truncate" href="#refinery.lib.structures.MemoryFileMethods.truncate">truncate</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.write_byte" href="#refinery.lib.structures.MemoryFileMethods.write_byte">write_byte</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.write" href="#refinery.lib.structures.MemoryFileMethods.write">write</a></code></li>
<li><code><a title="refinery.lib.structures.MemoryFileMethods.replay" href="#refinery.lib.structures.MemoryFileMethods.replay">replay</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.structures.MemoryFile" href="#refinery.lib.structures.MemoryFile">MemoryFile</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.order" href="#refinery.lib.structures.order">order</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.StructReader" href="#refinery.lib.structures.StructReader">StructReader</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.structures.StructReader.read_exactly" href="#refinery.lib.structures.StructReader.read_exactly">read_exactly</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bit_field" href="#refinery.lib.structures.StructReader.read_bit_field">read_bit_field</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_integer" href="#refinery.lib.structures.StructReader.read_integer">read_integer</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.byte_align" href="#refinery.lib.structures.StructReader.byte_align">byte_align</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bytes" href="#refinery.lib.structures.StructReader.read_bytes">read_bytes</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_one_struct" href="#refinery.lib.structures.StructReader.read_one_struct">read_one_struct</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_struct" href="#refinery.lib.structures.StructReader.read_struct">read_struct</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bool_byte" href="#refinery.lib.structures.StructReader.read_bool_byte">read_bool_byte</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_regex" href="#refinery.lib.structures.StructReader.read_regex">read_regex</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_byte" href="#refinery.lib.structures.StructReader.read_byte">read_byte</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_char" href="#refinery.lib.structures.StructReader.read_char">read_char</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.u8fast" href="#refinery.lib.structures.StructReader.u8fast">u8fast</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.u8" href="#refinery.lib.structures.StructReader.u8">u8</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.i8" href="#refinery.lib.structures.StructReader.i8">i8</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.u16" href="#refinery.lib.structures.StructReader.u16">u16</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.u32" href="#refinery.lib.structures.StructReader.u32">u32</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.u64" href="#refinery.lib.structures.StructReader.u64">u64</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.i16" href="#refinery.lib.structures.StructReader.i16">i16</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.i32" href="#refinery.lib.structures.StructReader.i32">i32</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.i64" href="#refinery.lib.structures.StructReader.i64">i64</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.f32" href="#refinery.lib.structures.StructReader.f32">f32</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.f64" href="#refinery.lib.structures.StructReader.f64">f64</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_terminated_array" href="#refinery.lib.structures.StructReader.read_terminated_array">read_terminated_array</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_guid" href="#refinery.lib.structures.StructReader.read_guid">read_guid</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_uuid" href="#refinery.lib.structures.StructReader.read_uuid">read_uuid</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_c_string" href="#refinery.lib.structures.StructReader.read_c_string">read_c_string</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_w_string" href="#refinery.lib.structures.StructReader.read_w_string">read_w_string</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_length_prefixed_ascii" href="#refinery.lib.structures.StructReader.read_length_prefixed_ascii">read_length_prefixed_ascii</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_length_prefixed_utf8" href="#refinery.lib.structures.StructReader.read_length_prefixed_utf8">read_length_prefixed_utf8</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_length_prefixed_utf16" href="#refinery.lib.structures.StructReader.read_length_prefixed_utf16">read_length_prefixed_utf16</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_length_prefixed" href="#refinery.lib.structures.StructReader.read_length_prefixed">read_length_prefixed</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_7bit_encoded_int" href="#refinery.lib.structures.StructReader.read_7bit_encoded_int">read_7bit_encoded_int</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bits" href="#refinery.lib.structures.StructReader.read_bits">read_bits</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_flags" href="#refinery.lib.structures.StructReader.read_flags">read_flags</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.structures.StructReaderBits" href="#refinery.lib.structures.StructReaderBits">StructReaderBits</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.lib.structures.StructReaderBits.byte_align" href="#refinery.lib.structures.StructReaderBits.byte_align">byte_align</a></code></li>
<li><code><a title="refinery.lib.structures.StructReaderBits.seek" href="#refinery.lib.structures.StructReaderBits.seek">seek</a></code></li>
<li><code><a title="refinery.lib.structures.StructReaderBits.read_integer" href="#refinery.lib.structures.StructReaderBits.read_integer">read_integer</a></code></li>
<li><code><a title="refinery.lib.structures.StructReaderBits.read_bit" href="#refinery.lib.structures.StructReaderBits.read_bit">read_bit</a></code></li>
<li><code><a title="refinery.lib.structures.StructReaderBits.read_nibble" href="#refinery.lib.structures.StructReaderBits.read_nibble">read_nibble</a></code></li>
<li><code><a title="refinery.lib.structures.StructReaderBits.read_byte" href="#refinery.lib.structures.StructReaderBits.read_byte">read_byte</a></code></li>
<li><code><a title="refinery.lib.structures.StructReaderBits.read_char" href="#refinery.lib.structures.StructReaderBits.read_char">read_char</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.structures.StructMeta" href="#refinery.lib.structures.StructMeta">StructMeta</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.structures.Struct" href="#refinery.lib.structures.Struct">Struct</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.structures.Struct.Parse" href="#refinery.lib.structures.Struct.Parse">Parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.structures.PerInstanceAttribute" href="#refinery.lib.structures.PerInstanceAttribute">PerInstanceAttribute</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.structures.PerInstanceAttribute.resolve" href="#refinery.lib.structures.PerInstanceAttribute.resolve">resolve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.structures.FlagAccessMixin" href="#refinery.lib.structures.FlagAccessMixin">FlagAccessMixin</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
