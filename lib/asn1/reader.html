<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.asn1.reader documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.asn1.reader</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/asn1/reader.py#L1-L525" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from __future__ import annotations

import codecs

from collections import OrderedDict
from typing import TYPE_CHECKING, Any, Union

from refinery.lib.structures import StructReader

from refinery.lib.asn1.schema import (
    CLASS_UNIVERSAL,
    _MISSING,
    ANY,
    SEQUENCE,
    SET,
    ASN1SchemaMismatch,
    Choice,
    SchemaType,
    Seq,
    SeqOf,
    SetOf,
)

if TYPE_CHECKING:
    ASN1Value = Union[
        None,
        bool,
        int,
        float,
        str,
        bytes,
        list,
        dict[str, Any],
        OrderedDict[str, Any],
        object,
    ]


class ASN1Reader(StructReader[memoryview]):

    _EOC = object()

    _STRING_ENCODINGS = {
        12: &#39;utf-8&#39;,      # UTF8String
        18: &#39;ascii&#39;,      # NumericString
        19: &#39;ascii&#39;,      # PrintableString
        20: &#39;latin-1&#39;,    # T61String / TeletexString
        22: &#39;ascii&#39;,      # IA5String
        23: &#39;ascii&#39;,      # UTCTime
        24: &#39;ascii&#39;,      # GeneralizedTime
        25: &#39;latin-1&#39;,    # GraphicString
        26: &#39;ascii&#39;,      # VisibleString / ISO646String
        27: &#39;latin-1&#39;,    # GeneralString
        28: &#39;utf-32-be&#39;,  # UniversalString
        30: &#39;utf-16-be&#39;,  # BMPString
    }

    _TAG_CLASS_NAMES = (&#39;universal&#39;, &#39;application&#39;, &#39;context&#39;, &#39;private&#39;)

    _OID_NAMES = {
        &#39;2.5.4.3&#39;                    : &#39;commonName&#39;,
        &#39;2.5.4.4&#39;                    : &#39;surname&#39;,
        &#39;2.5.4.5&#39;                    : &#39;serialNumber&#39;,
        &#39;2.5.4.6&#39;                    : &#39;countryName&#39;,
        &#39;2.5.4.7&#39;                    : &#39;localityName&#39;,
        &#39;2.5.4.8&#39;                    : &#39;stateOrProvinceName&#39;,
        &#39;2.5.4.9&#39;                    : &#39;streetAddress&#39;,
        &#39;2.5.4.10&#39;                   : &#39;organizationName&#39;,
        &#39;2.5.4.11&#39;                   : &#39;organizationalUnitName&#39;,
        &#39;2.5.4.12&#39;                   : &#39;title&#39;,
        &#39;2.5.4.17&#39;                   : &#39;postalCode&#39;,
        &#39;2.5.4.42&#39;                   : &#39;givenName&#39;,
        &#39;2.5.4.43&#39;                   : &#39;initials&#39;,
        &#39;2.5.4.46&#39;                   : &#39;dnQualifier&#39;,
        &#39;2.5.4.65&#39;                   : &#39;pseudonym&#39;,
        &#39;2.5.29.14&#39;                  : &#39;subjectKeyIdentifier&#39;,
        &#39;2.5.29.15&#39;                  : &#39;keyUsage&#39;,
        &#39;2.5.29.17&#39;                  : &#39;subjectAltName&#39;,
        &#39;2.5.29.18&#39;                  : &#39;issuerAltName&#39;,
        &#39;2.5.29.19&#39;                  : &#39;basicConstraints&#39;,
        &#39;2.5.29.20&#39;                  : &#39;cRLNumber&#39;,
        &#39;2.5.29.21&#39;                  : &#39;cRLReason&#39;,
        &#39;2.5.29.31&#39;                  : &#39;cRLDistributionPoints&#39;,
        &#39;2.5.29.32&#39;                  : &#39;certificatePolicies&#39;,
        &#39;2.5.29.33&#39;                  : &#39;policyMappings&#39;,
        &#39;2.5.29.35&#39;                  : &#39;authorityKeyIdentifier&#39;,
        &#39;2.5.29.36&#39;                  : &#39;policyConstraints&#39;,
        &#39;2.5.29.37&#39;                  : &#39;extKeyUsage&#39;,
        &#39;2.5.29.46&#39;                  : &#39;freshestCRL&#39;,
        &#39;2.5.29.54&#39;                  : &#39;inhibitAnyPolicy&#39;,
        &#39;1.3.6.1.5.5.7.1.1&#39;          : &#39;authorityInfoAccess&#39;,
        &#39;1.3.6.1.5.5.7.1.11&#39;         : &#39;subjectInfoAccess&#39;,
        &#39;1.3.6.1.5.5.7.48.1&#39;         : &#39;ocsp&#39;,
        &#39;1.3.6.1.5.5.7.48.2&#39;         : &#39;caIssuers&#39;,
        &#39;1.3.6.1.5.5.7.3.1&#39;          : &#39;serverAuth&#39;,
        &#39;1.3.6.1.5.5.7.3.2&#39;          : &#39;clientAuth&#39;,
        &#39;1.3.6.1.5.5.7.3.3&#39;          : &#39;codeSigning&#39;,
        &#39;1.3.6.1.5.5.7.3.4&#39;          : &#39;emailProtection&#39;,
        &#39;1.3.6.1.5.5.7.3.8&#39;          : &#39;timeStamping&#39;,
        &#39;1.3.6.1.5.5.7.3.9&#39;          : &#39;ocspSigning&#39;,
        &#39;1.2.840.113549.1.1.1&#39;       : &#39;rsaEncryption&#39;,
        &#39;1.2.840.113549.1.1.5&#39;       : &#39;sha1WithRSAEncryption&#39;,
        &#39;1.2.840.113549.1.1.7&#39;       : &#39;rsaOAEP&#39;,
        &#39;1.2.840.113549.1.1.8&#39;       : &#39;sha256WithRSAEncryption-mgf1&#39;,
        &#39;1.2.840.113549.1.1.10&#39;      : &#39;rsaPSS&#39;,
        &#39;1.2.840.113549.1.1.11&#39;      : &#39;sha256WithRSAEncryption&#39;,
        &#39;1.2.840.113549.1.1.12&#39;      : &#39;sha384WithRSAEncryption&#39;,
        &#39;1.2.840.113549.1.1.13&#39;      : &#39;sha512WithRSAEncryption&#39;,
        &#39;1.2.840.113549.1.1.14&#39;      : &#39;sha224WithRSAEncryption&#39;,
        &#39;1.2.840.10045.2.1&#39;          : &#39;ecPublicKey&#39;,
        &#39;1.2.840.10045.4.3.1&#39;        : &#39;ecdsaWithSHA224&#39;,
        &#39;1.2.840.10045.4.3.2&#39;        : &#39;ecdsaWithSHA256&#39;,
        &#39;1.2.840.10045.4.3.3&#39;        : &#39;ecdsaWithSHA384&#39;,
        &#39;1.2.840.10045.4.3.4&#39;        : &#39;ecdsaWithSHA512&#39;,
        &#39;1.3.101.110&#39;                : &#39;x25519&#39;,
        &#39;1.3.101.111&#39;                : &#39;x448&#39;,
        &#39;1.3.101.112&#39;                : &#39;ed25519&#39;,
        &#39;1.3.101.113&#39;                : &#39;ed448&#39;,
        &#39;1.2.840.10045.3.1.7&#39;        : &#39;secp256r1&#39;,
        &#39;1.3.132.0.34&#39;               : &#39;secp384r1&#39;,
        &#39;1.3.132.0.35&#39;               : &#39;secp521r1&#39;,
        &#39;1.3.132.0.10&#39;               : &#39;secp256k1&#39;,
        &#39;1.3.14.3.2.26&#39;              : &#39;sha1&#39;,
        &#39;2.16.840.1.101.3.4.2.1&#39;     : &#39;sha256&#39;,
        &#39;2.16.840.1.101.3.4.2.2&#39;     : &#39;sha384&#39;,
        &#39;2.16.840.1.101.3.4.2.3&#39;     : &#39;sha512&#39;,
        &#39;2.16.840.1.101.3.4.2.4&#39;     : &#39;sha224&#39;,
        &#39;2.16.840.1.101.3.4.2.6&#39;     : &#39;sha512-256&#39;,
        &#39;2.16.840.1.101.3.4.2.8&#39;     : &#39;sha3-256&#39;,
        &#39;2.16.840.1.101.3.4.2.9&#39;     : &#39;sha3-384&#39;,
        &#39;2.16.840.1.101.3.4.2.10&#39;    : &#39;sha3-512&#39;,
        &#39;1.2.840.113549.1.7.1&#39;       : &#39;data&#39;,
        &#39;1.2.840.113549.1.7.2&#39;       : &#39;signedData&#39;,
        &#39;1.2.840.113549.1.7.3&#39;       : &#39;envelopedData&#39;,
        &#39;1.2.840.113549.1.7.5&#39;       : &#39;digestedData&#39;,
        &#39;1.2.840.113549.1.7.6&#39;       : &#39;encryptedData&#39;,
        &#39;1.2.840.113549.1.9.1&#39;       : &#39;emailAddress&#39;,
        &#39;1.2.840.113549.1.9.2&#39;       : &#39;unstructuredName&#39;,
        &#39;1.2.840.113549.1.9.3&#39;       : &#39;contentType&#39;,
        &#39;1.2.840.113549.1.9.4&#39;       : &#39;messageDigest&#39;,
        &#39;1.2.840.113549.1.9.5&#39;       : &#39;signingTime&#39;,
        &#39;1.2.840.113549.1.9.14&#39;      : &#39;extensionRequest&#39;,
        &#39;1.2.840.113549.1.9.15&#39;      : &#39;smimeCapabilities&#39;,
        &#39;1.2.840.113549.1.12.1.3&#39;    : &#39;pbeWithSHAAnd3KeyTripleDES&#39;,
        &#39;1.2.840.113549.1.12.1.6&#39;    : &#39;pbeWithSHAAnd40BitRC2&#39;,
        &#39;1.2.840.113549.1.12.10.1.1&#39; : &#39;keyBag&#39;,
        &#39;1.2.840.113549.1.12.10.1.2&#39; : &#39;pkcs8ShroudedKeyBag&#39;,
        &#39;1.2.840.113549.1.12.10.1.3&#39; : &#39;certBag&#39;,
        &#39;1.2.840.113549.1.12.10.1.5&#39; : &#39;secretBag&#39;,
        &#39;1.2.840.113549.1.12.10.1.6&#39; : &#39;safeContentsBag&#39;,
        &#39;2.16.840.1.101.3.4.1.2&#39;     : &#39;aes128-CBC&#39;,
        &#39;2.16.840.1.101.3.4.1.6&#39;     : &#39;aes128-GCM&#39;,
        &#39;2.16.840.1.101.3.4.1.22&#39;    : &#39;aes192-CBC&#39;,
        &#39;2.16.840.1.101.3.4.1.26&#39;    : &#39;aes192-GCM&#39;,
        &#39;2.16.840.1.101.3.4.1.42&#39;    : &#39;aes256-CBC&#39;,
        &#39;2.16.840.1.101.3.4.1.46&#39;    : &#39;aes256-GCM&#39;,
        &#39;1.2.840.113549.1.9.16.1.4&#39;  : &#39;timestampToken&#39;,
        &#39;1.2.840.113549.1.9.16.2.12&#39; : &#39;signingCertificate&#39;,
        &#39;0.9.2342.19200300.100.1.1&#39;  : &#39;uid&#39;,
        &#39;0.9.2342.19200300.100.1.25&#39; : &#39;domainComponent&#39;,
        &#39;1.3.6.1.4.1.311.20.2.3&#39;     : &#39;userPrincipalName&#39;,
        &#39;1.3.6.1.4.1.311.60.2.1.3&#39;   : &#39;jurisdictionCountry&#39;,
        &#39;1.2.840.113549.2.7&#39;         : &#39;hmacWithSHA1&#39;,
        &#39;1.2.840.113549.2.9&#39;         : &#39;hmacWithSHA256&#39;,
        &#39;1.2.840.113549.2.10&#39;        : &#39;hmacWithSHA384&#39;,
        &#39;1.2.840.113549.2.11&#39;        : &#39;hmacWithSHA512&#39;,
    }

    _OID_NAMES_REV = {v: k for k, v in _OID_NAMES.items()}

    def _read_tag(self) -&gt; tuple[int, bool, int]:
        b = self.u8()
        tag_class = (b &gt;&gt; 6) &amp; 3
        constructed = bool(b &amp; 0x20)
        tag_number = b &amp; 0x1F
        if tag_number == 0x1F:
            tag_number = 0
            while True:
                b = self.u8()
                tag_number = (tag_number &lt;&lt; 7) | (b &amp; 0x7F)
                if not (b &amp; 0x80):
                    break
        return tag_class, constructed, tag_number

    def _read_length(self) -&gt; int:
        b = self.u8()
        if b &lt; 0x80:
            return b
        if b == 0x80:
            return -1
        n = b &amp; 0x7F
        length = 0
        for _ in range(n):
            length = (length &lt;&lt; 8) | self.u8()
        return length

    def _read_children(self, length: int) -&gt; list[ASN1Value]:
        if length &lt; 0:
            children: list[ASN1Value] = []
            while True:
                item = self.read_tlv()
                if item is self._EOC:
                    break
                children.append(item)
            return children
        end = self.tell() + length
        children = []
        while self.tell() &lt; end:
            children.append(self.read_tlv())
        return children

    @staticmethod
    def _try_decode_nested(data: bytes) -&gt; ASN1Value | None:
        if len(data) &lt; 2:
            return None
        try:
            reader = ASN1Reader(memoryview(data), bigendian=True)
            result = reader.read_tlv()
            if result is not reader._EOC and reader.remaining_bytes == 0:
                return result
        except Exception:
            pass
        return None

    @classmethod
    def _decode_oid(cls, data: bytes | memoryview) -&gt; str:
        subids: list[int] = []
        value = 0
        for b in data:
            value = (value &lt;&lt; 7) | (b &amp; 0x7F)
            if not (b &amp; 0x80):
                subids.append(value)
                value = 0
        if not subids:
            return &#39;&#39;
        first = subids[0]
        if first &lt; 40:
            components = [0, first]
        elif first &lt; 80:
            components = [1, first - 40]
        else:
            components = [2, first - 80]
        components.extend(subids[1:])
        dotted = &#39;.&#39;.join(str(c) for c in components)
        return cls._OID_NAMES.get(dotted, dotted)

    @staticmethod
    def _decode_relative_oid(data: bytes | memoryview) -&gt; str:
        subids: list[int] = []
        value = 0
        for b in data:
            value = (value &lt;&lt; 7) | (b &amp; 0x7F)
            if not (b &amp; 0x80):
                subids.append(value)
                value = 0
        return &#39;.&#39;.join(str(c) for c in subids)

    @staticmethod
    def _decode_real(content: bytes | memoryview) -&gt; float:
        if not content:
            return 0.0
        fb = content[0]
        if fb == 0x40:
            return float(&#39;inf&#39;)
        if fb == 0x41:
            return float(&#39;-inf&#39;)
        if fb &amp; 0x80:
            sign = -1 if (fb &amp; 0x40) else 1
            base = [2, 8, 16, 2][(fb &gt;&gt; 4) &amp; 3]
            scale = (fb &gt;&gt; 2) &amp; 3
            ef = fb &amp; 3
            idx = 1
            if ef &lt; 3:
                elen = ef + 1
            else:
                elen = content[idx]
                idx += 1
            exp = int.from_bytes(content[idx:idx + elen], &#39;big&#39;, signed=True)
            idx += elen
            n = int.from_bytes(content[idx:], &#39;big&#39;, signed=False)
            return float(sign * n * (2 ** scale) * (base ** exp))
        return float(codecs.decode(content[1:], &#39;ascii&#39;))

    def _decode_universal_primitive(self, tag_number: int, content: bytes | memoryview) -&gt; ASN1Value:
        if tag_number == 1:  # BOOLEAN
            return bool(content[-1]) if content else False
        if tag_number == 2:  # INTEGER
            return int.from_bytes(content, &#39;big&#39;, signed=True) if content else 0
        if tag_number == 3:  # BIT STRING
            if not content:
                return b&#39;&#39;
            unused = content[0]
            payload = bytes(content[1:])
            if unused == 0:
                nested = self._try_decode_nested(payload)
                if nested is not None:
                    return nested
            return payload
        if tag_number == 4:  # OCTET STRING
            content = bytes(content)
            nested = self._try_decode_nested(content)
            return nested if nested is not None else content
        if tag_number == 5:  # NULL
            return None
        if tag_number == 6:  # OBJECT IDENTIFIER
            return self._decode_oid(content)
        if tag_number == 9:  # REAL
            return self._decode_real(content)
        if tag_number == 10:  # ENUMERATED
            return int.from_bytes(content, &#39;big&#39;, signed=True) if content else 0
        if tag_number == 13:  # RELATIVE-OID
            return self._decode_relative_oid(content)
        enc = self._STRING_ENCODINGS.get(tag_number)
        if enc is not None:
            return bytes(content).decode(enc)
        return bytes(content)

    @staticmethod
    def _unwrap_single(children: list) -&gt; ASN1Value:
        if len(children) == 1 and isinstance(children[0], (list, dict)):
            return children[0]
        return children

    def read_tlv(self) -&gt; ASN1Value:
        tag_class, constructed, tag_number = self._read_tag()

        if tag_class == 0 and not constructed and tag_number == 0:
            self._read_length()
            return self._EOC

        length = self._read_length()

        if tag_class == 0:
            if constructed:
                return self._unwrap_single(self._read_children(length))
            content = bytes(self.read_exactly(length)) if length &gt; 0 else b&#39;&#39;
            return self._decode_universal_primitive(tag_number, content)

        if constructed:
            value = self._unwrap_single(self._read_children(length))
        else:
            content = bytes(self.read_exactly(length)) if length &gt; 0 else b&#39;&#39;
            nested = self._try_decode_nested(content)
            value = nested if nested is not None else content

        return {&#39;tag&#39;: F&#39;{self._TAG_CLASS_NAMES[tag_class]}-{tag_number}&#39;, &#39;value&#39;: value}

    def _expected_tag(self, schema_type: SchemaType) -&gt; tuple[int, bool, int] | None:
        if schema_type is ANY:
            return None
        if isinstance(schema_type, int):
            constructed = schema_type in (SEQUENCE, SET)
            return (CLASS_UNIVERSAL, constructed, schema_type)
        if isinstance(schema_type, Seq):
            return (CLASS_UNIVERSAL, True, SEQUENCE)
        if isinstance(schema_type, SeqOf):
            return (CLASS_UNIVERSAL, True, SEQUENCE)
        if isinstance(schema_type, SetOf):
            return (CLASS_UNIVERSAL, True, SET)
        if isinstance(schema_type, Choice):
            return None
        return None

    def _decode_schema_primitive(self, tag_number: int, length: int) -&gt; ASN1Value:
        content = bytes(self.read_exactly(length)) if length &gt; 0 else b&#39;&#39;
        return self._decode_universal_primitive(tag_number, content)

    def _decode_constructed_children(self, length: int, element_schema: SchemaType) -&gt; list[ASN1Value]:
        end = self.tell() + length
        children: list[ASN1Value] = []
        while self.tell() &lt; end:
            children.append(self.decode_with_schema(element_schema))
        if isinstance(element_schema, (SetOf, SeqOf)):
            return [item for child in children for item in child]
        return children

    def _decode_seq(self, schema: Seq, length: int) -&gt; OrderedDict[str, ASN1Value]:
        end = self.tell() + length
        result: OrderedDict[str, ASN1Value] = OrderedDict()

        for field in schema.fields:
            if self.tell() &gt;= end:
                if field.optional:
                    if field.default is not _MISSING:
                        result[field.name] = field.default
                    continue
                raise ASN1SchemaMismatch(
                    F&#39;required field {field.name!r} missing: no more data&#39;)

            pos = self.tell()
            tag_class, constructed, tag_number = self._read_tag()
            fld_length = self._read_length()

            matched = False
            value: ASN1Value = None

            if field.explicit is not None:
                if tag_class == field.tag_class and tag_number == field.explicit and constructed:
                    value = self.decode_with_schema(field.type)
                    matched = True
            elif field.implicit is not None:
                if tag_class == field.tag_class and tag_number == field.implicit:
                    value = self._decode_implicit(field.type, fld_length, constructed)
                    matched = True
            else:
                expected = self._expected_tag(field.type)
                if expected is None:
                    self.seekrel(-self.tell() + pos)
                    if isinstance(field.type, Choice):
                        value = self._decode_choice(field.type, end)
                    else:
                        value = self.read_tlv()
                    matched = True
                elif (tag_class, constructed, tag_number) == expected:
                    value = self._decode_typed_body(field.type, fld_length, constructed)
                    matched = True

            if not matched:
                self.seekrel(-self.tell() + pos)
                if field.optional:
                    if field.default is not _MISSING:
                        result[field.name] = field.default
                    continue
                raise ASN1SchemaMismatch(
                    F&#39;required field {field.name!r}: expected tag mismatch&#39;)

            result[field.name] = value

        return result

    def _decode_implicit(self, schema_type: SchemaType, length: int, constructed: bool) -&gt; ASN1Value:
        if isinstance(schema_type, int):
            if schema_type in (SEQUENCE, SET):
                return self._decode_constructed_children(length, ANY)
            return self._decode_schema_primitive(schema_type, length)
        if isinstance(schema_type, Seq):
            return self._decode_seq(schema_type, length)
        if isinstance(schema_type, SeqOf):
            return self._decode_constructed_children(length, schema_type.element)
        if isinstance(schema_type, SetOf):
            return self._decode_constructed_children(length, schema_type.element)
        content = bytes(self.read_exactly(length)) if length &gt; 0 else b&#39;&#39;
        nested = self._try_decode_nested(content)
        return nested if nested is not None else content

    def _decode_typed_body(self, schema_type: SchemaType, length: int, constructed: bool) -&gt; ASN1Value:
        if isinstance(schema_type, int):
            if constructed:
                return self._read_children(length)
            return self._decode_schema_primitive(schema_type, length)
        if isinstance(schema_type, Seq):
            return self._decode_seq(schema_type, length)
        if isinstance(schema_type, SeqOf):
            return self._decode_constructed_children(length, schema_type.element)
        if isinstance(schema_type, SetOf):
            return self._decode_constructed_children(length, schema_type.element)
        if constructed:
            return self._read_children(length)
        content = bytes(self.read_exactly(length)) if length &gt; 0 else b&#39;&#39;
        return self._decode_universal_primitive(0, content)

    def _decode_choice(self, schema: Choice, end: int | None = None) -&gt; ASN1Value:
        pos = self.tell()
        tag_class, constructed, tag_number = self._read_tag()
        fld_length = self._read_length()

        has_untagged = False
        for alt in schema.alternatives:
            if alt.explicit is not None:
                if tag_class == alt.tag_class and tag_number == alt.explicit and constructed:
                    return self.decode_with_schema(alt.type)
            elif alt.implicit is not None:
                if tag_class == alt.tag_class and tag_number == alt.implicit:
                    return self._decode_implicit(alt.type, fld_length, constructed)
            else:
                has_untagged = True
                expected = self._expected_tag(alt.type)
                if expected is None or (tag_class, constructed, tag_number) == expected:
                    return self._decode_typed_body(alt.type, fld_length, constructed)

        if not has_untagged:
            raise ASN1SchemaMismatch(
                F&#39;no CHOICE alternative matched: class={tag_class} number={tag_number}&#39;)

        self.seekrel(-self.tell() + pos)
        return self.read_tlv()

    def decode_with_schema(self, schema: SchemaType) -&gt; ASN1Value:
        if schema is ANY:
            return self.read_tlv()

        if isinstance(schema, int):
            tag_class, constructed, tag_number = self._read_tag()
            length = self._read_length()
            if tag_class != CLASS_UNIVERSAL or tag_number != schema:
                raise ASN1SchemaMismatch(
                    F&#39;expected universal tag {schema}, got class={tag_class} number={tag_number}&#39;)
            return self._decode_typed_body(schema, length, constructed)

        if isinstance(schema, Seq):
            tag_class, constructed, tag_number = self._read_tag()
            length = self._read_length()
            if tag_class != CLASS_UNIVERSAL or tag_number != SEQUENCE or not constructed:
                raise ASN1SchemaMismatch(
                    F&#39;expected SEQUENCE, got class={tag_class} constructed={constructed} number={tag_number}&#39;)
            return self._decode_seq(schema, length)

        if isinstance(schema, SeqOf):
            tag_class, constructed, tag_number = self._read_tag()
            length = self._read_length()
            if tag_class != CLASS_UNIVERSAL or tag_number != SEQUENCE or not constructed:
                raise ASN1SchemaMismatch(&#39;expected SEQUENCE OF&#39;)
            return self._decode_constructed_children(length, schema.element)

        if isinstance(schema, SetOf):
            tag_class, constructed, tag_number = self._read_tag()
            length = self._read_length()
            if tag_class != CLASS_UNIVERSAL or tag_number != SET or not constructed:
                raise ASN1SchemaMismatch(&#39;expected SET OF&#39;)
            return self._decode_constructed_children(length, schema.element)

        if isinstance(schema, Choice):
            return self._decode_choice(schema)

        raise ASN1SchemaMismatch(F&#39;unknown schema type: {type(schema)}&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.asn1.reader.ASN1Reader"><code class="flex name class">
<span>class <span class="ident">ASN1Reader</span></span>
<span>(</span><span>data, bigendian=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An extension of a <code><a title="refinery.lib.structures.MemoryFile" href="../structures.html#refinery.lib.structures.MemoryFile">MemoryFile</a></code> which provides methods to read
structured data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/asn1/reader.py#L39-L525" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ASN1Reader(StructReader[memoryview]):

    _EOC = object()

    _STRING_ENCODINGS = {
        12: &#39;utf-8&#39;,      # UTF8String
        18: &#39;ascii&#39;,      # NumericString
        19: &#39;ascii&#39;,      # PrintableString
        20: &#39;latin-1&#39;,    # T61String / TeletexString
        22: &#39;ascii&#39;,      # IA5String
        23: &#39;ascii&#39;,      # UTCTime
        24: &#39;ascii&#39;,      # GeneralizedTime
        25: &#39;latin-1&#39;,    # GraphicString
        26: &#39;ascii&#39;,      # VisibleString / ISO646String
        27: &#39;latin-1&#39;,    # GeneralString
        28: &#39;utf-32-be&#39;,  # UniversalString
        30: &#39;utf-16-be&#39;,  # BMPString
    }

    _TAG_CLASS_NAMES = (&#39;universal&#39;, &#39;application&#39;, &#39;context&#39;, &#39;private&#39;)

    _OID_NAMES = {
        &#39;2.5.4.3&#39;                    : &#39;commonName&#39;,
        &#39;2.5.4.4&#39;                    : &#39;surname&#39;,
        &#39;2.5.4.5&#39;                    : &#39;serialNumber&#39;,
        &#39;2.5.4.6&#39;                    : &#39;countryName&#39;,
        &#39;2.5.4.7&#39;                    : &#39;localityName&#39;,
        &#39;2.5.4.8&#39;                    : &#39;stateOrProvinceName&#39;,
        &#39;2.5.4.9&#39;                    : &#39;streetAddress&#39;,
        &#39;2.5.4.10&#39;                   : &#39;organizationName&#39;,
        &#39;2.5.4.11&#39;                   : &#39;organizationalUnitName&#39;,
        &#39;2.5.4.12&#39;                   : &#39;title&#39;,
        &#39;2.5.4.17&#39;                   : &#39;postalCode&#39;,
        &#39;2.5.4.42&#39;                   : &#39;givenName&#39;,
        &#39;2.5.4.43&#39;                   : &#39;initials&#39;,
        &#39;2.5.4.46&#39;                   : &#39;dnQualifier&#39;,
        &#39;2.5.4.65&#39;                   : &#39;pseudonym&#39;,
        &#39;2.5.29.14&#39;                  : &#39;subjectKeyIdentifier&#39;,
        &#39;2.5.29.15&#39;                  : &#39;keyUsage&#39;,
        &#39;2.5.29.17&#39;                  : &#39;subjectAltName&#39;,
        &#39;2.5.29.18&#39;                  : &#39;issuerAltName&#39;,
        &#39;2.5.29.19&#39;                  : &#39;basicConstraints&#39;,
        &#39;2.5.29.20&#39;                  : &#39;cRLNumber&#39;,
        &#39;2.5.29.21&#39;                  : &#39;cRLReason&#39;,
        &#39;2.5.29.31&#39;                  : &#39;cRLDistributionPoints&#39;,
        &#39;2.5.29.32&#39;                  : &#39;certificatePolicies&#39;,
        &#39;2.5.29.33&#39;                  : &#39;policyMappings&#39;,
        &#39;2.5.29.35&#39;                  : &#39;authorityKeyIdentifier&#39;,
        &#39;2.5.29.36&#39;                  : &#39;policyConstraints&#39;,
        &#39;2.5.29.37&#39;                  : &#39;extKeyUsage&#39;,
        &#39;2.5.29.46&#39;                  : &#39;freshestCRL&#39;,
        &#39;2.5.29.54&#39;                  : &#39;inhibitAnyPolicy&#39;,
        &#39;1.3.6.1.5.5.7.1.1&#39;          : &#39;authorityInfoAccess&#39;,
        &#39;1.3.6.1.5.5.7.1.11&#39;         : &#39;subjectInfoAccess&#39;,
        &#39;1.3.6.1.5.5.7.48.1&#39;         : &#39;ocsp&#39;,
        &#39;1.3.6.1.5.5.7.48.2&#39;         : &#39;caIssuers&#39;,
        &#39;1.3.6.1.5.5.7.3.1&#39;          : &#39;serverAuth&#39;,
        &#39;1.3.6.1.5.5.7.3.2&#39;          : &#39;clientAuth&#39;,
        &#39;1.3.6.1.5.5.7.3.3&#39;          : &#39;codeSigning&#39;,
        &#39;1.3.6.1.5.5.7.3.4&#39;          : &#39;emailProtection&#39;,
        &#39;1.3.6.1.5.5.7.3.8&#39;          : &#39;timeStamping&#39;,
        &#39;1.3.6.1.5.5.7.3.9&#39;          : &#39;ocspSigning&#39;,
        &#39;1.2.840.113549.1.1.1&#39;       : &#39;rsaEncryption&#39;,
        &#39;1.2.840.113549.1.1.5&#39;       : &#39;sha1WithRSAEncryption&#39;,
        &#39;1.2.840.113549.1.1.7&#39;       : &#39;rsaOAEP&#39;,
        &#39;1.2.840.113549.1.1.8&#39;       : &#39;sha256WithRSAEncryption-mgf1&#39;,
        &#39;1.2.840.113549.1.1.10&#39;      : &#39;rsaPSS&#39;,
        &#39;1.2.840.113549.1.1.11&#39;      : &#39;sha256WithRSAEncryption&#39;,
        &#39;1.2.840.113549.1.1.12&#39;      : &#39;sha384WithRSAEncryption&#39;,
        &#39;1.2.840.113549.1.1.13&#39;      : &#39;sha512WithRSAEncryption&#39;,
        &#39;1.2.840.113549.1.1.14&#39;      : &#39;sha224WithRSAEncryption&#39;,
        &#39;1.2.840.10045.2.1&#39;          : &#39;ecPublicKey&#39;,
        &#39;1.2.840.10045.4.3.1&#39;        : &#39;ecdsaWithSHA224&#39;,
        &#39;1.2.840.10045.4.3.2&#39;        : &#39;ecdsaWithSHA256&#39;,
        &#39;1.2.840.10045.4.3.3&#39;        : &#39;ecdsaWithSHA384&#39;,
        &#39;1.2.840.10045.4.3.4&#39;        : &#39;ecdsaWithSHA512&#39;,
        &#39;1.3.101.110&#39;                : &#39;x25519&#39;,
        &#39;1.3.101.111&#39;                : &#39;x448&#39;,
        &#39;1.3.101.112&#39;                : &#39;ed25519&#39;,
        &#39;1.3.101.113&#39;                : &#39;ed448&#39;,
        &#39;1.2.840.10045.3.1.7&#39;        : &#39;secp256r1&#39;,
        &#39;1.3.132.0.34&#39;               : &#39;secp384r1&#39;,
        &#39;1.3.132.0.35&#39;               : &#39;secp521r1&#39;,
        &#39;1.3.132.0.10&#39;               : &#39;secp256k1&#39;,
        &#39;1.3.14.3.2.26&#39;              : &#39;sha1&#39;,
        &#39;2.16.840.1.101.3.4.2.1&#39;     : &#39;sha256&#39;,
        &#39;2.16.840.1.101.3.4.2.2&#39;     : &#39;sha384&#39;,
        &#39;2.16.840.1.101.3.4.2.3&#39;     : &#39;sha512&#39;,
        &#39;2.16.840.1.101.3.4.2.4&#39;     : &#39;sha224&#39;,
        &#39;2.16.840.1.101.3.4.2.6&#39;     : &#39;sha512-256&#39;,
        &#39;2.16.840.1.101.3.4.2.8&#39;     : &#39;sha3-256&#39;,
        &#39;2.16.840.1.101.3.4.2.9&#39;     : &#39;sha3-384&#39;,
        &#39;2.16.840.1.101.3.4.2.10&#39;    : &#39;sha3-512&#39;,
        &#39;1.2.840.113549.1.7.1&#39;       : &#39;data&#39;,
        &#39;1.2.840.113549.1.7.2&#39;       : &#39;signedData&#39;,
        &#39;1.2.840.113549.1.7.3&#39;       : &#39;envelopedData&#39;,
        &#39;1.2.840.113549.1.7.5&#39;       : &#39;digestedData&#39;,
        &#39;1.2.840.113549.1.7.6&#39;       : &#39;encryptedData&#39;,
        &#39;1.2.840.113549.1.9.1&#39;       : &#39;emailAddress&#39;,
        &#39;1.2.840.113549.1.9.2&#39;       : &#39;unstructuredName&#39;,
        &#39;1.2.840.113549.1.9.3&#39;       : &#39;contentType&#39;,
        &#39;1.2.840.113549.1.9.4&#39;       : &#39;messageDigest&#39;,
        &#39;1.2.840.113549.1.9.5&#39;       : &#39;signingTime&#39;,
        &#39;1.2.840.113549.1.9.14&#39;      : &#39;extensionRequest&#39;,
        &#39;1.2.840.113549.1.9.15&#39;      : &#39;smimeCapabilities&#39;,
        &#39;1.2.840.113549.1.12.1.3&#39;    : &#39;pbeWithSHAAnd3KeyTripleDES&#39;,
        &#39;1.2.840.113549.1.12.1.6&#39;    : &#39;pbeWithSHAAnd40BitRC2&#39;,
        &#39;1.2.840.113549.1.12.10.1.1&#39; : &#39;keyBag&#39;,
        &#39;1.2.840.113549.1.12.10.1.2&#39; : &#39;pkcs8ShroudedKeyBag&#39;,
        &#39;1.2.840.113549.1.12.10.1.3&#39; : &#39;certBag&#39;,
        &#39;1.2.840.113549.1.12.10.1.5&#39; : &#39;secretBag&#39;,
        &#39;1.2.840.113549.1.12.10.1.6&#39; : &#39;safeContentsBag&#39;,
        &#39;2.16.840.1.101.3.4.1.2&#39;     : &#39;aes128-CBC&#39;,
        &#39;2.16.840.1.101.3.4.1.6&#39;     : &#39;aes128-GCM&#39;,
        &#39;2.16.840.1.101.3.4.1.22&#39;    : &#39;aes192-CBC&#39;,
        &#39;2.16.840.1.101.3.4.1.26&#39;    : &#39;aes192-GCM&#39;,
        &#39;2.16.840.1.101.3.4.1.42&#39;    : &#39;aes256-CBC&#39;,
        &#39;2.16.840.1.101.3.4.1.46&#39;    : &#39;aes256-GCM&#39;,
        &#39;1.2.840.113549.1.9.16.1.4&#39;  : &#39;timestampToken&#39;,
        &#39;1.2.840.113549.1.9.16.2.12&#39; : &#39;signingCertificate&#39;,
        &#39;0.9.2342.19200300.100.1.1&#39;  : &#39;uid&#39;,
        &#39;0.9.2342.19200300.100.1.25&#39; : &#39;domainComponent&#39;,
        &#39;1.3.6.1.4.1.311.20.2.3&#39;     : &#39;userPrincipalName&#39;,
        &#39;1.3.6.1.4.1.311.60.2.1.3&#39;   : &#39;jurisdictionCountry&#39;,
        &#39;1.2.840.113549.2.7&#39;         : &#39;hmacWithSHA1&#39;,
        &#39;1.2.840.113549.2.9&#39;         : &#39;hmacWithSHA256&#39;,
        &#39;1.2.840.113549.2.10&#39;        : &#39;hmacWithSHA384&#39;,
        &#39;1.2.840.113549.2.11&#39;        : &#39;hmacWithSHA512&#39;,
    }

    _OID_NAMES_REV = {v: k for k, v in _OID_NAMES.items()}

    def _read_tag(self) -&gt; tuple[int, bool, int]:
        b = self.u8()
        tag_class = (b &gt;&gt; 6) &amp; 3
        constructed = bool(b &amp; 0x20)
        tag_number = b &amp; 0x1F
        if tag_number == 0x1F:
            tag_number = 0
            while True:
                b = self.u8()
                tag_number = (tag_number &lt;&lt; 7) | (b &amp; 0x7F)
                if not (b &amp; 0x80):
                    break
        return tag_class, constructed, tag_number

    def _read_length(self) -&gt; int:
        b = self.u8()
        if b &lt; 0x80:
            return b
        if b == 0x80:
            return -1
        n = b &amp; 0x7F
        length = 0
        for _ in range(n):
            length = (length &lt;&lt; 8) | self.u8()
        return length

    def _read_children(self, length: int) -&gt; list[ASN1Value]:
        if length &lt; 0:
            children: list[ASN1Value] = []
            while True:
                item = self.read_tlv()
                if item is self._EOC:
                    break
                children.append(item)
            return children
        end = self.tell() + length
        children = []
        while self.tell() &lt; end:
            children.append(self.read_tlv())
        return children

    @staticmethod
    def _try_decode_nested(data: bytes) -&gt; ASN1Value | None:
        if len(data) &lt; 2:
            return None
        try:
            reader = ASN1Reader(memoryview(data), bigendian=True)
            result = reader.read_tlv()
            if result is not reader._EOC and reader.remaining_bytes == 0:
                return result
        except Exception:
            pass
        return None

    @classmethod
    def _decode_oid(cls, data: bytes | memoryview) -&gt; str:
        subids: list[int] = []
        value = 0
        for b in data:
            value = (value &lt;&lt; 7) | (b &amp; 0x7F)
            if not (b &amp; 0x80):
                subids.append(value)
                value = 0
        if not subids:
            return &#39;&#39;
        first = subids[0]
        if first &lt; 40:
            components = [0, first]
        elif first &lt; 80:
            components = [1, first - 40]
        else:
            components = [2, first - 80]
        components.extend(subids[1:])
        dotted = &#39;.&#39;.join(str(c) for c in components)
        return cls._OID_NAMES.get(dotted, dotted)

    @staticmethod
    def _decode_relative_oid(data: bytes | memoryview) -&gt; str:
        subids: list[int] = []
        value = 0
        for b in data:
            value = (value &lt;&lt; 7) | (b &amp; 0x7F)
            if not (b &amp; 0x80):
                subids.append(value)
                value = 0
        return &#39;.&#39;.join(str(c) for c in subids)

    @staticmethod
    def _decode_real(content: bytes | memoryview) -&gt; float:
        if not content:
            return 0.0
        fb = content[0]
        if fb == 0x40:
            return float(&#39;inf&#39;)
        if fb == 0x41:
            return float(&#39;-inf&#39;)
        if fb &amp; 0x80:
            sign = -1 if (fb &amp; 0x40) else 1
            base = [2, 8, 16, 2][(fb &gt;&gt; 4) &amp; 3]
            scale = (fb &gt;&gt; 2) &amp; 3
            ef = fb &amp; 3
            idx = 1
            if ef &lt; 3:
                elen = ef + 1
            else:
                elen = content[idx]
                idx += 1
            exp = int.from_bytes(content[idx:idx + elen], &#39;big&#39;, signed=True)
            idx += elen
            n = int.from_bytes(content[idx:], &#39;big&#39;, signed=False)
            return float(sign * n * (2 ** scale) * (base ** exp))
        return float(codecs.decode(content[1:], &#39;ascii&#39;))

    def _decode_universal_primitive(self, tag_number: int, content: bytes | memoryview) -&gt; ASN1Value:
        if tag_number == 1:  # BOOLEAN
            return bool(content[-1]) if content else False
        if tag_number == 2:  # INTEGER
            return int.from_bytes(content, &#39;big&#39;, signed=True) if content else 0
        if tag_number == 3:  # BIT STRING
            if not content:
                return b&#39;&#39;
            unused = content[0]
            payload = bytes(content[1:])
            if unused == 0:
                nested = self._try_decode_nested(payload)
                if nested is not None:
                    return nested
            return payload
        if tag_number == 4:  # OCTET STRING
            content = bytes(content)
            nested = self._try_decode_nested(content)
            return nested if nested is not None else content
        if tag_number == 5:  # NULL
            return None
        if tag_number == 6:  # OBJECT IDENTIFIER
            return self._decode_oid(content)
        if tag_number == 9:  # REAL
            return self._decode_real(content)
        if tag_number == 10:  # ENUMERATED
            return int.from_bytes(content, &#39;big&#39;, signed=True) if content else 0
        if tag_number == 13:  # RELATIVE-OID
            return self._decode_relative_oid(content)
        enc = self._STRING_ENCODINGS.get(tag_number)
        if enc is not None:
            return bytes(content).decode(enc)
        return bytes(content)

    @staticmethod
    def _unwrap_single(children: list) -&gt; ASN1Value:
        if len(children) == 1 and isinstance(children[0], (list, dict)):
            return children[0]
        return children

    def read_tlv(self) -&gt; ASN1Value:
        tag_class, constructed, tag_number = self._read_tag()

        if tag_class == 0 and not constructed and tag_number == 0:
            self._read_length()
            return self._EOC

        length = self._read_length()

        if tag_class == 0:
            if constructed:
                return self._unwrap_single(self._read_children(length))
            content = bytes(self.read_exactly(length)) if length &gt; 0 else b&#39;&#39;
            return self._decode_universal_primitive(tag_number, content)

        if constructed:
            value = self._unwrap_single(self._read_children(length))
        else:
            content = bytes(self.read_exactly(length)) if length &gt; 0 else b&#39;&#39;
            nested = self._try_decode_nested(content)
            value = nested if nested is not None else content

        return {&#39;tag&#39;: F&#39;{self._TAG_CLASS_NAMES[tag_class]}-{tag_number}&#39;, &#39;value&#39;: value}

    def _expected_tag(self, schema_type: SchemaType) -&gt; tuple[int, bool, int] | None:
        if schema_type is ANY:
            return None
        if isinstance(schema_type, int):
            constructed = schema_type in (SEQUENCE, SET)
            return (CLASS_UNIVERSAL, constructed, schema_type)
        if isinstance(schema_type, Seq):
            return (CLASS_UNIVERSAL, True, SEQUENCE)
        if isinstance(schema_type, SeqOf):
            return (CLASS_UNIVERSAL, True, SEQUENCE)
        if isinstance(schema_type, SetOf):
            return (CLASS_UNIVERSAL, True, SET)
        if isinstance(schema_type, Choice):
            return None
        return None

    def _decode_schema_primitive(self, tag_number: int, length: int) -&gt; ASN1Value:
        content = bytes(self.read_exactly(length)) if length &gt; 0 else b&#39;&#39;
        return self._decode_universal_primitive(tag_number, content)

    def _decode_constructed_children(self, length: int, element_schema: SchemaType) -&gt; list[ASN1Value]:
        end = self.tell() + length
        children: list[ASN1Value] = []
        while self.tell() &lt; end:
            children.append(self.decode_with_schema(element_schema))
        if isinstance(element_schema, (SetOf, SeqOf)):
            return [item for child in children for item in child]
        return children

    def _decode_seq(self, schema: Seq, length: int) -&gt; OrderedDict[str, ASN1Value]:
        end = self.tell() + length
        result: OrderedDict[str, ASN1Value] = OrderedDict()

        for field in schema.fields:
            if self.tell() &gt;= end:
                if field.optional:
                    if field.default is not _MISSING:
                        result[field.name] = field.default
                    continue
                raise ASN1SchemaMismatch(
                    F&#39;required field {field.name!r} missing: no more data&#39;)

            pos = self.tell()
            tag_class, constructed, tag_number = self._read_tag()
            fld_length = self._read_length()

            matched = False
            value: ASN1Value = None

            if field.explicit is not None:
                if tag_class == field.tag_class and tag_number == field.explicit and constructed:
                    value = self.decode_with_schema(field.type)
                    matched = True
            elif field.implicit is not None:
                if tag_class == field.tag_class and tag_number == field.implicit:
                    value = self._decode_implicit(field.type, fld_length, constructed)
                    matched = True
            else:
                expected = self._expected_tag(field.type)
                if expected is None:
                    self.seekrel(-self.tell() + pos)
                    if isinstance(field.type, Choice):
                        value = self._decode_choice(field.type, end)
                    else:
                        value = self.read_tlv()
                    matched = True
                elif (tag_class, constructed, tag_number) == expected:
                    value = self._decode_typed_body(field.type, fld_length, constructed)
                    matched = True

            if not matched:
                self.seekrel(-self.tell() + pos)
                if field.optional:
                    if field.default is not _MISSING:
                        result[field.name] = field.default
                    continue
                raise ASN1SchemaMismatch(
                    F&#39;required field {field.name!r}: expected tag mismatch&#39;)

            result[field.name] = value

        return result

    def _decode_implicit(self, schema_type: SchemaType, length: int, constructed: bool) -&gt; ASN1Value:
        if isinstance(schema_type, int):
            if schema_type in (SEQUENCE, SET):
                return self._decode_constructed_children(length, ANY)
            return self._decode_schema_primitive(schema_type, length)
        if isinstance(schema_type, Seq):
            return self._decode_seq(schema_type, length)
        if isinstance(schema_type, SeqOf):
            return self._decode_constructed_children(length, schema_type.element)
        if isinstance(schema_type, SetOf):
            return self._decode_constructed_children(length, schema_type.element)
        content = bytes(self.read_exactly(length)) if length &gt; 0 else b&#39;&#39;
        nested = self._try_decode_nested(content)
        return nested if nested is not None else content

    def _decode_typed_body(self, schema_type: SchemaType, length: int, constructed: bool) -&gt; ASN1Value:
        if isinstance(schema_type, int):
            if constructed:
                return self._read_children(length)
            return self._decode_schema_primitive(schema_type, length)
        if isinstance(schema_type, Seq):
            return self._decode_seq(schema_type, length)
        if isinstance(schema_type, SeqOf):
            return self._decode_constructed_children(length, schema_type.element)
        if isinstance(schema_type, SetOf):
            return self._decode_constructed_children(length, schema_type.element)
        if constructed:
            return self._read_children(length)
        content = bytes(self.read_exactly(length)) if length &gt; 0 else b&#39;&#39;
        return self._decode_universal_primitive(0, content)

    def _decode_choice(self, schema: Choice, end: int | None = None) -&gt; ASN1Value:
        pos = self.tell()
        tag_class, constructed, tag_number = self._read_tag()
        fld_length = self._read_length()

        has_untagged = False
        for alt in schema.alternatives:
            if alt.explicit is not None:
                if tag_class == alt.tag_class and tag_number == alt.explicit and constructed:
                    return self.decode_with_schema(alt.type)
            elif alt.implicit is not None:
                if tag_class == alt.tag_class and tag_number == alt.implicit:
                    return self._decode_implicit(alt.type, fld_length, constructed)
            else:
                has_untagged = True
                expected = self._expected_tag(alt.type)
                if expected is None or (tag_class, constructed, tag_number) == expected:
                    return self._decode_typed_body(alt.type, fld_length, constructed)

        if not has_untagged:
            raise ASN1SchemaMismatch(
                F&#39;no CHOICE alternative matched: class={tag_class} number={tag_number}&#39;)

        self.seekrel(-self.tell() + pos)
        return self.read_tlv()

    def decode_with_schema(self, schema: SchemaType) -&gt; ASN1Value:
        if schema is ANY:
            return self.read_tlv()

        if isinstance(schema, int):
            tag_class, constructed, tag_number = self._read_tag()
            length = self._read_length()
            if tag_class != CLASS_UNIVERSAL or tag_number != schema:
                raise ASN1SchemaMismatch(
                    F&#39;expected universal tag {schema}, got class={tag_class} number={tag_number}&#39;)
            return self._decode_typed_body(schema, length, constructed)

        if isinstance(schema, Seq):
            tag_class, constructed, tag_number = self._read_tag()
            length = self._read_length()
            if tag_class != CLASS_UNIVERSAL or tag_number != SEQUENCE or not constructed:
                raise ASN1SchemaMismatch(
                    F&#39;expected SEQUENCE, got class={tag_class} constructed={constructed} number={tag_number}&#39;)
            return self._decode_seq(schema, length)

        if isinstance(schema, SeqOf):
            tag_class, constructed, tag_number = self._read_tag()
            length = self._read_length()
            if tag_class != CLASS_UNIVERSAL or tag_number != SEQUENCE or not constructed:
                raise ASN1SchemaMismatch(&#39;expected SEQUENCE OF&#39;)
            return self._decode_constructed_children(length, schema.element)

        if isinstance(schema, SetOf):
            tag_class, constructed, tag_number = self._read_tag()
            length = self._read_length()
            if tag_class != CLASS_UNIVERSAL or tag_number != SET or not constructed:
                raise ASN1SchemaMismatch(&#39;expected SET OF&#39;)
            return self._decode_constructed_children(length, schema.element)

        if isinstance(schema, Choice):
            return self._decode_choice(schema)

        raise ASN1SchemaMismatch(F&#39;unknown schema type: {type(schema)}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></li>
<li><a title="refinery.lib.structures.MemoryFile" href="../structures.html#refinery.lib.structures.MemoryFile">MemoryFile</a></li>
<li><a title="refinery.lib.structures.MemoryFileMethods" href="../structures.html#refinery.lib.structures.MemoryFileMethods">MemoryFileMethods</a></li>
<li>typing.Generic</li>
<li>_io.BytesIO</li>
<li>_io._BufferedIOBase</li>
<li>_io._IOBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.asn1.reader.ASN1Reader.read_tlv"><code class="name flex">
<span>def <span class="ident">read_tlv</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/asn1/reader.py#L324-L346" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_tlv(self) -&gt; ASN1Value:
    tag_class, constructed, tag_number = self._read_tag()

    if tag_class == 0 and not constructed and tag_number == 0:
        self._read_length()
        return self._EOC

    length = self._read_length()

    if tag_class == 0:
        if constructed:
            return self._unwrap_single(self._read_children(length))
        content = bytes(self.read_exactly(length)) if length &gt; 0 else b&#39;&#39;
        return self._decode_universal_primitive(tag_number, content)

    if constructed:
        value = self._unwrap_single(self._read_children(length))
    else:
        content = bytes(self.read_exactly(length)) if length &gt; 0 else b&#39;&#39;
        nested = self._try_decode_nested(content)
        value = nested if nested is not None else content

    return {&#39;tag&#39;: F&#39;{self._TAG_CLASS_NAMES[tag_class]}-{tag_number}&#39;, &#39;value&#39;: value}</code></pre>
</details>
</dd>
<dt id="refinery.lib.asn1.reader.ASN1Reader.decode_with_schema"><code class="name flex">
<span>def <span class="ident">decode_with_schema</span></span>(<span>self, schema)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/asn1/reader.py#L488-L525" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decode_with_schema(self, schema: SchemaType) -&gt; ASN1Value:
    if schema is ANY:
        return self.read_tlv()

    if isinstance(schema, int):
        tag_class, constructed, tag_number = self._read_tag()
        length = self._read_length()
        if tag_class != CLASS_UNIVERSAL or tag_number != schema:
            raise ASN1SchemaMismatch(
                F&#39;expected universal tag {schema}, got class={tag_class} number={tag_number}&#39;)
        return self._decode_typed_body(schema, length, constructed)

    if isinstance(schema, Seq):
        tag_class, constructed, tag_number = self._read_tag()
        length = self._read_length()
        if tag_class != CLASS_UNIVERSAL or tag_number != SEQUENCE or not constructed:
            raise ASN1SchemaMismatch(
                F&#39;expected SEQUENCE, got class={tag_class} constructed={constructed} number={tag_number}&#39;)
        return self._decode_seq(schema, length)

    if isinstance(schema, SeqOf):
        tag_class, constructed, tag_number = self._read_tag()
        length = self._read_length()
        if tag_class != CLASS_UNIVERSAL or tag_number != SEQUENCE or not constructed:
            raise ASN1SchemaMismatch(&#39;expected SEQUENCE OF&#39;)
        return self._decode_constructed_children(length, schema.element)

    if isinstance(schema, SetOf):
        tag_class, constructed, tag_number = self._read_tag()
        length = self._read_length()
        if tag_class != CLASS_UNIVERSAL or tag_number != SET or not constructed:
            raise ASN1SchemaMismatch(&#39;expected SET OF&#39;)
        return self._decode_constructed_children(length, schema.element)

    if isinstance(schema, Choice):
        return self._decode_choice(schema)

    raise ASN1SchemaMismatch(F&#39;unknown schema type: {type(schema)}&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.structures.StructReader.SEEK" href="../structures.html#refinery.lib.structures.MemoryFileMethods.SEEK">SEEK</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.Unaligned" href="../structures.html#refinery.lib.structures.StructReader.Unaligned">Unaligned</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.byte_align" href="../structures.html#refinery.lib.structures.StructReader.byte_align">byte_align</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bit_field" href="../structures.html#refinery.lib.structures.StructReader.read_bit_field">read_bit_field</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bits" href="../structures.html#refinery.lib.structures.StructReader.read_bits">read_bits</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_bytes" href="../structures.html#refinery.lib.structures.StructReader.read_bytes">read_bytes</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_exactly" href="../structures.html#refinery.lib.structures.StructReader.read_exactly">read_exactly</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_flags" href="../structures.html#refinery.lib.structures.StructReader.read_flags">read_flags</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_integer" href="../structures.html#refinery.lib.structures.StructReader.read_integer">read_integer</a></code></li>
<li><code><a title="refinery.lib.structures.StructReader.read_struct" href="../structures.html#refinery.lib.structures.StructReader.read_struct">read_struct</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib.asn1" href="index.html">refinery.lib.asn1</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.asn1.reader.ASN1Reader" href="#refinery.lib.asn1.reader.ASN1Reader">ASN1Reader</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.asn1.reader.ASN1Reader.read_tlv" href="#refinery.lib.asn1.reader.ASN1Reader.read_tlv">read_tlv</a></code></li>
<li><code><a title="refinery.lib.asn1.reader.ASN1Reader.decode_with_schema" href="#refinery.lib.asn1.reader.ASN1Reader.decode_with_schema">decode_with_schema</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
