<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.json documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.json</code></h1>
</header>
<section id="section-intro">
<p>In order to represent arbitrary data as JSON, these classes help extend the built-in
json module in order to support custom encoding of already serializable types.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/json.py#L1-L149" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
In order to represent arbitrary data as JSON, these classes help extend the built-in
json module in order to support custom encoding of already serializable types.
&#34;&#34;&#34;
from __future__ import annotations

import datetime
import json
import re
import uuid

from refinery.lib.types import buf


class JSONEncoderExMeta(type):
    &#34;&#34;&#34;
    This metaclass is the type of `refinery.lib.json.JSONEncoderEx` and exists in
    order to facilitate a context manager at the type level.
    &#34;&#34;&#34;

    def __enter__(cls):
        def _custom_isinstance(obj, tp):
            if cls.handled(obj):
                return False
            return isinstance(obj, tp)

        def mkiter(*args, **kwargs):
            kwargs.update(isinstance=_custom_isinstance)
            return cls._make_iterencode_old(*args, **kwargs)

        cls._make_iterencode_old = json.encoder._make_iterencode
        json.encoder._make_iterencode = mkiter
        return cls

    def __exit__(cls, etype, eval, tb):
        json.encoder._make_iterencode = cls._make_iterencode_old
        return False

    def dumps(cls, data, indent=4, **kwargs):
        kwargs.setdefault(&#39;cls&#39;, cls)
        return json.dumps(data, indent=indent, **kwargs)


class JSONEncoderEx(json.JSONEncoder, metaclass=JSONEncoderExMeta):
    &#34;&#34;&#34;
    Base class for JSON encoders used in refinery. Any such encoder can
    be used as a context which temporarily performs a monkey-patch of the
    built-in json module to allow custom encoding of already serializable
    types such as `list` or `dict`. This is done as follows:

        class MyEncoder(JSONEncoderEx):
            pass

        with MyEncoder as encoder:
            return encoder.dumps(data)
    &#34;&#34;&#34;
    def encode(self, obj):
        if isinstance(obj, dict) and not all(isinstance(k, str) for k in obj.keys()):
            def _encode(k):
                if isinstance(k, (bytes, bytearray, memoryview)):
                    try: return k.encode(&#39;ascii&#39;)
                    except Exception: pass
                return str(k)
            obj = {_encode(key): value for key, value in obj.items()}
        data = super().encode(obj)
        if self.substitute:
            uids = R&#39;&#39;&#39;([&#39;&#34;])({})\1&#39;&#39;&#39;.format(&#39;|&#39;.join(re.escape(u) for u in self.substitute))
            return re.sub(uids, lambda m: self.substitute[m[2]], data)
        return data

    def encode_raw(self, representation):
        uid = str(uuid.uuid4())
        self.substitute[uid] = representation
        return uid

    def default(self, obj):
        if isinstance(obj, datetime.datetime):
            return obj.isoformat(&#39; &#39;, &#39;seconds&#39;)
        return super().default(obj)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.substitute = {}

    @classmethod
    def handled(cls, obj) -&gt; bool:
        &#34;&#34;&#34;
        Returns whether the given object can be handled by the decoder. When a `refinery.lib.json.JSONEncoderEx` is used as
        a context manager, then it is possible to return `True` for basic types such as `list` to provide custom encodings of
        these types.
        &#34;&#34;&#34;
        return False


class BytesEncoder(JSONEncoderEx):
    &#34;&#34;&#34;
    A base class for JSON encoders that can encode byte arrays.
    &#34;&#34;&#34;

    @classmethod
    def _is_byte_array(cls, obj) -&gt; bool:
        return isinstance(obj, (bytes, bytearray, memoryview))

    @classmethod
    def handled(cls, obj) -&gt; bool:
        return cls._is_byte_array(obj) or super().handled(obj)

    def encode_bytes(self, obj: buf):
        raise NotImplementedError

    def default(self, obj):
        if self._is_byte_array(obj):
            return self.encode_bytes(obj)
        return super().default(obj)


class BytesAsArrayEncoder(BytesEncoder):
    &#34;&#34;&#34;
    This JSON Encoder encodes byte strings as arrays of integers.
    &#34;&#34;&#34;
    def encode_bytes(self, obj: buf):
        return self.encode_raw(&#39;[{}]&#39;.format(&#39;,&#39;.join(str(b &amp; 0xFF) for b in obj)))


class BytesAsStringEncoder(BytesEncoder):
    &#34;&#34;&#34;
    This JSON Encoder encodes byte strings as escaped strings.
    &#34;&#34;&#34;
    def encode_bytes(self, obj: buf):
        if not isinstance(obj, (bytes, bytearray)):
            if not isinstance(obj, memoryview):
                obj = (b &amp; 0xFF for b in obj)
            obj = bytes(obj)
        return obj.decode(&#39;latin1&#39;)


def flattened(data: dict, prefix=&#39;&#39;, separator=&#39;.&#39;) -&gt; list[tuple[str, int | float | str]]:
    def flatten(cursor, prefix):
        if isinstance(cursor, dict):
            for key, value in cursor.items():
                new_prefix = key if not prefix else F&#39;{prefix}{separator}{key}&#39;
                yield from flatten(value, new_prefix)
        elif isinstance(cursor, list):
            width = len(F&#39;{len(cursor) - 1:X}&#39;)
            for key, value in enumerate(cursor):
                yield from flatten(value, F&#39;{prefix}[0x{key:0{width}X}]&#39;)
        else:
            yield (prefix, cursor)
    yield from flatten(data, prefix)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.json.flattened"><code class="name flex">
<span>def <span class="ident">flattened</span></span>(<span>data, prefix='', separator='.')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/json.py#L137-L149" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flattened(data: dict, prefix=&#39;&#39;, separator=&#39;.&#39;) -&gt; list[tuple[str, int | float | str]]:
    def flatten(cursor, prefix):
        if isinstance(cursor, dict):
            for key, value in cursor.items():
                new_prefix = key if not prefix else F&#39;{prefix}{separator}{key}&#39;
                yield from flatten(value, new_prefix)
        elif isinstance(cursor, list):
            width = len(F&#39;{len(cursor) - 1:X}&#39;)
            for key, value in enumerate(cursor):
                yield from flatten(value, F&#39;{prefix}[0x{key:0{width}X}]&#39;)
        else:
            yield (prefix, cursor)
    yield from flatten(data, prefix)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.json.JSONEncoderExMeta"><code class="flex name class">
<span>class <span class="ident">JSONEncoderExMeta</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>This metaclass is the type of <code><a title="refinery.lib.json.JSONEncoderEx" href="#refinery.lib.json.JSONEncoderEx">JSONEncoderEx</a></code> and exists in
order to facilitate a context manager at the type level.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/json.py#L15-L41" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class JSONEncoderExMeta(type):
    &#34;&#34;&#34;
    This metaclass is the type of `refinery.lib.json.JSONEncoderEx` and exists in
    order to facilitate a context manager at the type level.
    &#34;&#34;&#34;

    def __enter__(cls):
        def _custom_isinstance(obj, tp):
            if cls.handled(obj):
                return False
            return isinstance(obj, tp)

        def mkiter(*args, **kwargs):
            kwargs.update(isinstance=_custom_isinstance)
            return cls._make_iterencode_old(*args, **kwargs)

        cls._make_iterencode_old = json.encoder._make_iterencode
        json.encoder._make_iterencode = mkiter
        return cls

    def __exit__(cls, etype, eval, tb):
        json.encoder._make_iterencode = cls._make_iterencode_old
        return False

    def dumps(cls, data, indent=4, **kwargs):
        kwargs.setdefault(&#39;cls&#39;, cls)
        return json.dumps(data, indent=indent, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.json.JSONEncoderExMeta.dumps"><code class="name flex">
<span>def <span class="ident">dumps</span></span>(<span>cls, data, indent=4, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/json.py#L39-L41" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dumps(cls, data, indent=4, **kwargs):
    kwargs.setdefault(&#39;cls&#39;, cls)
    return json.dumps(data, indent=indent, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.json.JSONEncoderEx"><code class="flex name class">
<span>class <span class="ident">JSONEncoderEx</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for JSON encoders used in refinery. Any such encoder can
be used as a context which temporarily performs a monkey-patch of the
built-in json module to allow custom encoding of already serializable
types such as <code>list</code> or <code>dict</code>. This is done as follows:</p>
<pre><code>class MyEncoder(JSONEncoderEx):
    pass

with MyEncoder as encoder:
    return encoder.dumps(data)
</code></pre>
<p>Constructor for JSONEncoder, with sensible defaults.</p>
<p>If skipkeys is false, then it is a TypeError to attempt
encoding of keys that are not str, int, float, bool or None.
If skipkeys is True, such items are simply skipped.</p>
<p>If ensure_ascii is true, the output is guaranteed to be str
objects with all incoming non-ASCII characters escaped.
If
ensure_ascii is false, the output can contain non-ASCII characters.</p>
<p>If check_circular is true, then lists, dicts, and custom encoded
objects will be checked for circular references during encoding to
prevent an infinite recursion (which would cause an RecursionError).
Otherwise, no such check takes place.</p>
<p>If allow_nan is true, then NaN, Infinity, and -Infinity will be
encoded as such.
This behavior is not JSON specification compliant,
but is consistent with most JavaScript based encoders and decoders.
Otherwise, it will be a ValueError to encode such floats.</p>
<p>If sort_keys is true, then the output of dictionaries will be
sorted by key; this is useful for regression tests to ensure
that JSON serializations can be compared on a day-to-day basis.</p>
<p>If indent is a non-negative integer, then JSON array
elements and object members will be pretty-printed with that
indent level.
An indent level of 0 will only insert newlines.
None is the most compact representation.</p>
<p>If specified, separators should be an (item_separator, key_separator)
tuple.
The default is (', ', ': ') if <em>indent</em> is <code>None</code> and
(',', ': ') otherwise.
To get the most compact JSON representation,
you should specify (',', ':') to eliminate whitespace.</p>
<p>If specified, default is a function that gets called for objects
that can't otherwise be serialized.
It should return a JSON encodable
version of the object or raise a <code>TypeError</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/json.py#L44-L92" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class JSONEncoderEx(json.JSONEncoder, metaclass=JSONEncoderExMeta):
    &#34;&#34;&#34;
    Base class for JSON encoders used in refinery. Any such encoder can
    be used as a context which temporarily performs a monkey-patch of the
    built-in json module to allow custom encoding of already serializable
    types such as `list` or `dict`. This is done as follows:

        class MyEncoder(JSONEncoderEx):
            pass

        with MyEncoder as encoder:
            return encoder.dumps(data)
    &#34;&#34;&#34;
    def encode(self, obj):
        if isinstance(obj, dict) and not all(isinstance(k, str) for k in obj.keys()):
            def _encode(k):
                if isinstance(k, (bytes, bytearray, memoryview)):
                    try: return k.encode(&#39;ascii&#39;)
                    except Exception: pass
                return str(k)
            obj = {_encode(key): value for key, value in obj.items()}
        data = super().encode(obj)
        if self.substitute:
            uids = R&#39;&#39;&#39;([&#39;&#34;])({})\1&#39;&#39;&#39;.format(&#39;|&#39;.join(re.escape(u) for u in self.substitute))
            return re.sub(uids, lambda m: self.substitute[m[2]], data)
        return data

    def encode_raw(self, representation):
        uid = str(uuid.uuid4())
        self.substitute[uid] = representation
        return uid

    def default(self, obj):
        if isinstance(obj, datetime.datetime):
            return obj.isoformat(&#39; &#39;, &#39;seconds&#39;)
        return super().default(obj)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.substitute = {}

    @classmethod
    def handled(cls, obj) -&gt; bool:
        &#34;&#34;&#34;
        Returns whether the given object can be handled by the decoder. When a `refinery.lib.json.JSONEncoderEx` is used as
        a context manager, then it is possible to return `True` for basic types such as `list` to provide custom encodings of
        these types.
        &#34;&#34;&#34;
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>json.encoder.JSONEncoder</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.json.BytesEncoder" href="#refinery.lib.json.BytesEncoder">BytesEncoder</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.json.JSONEncoderEx.handled"><code class="name flex">
<span>def <span class="ident">handled</span></span>(<span>obj)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns whether the given object can be handled by the decoder. When a <code><a title="refinery.lib.json.JSONEncoderEx" href="#refinery.lib.json.JSONEncoderEx">JSONEncoderEx</a></code> is used as
a context manager, then it is possible to return <code>True</code> for basic types such as <code>list</code> to provide custom encodings of
these types.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.json.JSONEncoderEx.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a JSON string representation of a Python data structure.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from json.encoder import JSONEncoder
&gt;&gt;&gt; JSONEncoder().encode({&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]})
'{&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]}'
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/json.py#L57-L69" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encode(self, obj):
    if isinstance(obj, dict) and not all(isinstance(k, str) for k in obj.keys()):
        def _encode(k):
            if isinstance(k, (bytes, bytearray, memoryview)):
                try: return k.encode(&#39;ascii&#39;)
                except Exception: pass
            return str(k)
        obj = {_encode(key): value for key, value in obj.items()}
    data = super().encode(obj)
    if self.substitute:
        uids = R&#39;&#39;&#39;([&#39;&#34;])({})\1&#39;&#39;&#39;.format(&#39;|&#39;.join(re.escape(u) for u in self.substitute))
        return re.sub(uids, lambda m: self.substitute[m[2]], data)
    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.json.JSONEncoderEx.encode_raw"><code class="name flex">
<span>def <span class="ident">encode_raw</span></span>(<span>self, representation)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/json.py#L71-L74" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encode_raw(self, representation):
    uid = str(uuid.uuid4())
    self.substitute[uid] = representation
    return uid</code></pre>
</details>
</dd>
<dt id="refinery.lib.json.JSONEncoderEx.default"><code class="name flex">
<span>def <span class="ident">default</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<section class="desc"><p>Implement this method in a subclass such that it returns
a serializable object for <code>o</code>, or calls the base implementation
(to raise a <code>TypeError</code>).</p>
<p>For example, to support arbitrary iterators, you could
implement default like this::</p>
<pre><code>def default(self, o):
    try:
        iterable = iter(o)
    except TypeError:
        pass
    else:
        return list(iterable)
    # Let the base class default method raise the TypeError
    return super().default(o)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/json.py#L76-L79" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def default(self, obj):
    if isinstance(obj, datetime.datetime):
        return obj.isoformat(&#39; &#39;, &#39;seconds&#39;)
    return super().default(obj)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.json.BytesEncoder"><code class="flex name class">
<span>class <span class="ident">BytesEncoder</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A base class for JSON encoders that can encode byte arrays.</p>
<p>Constructor for JSONEncoder, with sensible defaults.</p>
<p>If skipkeys is false, then it is a TypeError to attempt
encoding of keys that are not str, int, float, bool or None.
If skipkeys is True, such items are simply skipped.</p>
<p>If ensure_ascii is true, the output is guaranteed to be str
objects with all incoming non-ASCII characters escaped.
If
ensure_ascii is false, the output can contain non-ASCII characters.</p>
<p>If check_circular is true, then lists, dicts, and custom encoded
objects will be checked for circular references during encoding to
prevent an infinite recursion (which would cause an RecursionError).
Otherwise, no such check takes place.</p>
<p>If allow_nan is true, then NaN, Infinity, and -Infinity will be
encoded as such.
This behavior is not JSON specification compliant,
but is consistent with most JavaScript based encoders and decoders.
Otherwise, it will be a ValueError to encode such floats.</p>
<p>If sort_keys is true, then the output of dictionaries will be
sorted by key; this is useful for regression tests to ensure
that JSON serializations can be compared on a day-to-day basis.</p>
<p>If indent is a non-negative integer, then JSON array
elements and object members will be pretty-printed with that
indent level.
An indent level of 0 will only insert newlines.
None is the most compact representation.</p>
<p>If specified, separators should be an (item_separator, key_separator)
tuple.
The default is (', ', ': ') if <em>indent</em> is <code>None</code> and
(',', ': ') otherwise.
To get the most compact JSON representation,
you should specify (',', ':') to eliminate whitespace.</p>
<p>If specified, default is a function that gets called for objects
that can't otherwise be serialized.
It should return a JSON encodable
version of the object or raise a <code>TypeError</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/json.py#L95-L114" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BytesEncoder(JSONEncoderEx):
    &#34;&#34;&#34;
    A base class for JSON encoders that can encode byte arrays.
    &#34;&#34;&#34;

    @classmethod
    def _is_byte_array(cls, obj) -&gt; bool:
        return isinstance(obj, (bytes, bytearray, memoryview))

    @classmethod
    def handled(cls, obj) -&gt; bool:
        return cls._is_byte_array(obj) or super().handled(obj)

    def encode_bytes(self, obj: buf):
        raise NotImplementedError

    def default(self, obj):
        if self._is_byte_array(obj):
            return self.encode_bytes(obj)
        return super().default(obj)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.json.JSONEncoderEx" href="#refinery.lib.json.JSONEncoderEx">JSONEncoderEx</a></li>
<li>json.encoder.JSONEncoder</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.json.BytesAsArrayEncoder" href="#refinery.lib.json.BytesAsArrayEncoder">BytesAsArrayEncoder</a></li>
<li><a title="refinery.lib.json.BytesAsStringEncoder" href="#refinery.lib.json.BytesAsStringEncoder">BytesAsStringEncoder</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.json.BytesEncoder.encode_bytes"><code class="name flex">
<span>def <span class="ident">encode_bytes</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/json.py#L108-L109" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encode_bytes(self, obj: buf):
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.json.JSONEncoderEx" href="#refinery.lib.json.JSONEncoderEx">JSONEncoderEx</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.json.JSONEncoderEx.default" href="#refinery.lib.json.JSONEncoderEx.default">default</a></code></li>
<li><code><a title="refinery.lib.json.JSONEncoderEx.encode" href="#refinery.lib.json.JSONEncoderEx.encode">encode</a></code></li>
<li><code><a title="refinery.lib.json.JSONEncoderEx.handled" href="#refinery.lib.json.JSONEncoderEx.handled">handled</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.json.BytesAsArrayEncoder"><code class="flex name class">
<span>class <span class="ident">BytesAsArrayEncoder</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>This JSON Encoder encodes byte strings as arrays of integers.</p>
<p>Constructor for JSONEncoder, with sensible defaults.</p>
<p>If skipkeys is false, then it is a TypeError to attempt
encoding of keys that are not str, int, float, bool or None.
If skipkeys is True, such items are simply skipped.</p>
<p>If ensure_ascii is true, the output is guaranteed to be str
objects with all incoming non-ASCII characters escaped.
If
ensure_ascii is false, the output can contain non-ASCII characters.</p>
<p>If check_circular is true, then lists, dicts, and custom encoded
objects will be checked for circular references during encoding to
prevent an infinite recursion (which would cause an RecursionError).
Otherwise, no such check takes place.</p>
<p>If allow_nan is true, then NaN, Infinity, and -Infinity will be
encoded as such.
This behavior is not JSON specification compliant,
but is consistent with most JavaScript based encoders and decoders.
Otherwise, it will be a ValueError to encode such floats.</p>
<p>If sort_keys is true, then the output of dictionaries will be
sorted by key; this is useful for regression tests to ensure
that JSON serializations can be compared on a day-to-day basis.</p>
<p>If indent is a non-negative integer, then JSON array
elements and object members will be pretty-printed with that
indent level.
An indent level of 0 will only insert newlines.
None is the most compact representation.</p>
<p>If specified, separators should be an (item_separator, key_separator)
tuple.
The default is (', ', ': ') if <em>indent</em> is <code>None</code> and
(',', ': ') otherwise.
To get the most compact JSON representation,
you should specify (',', ':') to eliminate whitespace.</p>
<p>If specified, default is a function that gets called for objects
that can't otherwise be serialized.
It should return a JSON encodable
version of the object or raise a <code>TypeError</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/json.py#L117-L122" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BytesAsArrayEncoder(BytesEncoder):
    &#34;&#34;&#34;
    This JSON Encoder encodes byte strings as arrays of integers.
    &#34;&#34;&#34;
    def encode_bytes(self, obj: buf):
        return self.encode_raw(&#39;[{}]&#39;.format(&#39;,&#39;.join(str(b &amp; 0xFF) for b in obj)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.json.BytesEncoder" href="#refinery.lib.json.BytesEncoder">BytesEncoder</a></li>
<li><a title="refinery.lib.json.JSONEncoderEx" href="#refinery.lib.json.JSONEncoderEx">JSONEncoderEx</a></li>
<li>json.encoder.JSONEncoder</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.json.BytesAsArrayEncoder.encode_bytes"><code class="name flex">
<span>def <span class="ident">encode_bytes</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/json.py#L121-L122" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encode_bytes(self, obj: buf):
    return self.encode_raw(&#39;[{}]&#39;.format(&#39;,&#39;.join(str(b &amp; 0xFF) for b in obj)))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.json.BytesEncoder" href="#refinery.lib.json.BytesEncoder">BytesEncoder</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.json.BytesEncoder.default" href="#refinery.lib.json.JSONEncoderEx.default">default</a></code></li>
<li><code><a title="refinery.lib.json.BytesEncoder.encode" href="#refinery.lib.json.JSONEncoderEx.encode">encode</a></code></li>
<li><code><a title="refinery.lib.json.BytesEncoder.handled" href="#refinery.lib.json.JSONEncoderEx.handled">handled</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.json.BytesAsStringEncoder"><code class="flex name class">
<span>class <span class="ident">BytesAsStringEncoder</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>This JSON Encoder encodes byte strings as escaped strings.</p>
<p>Constructor for JSONEncoder, with sensible defaults.</p>
<p>If skipkeys is false, then it is a TypeError to attempt
encoding of keys that are not str, int, float, bool or None.
If skipkeys is True, such items are simply skipped.</p>
<p>If ensure_ascii is true, the output is guaranteed to be str
objects with all incoming non-ASCII characters escaped.
If
ensure_ascii is false, the output can contain non-ASCII characters.</p>
<p>If check_circular is true, then lists, dicts, and custom encoded
objects will be checked for circular references during encoding to
prevent an infinite recursion (which would cause an RecursionError).
Otherwise, no such check takes place.</p>
<p>If allow_nan is true, then NaN, Infinity, and -Infinity will be
encoded as such.
This behavior is not JSON specification compliant,
but is consistent with most JavaScript based encoders and decoders.
Otherwise, it will be a ValueError to encode such floats.</p>
<p>If sort_keys is true, then the output of dictionaries will be
sorted by key; this is useful for regression tests to ensure
that JSON serializations can be compared on a day-to-day basis.</p>
<p>If indent is a non-negative integer, then JSON array
elements and object members will be pretty-printed with that
indent level.
An indent level of 0 will only insert newlines.
None is the most compact representation.</p>
<p>If specified, separators should be an (item_separator, key_separator)
tuple.
The default is (', ', ': ') if <em>indent</em> is <code>None</code> and
(',', ': ') otherwise.
To get the most compact JSON representation,
you should specify (',', ':') to eliminate whitespace.</p>
<p>If specified, default is a function that gets called for objects
that can't otherwise be serialized.
It should return a JSON encodable
version of the object or raise a <code>TypeError</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/json.py#L125-L134" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BytesAsStringEncoder(BytesEncoder):
    &#34;&#34;&#34;
    This JSON Encoder encodes byte strings as escaped strings.
    &#34;&#34;&#34;
    def encode_bytes(self, obj: buf):
        if not isinstance(obj, (bytes, bytearray)):
            if not isinstance(obj, memoryview):
                obj = (b &amp; 0xFF for b in obj)
            obj = bytes(obj)
        return obj.decode(&#39;latin1&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.json.BytesEncoder" href="#refinery.lib.json.BytesEncoder">BytesEncoder</a></li>
<li><a title="refinery.lib.json.JSONEncoderEx" href="#refinery.lib.json.JSONEncoderEx">JSONEncoderEx</a></li>
<li>json.encoder.JSONEncoder</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.units.formats.java.deserialize.JavaEncoder" href="../units/formats/java/deserialize.html#refinery.units.formats.java.deserialize.JavaEncoder">JavaEncoder</a></li>
<li><a title="refinery.units.formats.pe.dotnet.DotNetEncoder" href="../units/formats/pe/dotnet/index.html#refinery.units.formats.pe.dotnet.DotNetEncoder">DotNetEncoder</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.json.BytesAsStringEncoder.encode_bytes"><code class="name flex">
<span>def <span class="ident">encode_bytes</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/json.py#L129-L134" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encode_bytes(self, obj: buf):
    if not isinstance(obj, (bytes, bytearray)):
        if not isinstance(obj, memoryview):
            obj = (b &amp; 0xFF for b in obj)
        obj = bytes(obj)
    return obj.decode(&#39;latin1&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.json.BytesEncoder" href="#refinery.lib.json.BytesEncoder">BytesEncoder</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.json.BytesEncoder.default" href="#refinery.lib.json.JSONEncoderEx.default">default</a></code></li>
<li><code><a title="refinery.lib.json.BytesEncoder.encode" href="#refinery.lib.json.JSONEncoderEx.encode">encode</a></code></li>
<li><code><a title="refinery.lib.json.BytesEncoder.handled" href="#refinery.lib.json.JSONEncoderEx.handled">handled</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.json.flattened" href="#refinery.lib.json.flattened">flattened</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.json.JSONEncoderExMeta" href="#refinery.lib.json.JSONEncoderExMeta">JSONEncoderExMeta</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.json.JSONEncoderExMeta.dumps" href="#refinery.lib.json.JSONEncoderExMeta.dumps">dumps</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.json.JSONEncoderEx" href="#refinery.lib.json.JSONEncoderEx">JSONEncoderEx</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.json.JSONEncoderEx.handled" href="#refinery.lib.json.JSONEncoderEx.handled">handled</a></code></li>
<li><code><a title="refinery.lib.json.JSONEncoderEx.encode" href="#refinery.lib.json.JSONEncoderEx.encode">encode</a></code></li>
<li><code><a title="refinery.lib.json.JSONEncoderEx.encode_raw" href="#refinery.lib.json.JSONEncoderEx.encode_raw">encode_raw</a></code></li>
<li><code><a title="refinery.lib.json.JSONEncoderEx.default" href="#refinery.lib.json.JSONEncoderEx.default">default</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.json.BytesEncoder" href="#refinery.lib.json.BytesEncoder">BytesEncoder</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.json.BytesEncoder.encode_bytes" href="#refinery.lib.json.BytesEncoder.encode_bytes">encode_bytes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.json.BytesAsArrayEncoder" href="#refinery.lib.json.BytesAsArrayEncoder">BytesAsArrayEncoder</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.json.BytesAsArrayEncoder.encode_bytes" href="#refinery.lib.json.BytesAsArrayEncoder.encode_bytes">encode_bytes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.json.BytesAsStringEncoder" href="#refinery.lib.json.BytesAsStringEncoder">BytesAsStringEncoder</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.json.BytesAsStringEncoder.encode_bytes" href="#refinery.lib.json.BytesAsStringEncoder.encode_bytes">encode_bytes</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
