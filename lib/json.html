<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.json documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.json</code></h1>
</header>
<section id="section-intro">
<p>This module provides JSON encoding and decoding. All refinery units should use this interface
rather than the standard library JSON module. It first attempts to use the orJSON external library
as backend, which is much faster, and then falls back to the standard library if orJSON is not
available.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/json.py#L1-L200" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides JSON encoding and decoding. All refinery units should use this interface
rather than the standard library JSON module. It first attempts to use the orJSON external library
as backend, which is much faster, and then falls back to the standard library if orJSON is not
available.
&#34;&#34;&#34;
from __future__ import annotations

import codecs
import json as pyjson

from datetime import date, datetime, time
from enum import Enum, IntFlag
from uuid import UUID

from refinery.lib.shared.orjson import orjson
from refinery.lib.types import Any, Callable, Generator, isbuffer


def flattened(data: dict, prefix: str = &#39;&#39;, separator: str = &#39;.&#39;):
    &#34;&#34;&#34;
    Yield the rows of a flattened view for the input JSON dictionary. This is used by several
    refinery units to display a tabular view of what would otherwise be output as JSON.
    &#34;&#34;&#34;
    def flatten(
        cursor: dict | list | str | int | float | bool, prefix: str
    ) -&gt; Generator[tuple[str, int | float | bool | str]]:
        if isinstance(cursor, dict):
            for key, value in cursor.items():
                new_prefix = key if not prefix else F&#39;{prefix}{separator}{key}&#39;
                yield from flatten(value, new_prefix)
        elif isinstance(cursor, list):
            width = len(F&#39;{len(cursor) - 1:X}&#39;)
            for key, value in enumerate(cursor):
                yield from flatten(value, F&#39;{prefix}[0x{key:0{width}X}]&#39;)
        else:
            yield (prefix, cursor)
    yield from flatten(data, prefix)


def _common_conversions(o):
    if isinstance(o, Enum):
        return o.name
    if isinstance(o, datetime):
        return o.isoformat(&#39; &#39;, &#39;seconds&#39;)
    if isinstance(o, time):
        return o.isoformat(&#39;seconds&#39;)
    if isinstance(o, date):
        return o.isoformat()


def convert_key(k: Enum | datetime | date | time | int | float | bool | str) -&gt; str:
    &#34;&#34;&#34;
    Conversions of several non-string types for dictionary keys to enable JSON serialization.
    &#34;&#34;&#34;
    return str(k) if (t := _common_conversions(k)) is None else t


def standard_conversions(o):
    &#34;&#34;&#34;
    Converts `datetime` and `UUID` objects to their canonical string representations, and also
    converts `set`. `tuple`. and `frozenset` objects to `list`s for JSON serialization. Other
    serialization of standard object types should be added here.
    &#34;&#34;&#34;
    if (t := _common_conversions(o)) is not None:
        return t
    if isinstance(o, IntFlag):
        return [flag.name for flag in o.__class__ if o &amp; flag == flag]
    if isinstance(o, UUID):
        return str(o)
    if isinstance(o, (set, tuple, frozenset)):
        return list(o)
    raise TypeError


def preprocess(o, keys: bool = False):
    &#34;&#34;&#34;
    This method ensures that no integers requiring more than 64 bits are stored within nested
    dictionaries and lists of the input object. Integers that exceed this limit are converted
    to hexadecimal string representations with prefix.

    When the `keys` option is set, the method also uses `refinery.lib.json.convert_key` to turn
    all non-string keys in dictionaries into strings.
    &#34;&#34;&#34;
    if isinstance(o, dict):
        if not keys:
            for k, v in o.items():
                o[k] = preprocess(v, keys=False)
        else:
            invalid_keys = []
            for k, v in o.items():
                if not isinstance(k, str):
                    invalid_keys.append(k)
                else:
                    o[k] = preprocess(v, keys=True)
            for k in invalid_keys:
                o[convert_key(k)] = preprocess(o.pop(k))
    elif isinstance(o, list):
        for k, v in enumerate(o):
            o[k] = preprocess(v, keys=keys)
    elif isinstance(o, int) and o.bit_length() &gt; 64:
        return hex(o)
    return o


def py_json_dumps(
    object,
    pretty: bool = True,
    checks: bool = True,
    tojson: Callable[[Any], Any] | None = None,
) -&gt; bytes:
    &#34;&#34;&#34;
    This is the JSON dump method wrapper which is based on the standard library backend. It is
    exposed separately to allow testing.
    &#34;&#34;&#34;
    class enc(pyjson.JSONEncoder):
        default = staticmethod(tojson or standard_conversions) # type:ignore
    if checks:
        object = preprocess(object, keys=True)
    if pretty:
        out = pyjson.dumps(object, ensure_ascii=False, cls=enc, indent=2)
    else:
        out = pyjson.dumps(object, ensure_ascii=False, cls=enc, indent=None, separators=(&#39;,&#39;, &#39;:&#39;))
    return out.encode(&#39;utf8&#39;)


try:
    _or_json_loads = orjson.loads
    _or_json_dumps = orjson.dumps
except ImportError:
    dumps = py_json_dumps
    loads = pyjson.loads
else:
    def __loads(data):
        # orjson does not like subclasses of bytearray, and we do that a lot
        return _or_json_loads(memoryview(data))

    def __dumps(
        object,
        pretty: bool = True,
        checks: bool = True,
        tojson: Callable[[Any], Any] | None = None,
    ):
        default = tojson or standard_conversions
        options = (
            0
            | orjson.OPT_PASSTHROUGH_DATETIME
            | orjson.OPT_NON_STR_KEYS
            | orjson.OPT_OMIT_MICROSECONDS
            | orjson.OPT_SERIALIZE_DATACLASS
            | orjson.OPT_SERIALIZE_UUID
        )
        if pretty:
            options |= orjson.OPT_INDENT_2
        if checks:
            object = preprocess(object)
        return _or_json_dumps(
            object,
            option=options,
            default=default,
        )

    loads = __loads
    dumps = __dumps


def bytes_as_array(o):
    &#34;&#34;&#34;
    A default handler that will convert byte strings to lists of integers.
    &#34;&#34;&#34;
    if isbuffer(o):
        return [int(b &amp; 0xFF) for b in o]
    return standard_conversions(o)


def bytes_as_string(o):
    &#34;&#34;&#34;
    A default handler that will convert byte strings to 8-bit ASCII encoded strings.
    &#34;&#34;&#34;
    if isbuffer(o):
        return codecs.decode(o, &#39;latin1&#39;)
    return standard_conversions(o)


__pdoc__ = {
    &#39;dumps&#39;: (
        &#39;A unified proxy method for dumping input data to JSON, using either the orJSON or the &#39;
        &#39;standard library as backend, depending on what is available. The interface more closely &#39;
        &#39;resembles orJSON: The `pretty` option controls whether the output is indented or &#39;
        &#39;minified, and an optional conversion handler can be passed as the `default` parameter &#39;
        &#39;to serialize Python objects that are not handled natively by the backend. Finally, the &#39;
        &#39;option `checks` can be set to false to prevent all preprocessing of the input data. Use &#39;
        &#39;it when you are absolutely certain that the input is JSON-serializable and requires no &#39;
        &#39;normalization of any kind.&#39;
    ),
    &#39;loads&#39;: (
        &#39;A unified proxy method for loading JSON data as a Python object, using either orJSON &#39;
        &#39;or the standard library backend.&#39;
    ),
}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.json.flattened"><code class="name flex">
<span>def <span class="ident">flattened</span></span>(<span>data, prefix='', separator='.')</span>
</code></dt>
<dd>
<section class="desc"><p>Yield the rows of a flattened view for the input JSON dictionary. This is used by several
refinery units to display a tabular view of what would otherwise be output as JSON.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/json.py#L20-L38" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flattened(data: dict, prefix: str = &#39;&#39;, separator: str = &#39;.&#39;):
    &#34;&#34;&#34;
    Yield the rows of a flattened view for the input JSON dictionary. This is used by several
    refinery units to display a tabular view of what would otherwise be output as JSON.
    &#34;&#34;&#34;
    def flatten(
        cursor: dict | list | str | int | float | bool, prefix: str
    ) -&gt; Generator[tuple[str, int | float | bool | str]]:
        if isinstance(cursor, dict):
            for key, value in cursor.items():
                new_prefix = key if not prefix else F&#39;{prefix}{separator}{key}&#39;
                yield from flatten(value, new_prefix)
        elif isinstance(cursor, list):
            width = len(F&#39;{len(cursor) - 1:X}&#39;)
            for key, value in enumerate(cursor):
                yield from flatten(value, F&#39;{prefix}[0x{key:0{width}X}]&#39;)
        else:
            yield (prefix, cursor)
    yield from flatten(data, prefix)</code></pre>
</details>
</dd>
<dt id="refinery.lib.json.convert_key"><code class="name flex">
<span>def <span class="ident">convert_key</span></span>(<span>k)</span>
</code></dt>
<dd>
<section class="desc"><p>Conversions of several non-string types for dictionary keys to enable JSON serialization.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/json.py#L52-L56" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def convert_key(k: Enum | datetime | date | time | int | float | bool | str) -&gt; str:
    &#34;&#34;&#34;
    Conversions of several non-string types for dictionary keys to enable JSON serialization.
    &#34;&#34;&#34;
    return str(k) if (t := _common_conversions(k)) is None else t</code></pre>
</details>
</dd>
<dt id="refinery.lib.json.standard_conversions"><code class="name flex">
<span>def <span class="ident">standard_conversions</span></span>(<span>o)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts <code>datetime</code> and <code>UUID</code> objects to their canonical string representations, and also
converts <code>set</code>. <code>tuple</code>. and <code>frozenset</code> objects to <code>list</code>s for JSON serialization. Other
serialization of standard object types should be added here.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/json.py#L59-L73" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def standard_conversions(o):
    &#34;&#34;&#34;
    Converts `datetime` and `UUID` objects to their canonical string representations, and also
    converts `set`. `tuple`. and `frozenset` objects to `list`s for JSON serialization. Other
    serialization of standard object types should be added here.
    &#34;&#34;&#34;
    if (t := _common_conversions(o)) is not None:
        return t
    if isinstance(o, IntFlag):
        return [flag.name for flag in o.__class__ if o &amp; flag == flag]
    if isinstance(o, UUID):
        return str(o)
    if isinstance(o, (set, tuple, frozenset)):
        return list(o)
    raise TypeError</code></pre>
</details>
</dd>
<dt id="refinery.lib.json.preprocess"><code class="name flex">
<span>def <span class="ident">preprocess</span></span>(<span>o, keys=False)</span>
</code></dt>
<dd>
<section class="desc"><p>This method ensures that no integers requiring more than 64 bits are stored within nested
dictionaries and lists of the input object. Integers that exceed this limit are converted
to hexadecimal string representations with prefix.</p>
<p>When the <code>keys</code> option is set, the method also uses <code><a title="refinery.lib.json.convert_key" href="#refinery.lib.json.convert_key">convert_key()</a></code> to turn
all non-string keys in dictionaries into strings.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/json.py#L76-L103" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def preprocess(o, keys: bool = False):
    &#34;&#34;&#34;
    This method ensures that no integers requiring more than 64 bits are stored within nested
    dictionaries and lists of the input object. Integers that exceed this limit are converted
    to hexadecimal string representations with prefix.

    When the `keys` option is set, the method also uses `refinery.lib.json.convert_key` to turn
    all non-string keys in dictionaries into strings.
    &#34;&#34;&#34;
    if isinstance(o, dict):
        if not keys:
            for k, v in o.items():
                o[k] = preprocess(v, keys=False)
        else:
            invalid_keys = []
            for k, v in o.items():
                if not isinstance(k, str):
                    invalid_keys.append(k)
                else:
                    o[k] = preprocess(v, keys=True)
            for k in invalid_keys:
                o[convert_key(k)] = preprocess(o.pop(k))
    elif isinstance(o, list):
        for k, v in enumerate(o):
            o[k] = preprocess(v, keys=keys)
    elif isinstance(o, int) and o.bit_length() &gt; 64:
        return hex(o)
    return o</code></pre>
</details>
</dd>
<dt id="refinery.lib.json.py_json_dumps"><code class="name flex">
<span>def <span class="ident">py_json_dumps</span></span>(<span>object, pretty=True, checks=True, tojson=None)</span>
</code></dt>
<dd>
<section class="desc"><p>This is the JSON dump method wrapper which is based on the standard library backend. It is
exposed separately to allow testing.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/json.py#L106-L124" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def py_json_dumps(
    object,
    pretty: bool = True,
    checks: bool = True,
    tojson: Callable[[Any], Any] | None = None,
) -&gt; bytes:
    &#34;&#34;&#34;
    This is the JSON dump method wrapper which is based on the standard library backend. It is
    exposed separately to allow testing.
    &#34;&#34;&#34;
    class enc(pyjson.JSONEncoder):
        default = staticmethod(tojson or standard_conversions) # type:ignore
    if checks:
        object = preprocess(object, keys=True)
    if pretty:
        out = pyjson.dumps(object, ensure_ascii=False, cls=enc, indent=2)
    else:
        out = pyjson.dumps(object, ensure_ascii=False, cls=enc, indent=None, separators=(&#39;,&#39;, &#39;:&#39;))
    return out.encode(&#39;utf8&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.json.loads"><code class="name flex">
<span>def <span class="ident">loads</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>A unified proxy method for loading JSON data as a Python object, using either orJSON or the standard library backend.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/json.py#L134-L136" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def __loads(data):
    # orjson does not like subclasses of bytearray, and we do that a lot
    return _or_json_loads(memoryview(data))</code></pre>
</details>
</dd>
<dt id="refinery.lib.json.dumps"><code class="name flex">
<span>def <span class="ident">dumps</span></span>(<span>object, pretty=True, checks=True, tojson=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A unified proxy method for dumping input data to JSON, using either the orJSON or the standard library as backend, depending on what is available. The interface more closely resembles orJSON: The <code>pretty</code> option controls whether the output is indented or minified, and an optional conversion handler can be passed as the <code>default</code> parameter to serialize Python objects that are not handled natively by the backend. Finally, the option <code>checks</code> can be set to false to prevent all preprocessing of the input data. Use it when you are absolutely certain that the input is JSON-serializable and requires no normalization of any kind.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/json.py#L138-L161" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def __dumps(
    object,
    pretty: bool = True,
    checks: bool = True,
    tojson: Callable[[Any], Any] | None = None,
):
    default = tojson or standard_conversions
    options = (
        0
        | orjson.OPT_PASSTHROUGH_DATETIME
        | orjson.OPT_NON_STR_KEYS
        | orjson.OPT_OMIT_MICROSECONDS
        | orjson.OPT_SERIALIZE_DATACLASS
        | orjson.OPT_SERIALIZE_UUID
    )
    if pretty:
        options |= orjson.OPT_INDENT_2
    if checks:
        object = preprocess(object)
    return _or_json_dumps(
        object,
        option=options,
        default=default,
    )</code></pre>
</details>
</dd>
<dt id="refinery.lib.json.bytes_as_array"><code class="name flex">
<span>def <span class="ident">bytes_as_array</span></span>(<span>o)</span>
</code></dt>
<dd>
<section class="desc"><p>A default handler that will convert byte strings to lists of integers.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/json.py#L167-L173" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bytes_as_array(o):
    &#34;&#34;&#34;
    A default handler that will convert byte strings to lists of integers.
    &#34;&#34;&#34;
    if isbuffer(o):
        return [int(b &amp; 0xFF) for b in o]
    return standard_conversions(o)</code></pre>
</details>
</dd>
<dt id="refinery.lib.json.bytes_as_string"><code class="name flex">
<span>def <span class="ident">bytes_as_string</span></span>(<span>o)</span>
</code></dt>
<dd>
<section class="desc"><p>A default handler that will convert byte strings to 8-bit ASCII encoded strings.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/json.py#L176-L182" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bytes_as_string(o):
    &#34;&#34;&#34;
    A default handler that will convert byte strings to 8-bit ASCII encoded strings.
    &#34;&#34;&#34;
    if isbuffer(o):
        return codecs.decode(o, &#39;latin1&#39;)
    return standard_conversions(o)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.json.flattened" href="#refinery.lib.json.flattened">flattened</a></code></li>
<li><code><a title="refinery.lib.json.convert_key" href="#refinery.lib.json.convert_key">convert_key</a></code></li>
<li><code><a title="refinery.lib.json.standard_conversions" href="#refinery.lib.json.standard_conversions">standard_conversions</a></code></li>
<li><code><a title="refinery.lib.json.preprocess" href="#refinery.lib.json.preprocess">preprocess</a></code></li>
<li><code><a title="refinery.lib.json.py_json_dumps" href="#refinery.lib.json.py_json_dumps">py_json_dumps</a></code></li>
<li><code><a title="refinery.lib.json.loads" href="#refinery.lib.json.loads">loads</a></code></li>
<li><code><a title="refinery.lib.json.dumps" href="#refinery.lib.json.dumps">dumps</a></code></li>
<li><code><a title="refinery.lib.json.bytes_as_array" href="#refinery.lib.json.bytes_as_array">bytes_as_array</a></code></li>
<li><code><a title="refinery.lib.json.bytes_as_string" href="#refinery.lib.json.bytes_as_string">bytes_as_string</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
