<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.executable documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.executable</code></h1>
</header>
<section id="section-intro">
<p>This module implements an abstraction layer executable loader for PE, ELF, and MachO files.
The provided interface is the same for all executables. It powers the following units:</p>
<ul>
<li><code><a title="refinery.vsnip" href="../index.html#refinery.vsnip">vsnip</a></code></li>
<li><code><a title="refinery.vsect" href="../index.html#refinery.vsect">vsect</a></code></li>
<li><code><a title="refinery.vaddr" href="../index.html#refinery.vaddr">vaddr</a></code></li>
<li><code><a title="refinery.vmemref" href="../index.html#refinery.vmemref">vmemref</a></code></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L1-L1024" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module implements an abstraction layer executable loader for PE, ELF, and MachO files.
The provided interface is the same for all executables. It powers the following units:

- `refinery.vsnip`
- `refinery.vsect`
- `refinery.vaddr`
- `refinery.vmemref`
&#34;&#34;&#34;
from __future__ import annotations

import codecs
import itertools

from abc import ABC, abstractmethod
from enum import Enum
from functools import lru_cache
from typing import TYPE_CHECKING, NamedTuple

from refinery.lib import lief
from refinery.lib.shared import capstone as cs
from refinery.lib.types import INF, buf

if TYPE_CHECKING:
    from typing import (
        ClassVar,
        Generator,
        Iterable,
        Union,
    )

    from capstone import Cs
    from lief.ELF import Binary as ELFBinary
    from lief.MachO import Binary as MachOBinary
    from lief.MachO import FatBinary as MachOFatBinary
    from lief.PE import Binary as PEBinary

    AnyLIEF = Union[
        MachOBinary,
        MachOFatBinary,
        ELFBinary,
        PEBinary,
    ]


class ParsingFailure(ValueError):
    &#34;&#34;&#34;
    Exception generated for parsing errors of an input `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    def __init__(self, kind):
        super().__init__(F&#39;unable to parse input as {kind} file&#39;)


def align(alignment: int, value: int, down=False) -&gt; int:
    &#34;&#34;&#34;
    Given an alignment size and an integer value, compute the byte boundary to where this value
    would be aligned. By default, the next higher address that satisfies the alignment is computed;
    The optional parameter `down` can be set to `True` to instead return the next lower one.
    &#34;&#34;&#34;
    if alignment &gt;= 2:
        incomplete_chunk_count = value % alignment
        if incomplete_chunk_count &gt; 0:
            if not down:
                value += alignment - incomplete_chunk_count
            else:
                value -= incomplete_chunk_count
    return value


class Range(NamedTuple):
    &#34;&#34;&#34;
    A range of bytes specified by a lower and an upper bound. A `refinery.lib.executable.Range`
    can be subtracted from another one to return a list of ranges that are the result of
    removing the former from the latter. This operation is the only reason for using a custom
    class over the builtin `range` object, which does not support this.
    &#34;&#34;&#34;
    lower: int
    upper: int

    def range(self):
        &#34;&#34;&#34;
        Convertsion to a `range` object.
        &#34;&#34;&#34;
        return range(self.lower, self.upper)

    def slice(self):
        &#34;&#34;&#34;
        Conversion to a `slice` object.
        &#34;&#34;&#34;
        return slice(self.lower, self.upper)

    def __eq__(self, other):
        if not isinstance(other, Range):
            return False
        return other.lower == self.lower and other.upper == self.upper

    def __len__(self):
        return self.upper - self.lower

    def __contains__(self, addr: object):
        if not isinstance(addr, int):
            raise TypeError
        return self.lower &lt;= addr &lt; self.upper

    def __str__(self):
        return F&#39;0x{self.lower:X}:0x{self.upper:X}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;

    def __sub__(self, them: Range) -&gt; list[Range]:
        pieces = []
        if self.lower &lt; them.lower:
            pieces.append(Range(self.lower, min(them.lower, self.upper)))
        if them.upper &lt; self.upper:
            pieces.append(Range(max(self.lower, them.upper), self.upper))
        return pieces


class BoxedOffset(NamedTuple):
    &#34;&#34;&#34;
    An offset together with a range of available bytes at that location.
    &#34;&#34;&#34;
    box: Range
    position: int

    def __str__(self):
        return F&#39;0x{self.position:X} in {self.box!s}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;


class Location(NamedTuple):
    &#34;&#34;&#34;
    A location in an `refinery.lib.executable.Executable`. Contains `refinery.lib.executable.BoxedOffset`
    for both its physical and virtual range of bytes.
    &#34;&#34;&#34;
    physical: BoxedOffset
    virtual: BoxedOffset

    def __str__(self):
        return F&#39;V={self.virtual!s}; P={self.physical!s}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;


class ArchItem(NamedTuple):
    &#34;&#34;&#34;
    An item of the `refinery.lib.executable.Arch` enumeration. It is used to store the register
    size in bits for a given architecture.
    &#34;&#34;&#34;
    pointer_size: int
    id: str


class Arch(ArchItem, Enum):
    &#34;&#34;&#34;
    An enumeration of supported architectures and their register sizes.
    &#34;&#34;&#34;
    X32 = (32, &#39;X32&#39;)
    X64 = (64, &#39;X64&#39;)
    ARM32 = (32, &#39;ARM32&#39;)
    ARM64 = (64, &#39;ARM64&#39;)
    MIPS16 = (16, &#39;MIPS16&#39;)
    MIPS32 = (32, &#39;MIPS32&#39;)
    MIPS64 = (64, &#39;MIPS64&#39;)
    PPC32 = (32, &#39;PPC32&#39;)
    PPC64 = (64, &#39;PPC64&#39;)
    SPARC32 = (32, &#39;SPARC32&#39;)
    SPARC64 = (64, &#39;SPARC64&#39;)


class LT(str, Enum):
    &#34;&#34;&#34;
    An enumeration to distinguish between physical and virtual address types.
    &#34;&#34;&#34;
    PHYSICAL = &#39;offset&#39;
    VIRTUAL = &#39;address&#39;


class ET(str, Enum):
    &#34;&#34;&#34;
    An enumeration to distinguish various executable types.
    &#34;&#34;&#34;
    ELF = &#39;ELF&#39;
    MachO = &#39;MachO&#39;
    PE = &#39;PE&#39;
    BLOB = &#39;BLOB&#39;


class BO(str, Enum):
    &#34;&#34;&#34;
    An enumeration to distinguish big and little endian.
    &#34;&#34;&#34;
    BE = &#39;big&#39;
    LE = &#39;little&#39;


class Section(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a section inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    name: str
    physical: Range
    virtual: Range
    synthetic: bool

    def as_segment(self: Section, populate_sections=False) -&gt; Segment:
        sections = [self] if populate_sections else None
        return Segment(self.physical, self.virtual, sections, self.name)

    def __eq__(self, other):
        if not isinstance(other, Section):
            return False
        return other.physical == self.physical and other.virtual == self.virtual

    def __str__(self):
        return str(self.as_segment())

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;


class Relocation(NamedTuple):
    &#34;&#34;&#34;
    The data required to apply a relocation; An integer of the given size at the given address has
    to be patched to the given value.
    &#34;&#34;&#34;
    address: int
    value: int
    size: int


class Symbol(NamedTuple):
    address: int
    name: str | None
    size: int | None
    function: bool
    exported: bool
    imported: bool
    is_entry: bool = False
    section: Section | None = None

    def get_name(self):
        name = self.name
        if name is not None:
            return name
        if self.is_entry:
            return &#39;entry&#39;
        if self.function:
            return F&#39;sub_{self.address:08X}&#39;
        else:
            return F&#39;sym_{self.address:08X}&#39;


class Segment(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a segment inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    physical: Range
    virtual: Range
    sections: list[Section] | None
    name: str | None = None

    def as_section(self) -&gt; Section:
        if self.name is None:
            raise ValueError(&#39;Unable to convert nameless segment to section.&#39;)
        return Section(self.name, self.physical, self.virtual, False)

    def __eq__(self, other):
        if not isinstance(other, Segment):
            return False
        return other.virtual == self.virtual and other.physical == self.physical

    def __str__(self):
        msg = F&#39;P=[{self.physical!s}];V=[{self.virtual!s}]&#39;
        if self.name is not None:
            msg = F&#39;{self.name}:{msg}&#39;
        return msg

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;


class CompartmentNotFound(LookupError):
    &#34;&#34;&#34;
    This exception is raised when `refinery.lib.executable.Executable.lookup_location` fails to
    find a `refinery.lib.executable.Segment` that contains the given location.
    &#34;&#34;&#34;
    def __init__(self, lt: LT, location: int):
        super().__init__(F&#39;Unable to find a segment that contains the {lt.value} 0x{location:X}.&#39;)
        self.location_type = lt
        self.location = location


class Executable(ABC):
    &#34;&#34;&#34;
    An abstract representation of a parsed executable in memory.
    &#34;&#34;&#34;

    _data: buf
    _head: AnyLIEF | None
    _base: int | None

    blob: ClassVar[bool] = False

    @property
    @abstractmethod
    def _type(self) -&gt; ET:
        pass

    @classmethod
    def Load(cls, data: buf, base: int | None = None) -&gt; LIEF:
        &#34;&#34;&#34;
        Uses the `refinery.lib.lief.load` function to parse the input data.
        &#34;&#34;&#34;
        if (parsed := lief.load(data)) is None:
            raise ValueError(&#39;LIEF was unable to parse the input.&#39;)
        if isinstance(parsed, lief.COFF.Binary):
            raise NotImplementedError
        return LIEF(parsed, data, base)

    def __init__(self, head: AnyLIEF | None, data: buf, base: int | None = None):
        self._data = data
        self._head = head
        self._base = base

    @property
    def head(self):
        &#34;&#34;&#34;
        Return the internal object representing the parsed file format header.
        &#34;&#34;&#34;
        return self._head

    @property
    def type(self):
        &#34;&#34;&#34;
        Returns the `refinery.lib.executable.ET` instance that identifies the executable type.
        &#34;&#34;&#34;
        return self._type

    def __getitem__(self, key: int | slice | Range):
        return self.read(key)

    def __contains__(self, key: int | slice | Range):
        try:
            self.read(key)
        except LookupError:
            return False
        else:
            return True

    def read_integer(self, address: int, size: int | None = None):
        &#34;&#34;&#34;
        Read an integer at the given address. The size defaults to the pointer size in bytes.
        &#34;&#34;&#34;
        if size is None:
            size = self.pointer_size_in_bytes
        return int.from_bytes(self[address:address + size], self.byte_order().value)

    def read(self, key: int | slice | Range) -&gt; memoryview:
        &#34;&#34;&#34;
        Read data from the binary based on a given address. If the input `key` is a single integer,
        the function reads a single byte from the given address.
        &#34;&#34;&#34;
        if isinstance(key, Range):
            key = slice(key.lower, key.upper)
        elif isinstance(key, int):
            if key &lt; 0:
                raise LookupError(F&#39;Reading from negative address -0x{-key:X}.&#39;)
            key = slice(key, key + 1, 1)
        if key.start is None:
            raise LookupError(R&#39;Slice indices with unspecified start are not supported.&#39;)
        if key.stop is not None and key.stop &lt; key.start:
            raise LookupError(R&#39;The slice end must lie after the slice start.&#39;)

        box = self.location_from_address(key.start)

        if key.stop is None:
            end = box.physical.box.upper
        elif key.stop &lt;= box.virtual.box.upper:
            end = box.physical.position + (key.stop - key.start)
        else:
            raise LookupError(F&#39;The end address 0x{key.stop:X} is beyond the section end 0x{box.virtual.box.upper:X}.&#39;)

        return self.data[box.physical.position:end]

    @staticmethod
    def ascii(string: str | buf) -&gt; str:
        &#34;&#34;&#34;
        If the input `string` is a `str` instance, the function returns the input value. Byte
        strings are truncated to the first occurrence of a null byte and then decoded using
        the `latin-1` codec.
        &#34;&#34;&#34;
        if isinstance(string, str):
            return string
        for k, b in enumerate(string):
            if b == 0:
                string = string[:k]
                break
        return codecs.decode(string, &#39;latin-1&#39;)

    def rebase_usr_to_img(self, addr: int) -&gt; int:
        return addr - self.base + self.image_defined_base()

    def rebase_img_to_usr(self, addr: int) -&gt; int:
        return addr - self.image_defined_base() + self.base

    @property
    def base(self) -&gt; int:
        &#34;&#34;&#34;
        Return the base address when mapped to memory. This is either the value passed to the
        constructor, or `refinery.lib.exectuable.Executable.image_defined_base`.
        &#34;&#34;&#34;
        if self._base is None:
            return self.image_defined_base()
        return self._base

    @base.setter
    def base(self, value: int):
        self._base = value

    @property
    def data(self) -&gt; memoryview:
        &#34;&#34;&#34;
        Return a (readonly) view to the raw bytes of the executable image.
        &#34;&#34;&#34;
        view = memoryview(self._data)
        view = view.toreadonly()
        return view

    @property
    def pointer_size(self) -&gt; int:
        &#34;&#34;&#34;
        Return the size of a pointer in bits. Depends on `refinery.lib.executable.Executable.arch`.
        &#34;&#34;&#34;
        return self.arch().pointer_size

    @property
    def pointer_size_in_bytes(self) -&gt; int:
        &#34;&#34;&#34;
        Return the size of a pointer in bytes. Depends on `refinery.lib.executable.Executable.arch`.
        &#34;&#34;&#34;
        return self.pointer_size // 8

    def location_from_address(self, address: int) -&gt; Location:
        &#34;&#34;&#34;
        Return a `refinery.lib.executable.Location` from the given address.
        &#34;&#34;&#34;
        return self.lookup_location(address, LT.VIRTUAL)

    def location_from_offset(self, offset: int) -&gt; Location:
        &#34;&#34;&#34;
        Return a `refinery.lib.executable.Location` from the given file offset.
        &#34;&#34;&#34;
        return self.lookup_location(offset, LT.PHYSICAL)

    def offset_to_address(self, offset: int):
        &#34;&#34;&#34;
        Return the virtual address corresponding to a file offset.
        &#34;&#34;&#34;
        return self.location_from_offset(offset).virtual.position

    def address_to_offset(self, address: int):
        &#34;&#34;&#34;
        Return the virtual address corresponding to a file offset.
        &#34;&#34;&#34;
        return self.location_from_address(address).physical.position

    def image_defined_size(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the size of the executable on disk.
        &#34;&#34;&#34;
        size = 0
        for segment in self.segments():
            size = max(size, segment.physical.upper)
        for section in self.sections():
            size = max(size, section.physical.upper)
        return size

    def image_defined_address_space(self) -&gt; Range:
        &#34;&#34;&#34;
        Returns the size of the executalbe in memory.
        &#34;&#34;&#34;
        upper = 0
        lower = INF
        for segment in self.segments():
            upper = max(upper, segment.virtual.upper)
            lower = min(lower, segment.virtual.lower)
        for section in self.sections():
            upper = max(upper, section.virtual.upper)
            lower = min(lower, section.virtual.lower)
        if not isinstance(lower, int) or upper &lt; lower:
            raise RuntimeError(F&#39;The computed address space upper bound 0x{upper:X} is less than the computed lower bound 0x{lower:X}.&#39;)
        return Range(lower, upper)

    def lookup_location(self, location: int, lt: LT) -&gt; Location:
        &#34;&#34;&#34;
        For a address or file offset, compute the corresponding `refinery.lib.executable.Location`.
        &#34;&#34;&#34;
        for part in itertools.chain(self.sections(), self.segments()):
            phys = part.physical
            virt = part.virtual
            if lt is LT.PHYSICAL and location in phys:
                return Location(
                    BoxedOffset(phys, location),
                    BoxedOffset(virt, virt.lower + location - phys.lower)
                )
            if lt is LT.VIRTUAL and location in virt:
                return Location(
                    BoxedOffset(phys, phys.lower + location - virt.lower),
                    BoxedOffset(virt, location)
                )
        else:
            raise CompartmentNotFound(lt, location)

    @abstractmethod
    def _symbols(self) -&gt; Generator[Symbol]:
        ...

    def symbols(self) -&gt; Generator[Symbol]:
        &#34;&#34;&#34;
        Generates a list of symbols in the executable.
        &#34;&#34;&#34;
        for symbol in self._symbols():
            if symbol.address in self:
                yield symbol

    @abstractmethod
    def byte_order(self) -&gt; BO:
        &#34;&#34;&#34;
        The byte order used by the architecture of this executable.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def image_defined_base(self) -&gt; int:
        &#34;&#34;&#34;
        The image defined base address when mapped to memory.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def arch(self) -&gt; Arch:
        &#34;&#34;&#34;
        The architecture for which this executable was built.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def _sections(self) -&gt; Generator[Section]:
        ...

    @abstractmethod
    def _segments(self, populate_sections=False) -&gt; Generator[Segment]:
        ...

    @abstractmethod
    def _relocations(self) -&gt; Generator[Relocation]:
        ...

    def segments(self, populate_sections=False) -&gt; Generator[Segment]:
        &#34;&#34;&#34;
        An iterable of all `refinery.lib.executable.Segment`s in this executable.
        &#34;&#34;&#34;
        yield from self._segments(populate_sections=populate_sections)

    def relocations(self) -&gt; Generator[Relocation]:
        &#34;&#34;&#34;
        An iterable of all `refinery.lib.executable.Relocation`s defined in this executable.
        &#34;&#34;&#34;
        yield from self._relocations()

    def sections(self) -&gt; Generator[Section]:
        &#34;&#34;&#34;
        An iterable of all `refinery.lib.executable.Section`s in this executable.
        &#34;&#34;&#34;
        ib = self.image_defined_base()
        missing = [Range(0, len(self._data))]
        offsets = {}
        for section in self._sections():
            missing = [piece for patch in missing for piece in patch - section.physical]
            offsets[section.physical.lower] = section.virtual.lower
            yield section
        if not missing:
            return
        offsets.setdefault(0, ib)
        for gap in missing:
            p_floor = min((k for k in offsets if k &lt;= gap.lower), key=lambda p: p - gap.lower)
            v_floor = offsets[p_floor]
            v_lower = v_floor + (gap.lower - p_floor)
            v_upper = v_lower + len(gap)
            if gap.lower == 0:
                name = R&#39;synthesized/.header&#39;
            elif gap.upper == len(self._data):
                name = R&#39;synthesized/.overlay&#39;
            elif any(self._data[gap.slice()]):
                name = F&#39;synthesized/.gap-{gap.lower:08X}-{gap.upper:08X}&#39;
            else:
                name = F&#39;synthesized/.zeros-{gap.lower:08X}&#39;
            yield Section(name, gap, Range(v_lower, v_upper), True)

    def disassemble_instruction(self, address: int):
        &#34;&#34;&#34;
        Disassemble a single instruction at the given address.
        &#34;&#34;&#34;
        cs = self.disassembler()
        cs.detail = True
        data = self[address:address + 0x20]
        return next(cs.disasm(data, address, 1))

    @lru_cache
    def disassembler(self) -&gt; Cs:
        &#34;&#34;&#34;
        Create a capstone disassembler that matches the emulator&#39;s architecture.
        &#34;&#34;&#34;
        cs_arch, cs_mode = {
            Arch.X32     : (cs.CS_ARCH_X86,   cs.CS_MODE_32),     # noqa
            Arch.X64     : (cs.CS_ARCH_X86,   cs.CS_MODE_64),     # noqa
            Arch.ARM32   : (cs.CS_ARCH_ARM,   cs.CS_MODE_ARM),    # noqa
            Arch.ARM64   : (cs.CS_ARCH_ARM64, cs.CS_MODE_ARM),    # noqa
            Arch.MIPS16  : (cs.CS_ARCH_MIPS,  cs.CS_MODE_16),     # noqa
            Arch.MIPS32  : (cs.CS_ARCH_MIPS,  cs.CS_MODE_32),     # noqa
            Arch.MIPS64  : (cs.CS_ARCH_MIPS,  cs.CS_MODE_64),     # noqa
            Arch.PPC32   : (cs.CS_ARCH_PPC,   cs.CS_MODE_32),     # noqa
            Arch.PPC64   : (cs.CS_ARCH_PPC,   cs.CS_MODE_64),     # noqa
            Arch.SPARC32 : (cs.CS_ARCH_SPARC, cs.CS_MODE_32),     # noqa
            Arch.SPARC64 : (cs.CS_ARCH_SPARC, cs.CS_MODE_V9),     # noqa
        }[self.arch()]

        cs_mode |= {
            BO.BE: cs.CS_MODE_BIG_ENDIAN,
            BO.LE: cs.CS_MODE_LITTLE_ENDIAN,
        }[self.byte_order()]

        return cs.Cs(cs_arch, cs_mode)


class ExecutableCodeBlob(Executable):
    &#34;&#34;&#34;
    A dummy specialization of `refinery.lib.executable.Executable` that represents an unstructured
    blob of (shell)code. All information that would usually be obtained from a file header must be
    provided in the constructor for this object.
    &#34;&#34;&#34;

    _head = None
    _byte_order: BO
    _arch: Arch

    blob = True

    @property
    def _type(self):
        return ET.BLOB

    def __init__(self, data, base=None, arch: Arch = Arch.X32, byte_order: BO = BO.LE):
        super().__init__(None, data, base)
        self._byte_order = byte_order
        self._arch = arch

    def image_defined_base(self) -&gt; int:
        return 0

    def byte_order(self) -&gt; BO:
        return self._byte_order

    def arch(self) -&gt; Arch:
        return self._arch

    def _symbols(self) -&gt; Generator[Symbol]:
        section, = self._sections()
        yield Symbol(
            self.base,
            None,
            None,
            function=True,
            exported=True,
            imported=False,
            is_entry=True,
            section=section,
        )

    def _relocations(self):
        yield from ()

    def _sections(self) -&gt; Generator[Section]:
        v = Range(self.base, self.base + len(self.data))
        p = Range(0, len(self.data))
        yield Section(&#39;blob&#39;, p, v, False)

    def _segments(self, populate_sections=False) -&gt; Generator[Segment]:
        for s in self.sections():
            yield s.as_segment(populate_sections=populate_sections)


class LIEF(Executable):

    @property
    def _lh(self) -&gt; lief.AbstractBinary:
        return self._first_header.abstract

    @property
    def _first_header(self) -&gt; MachOBinary | ELFBinary | PEBinary:
        head = self._head
        if head is None:
            raise AttributeError
        if isinstance(head, lief.COFF.Binary):
            raise NotImplementedError
        if isinstance(head, lief.MachO.FatBinary):
            head = head.at(0)
        return head

    @property
    def _type(self):
        EF = lief.AbstractBinary.FORMATS
        HF = self._lh.format
        if HF is EF.UNKNOWN:
            raise AttributeError(&#39;Unknown executable type.&#39;)
        return {EF.MACHO: ET.MachO, EF.PE: ET.PE, EF.ELF: ET.ELF}[HF]

    def image_defined_base(self) -&gt; int:
        return self._lh.imagebase

    def byte_order(self) -&gt; BO:
        return BO.BE if self._lh.header.endianness == lief.Header.ENDIANNESS.BIG else BO.LE

    def arch(self) -&gt; Arch:
        LA = lief.Header.ARCHITECTURES
        LM = lief.Header.MODES
        arch = self._lh.header.architecture
        mode = self._lh.header.modes
        if arch == LA.UNKNOWN:
            raise ValueError(&#39;No architecture set.&#39;)
        elif arch == LA.ARM:
            return Arch.ARM32
        elif arch == LA.ARM64:
            return Arch.ARM64
        elif arch == LA.MIPS:
            if LM.BITS_16 == mode:
                return Arch.MIPS16
            if LM.BITS_32 == mode:
                return Arch.MIPS32
            if LM.BITS_64 == mode:
                return Arch.MIPS64
        elif arch == LA.PPC:
            if LM.BITS_32 == mode:
                return Arch.PPC32
            if LM.BITS_64 == mode:
                return Arch.PPC64
        elif arch == LA.SPARC:
            if LM.BITS_32 == mode:
                return Arch.SPARC32
            if LM.BITS_64 == mode:
                return Arch.SPARC64
        elif arch == LA.X86_64:
            assert LM.BITS_64 == mode
            return Arch.X64
        elif arch == LA.X86:
            if LM.BITS_32 == mode:
                return Arch.X32
            if LM.BITS_64 == mode:
                return Arch.X64
        raise NotImplementedError

    def _relocations(self):
        ps = self.pointer_size_in_bytes

        if isinstance((head := self._first_header), lief.ELF.Binary):
            for rel in head.object_relocations:
                if (symbol := rel.symbol) is None:
                    continue
                if &#39;_RELATIVE&#39; in (tn := rel.type.name):
                    base = self.base
                elif tn.endswith(&#39;GLOB_DAT&#39;) or tn.endswith(&#39;JUMP_SLOT&#39;):
                    base = symbol.value
                else:
                    continue
                addr = self.rebase_img_to_usr(rel.address)
                yield Relocation(addr, base + rel.addend, ps)
        elif (delta := (base := self.base) - self.image_defined_base()) != 0:
            def relocation(addr: int, size: int):
                addr = self.rebase_img_to_usr(addr)
                mask = (1 &lt;&lt; size) - 1
                rval = self.read_integer(addr, size) + delta &amp; mask
                return Relocation(addr, rval, size // 8)

            for rel in self._lh.relocations:
                if isinstance(rel, lief.MachO.Relocation):
                    yield relocation(rel.address, rel.size)
                elif isinstance(rel, lief.PE.Relocation):
                    rva = rel.virtual_address
                    if (delta := (base := self.base) - self.image_defined_base()) == 0:
                        continue
                    for entry in rel.entries:
                        if entry.type == lief.PE.RelocationEntry.BASE_TYPES.HIGHLOW:
                            size = 32
                        elif entry.type == lief.PE.RelocationEntry.BASE_TYPES.DIR64:
                            size = 64
                        else:
                            continue
                        if size != entry.size:
                            raise RuntimeError(F&#39;Unexpected relocation size: Guessed {size}, LIEF says {entry.size}.&#39;)
                        yield relocation(base + rva + entry.position, size)
                else:
                    raise TypeError(F&#39;Unexpected relocation type: {type(rel).__qualname__}&#39;)

    def _symbols(self) -&gt; Generator[Symbol]:
        yield Symbol(
            self.rebase_img_to_usr(self._lh.entrypoint),
            None,
            None,
            function=True,
            exported=True,
            imported=False,
            is_entry=True,
        )

        it: Iterable[lief.Symbol] = self._lh.symbols
        ps = self.pointer_size_in_bytes
        imports_done: set[str] = set()

        if isinstance((head := self._first_header), lief.PE.Binary):
            for imp in head.imports:
                dll = self.ascii(imp.name).lower()
                dll, _, ext = dll.rpartition(&#39;.&#39;)
                dll = dll or ext
                for symbol in imp.entries:
                    if symbol.is_ordinal:
                        name = F&#39;@{symbol.ordinal}&#39;
                    else:
                        name = self.ascii(symbol.demangled_name) or self.ascii(symbol.name)
                    yield Symbol(
                        symbol.iat_address + self.base,
                        F&#39;{dll}.{name}&#39;,
                        ps,
                        function=True,
                        exported=False,
                        imported=True,
                    )
        elif isinstance(head, lief.MachO.Binary):
            for binding in head.dyld_chained_fixups.bindings:
                name = binding.symbol.demangled_name or binding.symbol.name
                name = self.ascii(name)
                addr = self.rebase_img_to_usr(binding.address)
                imports_done.add(name)
                yield Symbol(
                    addr,
                    name,
                    ps,
                    function=True,
                    exported=False,
                    imported=True,
                )
        elif isinstance(head, lief.ELF.Binary):
            for binding in itertools.chain(
                head.pltgot_relocations,
                head.dynamic_relocations,
            ):
                name = binding.symbol.demangled_name or binding.symbol.name
                name = self.ascii(name)
                addr = self.rebase_img_to_usr(binding.address)
                imports_done.add(name)
                yield Symbol(
                    addr,
                    name,
                    ps,
                    function=True,
                    exported=False,
                    imported=True,
                )

        for symbol in it:
            addr = self.rebase_img_to_usr(value := symbol.value)
            name = self.ascii(symbol.name)
            size = symbol.size
            if isinstance(symbol, lief.COFF.Symbol):
                name = self.ascii(symbol.demangled_name) or name
                code = symbol.is_function or (
                    symbol.complex_type == lief.COFF.Symbol.COMPLEX_TYPE.FUNCTION)
                ext = symbol.is_external
                imp = not ext
                yield Symbol(
                    addr,
                    name,
                    size,
                    function=code,
                    exported=ext,
                    imported=imp,
                    section=self._convert_section(s) if (s := symbol.section) else None,
                )
            elif isinstance(symbol, lief.PE.ImportEntry):
                continue
            elif isinstance(symbol, lief.PE.ExportEntry):
                name = self.ascii(symbol.demangled_name) or name
                yield Symbol(
                    value + self.base,
                    name,
                    ps,
                    function=True,
                    exported=True,
                    imported=False,
                )
            elif isinstance(symbol, lief.ELF.Symbol):
                if symbol.imported and symbol.is_function:
                    continue
                name = self.ascii(symbol.demangled_name) or name
                if name in imports_done:
                    continue
                yield Symbol(
                    addr,
                    name,
                    size,
                    exported=symbol.exported,
                    imported=symbol.imported,
                    function=symbol.is_function,
                    section=self._convert_section(s) if (s := symbol.section) else None,
                )
            elif isinstance(symbol, lief.MachO.Symbol):
                name = self.ascii(symbol.demangled_name) or name
                if name in imports_done:
                    continue
                yield Symbol(
                    addr,
                    name,
                    size,
                    function=True,
                    imported=symbol.is_external,
                    exported=symbol.has_export_info,
                )
            else:
                yield Symbol(
                    addr,
                    name,
                    size,
                    function=False,
                    imported=False,
                    exported=False,
                )

    def _convert_section(self, section: lief.Section, segment_name: str | None = None) -&gt; Section:
        p_lower = section.offset
        p_upper = p_lower + section.size

        v_lower = section.virtual_address
        if self._type == ET.PE:
            v_lower += self.image_defined_base()
        v_lower = self.rebase_img_to_usr(v_lower)
        v_align = getattr(section, &#39;alignment&#39;, 1)
        v__size = getattr(section, &#39;virtual_size&#39;, section.size)
        v_upper = v_lower + align(v_align, v__size)
        name = self.ascii(section.name)
        if segment_name is not None:
            name = F&#39;{segment_name}/{name}&#39;
        return Section(
            name,
            Range(p_lower, p_upper),
            Range(v_lower, v_upper),
            synthetic=False,
        )

    @property
    def is_pe(self):
        return isinstance(self._head, lief.PE.Binary)

    @property
    def is_elf(self):
        return isinstance(self._head, lief.ELF.Binary)

    @property
    def is_macho(self):
        return isinstance(self._head, (lief.MachO.Binary, lief.MachO.FatBinary))

    def _sections(self) -&gt; Generator[Section]:
        if self.is_pe:
            it: Iterable[lief.Section] = self._lh.sections
            for section in it:
                if section.size == 0:
                    continue
                yield self._convert_section(section)
            return
        if self.is_elf:
            for section in self._lh.sections:
                if section.size &gt; 0:
                    yield self._convert_section(section)
            return
        for segment in self.segments(populate_sections=True):
            if segment.name:
                yield segment.as_section()
            if self.is_pe:
                return
            if sections := segment.sections:
                yield from sections

    def _segments(self, populate_sections=False) -&gt; Generator[Segment]:
        if self.is_pe:
            for section in self.sections():
                yield section.as_segment(populate_sections)
        else:
            fh = self._first_header
            assert isinstance(fh, (lief.MachO.Binary, lief.ELF.Binary))
            for segment in fh.segments:
                p_lower = segment.file_offset
                try:
                    p_upper = p_lower + segment.file_size
                except AttributeError:
                    p_upper = p_lower + segment.physical_size
                v_lower = segment.virtual_address
                v_lower = self.rebase_img_to_usr(v_lower)
                if v_lower &lt; 0:
                    continue # __PAGEZERO
                v_upper = v_lower + segment.virtual_size
                try:
                    name = segment.name
                except AttributeError:
                    name = None
                else:
                    name = self.ascii(name)
                if not populate_sections:
                    sections = None
                else:
                    sections = [self._convert_section(section, name) for section in segment.sections]
                yield Segment(Range(p_lower, p_upper), Range(v_lower, v_upper), sections, name)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.executable.align"><code class="name flex">
<span>def <span class="ident">align</span></span>(<span>alignment, value, down=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Given an alignment size and an integer value, compute the byte boundary to where this value
would be aligned. By default, the next higher address that satisfies the alignment is computed;
The optional parameter <code>down</code> can be set to <code>True</code> to instead return the next lower one.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L54-L67" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def align(alignment: int, value: int, down=False) -&gt; int:
    &#34;&#34;&#34;
    Given an alignment size and an integer value, compute the byte boundary to where this value
    would be aligned. By default, the next higher address that satisfies the alignment is computed;
    The optional parameter `down` can be set to `True` to instead return the next lower one.
    &#34;&#34;&#34;
    if alignment &gt;= 2:
        incomplete_chunk_count = value % alignment
        if incomplete_chunk_count &gt; 0:
            if not down:
                value += alignment - incomplete_chunk_count
            else:
                value -= incomplete_chunk_count
    return value</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.executable.ParsingFailure"><code class="flex name class">
<span>class <span class="ident">ParsingFailure</span></span>
<span>(</span><span>kind)</span>
</code></dt>
<dd>
<section class="desc"><p>Exception generated for parsing errors of an input <code><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L46-L51" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ParsingFailure(ValueError):
    &#34;&#34;&#34;
    Exception generated for parsing errors of an input `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    def __init__(self, kind):
        super().__init__(F&#39;unable to parse input as {kind} file&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.executable.Range"><code class="flex name class">
<span>class <span class="ident">Range</span></span>
<span>(</span><span>lower, upper)</span>
</code></dt>
<dd>
<section class="desc"><p>A range of bytes specified by a lower and an upper bound. A <code><a title="refinery.lib.executable.Range" href="#refinery.lib.executable.Range">Range</a></code>
can be subtracted from another one to return a list of ranges that are the result of
removing the former from the latter. This operation is the only reason for using a custom
class over the builtin <code>range</code> object, which does not support this.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L70-L117" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Range(NamedTuple):
    &#34;&#34;&#34;
    A range of bytes specified by a lower and an upper bound. A `refinery.lib.executable.Range`
    can be subtracted from another one to return a list of ranges that are the result of
    removing the former from the latter. This operation is the only reason for using a custom
    class over the builtin `range` object, which does not support this.
    &#34;&#34;&#34;
    lower: int
    upper: int

    def range(self):
        &#34;&#34;&#34;
        Convertsion to a `range` object.
        &#34;&#34;&#34;
        return range(self.lower, self.upper)

    def slice(self):
        &#34;&#34;&#34;
        Conversion to a `slice` object.
        &#34;&#34;&#34;
        return slice(self.lower, self.upper)

    def __eq__(self, other):
        if not isinstance(other, Range):
            return False
        return other.lower == self.lower and other.upper == self.upper

    def __len__(self):
        return self.upper - self.lower

    def __contains__(self, addr: object):
        if not isinstance(addr, int):
            raise TypeError
        return self.lower &lt;= addr &lt; self.upper

    def __str__(self):
        return F&#39;0x{self.lower:X}:0x{self.upper:X}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;

    def __sub__(self, them: Range) -&gt; list[Range]:
        pieces = []
        if self.lower &lt; them.lower:
            pieces.append(Range(self.lower, min(them.lower, self.upper)))
        if them.upper &lt; self.upper:
            pieces.append(Range(max(self.lower, them.upper), self.upper))
        return pieces</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.Range.lower"><code class="name">var <span class="ident">lower</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L70-L117" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Range(NamedTuple):
    &#34;&#34;&#34;
    A range of bytes specified by a lower and an upper bound. A `refinery.lib.executable.Range`
    can be subtracted from another one to return a list of ranges that are the result of
    removing the former from the latter. This operation is the only reason for using a custom
    class over the builtin `range` object, which does not support this.
    &#34;&#34;&#34;
    lower: int
    upper: int

    def range(self):
        &#34;&#34;&#34;
        Convertsion to a `range` object.
        &#34;&#34;&#34;
        return range(self.lower, self.upper)

    def slice(self):
        &#34;&#34;&#34;
        Conversion to a `slice` object.
        &#34;&#34;&#34;
        return slice(self.lower, self.upper)

    def __eq__(self, other):
        if not isinstance(other, Range):
            return False
        return other.lower == self.lower and other.upper == self.upper

    def __len__(self):
        return self.upper - self.lower

    def __contains__(self, addr: object):
        if not isinstance(addr, int):
            raise TypeError
        return self.lower &lt;= addr &lt; self.upper

    def __str__(self):
        return F&#39;0x{self.lower:X}:0x{self.upper:X}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;

    def __sub__(self, them: Range) -&gt; list[Range]:
        pieces = []
        if self.lower &lt; them.lower:
            pieces.append(Range(self.lower, min(them.lower, self.upper)))
        if them.upper &lt; self.upper:
            pieces.append(Range(max(self.lower, them.upper), self.upper))
        return pieces</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Range.upper"><code class="name">var <span class="ident">upper</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L70-L117" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Range(NamedTuple):
    &#34;&#34;&#34;
    A range of bytes specified by a lower and an upper bound. A `refinery.lib.executable.Range`
    can be subtracted from another one to return a list of ranges that are the result of
    removing the former from the latter. This operation is the only reason for using a custom
    class over the builtin `range` object, which does not support this.
    &#34;&#34;&#34;
    lower: int
    upper: int

    def range(self):
        &#34;&#34;&#34;
        Convertsion to a `range` object.
        &#34;&#34;&#34;
        return range(self.lower, self.upper)

    def slice(self):
        &#34;&#34;&#34;
        Conversion to a `slice` object.
        &#34;&#34;&#34;
        return slice(self.lower, self.upper)

    def __eq__(self, other):
        if not isinstance(other, Range):
            return False
        return other.lower == self.lower and other.upper == self.upper

    def __len__(self):
        return self.upper - self.lower

    def __contains__(self, addr: object):
        if not isinstance(addr, int):
            raise TypeError
        return self.lower &lt;= addr &lt; self.upper

    def __str__(self):
        return F&#39;0x{self.lower:X}:0x{self.upper:X}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;

    def __sub__(self, them: Range) -&gt; list[Range]:
        pieces = []
        if self.lower &lt; them.lower:
            pieces.append(Range(self.lower, min(them.lower, self.upper)))
        if them.upper &lt; self.upper:
            pieces.append(Range(max(self.lower, them.upper), self.upper))
        return pieces</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.executable.Range.range"><code class="name flex">
<span>def <span class="ident">range</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Convertsion to a <code>range</code> object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L80-L84" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def range(self):
    &#34;&#34;&#34;
    Convertsion to a `range` object.
    &#34;&#34;&#34;
    return range(self.lower, self.upper)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Range.slice"><code class="name flex">
<span>def <span class="ident">slice</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Conversion to a <code>slice</code> object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L86-L90" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def slice(self):
    &#34;&#34;&#34;
    Conversion to a `slice` object.
    &#34;&#34;&#34;
    return slice(self.lower, self.upper)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.BoxedOffset"><code class="flex name class">
<span>class <span class="ident">BoxedOffset</span></span>
<span>(</span><span>box, position)</span>
</code></dt>
<dd>
<section class="desc"><p>An offset together with a range of available bytes at that location.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L120-L131" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BoxedOffset(NamedTuple):
    &#34;&#34;&#34;
    An offset together with a range of available bytes at that location.
    &#34;&#34;&#34;
    box: Range
    position: int

    def __str__(self):
        return F&#39;0x{self.position:X} in {self.box!s}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.BoxedOffset.box"><code class="name">var <span class="ident">box</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L120-L131" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BoxedOffset(NamedTuple):
    &#34;&#34;&#34;
    An offset together with a range of available bytes at that location.
    &#34;&#34;&#34;
    box: Range
    position: int

    def __str__(self):
        return F&#39;0x{self.position:X} in {self.box!s}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.BoxedOffset.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L120-L131" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BoxedOffset(NamedTuple):
    &#34;&#34;&#34;
    An offset together with a range of available bytes at that location.
    &#34;&#34;&#34;
    box: Range
    position: int

    def __str__(self):
        return F&#39;0x{self.position:X} in {self.box!s}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.Location"><code class="flex name class">
<span>class <span class="ident">Location</span></span>
<span>(</span><span>physical, virtual)</span>
</code></dt>
<dd>
<section class="desc"><p>A location in an <code><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></code>. Contains <code><a title="refinery.lib.executable.BoxedOffset" href="#refinery.lib.executable.BoxedOffset">BoxedOffset</a></code>
for both its physical and virtual range of bytes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L134-L146" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Location(NamedTuple):
    &#34;&#34;&#34;
    A location in an `refinery.lib.executable.Executable`. Contains `refinery.lib.executable.BoxedOffset`
    for both its physical and virtual range of bytes.
    &#34;&#34;&#34;
    physical: BoxedOffset
    virtual: BoxedOffset

    def __str__(self):
        return F&#39;V={self.virtual!s}; P={self.physical!s}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.Location.physical"><code class="name">var <span class="ident">physical</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L134-L146" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Location(NamedTuple):
    &#34;&#34;&#34;
    A location in an `refinery.lib.executable.Executable`. Contains `refinery.lib.executable.BoxedOffset`
    for both its physical and virtual range of bytes.
    &#34;&#34;&#34;
    physical: BoxedOffset
    virtual: BoxedOffset

    def __str__(self):
        return F&#39;V={self.virtual!s}; P={self.physical!s}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Location.virtual"><code class="name">var <span class="ident">virtual</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L134-L146" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Location(NamedTuple):
    &#34;&#34;&#34;
    A location in an `refinery.lib.executable.Executable`. Contains `refinery.lib.executable.BoxedOffset`
    for both its physical and virtual range of bytes.
    &#34;&#34;&#34;
    physical: BoxedOffset
    virtual: BoxedOffset

    def __str__(self):
        return F&#39;V={self.virtual!s}; P={self.physical!s}&#39;

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.ArchItem"><code class="flex name class">
<span>class <span class="ident">ArchItem</span></span>
<span>(</span><span>pointer_size, id)</span>
</code></dt>
<dd>
<section class="desc"><p>An item of the <code><a title="refinery.lib.executable.Arch" href="#refinery.lib.executable.Arch">Arch</a></code> enumeration. It is used to store the register
size in bits for a given architecture.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L149-L155" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ArchItem(NamedTuple):
    &#34;&#34;&#34;
    An item of the `refinery.lib.executable.Arch` enumeration. It is used to store the register
    size in bits for a given architecture.
    &#34;&#34;&#34;
    pointer_size: int
    id: str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.executable.Arch" href="#refinery.lib.executable.Arch">Arch</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.ArchItem.pointer_size"><code class="name">var <span class="ident">pointer_size</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L149-L155" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ArchItem(NamedTuple):
    &#34;&#34;&#34;
    An item of the `refinery.lib.executable.Arch` enumeration. It is used to store the register
    size in bits for a given architecture.
    &#34;&#34;&#34;
    pointer_size: int
    id: str</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.ArchItem.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L149-L155" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ArchItem(NamedTuple):
    &#34;&#34;&#34;
    An item of the `refinery.lib.executable.Arch` enumeration. It is used to store the register
    size in bits for a given architecture.
    &#34;&#34;&#34;
    pointer_size: int
    id: str</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.Arch"><code class="flex name class">
<span>class <span class="ident">Arch</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration of supported architectures and their register sizes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L158-L172" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Arch(ArchItem, Enum):
    &#34;&#34;&#34;
    An enumeration of supported architectures and their register sizes.
    &#34;&#34;&#34;
    X32 = (32, &#39;X32&#39;)
    X64 = (64, &#39;X64&#39;)
    ARM32 = (32, &#39;ARM32&#39;)
    ARM64 = (64, &#39;ARM64&#39;)
    MIPS16 = (16, &#39;MIPS16&#39;)
    MIPS32 = (32, &#39;MIPS32&#39;)
    MIPS64 = (64, &#39;MIPS64&#39;)
    PPC32 = (32, &#39;PPC32&#39;)
    PPC64 = (64, &#39;PPC64&#39;)
    SPARC32 = (32, &#39;SPARC32&#39;)
    SPARC64 = (64, &#39;SPARC64&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.executable.ArchItem" href="#refinery.lib.executable.ArchItem">ArchItem</a></li>
<li>builtins.tuple</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.executable.Arch.X32"><code class="name">var <span class="ident">X32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.X64"><code class="name">var <span class="ident">X64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.ARM32"><code class="name">var <span class="ident">ARM32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.ARM64"><code class="name">var <span class="ident">ARM64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.MIPS16"><code class="name">var <span class="ident">MIPS16</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.MIPS32"><code class="name">var <span class="ident">MIPS32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.MIPS64"><code class="name">var <span class="ident">MIPS64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.PPC32"><code class="name">var <span class="ident">PPC32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.PPC64"><code class="name">var <span class="ident">PPC64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.SPARC32"><code class="name">var <span class="ident">SPARC32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.Arch.SPARC64"><code class="name">var <span class="ident">SPARC64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.executable.ArchItem" href="#refinery.lib.executable.ArchItem">ArchItem</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.executable.ArchItem.id" href="#refinery.lib.executable.ArchItem.id">id</a></code></li>
<li><code><a title="refinery.lib.executable.ArchItem.pointer_size" href="#refinery.lib.executable.ArchItem.pointer_size">pointer_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.executable.LT"><code class="flex name class">
<span>class <span class="ident">LT</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration to distinguish between physical and virtual address types.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L175-L180" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LT(str, Enum):
    &#34;&#34;&#34;
    An enumeration to distinguish between physical and virtual address types.
    &#34;&#34;&#34;
    PHYSICAL = &#39;offset&#39;
    VIRTUAL = &#39;address&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.executable.LT.PHYSICAL"><code class="name">var <span class="ident">PHYSICAL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.LT.VIRTUAL"><code class="name">var <span class="ident">VIRTUAL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.ET"><code class="flex name class">
<span>class <span class="ident">ET</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration to distinguish various executable types.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L183-L190" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ET(str, Enum):
    &#34;&#34;&#34;
    An enumeration to distinguish various executable types.
    &#34;&#34;&#34;
    ELF = &#39;ELF&#39;
    MachO = &#39;MachO&#39;
    PE = &#39;PE&#39;
    BLOB = &#39;BLOB&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.executable.ET.ELF"><code class="name">var <span class="ident">ELF</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.ET.MachO"><code class="name">var <span class="ident">MachO</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.ET.PE"><code class="name">var <span class="ident">PE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.ET.BLOB"><code class="name">var <span class="ident">BLOB</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.BO"><code class="flex name class">
<span>class <span class="ident">BO</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration to distinguish big and little endian.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L193-L198" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BO(str, Enum):
    &#34;&#34;&#34;
    An enumeration to distinguish big and little endian.
    &#34;&#34;&#34;
    BE = &#39;big&#39;
    LE = &#39;little&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.executable.BO.BE"><code class="name">var <span class="ident">BE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.executable.BO.LE"><code class="name">var <span class="ident">LE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.Section"><code class="flex name class">
<span>class <span class="ident">Section</span></span>
<span>(</span><span>name, physical, virtual, synthetic)</span>
</code></dt>
<dd>
<section class="desc"><p>An abstract representation of a section inside an <code><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L201-L223" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Section(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a section inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    name: str
    physical: Range
    virtual: Range
    synthetic: bool

    def as_segment(self: Section, populate_sections=False) -&gt; Segment:
        sections = [self] if populate_sections else None
        return Segment(self.physical, self.virtual, sections, self.name)

    def __eq__(self, other):
        if not isinstance(other, Section):
            return False
        return other.physical == self.physical and other.virtual == self.virtual

    def __str__(self):
        return str(self.as_segment())

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.Section.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L201-L223" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Section(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a section inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    name: str
    physical: Range
    virtual: Range
    synthetic: bool

    def as_segment(self: Section, populate_sections=False) -&gt; Segment:
        sections = [self] if populate_sections else None
        return Segment(self.physical, self.virtual, sections, self.name)

    def __eq__(self, other):
        if not isinstance(other, Section):
            return False
        return other.physical == self.physical and other.virtual == self.virtual

    def __str__(self):
        return str(self.as_segment())

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Section.physical"><code class="name">var <span class="ident">physical</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L201-L223" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Section(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a section inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    name: str
    physical: Range
    virtual: Range
    synthetic: bool

    def as_segment(self: Section, populate_sections=False) -&gt; Segment:
        sections = [self] if populate_sections else None
        return Segment(self.physical, self.virtual, sections, self.name)

    def __eq__(self, other):
        if not isinstance(other, Section):
            return False
        return other.physical == self.physical and other.virtual == self.virtual

    def __str__(self):
        return str(self.as_segment())

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Section.virtual"><code class="name">var <span class="ident">virtual</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L201-L223" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Section(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a section inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    name: str
    physical: Range
    virtual: Range
    synthetic: bool

    def as_segment(self: Section, populate_sections=False) -&gt; Segment:
        sections = [self] if populate_sections else None
        return Segment(self.physical, self.virtual, sections, self.name)

    def __eq__(self, other):
        if not isinstance(other, Section):
            return False
        return other.physical == self.physical and other.virtual == self.virtual

    def __str__(self):
        return str(self.as_segment())

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Section.synthetic"><code class="name">var <span class="ident">synthetic</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L201-L223" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Section(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a section inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    name: str
    physical: Range
    virtual: Range
    synthetic: bool

    def as_segment(self: Section, populate_sections=False) -&gt; Segment:
        sections = [self] if populate_sections else None
        return Segment(self.physical, self.virtual, sections, self.name)

    def __eq__(self, other):
        if not isinstance(other, Section):
            return False
        return other.physical == self.physical and other.virtual == self.virtual

    def __str__(self):
        return str(self.as_segment())

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.executable.Section.as_segment"><code class="name flex">
<span>def <span class="ident">as_segment</span></span>(<span>self, populate_sections=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L210-L212" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def as_segment(self: Section, populate_sections=False) -&gt; Segment:
    sections = [self] if populate_sections else None
    return Segment(self.physical, self.virtual, sections, self.name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.Relocation"><code class="flex name class">
<span>class <span class="ident">Relocation</span></span>
<span>(</span><span>address, value, size)</span>
</code></dt>
<dd>
<section class="desc"><p>The data required to apply a relocation; An integer of the given size at the given address has
to be patched to the given value.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L226-L233" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Relocation(NamedTuple):
    &#34;&#34;&#34;
    The data required to apply a relocation; An integer of the given size at the given address has
    to be patched to the given value.
    &#34;&#34;&#34;
    address: int
    value: int
    size: int</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.Relocation.address"><code class="name">var <span class="ident">address</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L226-L233" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Relocation(NamedTuple):
    &#34;&#34;&#34;
    The data required to apply a relocation; An integer of the given size at the given address has
    to be patched to the given value.
    &#34;&#34;&#34;
    address: int
    value: int
    size: int</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Relocation.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L226-L233" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Relocation(NamedTuple):
    &#34;&#34;&#34;
    The data required to apply a relocation; An integer of the given size at the given address has
    to be patched to the given value.
    &#34;&#34;&#34;
    address: int
    value: int
    size: int</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Relocation.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L226-L233" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Relocation(NamedTuple):
    &#34;&#34;&#34;
    The data required to apply a relocation; An integer of the given size at the given address has
    to be patched to the given value.
    &#34;&#34;&#34;
    address: int
    value: int
    size: int</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.Symbol"><code class="flex name class">
<span>class <span class="ident">Symbol</span></span>
<span>(</span><span>address, name, size, function, exported, imported, is_entry=False, section=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Symbol(address, name, size, function, exported, imported, is_entry, section)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L236-L255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Symbol(NamedTuple):
    address: int
    name: str | None
    size: int | None
    function: bool
    exported: bool
    imported: bool
    is_entry: bool = False
    section: Section | None = None

    def get_name(self):
        name = self.name
        if name is not None:
            return name
        if self.is_entry:
            return &#39;entry&#39;
        if self.function:
            return F&#39;sub_{self.address:08X}&#39;
        else:
            return F&#39;sym_{self.address:08X}&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.Symbol.address"><code class="name">var <span class="ident">address</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L236-L255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Symbol(NamedTuple):
    address: int
    name: str | None
    size: int | None
    function: bool
    exported: bool
    imported: bool
    is_entry: bool = False
    section: Section | None = None

    def get_name(self):
        name = self.name
        if name is not None:
            return name
        if self.is_entry:
            return &#39;entry&#39;
        if self.function:
            return F&#39;sub_{self.address:08X}&#39;
        else:
            return F&#39;sym_{self.address:08X}&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Symbol.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L236-L255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Symbol(NamedTuple):
    address: int
    name: str | None
    size: int | None
    function: bool
    exported: bool
    imported: bool
    is_entry: bool = False
    section: Section | None = None

    def get_name(self):
        name = self.name
        if name is not None:
            return name
        if self.is_entry:
            return &#39;entry&#39;
        if self.function:
            return F&#39;sub_{self.address:08X}&#39;
        else:
            return F&#39;sym_{self.address:08X}&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Symbol.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L236-L255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Symbol(NamedTuple):
    address: int
    name: str | None
    size: int | None
    function: bool
    exported: bool
    imported: bool
    is_entry: bool = False
    section: Section | None = None

    def get_name(self):
        name = self.name
        if name is not None:
            return name
        if self.is_entry:
            return &#39;entry&#39;
        if self.function:
            return F&#39;sub_{self.address:08X}&#39;
        else:
            return F&#39;sym_{self.address:08X}&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Symbol.function"><code class="name">var <span class="ident">function</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L236-L255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Symbol(NamedTuple):
    address: int
    name: str | None
    size: int | None
    function: bool
    exported: bool
    imported: bool
    is_entry: bool = False
    section: Section | None = None

    def get_name(self):
        name = self.name
        if name is not None:
            return name
        if self.is_entry:
            return &#39;entry&#39;
        if self.function:
            return F&#39;sub_{self.address:08X}&#39;
        else:
            return F&#39;sym_{self.address:08X}&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Symbol.exported"><code class="name">var <span class="ident">exported</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 4</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L236-L255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Symbol(NamedTuple):
    address: int
    name: str | None
    size: int | None
    function: bool
    exported: bool
    imported: bool
    is_entry: bool = False
    section: Section | None = None

    def get_name(self):
        name = self.name
        if name is not None:
            return name
        if self.is_entry:
            return &#39;entry&#39;
        if self.function:
            return F&#39;sub_{self.address:08X}&#39;
        else:
            return F&#39;sym_{self.address:08X}&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Symbol.imported"><code class="name">var <span class="ident">imported</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 5</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L236-L255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Symbol(NamedTuple):
    address: int
    name: str | None
    size: int | None
    function: bool
    exported: bool
    imported: bool
    is_entry: bool = False
    section: Section | None = None

    def get_name(self):
        name = self.name
        if name is not None:
            return name
        if self.is_entry:
            return &#39;entry&#39;
        if self.function:
            return F&#39;sub_{self.address:08X}&#39;
        else:
            return F&#39;sym_{self.address:08X}&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Symbol.is_entry"><code class="name">var <span class="ident">is_entry</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 6</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L236-L255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Symbol(NamedTuple):
    address: int
    name: str | None
    size: int | None
    function: bool
    exported: bool
    imported: bool
    is_entry: bool = False
    section: Section | None = None

    def get_name(self):
        name = self.name
        if name is not None:
            return name
        if self.is_entry:
            return &#39;entry&#39;
        if self.function:
            return F&#39;sub_{self.address:08X}&#39;
        else:
            return F&#39;sym_{self.address:08X}&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Symbol.section"><code class="name">var <span class="ident">section</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 7</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L236-L255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Symbol(NamedTuple):
    address: int
    name: str | None
    size: int | None
    function: bool
    exported: bool
    imported: bool
    is_entry: bool = False
    section: Section | None = None

    def get_name(self):
        name = self.name
        if name is not None:
            return name
        if self.is_entry:
            return &#39;entry&#39;
        if self.function:
            return F&#39;sub_{self.address:08X}&#39;
        else:
            return F&#39;sym_{self.address:08X}&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.executable.Symbol.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L246-L255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_name(self):
    name = self.name
    if name is not None:
        return name
    if self.is_entry:
        return &#39;entry&#39;
    if self.function:
        return F&#39;sub_{self.address:08X}&#39;
    else:
        return F&#39;sym_{self.address:08X}&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.Segment"><code class="flex name class">
<span>class <span class="ident">Segment</span></span>
<span>(</span><span>physical, virtual, sections, name=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An abstract representation of a segment inside an <code><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L258-L284" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Segment(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a segment inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    physical: Range
    virtual: Range
    sections: list[Section] | None
    name: str | None = None

    def as_section(self) -&gt; Section:
        if self.name is None:
            raise ValueError(&#39;Unable to convert nameless segment to section.&#39;)
        return Section(self.name, self.physical, self.virtual, False)

    def __eq__(self, other):
        if not isinstance(other, Segment):
            return False
        return other.virtual == self.virtual and other.physical == self.physical

    def __str__(self):
        msg = F&#39;P=[{self.physical!s}];V=[{self.virtual!s}]&#39;
        if self.name is not None:
            msg = F&#39;{self.name}:{msg}&#39;
        return msg

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.Segment.physical"><code class="name">var <span class="ident">physical</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L258-L284" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Segment(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a segment inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    physical: Range
    virtual: Range
    sections: list[Section] | None
    name: str | None = None

    def as_section(self) -&gt; Section:
        if self.name is None:
            raise ValueError(&#39;Unable to convert nameless segment to section.&#39;)
        return Section(self.name, self.physical, self.virtual, False)

    def __eq__(self, other):
        if not isinstance(other, Segment):
            return False
        return other.virtual == self.virtual and other.physical == self.physical

    def __str__(self):
        msg = F&#39;P=[{self.physical!s}];V=[{self.virtual!s}]&#39;
        if self.name is not None:
            msg = F&#39;{self.name}:{msg}&#39;
        return msg

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Segment.virtual"><code class="name">var <span class="ident">virtual</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L258-L284" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Segment(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a segment inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    physical: Range
    virtual: Range
    sections: list[Section] | None
    name: str | None = None

    def as_section(self) -&gt; Section:
        if self.name is None:
            raise ValueError(&#39;Unable to convert nameless segment to section.&#39;)
        return Section(self.name, self.physical, self.virtual, False)

    def __eq__(self, other):
        if not isinstance(other, Segment):
            return False
        return other.virtual == self.virtual and other.physical == self.physical

    def __str__(self):
        msg = F&#39;P=[{self.physical!s}];V=[{self.virtual!s}]&#39;
        if self.name is not None:
            msg = F&#39;{self.name}:{msg}&#39;
        return msg

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Segment.sections"><code class="name">var <span class="ident">sections</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L258-L284" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Segment(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a segment inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    physical: Range
    virtual: Range
    sections: list[Section] | None
    name: str | None = None

    def as_section(self) -&gt; Section:
        if self.name is None:
            raise ValueError(&#39;Unable to convert nameless segment to section.&#39;)
        return Section(self.name, self.physical, self.virtual, False)

    def __eq__(self, other):
        if not isinstance(other, Segment):
            return False
        return other.virtual == self.virtual and other.physical == self.physical

    def __str__(self):
        msg = F&#39;P=[{self.physical!s}];V=[{self.virtual!s}]&#39;
        if self.name is not None:
            msg = F&#39;{self.name}:{msg}&#39;
        return msg

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Segment.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L258-L284" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Segment(NamedTuple):
    &#34;&#34;&#34;
    An abstract representation of a segment inside an `refinery.lib.executable.Executable`.
    &#34;&#34;&#34;
    physical: Range
    virtual: Range
    sections: list[Section] | None
    name: str | None = None

    def as_section(self) -&gt; Section:
        if self.name is None:
            raise ValueError(&#39;Unable to convert nameless segment to section.&#39;)
        return Section(self.name, self.physical, self.virtual, False)

    def __eq__(self, other):
        if not isinstance(other, Segment):
            return False
        return other.virtual == self.virtual and other.physical == self.physical

    def __str__(self):
        msg = F&#39;P=[{self.physical!s}];V=[{self.virtual!s}]&#39;
        if self.name is not None:
            msg = F&#39;{self.name}:{msg}&#39;
        return msg

    def __repr__(self):
        return F&#39;&lt;{self.__class__.__name__}:{self!s}&gt;&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.executable.Segment.as_section"><code class="name flex">
<span>def <span class="ident">as_section</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L267-L270" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def as_section(self) -&gt; Section:
    if self.name is None:
        raise ValueError(&#39;Unable to convert nameless segment to section.&#39;)
    return Section(self.name, self.physical, self.virtual, False)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.CompartmentNotFound"><code class="flex name class">
<span>class <span class="ident">CompartmentNotFound</span></span>
<span>(</span><span>lt, location)</span>
</code></dt>
<dd>
<section class="desc"><p>This exception is raised when <code><a title="refinery.lib.executable.Executable.lookup_location" href="#refinery.lib.executable.Executable.lookup_location">Executable.lookup_location()</a></code> fails to
find a <code><a title="refinery.lib.executable.Segment" href="#refinery.lib.executable.Segment">Segment</a></code> that contains the given location.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L287-L295" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CompartmentNotFound(LookupError):
    &#34;&#34;&#34;
    This exception is raised when `refinery.lib.executable.Executable.lookup_location` fails to
    find a `refinery.lib.executable.Segment` that contains the given location.
    &#34;&#34;&#34;
    def __init__(self, lt: LT, location: int):
        super().__init__(F&#39;Unable to find a segment that contains the {lt.value} 0x{location:X}.&#39;)
        self.location_type = lt
        self.location = location</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.LookupError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.executable.Executable"><code class="flex name class">
<span>class <span class="ident">Executable</span></span>
<span>(</span><span>head, data, base=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An abstract representation of a parsed executable in memory.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L298-L638" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Executable(ABC):
    &#34;&#34;&#34;
    An abstract representation of a parsed executable in memory.
    &#34;&#34;&#34;

    _data: buf
    _head: AnyLIEF | None
    _base: int | None

    blob: ClassVar[bool] = False

    @property
    @abstractmethod
    def _type(self) -&gt; ET:
        pass

    @classmethod
    def Load(cls, data: buf, base: int | None = None) -&gt; LIEF:
        &#34;&#34;&#34;
        Uses the `refinery.lib.lief.load` function to parse the input data.
        &#34;&#34;&#34;
        if (parsed := lief.load(data)) is None:
            raise ValueError(&#39;LIEF was unable to parse the input.&#39;)
        if isinstance(parsed, lief.COFF.Binary):
            raise NotImplementedError
        return LIEF(parsed, data, base)

    def __init__(self, head: AnyLIEF | None, data: buf, base: int | None = None):
        self._data = data
        self._head = head
        self._base = base

    @property
    def head(self):
        &#34;&#34;&#34;
        Return the internal object representing the parsed file format header.
        &#34;&#34;&#34;
        return self._head

    @property
    def type(self):
        &#34;&#34;&#34;
        Returns the `refinery.lib.executable.ET` instance that identifies the executable type.
        &#34;&#34;&#34;
        return self._type

    def __getitem__(self, key: int | slice | Range):
        return self.read(key)

    def __contains__(self, key: int | slice | Range):
        try:
            self.read(key)
        except LookupError:
            return False
        else:
            return True

    def read_integer(self, address: int, size: int | None = None):
        &#34;&#34;&#34;
        Read an integer at the given address. The size defaults to the pointer size in bytes.
        &#34;&#34;&#34;
        if size is None:
            size = self.pointer_size_in_bytes
        return int.from_bytes(self[address:address + size], self.byte_order().value)

    def read(self, key: int | slice | Range) -&gt; memoryview:
        &#34;&#34;&#34;
        Read data from the binary based on a given address. If the input `key` is a single integer,
        the function reads a single byte from the given address.
        &#34;&#34;&#34;
        if isinstance(key, Range):
            key = slice(key.lower, key.upper)
        elif isinstance(key, int):
            if key &lt; 0:
                raise LookupError(F&#39;Reading from negative address -0x{-key:X}.&#39;)
            key = slice(key, key + 1, 1)
        if key.start is None:
            raise LookupError(R&#39;Slice indices with unspecified start are not supported.&#39;)
        if key.stop is not None and key.stop &lt; key.start:
            raise LookupError(R&#39;The slice end must lie after the slice start.&#39;)

        box = self.location_from_address(key.start)

        if key.stop is None:
            end = box.physical.box.upper
        elif key.stop &lt;= box.virtual.box.upper:
            end = box.physical.position + (key.stop - key.start)
        else:
            raise LookupError(F&#39;The end address 0x{key.stop:X} is beyond the section end 0x{box.virtual.box.upper:X}.&#39;)

        return self.data[box.physical.position:end]

    @staticmethod
    def ascii(string: str | buf) -&gt; str:
        &#34;&#34;&#34;
        If the input `string` is a `str` instance, the function returns the input value. Byte
        strings are truncated to the first occurrence of a null byte and then decoded using
        the `latin-1` codec.
        &#34;&#34;&#34;
        if isinstance(string, str):
            return string
        for k, b in enumerate(string):
            if b == 0:
                string = string[:k]
                break
        return codecs.decode(string, &#39;latin-1&#39;)

    def rebase_usr_to_img(self, addr: int) -&gt; int:
        return addr - self.base + self.image_defined_base()

    def rebase_img_to_usr(self, addr: int) -&gt; int:
        return addr - self.image_defined_base() + self.base

    @property
    def base(self) -&gt; int:
        &#34;&#34;&#34;
        Return the base address when mapped to memory. This is either the value passed to the
        constructor, or `refinery.lib.exectuable.Executable.image_defined_base`.
        &#34;&#34;&#34;
        if self._base is None:
            return self.image_defined_base()
        return self._base

    @base.setter
    def base(self, value: int):
        self._base = value

    @property
    def data(self) -&gt; memoryview:
        &#34;&#34;&#34;
        Return a (readonly) view to the raw bytes of the executable image.
        &#34;&#34;&#34;
        view = memoryview(self._data)
        view = view.toreadonly()
        return view

    @property
    def pointer_size(self) -&gt; int:
        &#34;&#34;&#34;
        Return the size of a pointer in bits. Depends on `refinery.lib.executable.Executable.arch`.
        &#34;&#34;&#34;
        return self.arch().pointer_size

    @property
    def pointer_size_in_bytes(self) -&gt; int:
        &#34;&#34;&#34;
        Return the size of a pointer in bytes. Depends on `refinery.lib.executable.Executable.arch`.
        &#34;&#34;&#34;
        return self.pointer_size // 8

    def location_from_address(self, address: int) -&gt; Location:
        &#34;&#34;&#34;
        Return a `refinery.lib.executable.Location` from the given address.
        &#34;&#34;&#34;
        return self.lookup_location(address, LT.VIRTUAL)

    def location_from_offset(self, offset: int) -&gt; Location:
        &#34;&#34;&#34;
        Return a `refinery.lib.executable.Location` from the given file offset.
        &#34;&#34;&#34;
        return self.lookup_location(offset, LT.PHYSICAL)

    def offset_to_address(self, offset: int):
        &#34;&#34;&#34;
        Return the virtual address corresponding to a file offset.
        &#34;&#34;&#34;
        return self.location_from_offset(offset).virtual.position

    def address_to_offset(self, address: int):
        &#34;&#34;&#34;
        Return the virtual address corresponding to a file offset.
        &#34;&#34;&#34;
        return self.location_from_address(address).physical.position

    def image_defined_size(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the size of the executable on disk.
        &#34;&#34;&#34;
        size = 0
        for segment in self.segments():
            size = max(size, segment.physical.upper)
        for section in self.sections():
            size = max(size, section.physical.upper)
        return size

    def image_defined_address_space(self) -&gt; Range:
        &#34;&#34;&#34;
        Returns the size of the executalbe in memory.
        &#34;&#34;&#34;
        upper = 0
        lower = INF
        for segment in self.segments():
            upper = max(upper, segment.virtual.upper)
            lower = min(lower, segment.virtual.lower)
        for section in self.sections():
            upper = max(upper, section.virtual.upper)
            lower = min(lower, section.virtual.lower)
        if not isinstance(lower, int) or upper &lt; lower:
            raise RuntimeError(F&#39;The computed address space upper bound 0x{upper:X} is less than the computed lower bound 0x{lower:X}.&#39;)
        return Range(lower, upper)

    def lookup_location(self, location: int, lt: LT) -&gt; Location:
        &#34;&#34;&#34;
        For a address or file offset, compute the corresponding `refinery.lib.executable.Location`.
        &#34;&#34;&#34;
        for part in itertools.chain(self.sections(), self.segments()):
            phys = part.physical
            virt = part.virtual
            if lt is LT.PHYSICAL and location in phys:
                return Location(
                    BoxedOffset(phys, location),
                    BoxedOffset(virt, virt.lower + location - phys.lower)
                )
            if lt is LT.VIRTUAL and location in virt:
                return Location(
                    BoxedOffset(phys, phys.lower + location - virt.lower),
                    BoxedOffset(virt, location)
                )
        else:
            raise CompartmentNotFound(lt, location)

    @abstractmethod
    def _symbols(self) -&gt; Generator[Symbol]:
        ...

    def symbols(self) -&gt; Generator[Symbol]:
        &#34;&#34;&#34;
        Generates a list of symbols in the executable.
        &#34;&#34;&#34;
        for symbol in self._symbols():
            if symbol.address in self:
                yield symbol

    @abstractmethod
    def byte_order(self) -&gt; BO:
        &#34;&#34;&#34;
        The byte order used by the architecture of this executable.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def image_defined_base(self) -&gt; int:
        &#34;&#34;&#34;
        The image defined base address when mapped to memory.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def arch(self) -&gt; Arch:
        &#34;&#34;&#34;
        The architecture for which this executable was built.
        &#34;&#34;&#34;
        ...

    @abstractmethod
    def _sections(self) -&gt; Generator[Section]:
        ...

    @abstractmethod
    def _segments(self, populate_sections=False) -&gt; Generator[Segment]:
        ...

    @abstractmethod
    def _relocations(self) -&gt; Generator[Relocation]:
        ...

    def segments(self, populate_sections=False) -&gt; Generator[Segment]:
        &#34;&#34;&#34;
        An iterable of all `refinery.lib.executable.Segment`s in this executable.
        &#34;&#34;&#34;
        yield from self._segments(populate_sections=populate_sections)

    def relocations(self) -&gt; Generator[Relocation]:
        &#34;&#34;&#34;
        An iterable of all `refinery.lib.executable.Relocation`s defined in this executable.
        &#34;&#34;&#34;
        yield from self._relocations()

    def sections(self) -&gt; Generator[Section]:
        &#34;&#34;&#34;
        An iterable of all `refinery.lib.executable.Section`s in this executable.
        &#34;&#34;&#34;
        ib = self.image_defined_base()
        missing = [Range(0, len(self._data))]
        offsets = {}
        for section in self._sections():
            missing = [piece for patch in missing for piece in patch - section.physical]
            offsets[section.physical.lower] = section.virtual.lower
            yield section
        if not missing:
            return
        offsets.setdefault(0, ib)
        for gap in missing:
            p_floor = min((k for k in offsets if k &lt;= gap.lower), key=lambda p: p - gap.lower)
            v_floor = offsets[p_floor]
            v_lower = v_floor + (gap.lower - p_floor)
            v_upper = v_lower + len(gap)
            if gap.lower == 0:
                name = R&#39;synthesized/.header&#39;
            elif gap.upper == len(self._data):
                name = R&#39;synthesized/.overlay&#39;
            elif any(self._data[gap.slice()]):
                name = F&#39;synthesized/.gap-{gap.lower:08X}-{gap.upper:08X}&#39;
            else:
                name = F&#39;synthesized/.zeros-{gap.lower:08X}&#39;
            yield Section(name, gap, Range(v_lower, v_upper), True)

    def disassemble_instruction(self, address: int):
        &#34;&#34;&#34;
        Disassemble a single instruction at the given address.
        &#34;&#34;&#34;
        cs = self.disassembler()
        cs.detail = True
        data = self[address:address + 0x20]
        return next(cs.disasm(data, address, 1))

    @lru_cache
    def disassembler(self) -&gt; Cs:
        &#34;&#34;&#34;
        Create a capstone disassembler that matches the emulator&#39;s architecture.
        &#34;&#34;&#34;
        cs_arch, cs_mode = {
            Arch.X32     : (cs.CS_ARCH_X86,   cs.CS_MODE_32),     # noqa
            Arch.X64     : (cs.CS_ARCH_X86,   cs.CS_MODE_64),     # noqa
            Arch.ARM32   : (cs.CS_ARCH_ARM,   cs.CS_MODE_ARM),    # noqa
            Arch.ARM64   : (cs.CS_ARCH_ARM64, cs.CS_MODE_ARM),    # noqa
            Arch.MIPS16  : (cs.CS_ARCH_MIPS,  cs.CS_MODE_16),     # noqa
            Arch.MIPS32  : (cs.CS_ARCH_MIPS,  cs.CS_MODE_32),     # noqa
            Arch.MIPS64  : (cs.CS_ARCH_MIPS,  cs.CS_MODE_64),     # noqa
            Arch.PPC32   : (cs.CS_ARCH_PPC,   cs.CS_MODE_32),     # noqa
            Arch.PPC64   : (cs.CS_ARCH_PPC,   cs.CS_MODE_64),     # noqa
            Arch.SPARC32 : (cs.CS_ARCH_SPARC, cs.CS_MODE_32),     # noqa
            Arch.SPARC64 : (cs.CS_ARCH_SPARC, cs.CS_MODE_V9),     # noqa
        }[self.arch()]

        cs_mode |= {
            BO.BE: cs.CS_MODE_BIG_ENDIAN,
            BO.LE: cs.CS_MODE_LITTLE_ENDIAN,
        }[self.byte_order()]

        return cs.Cs(cs_arch, cs_mode)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.executable.ExecutableCodeBlob" href="#refinery.lib.executable.ExecutableCodeBlob">ExecutableCodeBlob</a></li>
<li><a title="refinery.lib.executable.LIEF" href="#refinery.lib.executable.LIEF">LIEF</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.executable.Executable.blob"><code class="name">var <span class="ident">blob</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.executable.Executable.Load"><code class="name flex">
<span>def <span class="ident">Load</span></span>(<span>data, base=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Uses the <code><a title="refinery.lib.lief.load" href="lief.html#refinery.lib.lief.load">load()</a></code> function to parse the input data.</p></section>
</dd>
<dt id="refinery.lib.executable.Executable.ascii"><code class="name flex">
<span>def <span class="ident">ascii</span></span>(<span>string)</span>
</code></dt>
<dd>
<section class="desc"><p>If the input <code>string</code> is a <code>str</code> instance, the function returns the input value. Byte
strings are truncated to the first occurrence of a null byte and then decoded using
the <code>latin-1</code> codec.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L390-L403" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def ascii(string: str | buf) -&gt; str:
    &#34;&#34;&#34;
    If the input `string` is a `str` instance, the function returns the input value. Byte
    strings are truncated to the first occurrence of a null byte and then decoded using
    the `latin-1` codec.
    &#34;&#34;&#34;
    if isinstance(string, str):
        return string
    for k, b in enumerate(string):
        if b == 0:
            string = string[:k]
            break
    return codecs.decode(string, &#39;latin-1&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.Executable.head"><code class="name">var <span class="ident">head</span></code></dt>
<dd>
<section class="desc"><p>Return the internal object representing the parsed file format header.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L330-L335" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def head(self):
    &#34;&#34;&#34;
    Return the internal object representing the parsed file format header.
    &#34;&#34;&#34;
    return self._head</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"><p>Returns the <code><a title="refinery.lib.executable.ET" href="#refinery.lib.executable.ET">ET</a></code> instance that identifies the executable type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L337-L342" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def type(self):
    &#34;&#34;&#34;
    Returns the `refinery.lib.executable.ET` instance that identifies the executable type.
    &#34;&#34;&#34;
    return self._type</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.base"><code class="name">var <span class="ident">base</span></code></dt>
<dd>
<section class="desc"><p>Return the base address when mapped to memory. This is either the value passed to the
constructor, or <code>refinery.lib.exectuable.Executable.image_defined_base</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L411-L419" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def base(self) -&gt; int:
    &#34;&#34;&#34;
    Return the base address when mapped to memory. This is either the value passed to the
    constructor, or `refinery.lib.exectuable.Executable.image_defined_base`.
    &#34;&#34;&#34;
    if self._base is None:
        return self.image_defined_base()
    return self._base</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<section class="desc"><p>Return a (readonly) view to the raw bytes of the executable image.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L425-L432" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def data(self) -&gt; memoryview:
    &#34;&#34;&#34;
    Return a (readonly) view to the raw bytes of the executable image.
    &#34;&#34;&#34;
    view = memoryview(self._data)
    view = view.toreadonly()
    return view</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.pointer_size"><code class="name">var <span class="ident">pointer_size</span></code></dt>
<dd>
<section class="desc"><p>Return the size of a pointer in bits. Depends on <code><a title="refinery.lib.executable.Executable.arch" href="#refinery.lib.executable.Executable.arch">Executable.arch()</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L434-L439" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def pointer_size(self) -&gt; int:
    &#34;&#34;&#34;
    Return the size of a pointer in bits. Depends on `refinery.lib.executable.Executable.arch`.
    &#34;&#34;&#34;
    return self.arch().pointer_size</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.pointer_size_in_bytes"><code class="name">var <span class="ident">pointer_size_in_bytes</span></code></dt>
<dd>
<section class="desc"><p>Return the size of a pointer in bytes. Depends on <code><a title="refinery.lib.executable.Executable.arch" href="#refinery.lib.executable.Executable.arch">Executable.arch()</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L441-L446" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def pointer_size_in_bytes(self) -&gt; int:
    &#34;&#34;&#34;
    Return the size of a pointer in bytes. Depends on `refinery.lib.executable.Executable.arch`.
    &#34;&#34;&#34;
    return self.pointer_size // 8</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.executable.Executable.read_integer"><code class="name flex">
<span>def <span class="ident">read_integer</span></span>(<span>self, address, size=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Read an integer at the given address. The size defaults to the pointer size in bytes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L355-L361" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_integer(self, address: int, size: int | None = None):
    &#34;&#34;&#34;
    Read an integer at the given address. The size defaults to the pointer size in bytes.
    &#34;&#34;&#34;
    if size is None:
        size = self.pointer_size_in_bytes
    return int.from_bytes(self[address:address + size], self.byte_order().value)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<section class="desc"><p>Read data from the binary based on a given address. If the input <code>key</code> is a single integer,
the function reads a single byte from the given address.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L363-L388" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read(self, key: int | slice | Range) -&gt; memoryview:
    &#34;&#34;&#34;
    Read data from the binary based on a given address. If the input `key` is a single integer,
    the function reads a single byte from the given address.
    &#34;&#34;&#34;
    if isinstance(key, Range):
        key = slice(key.lower, key.upper)
    elif isinstance(key, int):
        if key &lt; 0:
            raise LookupError(F&#39;Reading from negative address -0x{-key:X}.&#39;)
        key = slice(key, key + 1, 1)
    if key.start is None:
        raise LookupError(R&#39;Slice indices with unspecified start are not supported.&#39;)
    if key.stop is not None and key.stop &lt; key.start:
        raise LookupError(R&#39;The slice end must lie after the slice start.&#39;)

    box = self.location_from_address(key.start)

    if key.stop is None:
        end = box.physical.box.upper
    elif key.stop &lt;= box.virtual.box.upper:
        end = box.physical.position + (key.stop - key.start)
    else:
        raise LookupError(F&#39;The end address 0x{key.stop:X} is beyond the section end 0x{box.virtual.box.upper:X}.&#39;)

    return self.data[box.physical.position:end]</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.rebase_usr_to_img"><code class="name flex">
<span>def <span class="ident">rebase_usr_to_img</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L405-L406" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rebase_usr_to_img(self, addr: int) -&gt; int:
    return addr - self.base + self.image_defined_base()</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.rebase_img_to_usr"><code class="name flex">
<span>def <span class="ident">rebase_img_to_usr</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L408-L409" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rebase_img_to_usr(self, addr: int) -&gt; int:
    return addr - self.image_defined_base() + self.base</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.location_from_address"><code class="name flex">
<span>def <span class="ident">location_from_address</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a <code><a title="refinery.lib.executable.Location" href="#refinery.lib.executable.Location">Location</a></code> from the given address.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L448-L452" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def location_from_address(self, address: int) -&gt; Location:
    &#34;&#34;&#34;
    Return a `refinery.lib.executable.Location` from the given address.
    &#34;&#34;&#34;
    return self.lookup_location(address, LT.VIRTUAL)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.location_from_offset"><code class="name flex">
<span>def <span class="ident">location_from_offset</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a <code><a title="refinery.lib.executable.Location" href="#refinery.lib.executable.Location">Location</a></code> from the given file offset.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L454-L458" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def location_from_offset(self, offset: int) -&gt; Location:
    &#34;&#34;&#34;
    Return a `refinery.lib.executable.Location` from the given file offset.
    &#34;&#34;&#34;
    return self.lookup_location(offset, LT.PHYSICAL)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.offset_to_address"><code class="name flex">
<span>def <span class="ident">offset_to_address</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the virtual address corresponding to a file offset.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L460-L464" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def offset_to_address(self, offset: int):
    &#34;&#34;&#34;
    Return the virtual address corresponding to a file offset.
    &#34;&#34;&#34;
    return self.location_from_offset(offset).virtual.position</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.address_to_offset"><code class="name flex">
<span>def <span class="ident">address_to_offset</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the virtual address corresponding to a file offset.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L466-L470" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def address_to_offset(self, address: int):
    &#34;&#34;&#34;
    Return the virtual address corresponding to a file offset.
    &#34;&#34;&#34;
    return self.location_from_address(address).physical.position</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.image_defined_size"><code class="name flex">
<span>def <span class="ident">image_defined_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the size of the executable on disk.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L472-L481" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def image_defined_size(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the size of the executable on disk.
    &#34;&#34;&#34;
    size = 0
    for segment in self.segments():
        size = max(size, segment.physical.upper)
    for section in self.sections():
        size = max(size, section.physical.upper)
    return size</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.image_defined_address_space"><code class="name flex">
<span>def <span class="ident">image_defined_address_space</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the size of the executalbe in memory.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L483-L497" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def image_defined_address_space(self) -&gt; Range:
    &#34;&#34;&#34;
    Returns the size of the executalbe in memory.
    &#34;&#34;&#34;
    upper = 0
    lower = INF
    for segment in self.segments():
        upper = max(upper, segment.virtual.upper)
        lower = min(lower, segment.virtual.lower)
    for section in self.sections():
        upper = max(upper, section.virtual.upper)
        lower = min(lower, section.virtual.lower)
    if not isinstance(lower, int) or upper &lt; lower:
        raise RuntimeError(F&#39;The computed address space upper bound 0x{upper:X} is less than the computed lower bound 0x{lower:X}.&#39;)
    return Range(lower, upper)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.lookup_location"><code class="name flex">
<span>def <span class="ident">lookup_location</span></span>(<span>self, location, lt)</span>
</code></dt>
<dd>
<section class="desc"><p>For a address or file offset, compute the corresponding <code><a title="refinery.lib.executable.Location" href="#refinery.lib.executable.Location">Location</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L499-L517" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def lookup_location(self, location: int, lt: LT) -&gt; Location:
    &#34;&#34;&#34;
    For a address or file offset, compute the corresponding `refinery.lib.executable.Location`.
    &#34;&#34;&#34;
    for part in itertools.chain(self.sections(), self.segments()):
        phys = part.physical
        virt = part.virtual
        if lt is LT.PHYSICAL and location in phys:
            return Location(
                BoxedOffset(phys, location),
                BoxedOffset(virt, virt.lower + location - phys.lower)
            )
        if lt is LT.VIRTUAL and location in virt:
            return Location(
                BoxedOffset(phys, phys.lower + location - virt.lower),
                BoxedOffset(virt, location)
            )
    else:
        raise CompartmentNotFound(lt, location)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.symbols"><code class="name flex">
<span>def <span class="ident">symbols</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a list of symbols in the executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L523-L529" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def symbols(self) -&gt; Generator[Symbol]:
    &#34;&#34;&#34;
    Generates a list of symbols in the executable.
    &#34;&#34;&#34;
    for symbol in self._symbols():
        if symbol.address in self:
            yield symbol</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.byte_order"><code class="name flex">
<span>def <span class="ident">byte_order</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The byte order used by the architecture of this executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L531-L536" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def byte_order(self) -&gt; BO:
    &#34;&#34;&#34;
    The byte order used by the architecture of this executable.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.image_defined_base"><code class="name flex">
<span>def <span class="ident">image_defined_base</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The image defined base address when mapped to memory.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L538-L543" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def image_defined_base(self) -&gt; int:
    &#34;&#34;&#34;
    The image defined base address when mapped to memory.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.arch"><code class="name flex">
<span>def <span class="ident">arch</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The architecture for which this executable was built.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L545-L550" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def arch(self) -&gt; Arch:
    &#34;&#34;&#34;
    The architecture for which this executable was built.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.segments"><code class="name flex">
<span>def <span class="ident">segments</span></span>(<span>self, populate_sections=False)</span>
</code></dt>
<dd>
<section class="desc"><p>An iterable of all <code><a title="refinery.lib.executable.Segment" href="#refinery.lib.executable.Segment">Segment</a></code>s in this executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L564-L568" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def segments(self, populate_sections=False) -&gt; Generator[Segment]:
    &#34;&#34;&#34;
    An iterable of all `refinery.lib.executable.Segment`s in this executable.
    &#34;&#34;&#34;
    yield from self._segments(populate_sections=populate_sections)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.relocations"><code class="name flex">
<span>def <span class="ident">relocations</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>An iterable of all <code><a title="refinery.lib.executable.Relocation" href="#refinery.lib.executable.Relocation">Relocation</a></code>s defined in this executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L570-L574" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def relocations(self) -&gt; Generator[Relocation]:
    &#34;&#34;&#34;
    An iterable of all `refinery.lib.executable.Relocation`s defined in this executable.
    &#34;&#34;&#34;
    yield from self._relocations()</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.sections"><code class="name flex">
<span>def <span class="ident">sections</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>An iterable of all <code><a title="refinery.lib.executable.Section" href="#refinery.lib.executable.Section">Section</a></code>s in this executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L576-L603" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sections(self) -&gt; Generator[Section]:
    &#34;&#34;&#34;
    An iterable of all `refinery.lib.executable.Section`s in this executable.
    &#34;&#34;&#34;
    ib = self.image_defined_base()
    missing = [Range(0, len(self._data))]
    offsets = {}
    for section in self._sections():
        missing = [piece for patch in missing for piece in patch - section.physical]
        offsets[section.physical.lower] = section.virtual.lower
        yield section
    if not missing:
        return
    offsets.setdefault(0, ib)
    for gap in missing:
        p_floor = min((k for k in offsets if k &lt;= gap.lower), key=lambda p: p - gap.lower)
        v_floor = offsets[p_floor]
        v_lower = v_floor + (gap.lower - p_floor)
        v_upper = v_lower + len(gap)
        if gap.lower == 0:
            name = R&#39;synthesized/.header&#39;
        elif gap.upper == len(self._data):
            name = R&#39;synthesized/.overlay&#39;
        elif any(self._data[gap.slice()]):
            name = F&#39;synthesized/.gap-{gap.lower:08X}-{gap.upper:08X}&#39;
        else:
            name = F&#39;synthesized/.zeros-{gap.lower:08X}&#39;
        yield Section(name, gap, Range(v_lower, v_upper), True)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.disassemble_instruction"><code class="name flex">
<span>def <span class="ident">disassemble_instruction</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<section class="desc"><p>Disassemble a single instruction at the given address.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L605-L612" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def disassemble_instruction(self, address: int):
    &#34;&#34;&#34;
    Disassemble a single instruction at the given address.
    &#34;&#34;&#34;
    cs = self.disassembler()
    cs.detail = True
    data = self[address:address + 0x20]
    return next(cs.disasm(data, address, 1))</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.Executable.disassembler"><code class="name flex">
<span>def <span class="ident">disassembler</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a capstone disassembler that matches the emulator's architecture.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L614-L638" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@lru_cache
def disassembler(self) -&gt; Cs:
    &#34;&#34;&#34;
    Create a capstone disassembler that matches the emulator&#39;s architecture.
    &#34;&#34;&#34;
    cs_arch, cs_mode = {
        Arch.X32     : (cs.CS_ARCH_X86,   cs.CS_MODE_32),     # noqa
        Arch.X64     : (cs.CS_ARCH_X86,   cs.CS_MODE_64),     # noqa
        Arch.ARM32   : (cs.CS_ARCH_ARM,   cs.CS_MODE_ARM),    # noqa
        Arch.ARM64   : (cs.CS_ARCH_ARM64, cs.CS_MODE_ARM),    # noqa
        Arch.MIPS16  : (cs.CS_ARCH_MIPS,  cs.CS_MODE_16),     # noqa
        Arch.MIPS32  : (cs.CS_ARCH_MIPS,  cs.CS_MODE_32),     # noqa
        Arch.MIPS64  : (cs.CS_ARCH_MIPS,  cs.CS_MODE_64),     # noqa
        Arch.PPC32   : (cs.CS_ARCH_PPC,   cs.CS_MODE_32),     # noqa
        Arch.PPC64   : (cs.CS_ARCH_PPC,   cs.CS_MODE_64),     # noqa
        Arch.SPARC32 : (cs.CS_ARCH_SPARC, cs.CS_MODE_32),     # noqa
        Arch.SPARC64 : (cs.CS_ARCH_SPARC, cs.CS_MODE_V9),     # noqa
    }[self.arch()]

    cs_mode |= {
        BO.BE: cs.CS_MODE_BIG_ENDIAN,
        BO.LE: cs.CS_MODE_LITTLE_ENDIAN,
    }[self.byte_order()]

    return cs.Cs(cs_arch, cs_mode)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.executable.ExecutableCodeBlob"><code class="flex name class">
<span>class <span class="ident">ExecutableCodeBlob</span></span>
<span>(</span><span>data, base=None, arch=Arch.X32, byte_order=BO.LE)</span>
</code></dt>
<dd>
<section class="desc"><p>A dummy specialization of <code><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></code> that represents an unstructured
blob of (shell)code. All information that would usually be obtained from a file header must be
provided in the constructor for this object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L641-L695" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ExecutableCodeBlob(Executable):
    &#34;&#34;&#34;
    A dummy specialization of `refinery.lib.executable.Executable` that represents an unstructured
    blob of (shell)code. All information that would usually be obtained from a file header must be
    provided in the constructor for this object.
    &#34;&#34;&#34;

    _head = None
    _byte_order: BO
    _arch: Arch

    blob = True

    @property
    def _type(self):
        return ET.BLOB

    def __init__(self, data, base=None, arch: Arch = Arch.X32, byte_order: BO = BO.LE):
        super().__init__(None, data, base)
        self._byte_order = byte_order
        self._arch = arch

    def image_defined_base(self) -&gt; int:
        return 0

    def byte_order(self) -&gt; BO:
        return self._byte_order

    def arch(self) -&gt; Arch:
        return self._arch

    def _symbols(self) -&gt; Generator[Symbol]:
        section, = self._sections()
        yield Symbol(
            self.base,
            None,
            None,
            function=True,
            exported=True,
            imported=False,
            is_entry=True,
            section=section,
        )

    def _relocations(self):
        yield from ()

    def _sections(self) -&gt; Generator[Section]:
        v = Range(self.base, self.base + len(self.data))
        p = Range(0, len(self.data))
        yield Section(&#39;blob&#39;, p, v, False)

    def _segments(self, populate_sections=False) -&gt; Generator[Segment]:
        for s in self.sections():
            yield s.as_segment(populate_sections=populate_sections)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.executable.ExecutableCodeBlob.blob"><code class="name">var <span class="ident">blob</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.executable.Executable.Load" href="#refinery.lib.executable.Executable.Load">Load</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.address_to_offset" href="#refinery.lib.executable.Executable.address_to_offset">address_to_offset</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.arch" href="#refinery.lib.executable.Executable.arch">arch</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.ascii" href="#refinery.lib.executable.Executable.ascii">ascii</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.base" href="#refinery.lib.executable.Executable.base">base</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.byte_order" href="#refinery.lib.executable.Executable.byte_order">byte_order</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.data" href="#refinery.lib.executable.Executable.data">data</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.disassemble_instruction" href="#refinery.lib.executable.Executable.disassemble_instruction">disassemble_instruction</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.disassembler" href="#refinery.lib.executable.Executable.disassembler">disassembler</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.head" href="#refinery.lib.executable.Executable.head">head</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_address_space" href="#refinery.lib.executable.Executable.image_defined_address_space">image_defined_address_space</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_base" href="#refinery.lib.executable.Executable.image_defined_base">image_defined_base</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_size" href="#refinery.lib.executable.Executable.image_defined_size">image_defined_size</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_address" href="#refinery.lib.executable.Executable.location_from_address">location_from_address</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_offset" href="#refinery.lib.executable.Executable.location_from_offset">location_from_offset</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.lookup_location" href="#refinery.lib.executable.Executable.lookup_location">lookup_location</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.offset_to_address" href="#refinery.lib.executable.Executable.offset_to_address">offset_to_address</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.pointer_size" href="#refinery.lib.executable.Executable.pointer_size">pointer_size</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.pointer_size_in_bytes" href="#refinery.lib.executable.Executable.pointer_size_in_bytes">pointer_size_in_bytes</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.read" href="#refinery.lib.executable.Executable.read">read</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.read_integer" href="#refinery.lib.executable.Executable.read_integer">read_integer</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.relocations" href="#refinery.lib.executable.Executable.relocations">relocations</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.sections" href="#refinery.lib.executable.Executable.sections">sections</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.segments" href="#refinery.lib.executable.Executable.segments">segments</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.symbols" href="#refinery.lib.executable.Executable.symbols">symbols</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.type" href="#refinery.lib.executable.Executable.type">type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.executable.LIEF"><code class="flex name class">
<span>class <span class="ident">LIEF</span></span>
<span>(</span><span>head, data, base=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An abstract representation of a parsed executable in memory.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L698-L1024" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LIEF(Executable):

    @property
    def _lh(self) -&gt; lief.AbstractBinary:
        return self._first_header.abstract

    @property
    def _first_header(self) -&gt; MachOBinary | ELFBinary | PEBinary:
        head = self._head
        if head is None:
            raise AttributeError
        if isinstance(head, lief.COFF.Binary):
            raise NotImplementedError
        if isinstance(head, lief.MachO.FatBinary):
            head = head.at(0)
        return head

    @property
    def _type(self):
        EF = lief.AbstractBinary.FORMATS
        HF = self._lh.format
        if HF is EF.UNKNOWN:
            raise AttributeError(&#39;Unknown executable type.&#39;)
        return {EF.MACHO: ET.MachO, EF.PE: ET.PE, EF.ELF: ET.ELF}[HF]

    def image_defined_base(self) -&gt; int:
        return self._lh.imagebase

    def byte_order(self) -&gt; BO:
        return BO.BE if self._lh.header.endianness == lief.Header.ENDIANNESS.BIG else BO.LE

    def arch(self) -&gt; Arch:
        LA = lief.Header.ARCHITECTURES
        LM = lief.Header.MODES
        arch = self._lh.header.architecture
        mode = self._lh.header.modes
        if arch == LA.UNKNOWN:
            raise ValueError(&#39;No architecture set.&#39;)
        elif arch == LA.ARM:
            return Arch.ARM32
        elif arch == LA.ARM64:
            return Arch.ARM64
        elif arch == LA.MIPS:
            if LM.BITS_16 == mode:
                return Arch.MIPS16
            if LM.BITS_32 == mode:
                return Arch.MIPS32
            if LM.BITS_64 == mode:
                return Arch.MIPS64
        elif arch == LA.PPC:
            if LM.BITS_32 == mode:
                return Arch.PPC32
            if LM.BITS_64 == mode:
                return Arch.PPC64
        elif arch == LA.SPARC:
            if LM.BITS_32 == mode:
                return Arch.SPARC32
            if LM.BITS_64 == mode:
                return Arch.SPARC64
        elif arch == LA.X86_64:
            assert LM.BITS_64 == mode
            return Arch.X64
        elif arch == LA.X86:
            if LM.BITS_32 == mode:
                return Arch.X32
            if LM.BITS_64 == mode:
                return Arch.X64
        raise NotImplementedError

    def _relocations(self):
        ps = self.pointer_size_in_bytes

        if isinstance((head := self._first_header), lief.ELF.Binary):
            for rel in head.object_relocations:
                if (symbol := rel.symbol) is None:
                    continue
                if &#39;_RELATIVE&#39; in (tn := rel.type.name):
                    base = self.base
                elif tn.endswith(&#39;GLOB_DAT&#39;) or tn.endswith(&#39;JUMP_SLOT&#39;):
                    base = symbol.value
                else:
                    continue
                addr = self.rebase_img_to_usr(rel.address)
                yield Relocation(addr, base + rel.addend, ps)
        elif (delta := (base := self.base) - self.image_defined_base()) != 0:
            def relocation(addr: int, size: int):
                addr = self.rebase_img_to_usr(addr)
                mask = (1 &lt;&lt; size) - 1
                rval = self.read_integer(addr, size) + delta &amp; mask
                return Relocation(addr, rval, size // 8)

            for rel in self._lh.relocations:
                if isinstance(rel, lief.MachO.Relocation):
                    yield relocation(rel.address, rel.size)
                elif isinstance(rel, lief.PE.Relocation):
                    rva = rel.virtual_address
                    if (delta := (base := self.base) - self.image_defined_base()) == 0:
                        continue
                    for entry in rel.entries:
                        if entry.type == lief.PE.RelocationEntry.BASE_TYPES.HIGHLOW:
                            size = 32
                        elif entry.type == lief.PE.RelocationEntry.BASE_TYPES.DIR64:
                            size = 64
                        else:
                            continue
                        if size != entry.size:
                            raise RuntimeError(F&#39;Unexpected relocation size: Guessed {size}, LIEF says {entry.size}.&#39;)
                        yield relocation(base + rva + entry.position, size)
                else:
                    raise TypeError(F&#39;Unexpected relocation type: {type(rel).__qualname__}&#39;)

    def _symbols(self) -&gt; Generator[Symbol]:
        yield Symbol(
            self.rebase_img_to_usr(self._lh.entrypoint),
            None,
            None,
            function=True,
            exported=True,
            imported=False,
            is_entry=True,
        )

        it: Iterable[lief.Symbol] = self._lh.symbols
        ps = self.pointer_size_in_bytes
        imports_done: set[str] = set()

        if isinstance((head := self._first_header), lief.PE.Binary):
            for imp in head.imports:
                dll = self.ascii(imp.name).lower()
                dll, _, ext = dll.rpartition(&#39;.&#39;)
                dll = dll or ext
                for symbol in imp.entries:
                    if symbol.is_ordinal:
                        name = F&#39;@{symbol.ordinal}&#39;
                    else:
                        name = self.ascii(symbol.demangled_name) or self.ascii(symbol.name)
                    yield Symbol(
                        symbol.iat_address + self.base,
                        F&#39;{dll}.{name}&#39;,
                        ps,
                        function=True,
                        exported=False,
                        imported=True,
                    )
        elif isinstance(head, lief.MachO.Binary):
            for binding in head.dyld_chained_fixups.bindings:
                name = binding.symbol.demangled_name or binding.symbol.name
                name = self.ascii(name)
                addr = self.rebase_img_to_usr(binding.address)
                imports_done.add(name)
                yield Symbol(
                    addr,
                    name,
                    ps,
                    function=True,
                    exported=False,
                    imported=True,
                )
        elif isinstance(head, lief.ELF.Binary):
            for binding in itertools.chain(
                head.pltgot_relocations,
                head.dynamic_relocations,
            ):
                name = binding.symbol.demangled_name or binding.symbol.name
                name = self.ascii(name)
                addr = self.rebase_img_to_usr(binding.address)
                imports_done.add(name)
                yield Symbol(
                    addr,
                    name,
                    ps,
                    function=True,
                    exported=False,
                    imported=True,
                )

        for symbol in it:
            addr = self.rebase_img_to_usr(value := symbol.value)
            name = self.ascii(symbol.name)
            size = symbol.size
            if isinstance(symbol, lief.COFF.Symbol):
                name = self.ascii(symbol.demangled_name) or name
                code = symbol.is_function or (
                    symbol.complex_type == lief.COFF.Symbol.COMPLEX_TYPE.FUNCTION)
                ext = symbol.is_external
                imp = not ext
                yield Symbol(
                    addr,
                    name,
                    size,
                    function=code,
                    exported=ext,
                    imported=imp,
                    section=self._convert_section(s) if (s := symbol.section) else None,
                )
            elif isinstance(symbol, lief.PE.ImportEntry):
                continue
            elif isinstance(symbol, lief.PE.ExportEntry):
                name = self.ascii(symbol.demangled_name) or name
                yield Symbol(
                    value + self.base,
                    name,
                    ps,
                    function=True,
                    exported=True,
                    imported=False,
                )
            elif isinstance(symbol, lief.ELF.Symbol):
                if symbol.imported and symbol.is_function:
                    continue
                name = self.ascii(symbol.demangled_name) or name
                if name in imports_done:
                    continue
                yield Symbol(
                    addr,
                    name,
                    size,
                    exported=symbol.exported,
                    imported=symbol.imported,
                    function=symbol.is_function,
                    section=self._convert_section(s) if (s := symbol.section) else None,
                )
            elif isinstance(symbol, lief.MachO.Symbol):
                name = self.ascii(symbol.demangled_name) or name
                if name in imports_done:
                    continue
                yield Symbol(
                    addr,
                    name,
                    size,
                    function=True,
                    imported=symbol.is_external,
                    exported=symbol.has_export_info,
                )
            else:
                yield Symbol(
                    addr,
                    name,
                    size,
                    function=False,
                    imported=False,
                    exported=False,
                )

    def _convert_section(self, section: lief.Section, segment_name: str | None = None) -&gt; Section:
        p_lower = section.offset
        p_upper = p_lower + section.size

        v_lower = section.virtual_address
        if self._type == ET.PE:
            v_lower += self.image_defined_base()
        v_lower = self.rebase_img_to_usr(v_lower)
        v_align = getattr(section, &#39;alignment&#39;, 1)
        v__size = getattr(section, &#39;virtual_size&#39;, section.size)
        v_upper = v_lower + align(v_align, v__size)
        name = self.ascii(section.name)
        if segment_name is not None:
            name = F&#39;{segment_name}/{name}&#39;
        return Section(
            name,
            Range(p_lower, p_upper),
            Range(v_lower, v_upper),
            synthetic=False,
        )

    @property
    def is_pe(self):
        return isinstance(self._head, lief.PE.Binary)

    @property
    def is_elf(self):
        return isinstance(self._head, lief.ELF.Binary)

    @property
    def is_macho(self):
        return isinstance(self._head, (lief.MachO.Binary, lief.MachO.FatBinary))

    def _sections(self) -&gt; Generator[Section]:
        if self.is_pe:
            it: Iterable[lief.Section] = self._lh.sections
            for section in it:
                if section.size == 0:
                    continue
                yield self._convert_section(section)
            return
        if self.is_elf:
            for section in self._lh.sections:
                if section.size &gt; 0:
                    yield self._convert_section(section)
            return
        for segment in self.segments(populate_sections=True):
            if segment.name:
                yield segment.as_section()
            if self.is_pe:
                return
            if sections := segment.sections:
                yield from sections

    def _segments(self, populate_sections=False) -&gt; Generator[Segment]:
        if self.is_pe:
            for section in self.sections():
                yield section.as_segment(populate_sections)
        else:
            fh = self._first_header
            assert isinstance(fh, (lief.MachO.Binary, lief.ELF.Binary))
            for segment in fh.segments:
                p_lower = segment.file_offset
                try:
                    p_upper = p_lower + segment.file_size
                except AttributeError:
                    p_upper = p_lower + segment.physical_size
                v_lower = segment.virtual_address
                v_lower = self.rebase_img_to_usr(v_lower)
                if v_lower &lt; 0:
                    continue # __PAGEZERO
                v_upper = v_lower + segment.virtual_size
                try:
                    name = segment.name
                except AttributeError:
                    name = None
                else:
                    name = self.ascii(name)
                if not populate_sections:
                    sections = None
                else:
                    sections = [self._convert_section(section, name) for section in segment.sections]
                yield Segment(Range(p_lower, p_upper), Range(v_lower, v_upper), sections, name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.executable.LIEF.is_pe"><code class="name">var <span class="ident">is_pe</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L963-L965" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def is_pe(self):
    return isinstance(self._head, lief.PE.Binary)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.LIEF.is_elf"><code class="name">var <span class="ident">is_elf</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L967-L969" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def is_elf(self):
    return isinstance(self._head, lief.ELF.Binary)</code></pre>
</details>
</dd>
<dt id="refinery.lib.executable.LIEF.is_macho"><code class="name">var <span class="ident">is_macho</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/executable.py#L971-L973" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def is_macho(self):
    return isinstance(self._head, (lief.MachO.Binary, lief.MachO.FatBinary))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.executable.Executable.Load" href="#refinery.lib.executable.Executable.Load">Load</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.address_to_offset" href="#refinery.lib.executable.Executable.address_to_offset">address_to_offset</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.arch" href="#refinery.lib.executable.Executable.arch">arch</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.ascii" href="#refinery.lib.executable.Executable.ascii">ascii</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.base" href="#refinery.lib.executable.Executable.base">base</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.byte_order" href="#refinery.lib.executable.Executable.byte_order">byte_order</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.data" href="#refinery.lib.executable.Executable.data">data</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.disassemble_instruction" href="#refinery.lib.executable.Executable.disassemble_instruction">disassemble_instruction</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.disassembler" href="#refinery.lib.executable.Executable.disassembler">disassembler</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.head" href="#refinery.lib.executable.Executable.head">head</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_address_space" href="#refinery.lib.executable.Executable.image_defined_address_space">image_defined_address_space</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_base" href="#refinery.lib.executable.Executable.image_defined_base">image_defined_base</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_size" href="#refinery.lib.executable.Executable.image_defined_size">image_defined_size</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_address" href="#refinery.lib.executable.Executable.location_from_address">location_from_address</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_offset" href="#refinery.lib.executable.Executable.location_from_offset">location_from_offset</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.lookup_location" href="#refinery.lib.executable.Executable.lookup_location">lookup_location</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.offset_to_address" href="#refinery.lib.executable.Executable.offset_to_address">offset_to_address</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.pointer_size" href="#refinery.lib.executable.Executable.pointer_size">pointer_size</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.pointer_size_in_bytes" href="#refinery.lib.executable.Executable.pointer_size_in_bytes">pointer_size_in_bytes</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.read" href="#refinery.lib.executable.Executable.read">read</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.read_integer" href="#refinery.lib.executable.Executable.read_integer">read_integer</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.relocations" href="#refinery.lib.executable.Executable.relocations">relocations</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.sections" href="#refinery.lib.executable.Executable.sections">sections</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.segments" href="#refinery.lib.executable.Executable.segments">segments</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.symbols" href="#refinery.lib.executable.Executable.symbols">symbols</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.type" href="#refinery.lib.executable.Executable.type">type</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.executable.align" href="#refinery.lib.executable.align">align</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.executable.ParsingFailure" href="#refinery.lib.executable.ParsingFailure">ParsingFailure</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Range" href="#refinery.lib.executable.Range">Range</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.executable.Range.range" href="#refinery.lib.executable.Range.range">range</a></code></li>
<li><code><a title="refinery.lib.executable.Range.slice" href="#refinery.lib.executable.Range.slice">slice</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.executable.BoxedOffset" href="#refinery.lib.executable.BoxedOffset">BoxedOffset</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Location" href="#refinery.lib.executable.Location">Location</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.ArchItem" href="#refinery.lib.executable.ArchItem">ArchItem</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Arch" href="#refinery.lib.executable.Arch">Arch</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.LT" href="#refinery.lib.executable.LT">LT</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.ET" href="#refinery.lib.executable.ET">ET</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.BO" href="#refinery.lib.executable.BO">BO</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Section" href="#refinery.lib.executable.Section">Section</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.executable.Section.as_segment" href="#refinery.lib.executable.Section.as_segment">as_segment</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Relocation" href="#refinery.lib.executable.Relocation">Relocation</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Symbol" href="#refinery.lib.executable.Symbol">Symbol</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.executable.Symbol.get_name" href="#refinery.lib.executable.Symbol.get_name">get_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Segment" href="#refinery.lib.executable.Segment">Segment</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.executable.Segment.as_section" href="#refinery.lib.executable.Segment.as_section">as_section</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.executable.CompartmentNotFound" href="#refinery.lib.executable.CompartmentNotFound">CompartmentNotFound</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.Executable" href="#refinery.lib.executable.Executable">Executable</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.executable.Executable.Load" href="#refinery.lib.executable.Executable.Load">Load</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.ascii" href="#refinery.lib.executable.Executable.ascii">ascii</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.read_integer" href="#refinery.lib.executable.Executable.read_integer">read_integer</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.read" href="#refinery.lib.executable.Executable.read">read</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.rebase_usr_to_img" href="#refinery.lib.executable.Executable.rebase_usr_to_img">rebase_usr_to_img</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.rebase_img_to_usr" href="#refinery.lib.executable.Executable.rebase_img_to_usr">rebase_img_to_usr</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_address" href="#refinery.lib.executable.Executable.location_from_address">location_from_address</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.location_from_offset" href="#refinery.lib.executable.Executable.location_from_offset">location_from_offset</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.offset_to_address" href="#refinery.lib.executable.Executable.offset_to_address">offset_to_address</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.address_to_offset" href="#refinery.lib.executable.Executable.address_to_offset">address_to_offset</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_size" href="#refinery.lib.executable.Executable.image_defined_size">image_defined_size</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_address_space" href="#refinery.lib.executable.Executable.image_defined_address_space">image_defined_address_space</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.lookup_location" href="#refinery.lib.executable.Executable.lookup_location">lookup_location</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.symbols" href="#refinery.lib.executable.Executable.symbols">symbols</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.byte_order" href="#refinery.lib.executable.Executable.byte_order">byte_order</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.image_defined_base" href="#refinery.lib.executable.Executable.image_defined_base">image_defined_base</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.arch" href="#refinery.lib.executable.Executable.arch">arch</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.segments" href="#refinery.lib.executable.Executable.segments">segments</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.relocations" href="#refinery.lib.executable.Executable.relocations">relocations</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.sections" href="#refinery.lib.executable.Executable.sections">sections</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.disassemble_instruction" href="#refinery.lib.executable.Executable.disassemble_instruction">disassemble_instruction</a></code></li>
<li><code><a title="refinery.lib.executable.Executable.disassembler" href="#refinery.lib.executable.Executable.disassembler">disassembler</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.executable.ExecutableCodeBlob" href="#refinery.lib.executable.ExecutableCodeBlob">ExecutableCodeBlob</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.executable.LIEF" href="#refinery.lib.executable.LIEF">LIEF</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
