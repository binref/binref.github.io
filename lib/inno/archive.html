<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.inno.archive documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.inno.archive</code></h1>
</header>
<section id="section-intro">
<p>Data structures and methods for parsing Inno Setup installer archives. The design is based
on <a href="https://constexpr.org/innoextract/">innoextract</a> source code and its Python port in <a href="https://malcat.fr/">Malcat</a>. The <a href="https://malcat.fr/">Malcat</a>
implementation served as the initial template but was re-written to work with refinery's
data structures.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1-L2797" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Data structures and methods for parsing Inno Setup installer archives. The design is based
on [innoextract][IE] source code and its Python port in [Malcat][MC]. The [Malcat][MC]
implementation served as the initial template but was re-written to work with refinery&#39;s
data structures.

[IE]: https://constexpr.org/innoextract/
[MC]: https://malcat.fr/
&#34;&#34;&#34;
from __future__ import annotations

import bz2
import codecs
import dataclasses
import enum
import functools
import lzma
import re
import struct
import zlib

from datetime import datetime, timezone
from functools import cached_property
from hashlib import md5, sha1, sha256
from typing import TYPE_CHECKING, NamedTuple

from refinery.lib.decompression import parse_lzma_properties
from refinery.lib.inno.ifps import IFPSFile
from refinery.lib.lcid import DEFAULT_CODEPAGE, LCID
from refinery.lib.structures import Struct, StructReader
from refinery.lib.tools import exception_to_string, one
from refinery.lib.types import buf
from refinery.units import Unit
from refinery.units.crypto.cipher.chacha import xchacha
from refinery.units.crypto.cipher.rc4 import rc4
from refinery.units.crypto.keyderive.pbkdf2 import pbkdf2
from refinery.units.formats.pe.perc import perc

if TYPE_CHECKING:
    from typing import (
        ClassVar,
        TypeVar,
    )
    _T = TypeVar(&#39;_T&#39;)
    _E = TypeVar(&#39;_E&#39;, bound=enum.IntEnum)


class InvalidPassword(ValueError):
    def __init__(self, password: str | None = None):
        if password is None:
            super().__init__(&#39;A password is required and none was given.&#39;)
        else:
            super().__init__(&#39;The given password is not correct.&#39;)


class IncorrectVersion(RuntimeError):
    pass


class FileChunkOutOfBounds(LookupError):
    pass


class IVF(enum.IntFlag):
    NoFlag   = 0b0000 # noqa
    Legacy   = 0b0001 # noqa
    Bits16   = 0b0010 # noqa
    UTF_16   = 0b0100 # noqa
    InnoSX   = 0b1000 # noqa
    Legacy32 = 0b0001
    Legacy16 = 0b0011
    IsLegacy = 0b0011


def _enum(options: type[_E], value: int, default: _E):
    try:
        return options(value)
    except ValueError:
        return default


class InnoVersion(NamedTuple):
    major: int
    minor: int
    patch: int
    build: int = 0
    flags: IVF = IVF.NoFlag

    @property
    def semver(self):
        return (self.major, self.minor, self.patch, self.build)

    @property
    def unicode(self):
        return self.flags &amp; IVF.UTF_16 == IVF.UTF_16

    @property
    def legacy(self):
        return self.flags &amp; IVF.Legacy

    @property
    def ascii(self):
        return self.flags &amp; IVF.UTF_16 == IVF.NoFlag

    @property
    def isx(self):
        return bool(self.flags &amp; IVF.InnoSX)

    @property
    def bits(self):
        return 0x10 if self.flags &amp; IVF.Bits16 else 0x20

    @classmethod
    def ParseLegacy(cls, dfn: bytes):
        v, s, _ = dfn.partition(B&#39;\x1A&#39;)
        if s and (m := re.fullmatch(BR&#39;i(\d+)\.(\d+)\.(\d+)--(16|32)&#39;, v)):
            major = int(m[1])
            minor = int(m[2])
            build = int(m[3])
            flags = IVF.Legacy16 if m[3] == B&#39;16&#39; else IVF.Legacy32
            return cls(major, minor, build, 0, flags)
        raise ValueError(dfn)

    @classmethod
    def Parse(cls, dfn: bytes):
        versions: list[InnoVersion] = []
        for match in [m.groups() for m in re.finditer(rb&#39;(.*?)\((\d+(?:\.\d+){2,3})(?:.*?\(([uU])\))?&#39;, dfn)]:
            sv = tuple(map(int, match[1].split(B&#39;.&#39;)))
            sv = (sv + (0,))[:4]
            vf = IVF.NoFlag
            if sv &gt;= (6, 3, 0) or match[2]:
                vf |= IVF.UTF_16
            if any(isx in match[0] for isx in (B&#39;My Inno Setup Extensions&#39;, B&#39;with ISX&#39;)):
                vf |= IVF.InnoSX
            versions.append(InnoVersion(*sv, vf))
        if len(versions) == 1:
            return versions[0]
        if len(versions) == 2:
            a, b = versions
            return InnoVersion(*max(a.semver, b.semver), a.flags | b.flags)
        raise ValueError(dfn)

    def __str__(self):
        v = F&#39;v{self.major}.{self.minor}.{self.patch:02d}.{self.build}&#39;
        a = R&#39;a&#39;
        u = R&#39;u&#39;
        if self.flags &amp; IVF.InnoSX:
            a = R&#39;&#39;
            v = F&#39;{v}x&#39;
        t = u if self.flags &amp; IVF.UTF_16 else a
        v = F&#39;{v}{t}&#39;
        if b := {
            IVF.Legacy16: &#39;16&#39;,
            IVF.Legacy32: &#39;32&#39;,
        }.get(self.flags &amp; IVF.IsLegacy):
            v = F&#39;{v}/{b}&#39;
        return v

    def __repr__(self):
        return str(self)

    def is_ambiguous(self):
        try:
            return _IS_AMBIGUOUS[self]
        except KeyError:
            return True


_I = InnoVersion

_FILE_TIME_1970_01_01 = 116444736000000000
_DEFAULT_INNO_VERSION = _I(5, 0, 0, 0, IVF.UTF_16)

_IS_AMBIGUOUS = {
    _I(1, 2, 10, 0, IVF.Legacy16): False,
    _I(1, 2, 10, 0, IVF.Legacy32): False,
    _I(1, 3,  3, 0, IVF.NoFlag): False, # noqa
    _I(1, 3,  9, 0, IVF.NoFlag): False, # noqa
    _I(1, 3, 10, 0, IVF.NoFlag): False, # noqa
    _I(1, 3, 10, 0, IVF.InnoSX): False, # noqa
    _I(1, 3, 12, 1, IVF.InnoSX): False, # noqa
    _I(1, 3, 21, 0, IVF.NoFlag): True,  # noqa
    _I(1, 3, 21, 0, IVF.InnoSX): True,  # noqa
    _I(1, 3, 24, 0, IVF.NoFlag): False, # noqa
    _I(1, 3, 24, 0, IVF.InnoSX): False, # noqa
    _I(1, 3, 25, 0, IVF.NoFlag): False, # noqa
    _I(1, 3, 25, 0, IVF.InnoSX): False, # noqa
    _I(2, 0,  0, 0, IVF.NoFlag): False, # noqa
    _I(2, 0,  1, 0, IVF.NoFlag): True,  # noqa
    _I(2, 0,  2, 0, IVF.NoFlag): False, # noqa
    _I(2, 0,  5, 0, IVF.NoFlag): False, # noqa
    _I(2, 0,  6, 0, IVF.NoFlag): False, # noqa
    _I(2, 0,  6, 0, IVF.InnoSX): False, # noqa
    _I(2, 0,  7, 0, IVF.NoFlag): False, # noqa
    _I(2, 0,  8, 0, IVF.NoFlag): False, # noqa
    _I(2, 0,  8, 0, IVF.InnoSX): False, # noqa
    _I(2, 0, 10, 0, IVF.InnoSX): False, # noqa
    _I(2, 0, 11, 0, IVF.NoFlag): False, # noqa
    _I(2, 0, 11, 0, IVF.InnoSX): False, # noqa
    _I(2, 0, 17, 0, IVF.NoFlag): False, # noqa
    _I(2, 0, 17, 0, IVF.InnoSX): False, # noqa
    _I(2, 0, 18, 0, IVF.NoFlag): False, # noqa
    _I(2, 0, 18, 0, IVF.InnoSX): False, # noqa
    _I(3, 0,  0, 0, IVF.NoFlag): False, # noqa
    _I(3, 0,  1, 0, IVF.NoFlag): False, # noqa
    _I(3, 0,  1, 0, IVF.InnoSX): False, # noqa
    _I(3, 0,  3, 0, IVF.NoFlag): True,  # noqa
    _I(3, 0,  3, 0, IVF.InnoSX): True,  # noqa
    _I(3, 0,  4, 0, IVF.NoFlag): False, # noqa
    _I(3, 0,  4, 0, IVF.InnoSX): False, # noqa
    _I(3, 0,  5, 0, IVF.NoFlag): False, # noqa
    _I(3, 0,  6, 1, IVF.InnoSX): False, # noqa
    _I(4, 0,  0, 0, IVF.NoFlag): False, # noqa
    _I(4, 0,  1, 0, IVF.NoFlag): False, # noqa
    _I(4, 0,  3, 0, IVF.NoFlag): False, # noqa
    _I(4, 0,  5, 0, IVF.NoFlag): False, # noqa
    _I(4, 0,  9, 0, IVF.NoFlag): False, # noqa
    _I(4, 0, 10, 0, IVF.NoFlag): False, # noqa
    _I(4, 0, 11, 0, IVF.NoFlag): False, # noqa
    _I(4, 1,  0, 0, IVF.NoFlag): False, # noqa
    _I(4, 1,  2, 0, IVF.NoFlag): False, # noqa
    _I(4, 1,  3, 0, IVF.NoFlag): False, # noqa
    _I(4, 1,  4, 0, IVF.NoFlag): False, # noqa
    _I(4, 1,  5, 0, IVF.NoFlag): False, # noqa
    _I(4, 1,  6, 0, IVF.NoFlag): False, # noqa
    _I(4, 1,  8, 0, IVF.NoFlag): False, # noqa
    _I(4, 2,  0, 0, IVF.NoFlag): False, # noqa
    _I(4, 2,  1, 0, IVF.NoFlag): False, # noqa
    _I(4, 2,  2, 0, IVF.NoFlag): False, # noqa
    _I(4, 2,  3, 0, IVF.NoFlag): True,  # noqa
    _I(4, 2,  4, 0, IVF.NoFlag): False, # noqa
    _I(4, 2,  5, 0, IVF.NoFlag): False, # noqa
    _I(4, 2,  6, 0, IVF.NoFlag): False, # noqa
    _I(5, 0,  0, 0, IVF.NoFlag): False, # noqa
    _I(5, 0,  1, 0, IVF.NoFlag): False, # noqa
    _I(5, 0,  3, 0, IVF.NoFlag): False, # noqa
    _I(5, 0,  4, 0, IVF.NoFlag): False, # noqa
    _I(5, 1,  0, 0, IVF.NoFlag): False, # noqa
    _I(5, 1,  2, 0, IVF.NoFlag): False, # noqa
    _I(5, 1,  7, 0, IVF.NoFlag): False, # noqa
    _I(5, 1, 10, 0, IVF.NoFlag): False, # noqa
    _I(5, 1, 13, 0, IVF.NoFlag): False, # noqa
    _I(5, 2,  0, 0, IVF.NoFlag): False, # noqa
    _I(5, 2,  1, 0, IVF.NoFlag): False, # noqa
    _I(5, 2,  3, 0, IVF.NoFlag): False, # noqa
    _I(5, 2,  5, 0, IVF.NoFlag): False, # noqa
    _I(5, 2,  5, 0, IVF.UTF_16): False, # noqa
    _I(5, 3,  0, 0, IVF.NoFlag): False, # noqa
    _I(5, 3,  0, 0, IVF.UTF_16): False, # noqa
    _I(5, 3,  3, 0, IVF.NoFlag): False, # noqa
    _I(5, 3,  3, 0, IVF.UTF_16): False, # noqa
    _I(5, 3,  5, 0, IVF.NoFlag): False, # noqa
    _I(5, 3,  5, 0, IVF.UTF_16): False, # noqa
    _I(5, 3,  6, 0, IVF.NoFlag): False, # noqa
    _I(5, 3,  6, 0, IVF.UTF_16): False, # noqa
    _I(5, 3,  7, 0, IVF.NoFlag): False, # noqa
    _I(5, 3,  7, 0, IVF.UTF_16): False, # noqa
    _I(5, 3,  8, 0, IVF.NoFlag): False, # noqa
    _I(5, 3,  8, 0, IVF.UTF_16): False, # noqa
    _I(5, 3,  9, 0, IVF.NoFlag): False, # noqa
    _I(5, 3,  9, 0, IVF.UTF_16): False, # noqa
    _I(5, 3, 10, 0, IVF.NoFlag): True,  # noqa
    _I(5, 3, 10, 0, IVF.UTF_16): True,  # noqa
    _I(5, 3, 10, 1, IVF.NoFlag): False, # noqa
    _I(5, 3, 10, 1, IVF.UTF_16): False, # noqa
    _I(5, 4,  2, 0, IVF.NoFlag): True,  # noqa
    _I(5, 4,  2, 0, IVF.UTF_16): True,  # noqa
    _I(5, 4,  2, 1, IVF.NoFlag): False, # noqa
    _I(5, 4,  2, 1, IVF.UTF_16): False, # noqa
    _I(5, 5,  0, 0, IVF.NoFlag): True,  # noqa
    _I(5, 5,  0, 0, IVF.UTF_16): True,  # noqa
    _I(5, 5,  0, 1, IVF.NoFlag): False, # noqa
    _I(5, 5,  0, 1, IVF.UTF_16): False, # noqa
    _I(5, 5,  6, 0, IVF.NoFlag): False, # noqa
    _I(5, 5,  6, 0, IVF.UTF_16): False, # noqa
    _I(5, 5,  7, 0, IVF.NoFlag): True,  # noqa
    _I(5, 5,  7, 0, IVF.UTF_16): True,  # noqa
    _I(5, 5,  7, 1, IVF.NoFlag): True,  # noqa
    _I(5, 5,  7, 1, IVF.UTF_16): True,  # noqa
    _I(5, 6,  0, 0, IVF.NoFlag): False, # noqa
    _I(5, 6,  0, 0, IVF.UTF_16): False, # noqa
    _I(5, 6,  2, 0, IVF.NoFlag): False, # noqa
    _I(5, 6,  2, 0, IVF.UTF_16): False, # noqa
    _I(6, 0,  0, 0, IVF.UTF_16): False, # noqa
    _I(6, 1,  0, 0, IVF.UTF_16): False, # noqa
    _I(6, 3,  0, 0, IVF.UTF_16): False, # noqa
    _I(6, 4,  0, 0, IVF.UTF_16): False, # noqa
    _I(6, 4,  0, 1, IVF.UTF_16): False, # noqa
    _I(6, 4,  1, 0, IVF.UTF_16): False, # noqa
    _I(6, 4,  2, 0, IVF.UTF_16): False, # noqa
    _I(6, 4,  3, 0, IVF.UTF_16): False, # noqa
}

_VERSIONS = sorted(_IS_AMBIGUOUS)


class JsonStruct(Struct):
    def json(self):
        def _json(v):
            if isinstance(v, list):
                return [_json(x) for x in v]
            if isinstance(v, dict):
                return {x: _json(y) for x, y in v.items()}
            if isinstance(v, JsonStruct):
                return v.json()
            if isinstance(v, enum.IntFlag):
                return [option.name for option in v.__class__ if v &amp; option == option]
            if isinstance(v, enum.IntEnum):
                return v.name
            if isinstance(v, memoryview):
                return codecs.decode(v, &#39;latin1&#39;)
            return v
        return {
            k: _json(v) for k, v in self.__dict__.items()
            if not k.startswith(&#39;_&#39;)
        }


class InnoStruct(JsonStruct):
    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, codec: str = &#39;latin1&#39;):
        if version.unicode:
            self._read_string = functools.partial(
                reader.read_length_prefixed_utf16, bytecount=True)
        else:
            def _read():
                data = reader.read_length_prefixed()
                try:
                    return codecs.decode(data, codec)
                except (LookupError, UnicodeDecodeError):
                    # TODO
                    return codecs.decode(data, &#39;latin1&#39;)
            self._read_string = _read


class CheckSumType(enum.IntEnum):
    Missing = 0 # noqa
    Adler32 = 1 # noqa
    CRC32   = 2 # noqa
    MD5     = 3 # noqa
    SHA1    = 4 # noqa
    SHA256  = 5 # noqa

    def strong(self):
        return self.value &gt;= 3


class Flags(enum.IntFlag):
    Empty                       = 0           # noqa
    DisableStartupPrompt        = enum.auto() # noqa
    Uninstallable               = enum.auto() # noqa
    CreateAppDir                = enum.auto() # noqa
    DisableDirPage              = enum.auto() # noqa
    DisableDirExistsWarning     = enum.auto() # noqa
    DisableProgramGroupPage     = enum.auto() # noqa
    AllowNoIcons                = enum.auto() # noqa
    AlwaysRestart               = enum.auto() # noqa
    BackSolid                   = enum.auto() # noqa
    AlwaysUsePersonalGroup      = enum.auto() # noqa
    WindowVisible               = enum.auto() # noqa
    WindowShowCaption           = enum.auto() # noqa
    WindowResizable             = enum.auto() # noqa
    WindowStartMaximized        = enum.auto() # noqa
    EnableDirDoesntExistWarning = enum.auto() # noqa
    DisableAppendDir            = enum.auto() # noqa
    Password                    = enum.auto() # noqa
    AllowRootDirectory          = enum.auto() # noqa
    DisableFinishedPage         = enum.auto() # noqa
    AdminPrivilegesRequired     = enum.auto() # noqa
    AlwaysCreateUninstallIcon   = enum.auto() # noqa
    OverwriteUninstRegEntries   = enum.auto() # noqa
    ChangesAssociations         = enum.auto() # noqa
    CreateUninstallRegKey       = enum.auto() # noqa
    UsePreviousAppDir           = enum.auto() # noqa
    BackColorHorizontal         = enum.auto() # noqa
    UsePreviousGroup            = enum.auto() # noqa
    UpdateUninstallLogAppName   = enum.auto() # noqa
    UsePreviousSetupType        = enum.auto() # noqa
    DisableReadyMemo            = enum.auto() # noqa
    AlwaysShowComponentsList    = enum.auto() # noqa
    FlatComponentsList          = enum.auto() # noqa
    ShowComponentSizes          = enum.auto() # noqa
    UsePreviousTasks            = enum.auto() # noqa
    DisableReadyPage            = enum.auto() # noqa
    AlwaysShowDirOnReadyPage    = enum.auto() # noqa
    AlwaysShowGroupOnReadyPage  = enum.auto() # noqa
    BzipUsed                    = enum.auto() # noqa
    AllowUNCPath                = enum.auto() # noqa
    UserInfoPage                = enum.auto() # noqa
    UsePreviousUserInfo         = enum.auto() # noqa
    UninstallRestartComputer    = enum.auto() # noqa
    RestartIfNeededByRun        = enum.auto() # noqa
    ShowTasksTreeLines          = enum.auto() # noqa
    ShowLanguageDialog          = enum.auto() # noqa
    DetectLanguageUsingLocale   = enum.auto() # noqa
    AllowCancelDuringInstall    = enum.auto() # noqa
    WizardImageStretch          = enum.auto() # noqa
    AppendDefaultDirName        = enum.auto() # noqa
    AppendDefaultGroupName      = enum.auto() # noqa
    EncryptionUsed              = enum.auto() # noqa
    ChangesEnvironment          = enum.auto() # noqa
    ShowUndisplayableLanguages  = enum.auto() # noqa
    SetupLogging                = enum.auto() # noqa
    SignedUninstaller           = enum.auto() # noqa
    UsePreviousLanguage         = enum.auto() # noqa
    DisableWelcomePage          = enum.auto() # noqa
    CloseApplications           = enum.auto() # noqa
    RestartApplications         = enum.auto() # noqa
    AllowNetworkDrive           = enum.auto() # noqa
    ForceCloseApplications      = enum.auto() # noqa
    AppNameHasConsts            = enum.auto() # noqa
    UsePreviousPrivileges       = enum.auto() # noqa
    WizardResizable             = enum.auto() # noqa
    UninstallLogging            = enum.auto() # noqa


class AutoBool(enum.IntEnum):
    Auto = 0
    No = 1
    Yes = 2

    @classmethod
    def From(cls, b: bool):
        return AutoBool.Yes if b else AutoBool.No


class WizardStyle(enum.IntEnum):
    Classic = 0
    Modern = 1


class StoredAlphaFormat(enum.IntEnum):
    AlphaIgnored = 0
    AlphaDefined = 1
    AlphaPremultiplied = 2


class UninstallLogMode(enum.IntEnum):
    Append = 0
    New = 1
    Overwrite = 2


class SetupStyle(enum.IntEnum):
    Classic = 0
    Modern = 1


class PrivilegesRequired(enum.IntEnum):
    Nothing = 0
    PowerUser = 1
    Admin = 2
    Lowest = 3


class PrivilegesRequiredOverrideAllowed(enum.IntFlag):
    Empty = 0
    CommandLine = 1
    Dialog = 2


class LanguageDetection(enum.IntEnum):
    UI = 0
    Locale = 1
    Nothing = 2


class CompressionMethod(enum.IntEnum):
    Store = 0
    Flate = 1
    BZip2 = 2
    LZMA1 = 3
    LZMA2 = 4

    def legacy_check(self, max: int, ver: str):
        if self.value &gt; max:
            raise ValueError(F&#39;Compression method {self.value} cannot be represented before version {ver}.&#39;)
        return self

    def legacy_conversion_pre_4_2_5(self):
        return self.legacy_check(2, &#39;4.2.5&#39;).__class__(self.value + 1)

    def legacy_conversion_pre_4_2_6(self):
        if self == CompressionMethod.Store:
            return self
        return self.legacy_check(2, &#39;4.2.6&#39;).__class__(self.value + 1)

    def legacy_conversion_pre_5_3_9(self):
        return self.legacy_check(3, &#39;5.3.9&#39;)


class Architecture(enum.IntFlag):
    Unknown = 0b00000 # noqa
    X86     = 0b00001 # noqa
    AMD64   = 0b00010 # noqa
    IA64    = 0b00100 # noqa
    ARM64   = 0b01000 # noqa
    All     = 0b01111 # noqa


class PasswordType(enum.IntEnum):
    CRC32     = 0           # noqa
    Nothing   = 0           # noqa
    MD5       = enum.auto() # noqa
    SHA1      = enum.auto() # noqa
    XChaCha20 = enum.auto() # noqa


class SetupTypeEnum(enum.IntEnum):
    User = 0
    DefaultFull = 1
    DefaultCompact = 2
    DefaultCustom = 3


class SetupFlags(enum.IntFlag):
    Fixed                     = 0b00001 # noqa
    Restart                   = 0b00010 # noqa
    DisableNoUninstallWarning = 0b00100 # noqa
    Exclusive                 = 0b01000 # noqa
    DontInheritCheck          = 0b10000 # noqa


class StreamCompressionMethod(enum.IntEnum):
    Store = 0
    Flate = 1
    LZMA1 = 2


class StreamHeader(InnoStruct):
    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.HeaderCrc = reader.u32()
        self.CompressedSize = size = reader.u32()
        if version &gt;= (4, 0, 9):
            self.StoredSize = self.CompressedSize
            if not reader.u8():
                self.Compression = StreamCompressionMethod.Store
            elif version &gt;= (4, 1, 6):
                self.Compression = StreamCompressionMethod.LZMA1
            else:
                self.Compression = StreamCompressionMethod.Flate
        else:
            self.UncompresedSize = reader.u32()
            if size == 0xFFFFFFFF:
                self.StoredSize = self.UncompresedSize
                self.Compression = StreamCompressionMethod.Store
            else:
                self.StoredSize = size
                self.Compression = StreamCompressionMethod.Flate
            # Add the size of a CRC32 checksum for each 4KiB subblock
            block_count, _r = divmod(self.StoredSize, 4096)
            block_count += int(bool(_r))
            self.StoredSize += 4 * block_count


class CrcCompressedBlock(JsonStruct):
    def __init__(self, reader: StructReader[memoryview], size: int):
        self.BlockCrc = reader.u32()
        self.BlockData = reader.read(size)


TSetupMagicToVersion = {
    B&#39;rDlPtS02\x87eVx&#39;          : _I(1, 2, 10), # noqa
    B&#39;rDlPtS04\x87eVx&#39;          : _I(4, 0,  0), # noqa
    B&#39;rDlPtS05\x87eVx&#39;          : _I(4, 0,  3), # noqa
    B&#39;rDlPtS06\x87eVx&#39;          : _I(4, 0, 10), # noqa
    B&#39;rDlPtS07\x87eVx&#39;          : _I(4, 1,  6), # noqa
    B&#39;rDlPtS\xcd\xe6\xd7{\x0b*&#39; : _I(5, 1,  5), # noqa
    B&#39;nS5W7dT\x83\xaa\x1b\x0fj&#39; : _I(5, 1,  5), # noqa
}


class TSetupOffsets(Struct):
    def __init__(self, reader: StructReader[memoryview]):
        start = reader.tell()
        check = reader.peek()

        self.id = bytes(reader.read(12))
        self.iv = iv = TSetupMagicToVersion.get(self.id)

        if iv is None:
            iv = _VERSIONS[-1]

        self.revision = reader.u32() if iv &gt;= (5, 1, 5) else None
        self.total_size = reader.u32()

        self.exe_offset = reader.u32()
        self.exe_compressed_size = None if iv &gt;= (4, 1, 6) else reader.u32()
        self.exe_uncompressed_size = reader.u32()

        if iv &gt;= (4, 0, 3):
            self.exe_checksum_type = CheckSumType.CRC32
        else:
            self.exe_checksum_type = CheckSumType.Adler32
        self.exe_checksum = reader.u32()

        self.messages = reader.u32() if iv &lt; (4, 0, 0) else None
        self.info_abs_offset = reader.u32()
        self.data_abs_offset = reader.u32()

        check = check[:reader.tell() - start]
        self.computed_checksum = zlib.crc32(check)
        self.expected_checksum = reader.u32() if (
            iv &gt;= (4, 0, 10)
        ) else self.computed_checksum

        self.base = min(
            self.exe_offset,
            self.info_abs_offset,
            self.data_abs_offset,
        )

        self.info_offset = self.info_abs_offset - self.base
        self.data_offset = self.data_abs_offset - self.base

    def Checked(self):
        if (_c := self.computed_checksum) != (_e := self.expected_checksum):
            raise ValueError(F&#39;Invalid checksum; computed {_c:08X}, header value is {_e:08X}.&#39;)
        if self.exe_uncompressed_size &lt; 0x100:
            raise ValueError(R&#39;The EXE uncompressed size value is too low.&#39;)
        if self.info_offset &lt; self.data_offset:
            raise ValueError(R&#39;TData offset is beyond TSetup offset.&#39;)
        return self

    @classmethod
    def Try(Cls, view: memoryview):
        try:
            return Cls(view).Checked()
        except ValueError:
            return None

    @classmethod
    def FindInBinary(Cls, data):
        issd = B&#39;Inno Setup Setup Data&#39;
        view = memoryview(data)
        if len(view) &lt; 0x1000:
            return None
        for magic in TSetupMagicToVersion:
            for match in re.finditer(re.escape(magic), view):
                if self := Cls.Try(view[match.start():]):
                    ip = self.base + self.info_offset
                    if view[ip:][:len(issd)] == issd:
                        return self


@dataclasses.dataclass
class InnoFile:
    reader: StructReader[buf]
    version: InnoVersion
    meta: SetupDataEntry
    path: str = &#34;&#34;
    dupe: bool = False
    setup: SetupFile | None = None
    compression_method: CompressionMethod | None = None
    password_hash: bytes = B&#39;&#39;
    password_salt: bytes = B&#39;&#39;
    password_type: PasswordType = PasswordType.Nothing

    @property
    def tags(self):
        if s := self.setup:
            return s.Flags
        else:
            return SetupFileFlags.Empty

    @property
    def unicode(self):
        return self.version.unicode

    @property
    def compression(self):
        if self.meta.Flags &amp; SetupDataEntryFlags.ChunkCompressed:
            return self.compression_method
        return CompressionMethod.Store

    @property
    def offset(self):
        return self.meta.Offset

    @property
    def size(self):
        return self.meta.FileSize

    @property
    def date(self):
        return self.meta.FileTime

    @property
    def chunk_offset(self):
        return self.meta.ChunkOffset

    @property
    def chunk_length(self):
        return self.meta.ChunkSize

    @property
    def checksum(self):
        return self.meta.Checksum

    @property
    def checksum_type(self):
        return self.meta.ChecksumType

    @property
    def encrypted(self):
        return bool(self.meta.Flags &amp; SetupDataEntryFlags.ChunkEncrypted)

    @property
    def filtered(self):
        return bool(self.meta.Flags &amp; SetupDataEntryFlags.CallInstructionOptimized)

    def check(self, data: buf):
        t = self.checksum_type
        if t == CheckSumType.Missing:
            return None
        if t == CheckSumType.Adler32:
            return zlib.adler32(data) &amp; 0xFFFFFFFF
        if t == CheckSumType.CRC32:
            return zlib.crc32(data) &amp; 0xFFFFFFFF
        if t == CheckSumType.MD5:
            return md5(data).digest()
        if t == CheckSumType.SHA1:
            return sha1(data).digest()
        if t == CheckSumType.SHA256:
            return sha256(data).digest()
        raise ValueError(F&#39;Unknown checksum type: {t!r}&#39;)


@dataclasses.dataclass
class InnoStream:
    header: StreamHeader
    blocks: list[CrcCompressedBlock] = dataclasses.field(default_factory=list)
    data: bytearray | None = None

    @property
    def compression(self):
        return self.header.Compression


class InstallMode(enum.IntEnum):
    Normal     = 0           # noqa
    Silent     = enum.auto() # noqa
    VerySilent = enum.auto() # noqa


class SetupHeader(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)

        def read_string():
            return reader.read_length_prefixed()

        if version &lt; (1, 3, 0):
            # skip uncompressed size
            reader.u32()

        if True:
            self.AppName = read_string()
            self.AppVersionedName = read_string()
        if version &gt;= (1, 3, 0):
            self.AppId = read_string()
        if True:
            self.AppCopyright = read_string()
        if version &gt;= (1, 3, 0):
            self.AppPublisher = read_string()
            self.AppPublisherUrl = read_string()
        if version &gt;= (5, 1, 13):
            self.AppSupportPhone = read_string()
        if version &gt;= (1, 3, 0):
            self.AppSupportUrl = read_string()
            self.AppUpdatesUrl = read_string()
            self.AppVersion = read_string()
        if True:
            self.DefaultDirName = read_string()
            self.DefaultGroupName = read_string()
        if version &lt; (3, 0, 0):
            self.UninstallIconName = reader.read_length_prefixed(encoding=&#39;cp1252&#39;)
        if True:
            self.BaseFilename = read_string()
        if (1, 3, 0) &lt;= version &lt; (5, 2, 5):
            self._license = reader.read_length_prefixed_ascii()
            self.InfoHead = reader.read_length_prefixed_ascii()
            self.InfoTail = reader.read_length_prefixed_ascii()
        if version &gt;= (1, 3, 3):
            self.UninstallFilesDir = read_string()
        if version &gt;= (1, 3, 6):
            self.UninstallName = read_string()
            self.UninstallIcon = read_string()
        if version &gt;= (1, 3, 14):
            self.AppMutex = read_string()
        if version &gt;= (3, 0, 0):
            self.DefaultUsername = read_string()
            self.DefaultOrganisation = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 6, 1):
            self.DefaultSerial = read_string()
        if (4, 0, 0) &lt;= version &lt; (5, 2, 5) or version.isx and version &gt;= (1, 3, 24):
            self._CompiledCode = read_string()
        if version &gt;= (4, 2, 4):
            self.AppReadmeFile = read_string()
            self.AppContact = read_string()
            self.AppComment = read_string()
            self.AppModifyPath = read_string()
        if version &gt;= (5, 3, 8):
            self.CreateUninstallRegistryKey = read_string()
        if version &gt;= (5, 3, 10):
            self.Uninstallable = read_string()
        else:
            self.Uninstallable = B&#39;&#39;
        if version &gt;= (5, 5, 0):
            self.CloseApplicationsFilter = read_string()
        if version &gt;= (5, 5, 6):
            self.SetupMutex = read_string()
        if version &gt;= (5, 6, 1):
            self.ChangesEnvironment = read_string()
            self.ChangesAssociations = read_string()
        if version &gt;= (6, 3, 0):
            self.ArchitecturesAllowed32 = read_string()
            self.ArchitecturesAllowed64 = read_string()
        if version &gt;= (6, 4, 2):
            self.CloseApplicationsFilterExcludes = read_string()
        if version &gt;= (5, 2, 5):
            self._license = reader.read_length_prefixed_ascii()
            self.InfoHead = reader.read_length_prefixed_ascii()
            self.InfoTail = reader.read_length_prefixed_ascii()
        if version &gt;= (5, 2, 1) and version &lt; (5, 3, 10):
            self.UninstallerSignature = read_string()
        if version &gt;= (5, 2, 5):
            self._CompiledCode = read_string()

        if self._CompiledCode and self._CompiledCode[:4] != B&#39;IFPS&#39;:
            raise ValueError(&#39;Invalid signature in compiled code.&#39;)

        if version &gt;= (2, 0, 6) and version.ascii:
            self.Charset = reader.read_integer(0x100)
        else:
            self.Charset = 0

        if version &gt;= (4, 0, 0):
            self.LanguageCount = reader.u32()
        elif version &gt;= (2, 0, 1):
            self.LanguageCount = 1
        else:
            self.LanguageCount = 0

        if version &gt;= (4, 2, 1):
            self.MessageCount = reader.u32()
        else:
            self.MessageCount = 0

        if version &gt;= (4, 1, 0):
            self.PermissionCount = reader.u32()
        else:
            self.PermissionCount = 0

        if version &gt;= (2, 0, 0) or version.isx:
            self.TypeCount = reader.u32()
            self.ComponentCount = reader.u32()
        else:
            self.TypeCount = 0
            self.ComponentCount = 0

        if version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 17):
            self.TaskCount = reader.u32()
        else:
            self.TaskCount = 0

        self.DirectoryCount = reader.u32()
        self.FileCount = reader.u32()
        self.DataEntryCount = reader.u32()
        self.IconCount = reader.u32()
        self.IniEntryCount = reader.u32()
        self.RegistryCount = reader.u32()
        self.DeleteCount = reader.u32()
        self.UninstallDeleteCount = reader.u32()
        self.RunCount = reader.u32()
        self.UninstallRunCount = reader.u32()

        if version &lt; (1, 3, 0):
            _license_len = reader.u32()
            _infhead_len = reader.u32()
            _inftail_len = reader.u32()

        self.WindowsVersion = WinVerRange(reader, version)

        self.BackColor1 = reader.u32() if (0, 0, 0) &lt;= version &lt; (6, 4, 0, 1) else 0
        self.BackColor2 = reader.u32() if (1, 3, 3) &lt;= version &lt; (6, 4, 0, 1) else 0

        if version &lt; (5, 5, 7):
            self.ImageBackColor = reader.u32()
        if (2, 0, 0) &lt;= version &lt; (5, 0, 4) or version.isx:
            self.SmallImageBackColor = reader.u32()
        if version &gt;= (6, 0, 0):
            self.WizardStyle = WizardStyle(reader.u8())
            self.WizardResizePercentX = reader.u32()
            self.WizardResizePercentY = reader.u32()
        else:
            self.WizardStyle = WizardStyle.Classic
            self.WizardResizePercentX = 0
            self.WizardResizePercentY = 0

        if version &gt;= (5, 5, 7):
            self.StoredAlphaFormat = StoredAlphaFormat(reader.u8())
        else:
            self.StoredAlphaFormat = StoredAlphaFormat.AlphaIgnored

        if version &gt;= (6, 4, 0):
            self.PasswordType = PasswordType.XChaCha20
            self.PasswordHash = reader.read(4)
        elif version &gt;= (5, 3, 9):
            self.PasswordType = PasswordType.SHA1
            self.PasswordHash = reader.read(20)
        elif version &gt;= (4, 2, 0):
            self.PasswordType = PasswordType.MD5
            self.PasswordHash = reader.read(16)
        else:
            self.PasswordType = PasswordType.CRC32
            self.PasswordHash = reader.u32()

        if version &gt;= (6, 4, 0):
            self.PasswordSalt = reader.read(44)
        elif version &gt;= (4, 2, 2):
            self.PasswordSalt = reader.read(8)
        else:
            self.PasswordSalt = None

        if version &gt;= (4, 0, 0):
            self.ExtraDiskSpace = reader.i64()
            self.SlicesPerDisk = reader.u32()
        else:
            self.ExtraDiskSpace = reader.u32()
            self.SlicesPerDisk = 1

        if (2, 0, 0) &lt;= version &lt; (5, 0, 0):
            self.InstallMode = _enum(InstallMode, reader.u8(), InstallMode.Normal)
        else:
            self.InstallMode = InstallMode.Normal
        if version &gt;= (1, 3, 0):
            self.UninstallLogMode = UninstallLogMode(reader.u8())
        else:
            self.UninstallLogMode = UninstallLogMode.New

        if version &gt;= (5, 0, 0):
            self.SetupStyle = SetupStyle.Modern
        elif (2, 0, 0) &lt;= version or version.isx and version &gt;= (1, 3, 13):
            self.SetupStyle = SetupStyle(reader.u8())
        else:
            self.SetupStyle = SetupStyle.Classic

        if version &gt;= (1, 3, 6):
            self.DirExistsWarning = AutoBool(reader.u8())
        else:
            self.DirExistsWarning = AutoBool.Auto
        if version.isx and (2, 0, 10) &lt;= version &lt; (3, 0, 0):
            self.CodeLineOffset = reader.u32()

        self.Flags = Flags.Empty

        if (3, 0, 0) &lt;= version &lt; (3, 0, 3):
            val = AutoBool(reader.u8())
            if val == AutoBool.Auto:
                self.Flags |= Flags.RestartIfNeededByRun
            elif val == AutoBool.Yes:
                self.Flags |= Flags.AlwaysRestart

        if version &gt;= (3, 0, 4) or version.isx and version &gt;= (3, 0, 3):
            self.PrivilegesRequired = PrivilegesRequired(reader.u8())
        if version &gt;= (5, 7, 0):
            self.PrivilegesRequiredOverrideAllowed = PrivilegesRequiredOverrideAllowed(reader.u8())
        if version &gt;= (4, 0, 10):
            self.ShowLanguageDialog = AutoBool(reader.u8())
            self.LanguageDetection = LanguageDetection(reader.u8())

        if version &gt;= (4, 1, 5):
            method = CompressionMethod(reader.u8())
            if version &lt; (4, 2, 5):
                method = method.legacy_conversion_pre_4_2_5()
            elif version &lt; (4, 2, 6):
                method = method.legacy_conversion_pre_4_2_5()
            elif version &lt; (5, 3, 9):
                method = method.legacy_conversion_pre_5_3_9()
            self.CompressionMethod = method

        if version &gt;= (6, 3, 0):
            self.ArchitecturesAllowed = Architecture.Unknown
            self.ArchitecturesInstalled64 = Architecture.Unknown
        elif version &gt;= (5, 1, 0):
            self.ArchitecturesAllowed = Architecture(reader.u8())
            self.ArchitecturesInstalled64 = Architecture(reader.u8())
        else:
            self.ArchitecturesAllowed = Architecture.All
            self.ArchitecturesInstalled64 = Architecture.All

        if (5, 2, 1) &lt;= version &lt; (5, 3, 10):
            self.UninstallerOriginalSize = reader.u32()
            self.UninstallheaderCrc = reader.u32()
        if version &gt;= (5, 3, 3):
            self.DisableDirPage = AutoBool(reader.u8())
            self.DisableProgramGroupPage = AutoBool(reader.u8())
        if version &gt;= (5, 5, 0):
            self.UninstallDisplaySize = reader.u64()
        elif version &gt;= (5, 3, 6):
            self.UninstallDisplaySize = reader.u32()
        else:
            self.UninstallDisplaySize = 0

        flags = []
        flags.append(Flags.DisableStartupPrompt)
        if version &lt; (5, 3, 10):
            flags.append(Flags.Uninstallable)
        flags.append(Flags.CreateAppDir)
        if version &lt; (5, 3, 3):
            flags.append(Flags.DisableDirPage)
        if version &lt; (1, 3, 6):
            flags.append(Flags.DisableDirExistsWarning)
        if version &lt; (5, 3, 3):
            flags.append(Flags.DisableProgramGroupPage)
        flags.append(Flags.AllowNoIcons)
        if version &lt; (3, 0, 0) or version &gt;= (3, 0, 3):
            flags.append(Flags.AlwaysRestart)
        if version &lt; (1, 3, 3):
            flags.append(Flags.BackSolid)
        flags.append(Flags.AlwaysUsePersonalGroup)
        if version &lt; (6, 4, 0):
            flags.append(Flags.WindowVisible)
            flags.append(Flags.WindowShowCaption)
            flags.append(Flags.WindowResizable)
            flags.append(Flags.WindowStartMaximized)
        flags.append(Flags.EnableDirDoesntExistWarning)
        if version &lt; (4, 1, 2):
            flags.append(Flags.DisableAppendDir)
        flags.append(Flags.Password)
        flags.append(Flags.AllowRootDirectory)
        flags.append(Flags.DisableFinishedPage)

        if version.bits &gt; 16:
            if version &lt; (3, 0, 4):
                flags.append(Flags.AdminPrivilegesRequired)
            if version &lt; (3, 0, 0):
                flags.append(Flags.AlwaysCreateUninstallIcon)
            if version &lt; (1, 3, 6):
                flags.append(Flags.OverwriteUninstRegEntries)
            if version &lt; (5, 6, 1):
                flags.append(Flags.ChangesAssociations)

        if version &lt; (5, 3, 8):
            flags.append(Flags.CreateUninstallRegKey)

        flags.append(Flags.UsePreviousAppDir)
        if version &lt; (6, 4, 0):
            flags.append(Flags.BackColorHorizontal)
        flags.append(Flags.UsePreviousGroup)
        flags.append(Flags.UpdateUninstallLogAppName)
        flags.append(Flags.UsePreviousSetupType)
        flags.append(Flags.DisableReadyMemo)
        flags.append(Flags.AlwaysShowComponentsList)
        flags.append(Flags.FlatComponentsList)
        flags.append(Flags.ShowComponentSizes)
        flags.append(Flags.UsePreviousTasks)
        flags.append(Flags.DisableReadyPage)
        flags.append(Flags.AlwaysShowDirOnReadyPage)
        flags.append(Flags.AlwaysShowGroupOnReadyPage)
        if version &lt; (4, 1, 5):
            flags.append(Flags.BzipUsed)
        flags.append(Flags.AllowUNCPath)
        flags.append(Flags.UserInfoPage)
        flags.append(Flags.UsePreviousUserInfo)
        flags.append(Flags.UninstallRestartComputer)
        flags.append(Flags.RestartIfNeededByRun)
        flags.append(Flags.ShowTasksTreeLines)
        if version &lt; (4, 0, 10):
            flags.append(Flags.ShowLanguageDialog)
        if version &gt;= (4, 0, 1) and version &lt; (4, 0, 10):
            flags.append(Flags.DetectLanguageUsingLocale)
        if version &gt;= (4, 0, 9):
            flags.append(Flags.AllowCancelDuringInstall)
        if version &gt;= (4, 1, 3):
            flags.append(Flags.WizardImageStretch)
        if version &gt;= (4, 1, 8):
            flags.append(Flags.AppendDefaultDirName)
            flags.append(Flags.AppendDefaultGroupName)
        if version &gt;= (4, 2, 2):
            flags.append(Flags.EncryptionUsed)
        if version &gt;= (5, 0, 4) and version &lt; (5, 6, 1):
            flags.append(Flags.ChangesEnvironment)
        if version &gt;= (5, 1, 7) and version.ascii:
            flags.append(Flags.ShowUndisplayableLanguages)
        if version &gt;= (5, 1, 13):
            flags.append(Flags.SetupLogging)
        if version &gt;= (5, 2, 1):
            flags.append(Flags.SignedUninstaller)
        if version &gt;= (5, 3, 8):
            flags.append(Flags.UsePreviousLanguage)
        if version &gt;= (5, 3, 9):
            flags.append(Flags.DisableWelcomePage)
        if version &gt;= (5, 5, 0):
            flags.append(Flags.CloseApplications)
            flags.append(Flags.RestartApplications)
            flags.append(Flags.AllowNetworkDrive)
        if version &gt;= (5, 5, 7):
            flags.append(Flags.ForceCloseApplications)
        if version &gt;= (6, 0, 0):
            flags.append(Flags.AppNameHasConsts)
            flags.append(Flags.UsePreviousPrivileges)
            flags.append(Flags.WizardResizable)
        if version &gt;= (6, 3, 0):
            flags.append(Flags.UninstallLogging)

        flagsize, _r = divmod(len(flags), 8)
        flagsize += int(bool(_r))
        bytecheck = bytes(reader.peek(flagsize + 1 + 4 + 1))

        if bytecheck[0] == 0:
            if bytecheck[~0] != 0 or bytecheck[~3:~0] == B&#39;\0\0\0&#39;:
                reader.u8()

        for flag in flags:
            if reader.read_bit():
                self.Flags |= flag

        if version &lt; (3, 0, 4):
            self.PrivilegesRequired = PrivilegesRequired.Admin if (
                self.Flags &amp; Flags.AdminPrivilegesRequired
            ) else PrivilegesRequired.Nothing

        if version &lt; (4, 0, 10):
            self.ShowLanguageDialog = AutoBool.From(
                self.Flags &amp; Flags.ShowLanguageDialog)
            self.LanguageDetection = LanguageDetection.Locale if (
                self.Flags &amp; Flags.DetectLanguageUsingLocale
            ) else LanguageDetection.UI

        if version &lt; (4, 1, 5):
            self.CompressionMethod = CompressionMethod.BZip2 if (
                self.Flags &amp; Flags.BzipUsed
            ) else CompressionMethod.Flate

        if version &lt; (5, 3, 3):
            self.DisableDirPage = AutoBool.From(self.Flags &amp; Flags.DisableDirPage)
            self.DisableProgramGroupPage = AutoBool.From(self.Flags &amp; Flags.DisableProgramGroupPage)

        if version &lt; (1, 3, 0):
            def _read_ascii(n: int):
                return codecs.decode(reader.read(_license_len), &#39;cp1252&#39;)
            self._license = _read_ascii(_license_len)
            self.InfoHead = _read_ascii(_infhead_len)
            self.InfoTail = _read_ascii(_inftail_len)

        reader.byte_align()

        if flagsize == 3:
            reader.u8()

    def get_license(self):
        return self._license

    def get_script(self):
        return self._CompiledCode

    def recode_strings(self, codec: str):
        for coded_string_attribute in [
            &#39;AppComment&#39;,
            &#39;AppContact&#39;,
            &#39;AppCopyright&#39;,
            &#39;AppId&#39;,
            &#39;AppModifyPath&#39;,
            &#39;AppMutex&#39;,
            &#39;AppName&#39;,
            &#39;AppPublisher&#39;,
            &#39;AppPublisherUrl&#39;,
            &#39;AppReadmeFile&#39;,
            &#39;AppSupportPhone&#39;,
            &#39;AppSupportUrl&#39;,
            &#39;AppUpdatesUrl&#39;,
            &#39;AppVersion&#39;,
            &#39;AppVersionedName&#39;,
            &#39;BaseFilename&#39;,
            &#39;ChangesAssociations&#39;,
            &#39;ChangesEnvironment&#39;,
            &#39;CloseApplicationsFilter&#39;,
            &#39;CreateUninstallRegistryKey&#39;,
            &#39;DefaultDirName&#39;,
            &#39;DefaultGroupName&#39;,
            &#39;DefaultOrganisation&#39;,
            &#39;DefaultSerial&#39;,
            &#39;DefaultUsername&#39;,
            &#39;SetupMutex&#39;,
            &#39;Uninstallable&#39;,
            &#39;UninstallFilesDir&#39;,
            &#39;UninstallIcon&#39;,
            &#39;UninstallName&#39;,
        ]:
            try:
                value: bytes = getattr(self, coded_string_attribute)
            except AttributeError:
                continue
            if not isinstance(value, (bytes, bytearray, memoryview)):
                raise RuntimeError(F&#39;Attempting to decode {coded_string_attribute} which was already decoded.&#39;)
            setattr(self, coded_string_attribute, codecs.decode(value, codec))


class Version(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.Build = reader.u16() if version &gt;= (1, 3, 19) else 0
        self.Minor = reader.u8()
        self.Major = reader.u8()

    def json(self):
        return F&#39;{self.Major:d}.{self.Minor:d}.{self.Build:04d}&#39;


class WindowsVersion(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.OS = Version(reader, version)
        self.NT = Version(reader, version)
        (
            self.ServicePackMinor,
            self.ServicePackMajor,
        ) = reader.read_struct(&#39;BB&#39;) if version &gt;= (1, 3, 19) else (0, 0)


class WinVerRange(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.Min = WindowsVersion(reader, version)
        self.Max = WindowsVersion(reader, version)


class LanguageId(JsonStruct):
    def __init__(self, reader: StructReader[memoryview]):
        self.Value = reader.i32()
        self.Name = LCID.get(self.Value, None)


class SetupLanguage(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, _: TSetup):
        super().__init__(reader, version)
        read_string = self._read_string

        self.Name = read_string()
        LanguageName = reader.read_length_prefixed()

        self.DialogFont = read_string()
        self.TitleFont = read_string()
        self.WelcomeFont = read_string()
        self.CopyrightFont = read_string()
        self._data = reader.read_length_prefixed()

        if version &gt;= (4, 0, 1):
            self.LicenseText = reader.read_length_prefixed_ascii()
            self.InfoBefore = reader.read_length_prefixed_ascii()
            self.InfoAfter = reader.read_length_prefixed_ascii()

        self.LanguageId = LanguageId(reader)

        if version &lt; (4, 2, 2):
            self.Codepage = DEFAULT_CODEPAGE.get(self.LanguageId.Value, &#39;cp1252&#39;)
        elif version.ascii:
            cp = reader.u32() or 1252
            self.Codepage = F&#39;cp{cp}&#39;
        else:
            if version &lt; (5, 3, 0):
                reader.u32()
            self.Codepage = &#39;utf-16le&#39;

        if version &gt;= (4, 2, 2):
            self.LanguageName = codecs.decode(LanguageName, &#39;utf-16le&#39;)
        else:
            self.LanguageName = codecs.decode(LanguageName, self.Codepage)

        self.DialogFontSize = reader.u32()

        if version &lt; (4, 1, 0):
            self.DialogFontStandardHeight = reader.u32()

        self.TitleFontSize = reader.u32()
        self.WelcomeFontSize = reader.u32()
        self.CopyrightFontSize = reader.u32()

        if version &gt;= (5, 2, 3):
            self.RightToLeft = reader.u8()


class SetupMessage(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        self.EncodedName = self._read_string()
        self._raw_value = reader.read_length_prefixed()
        self._language_index = reader.i32()
        try:
            self._language_value = parent.Languages[self._language_index]
        except IndexError:
            self._language_value = None
            codec = &#39;latin1&#39;
        else:
            codec = self._language_value.Codepage
        try:
            self.Value = codecs.decode(self._raw_value, codec)
        except LookupError:
            # TODO: This is a fallback
            self.Value = codecs.decode(self._raw_value, &#39;latin1&#39;)

    def get_raw_value(self):
        return self._raw_value

    def get_language_index(self):
        return self._language_index

    def get_language_value(self):
        return self._language_value


class SetupType(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string
        self.Name = read_string()
        self.Description = read_string()
        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        self.WindowsVersion = WinVerRange(reader, version)
        self.CustsomTypeCode = reader.u8()
        if version &gt;= (4, 0, 3):
            self.SetupType = SetupTypeEnum(reader.u8())
        else:
            self.SetupType = SetupTypeEnum.User
        if version &gt;= (4, 0, 0):
            self.Size = reader.u64()
        else:
            self.Size = reader.u32()


class SetupComponent(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string
        self.Name = read_string()
        self.Description = read_string()
        self.Types = read_string()
        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        if version &gt;= (4, 0, 0):
            self.ExtraDiskSpace = reader.u64()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 3):
            self.Level = reader.u32()
        else:
            self.Level = 0
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 4):
            self.Used = bool(reader.u8())
        else:
            self.Used = True
        if True:
            self.WindowsVersion = WinVerRange(reader, version)
            self.Flags = SetupFlags(reader.u8())
        if version &gt;= (4, 0, 0):
            self.Size = reader.u64()
        elif version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Size = reader.u32()


class SetupTaskFlags(enum.IntFlag):
    Empty            = 0           # noqa
    Exclusive        = enum.auto() # noqa
    Unchecked        = enum.auto() # noqa
    Restart          = enum.auto() # noqa
    CheckedOne       = enum.auto() # noqa
    DontInheritCheck = enum.auto() # noqa


class SetupTask(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string

        self.Name = read_string()
        self.Description = read_string()
        self.GroupDescription = read_string()
        self.Components = read_string()

        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 3):
            self.Level = reader.u32()
        else:
            self.Level = 0
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 4):
            self.Used = bool(reader.u8())
        else:
            self.Used = True
        if True:
            self.WindowsVersion = WinVerRange(reader, version)

        self.Flags = SetupTaskFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        if True:
            flagbit(SetupTaskFlags.Exclusive)
            flagbit(SetupTaskFlags.Unchecked)
        if version &gt;= (2, 0, 5):
            flagbit(SetupTaskFlags.Restart)
        if version &gt;= (2, 0, 6):
            flagbit(SetupTaskFlags.CheckedOne)
        if version &gt;= (4, 2, 3):
            flagbit(SetupTaskFlags.DontInheritCheck)

        reader.byte_align()


class SetupCondition(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string
        if version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 8):
            self.Components = read_string()
        if version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 17):
            self.Tasks = read_string()
        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        else:
            self.Check = None
        if version &gt;= (4, 1, 0):
            self.AfterInstall = read_string()
            self.BeforeInstall = read_string()


class SetupDirectoryFlags(enum.IntFlag):
    Empty                = 0           # noqa
    NeverUninstall       = enum.auto() # noqa
    DeleteAfterInstall   = enum.auto() # noqa
    AlwaysUninstall      = enum.auto() # noqa
    SetNtfsCompression   = enum.auto() # noqa
    UnsetNtfsCompression = enum.auto() # noqa


class SetupDirectory(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string

        if version &lt; (1, 3, 0):
            self.UncompressedSize = reader.u32()
        if True:
            self.Name = read_string()
            self.Condition = SetupCondition(reader, version, parent)

        if (4, 0, 11) &lt;= version &lt; (4, 1, 0):
            self.Permissions = read_string()
        if version &gt;= (2, 0, 11):
            self.Attributes = reader.u32()

        self.WindowsVersion = WinVerRange(reader, version)

        if version &gt;= (4, 1, 0):
            self.Permissions = reader.u16()

        self.Flags = SetupDirectoryFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0
        flagbit(SetupDirectoryFlags.NeverUninstall)
        flagbit(SetupDirectoryFlags.DeleteAfterInstall)
        flagbit(SetupDirectoryFlags.AlwaysUninstall)
        flagbit(SetupDirectoryFlags.SetNtfsCompression)
        flagbit(SetupDirectoryFlags.UnsetNtfsCompression)
        reader.byte_align()


class SetupPermission(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        self.Permission = reader.read_length_prefixed()


class SetupFileFlags(enum.IntFlag):
    Empty                              = 0           # noqa
    ConfirmOverwrite                   = enum.auto() # noqa
    NeverUninstall                     = enum.auto() # noqa
    RestartReplace                     = enum.auto() # noqa
    DeleteAfterInstall                 = enum.auto() # noqa
    RegisterServer                     = enum.auto() # noqa
    RegisterTypeLib                    = enum.auto() # noqa
    SharedFile                         = enum.auto() # noqa
    IsReadmeFile                       = enum.auto() # noqa
    CompareTimeStamp                   = enum.auto() # noqa
    FontIsNotTrueType                  = enum.auto() # noqa
    SkipIfSourceDoesntExist            = enum.auto() # noqa
    OverwriteReadOnly                  = enum.auto() # noqa
    OverwriteSameVersion               = enum.auto() # noqa
    CustomDestName                     = enum.auto() # noqa
    OnlyIfDestFileExists               = enum.auto() # noqa
    NoRegError                         = enum.auto() # noqa
    UninsRestartDelete                 = enum.auto() # noqa
    OnlyIfDoesntExist                  = enum.auto() # noqa
    IgnoreVersion                      = enum.auto() # noqa
    PromptIfOlder                      = enum.auto() # noqa
    DontCopy                           = enum.auto() # noqa
    UninsRemoveReadOnly                = enum.auto() # noqa
    RecurseSubDirsExternal             = enum.auto() # noqa
    ReplaceSameVersionIfContentsDiffer = enum.auto() # noqa
    DontVerifyChecksum                 = enum.auto() # noqa
    UninsNoSharedFilePrompt            = enum.auto() # noqa
    CreateAllSubDirs                   = enum.auto() # noqa
    Bits32                             = enum.auto() # noqa
    Bits64                             = enum.auto() # noqa
    ExternalSizePreset                 = enum.auto() # noqa
    SetNtfsCompression                 = enum.auto() # noqa
    UnsetNtfsCompression               = enum.auto() # noqa
    GacInstall                         = enum.auto() # noqa


class SetupFileType(enum.IntEnum):
    UserFile = 0
    UninstExe = 1
    RegSvrExe = 2


class SetupFileCopyMode(enum.IntEnum):
    Normal                  = 0           # noqa
    IfDoesntExist           = enum.auto() # noqa
    AlwaysOverwrite         = enum.auto() # noqa
    AlwaysSkipIfSameOrOlder = enum.auto() # noqa


class SetupFile(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string

        if version &lt; (1, 3, 0):
            self.UncompressedSize = reader.u32()
        if True:
            self.Source = read_string()
            self.Destination = read_string()
            self.InstallFontName = read_string()
        if version &gt;= (5, 2, 5):
            self.StrongAssemblyName = read_string()

        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)

        self.Location = reader.u32()
        self.Attributes = reader.u32()
        self.ExternalSize = reader.u64() if version &gt;= (4, 0, 0) else reader.u32()

        self.Flags = SetupFileFlags.Empty

        if version &lt; (3, 0, 5):
            copy = _enum(SetupFileCopyMode, reader.u8(), SetupFileCopyMode.Normal)
            if copy == SetupFileCopyMode.AlwaysSkipIfSameOrOlder:
                pass
            elif copy == SetupFileCopyMode.Normal:
                self.Flags |= SetupFileFlags.PromptIfOlder
            elif copy == SetupFileCopyMode.IfDoesntExist:
                self.Flags |= SetupFileFlags.OnlyIfDoesntExist | SetupFileFlags.PromptIfOlder
            elif copy == SetupFileCopyMode.AlwaysOverwrite:
                self.Flags |= SetupFileFlags.IgnoreVersion | SetupFileFlags.PromptIfOlder

        if version &gt;= (4, 1, 0):
            self.Permissions = reader.u16()

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        flagstart = reader.tell()

        if True:
            flagbit(SetupFileFlags.ConfirmOverwrite)
            flagbit(SetupFileFlags.NeverUninstall)
            flagbit(SetupFileFlags.RestartReplace)
            flagbit(SetupFileFlags.DeleteAfterInstall)
        if version.bits &gt; 16:
            flagbit(SetupFileFlags.RegisterServer)
            flagbit(SetupFileFlags.RegisterTypeLib)
            flagbit(SetupFileFlags.SharedFile)
        if version &lt; (2, 0, 0) and not version.isx:
            flagbit(SetupFileFlags.IsReadmeFile)
        if True:
            flagbit(SetupFileFlags.CompareTimeStamp)
            flagbit(SetupFileFlags.FontIsNotTrueType)
        if version &gt;= (1, 2, 5):
            flagbit(SetupFileFlags.SkipIfSourceDoesntExist)
        if version &gt;= (1, 2, 6):
            flagbit(SetupFileFlags.OverwriteReadOnly)
        if version &gt;= (1, 3, 21):
            flagbit(SetupFileFlags.OverwriteSameVersion)
            flagbit(SetupFileFlags.CustomDestName)
        if version &gt;= (1, 3, 25):
            flagbit(SetupFileFlags.OnlyIfDestFileExists)
        if version &gt;= (2, 0, 5):
            flagbit(SetupFileFlags.NoRegError)
        if version &gt;= (3, 0, 1):
            flagbit(SetupFileFlags.UninsRestartDelete)
        if version &gt;= (3, 0, 5):
            flagbit(SetupFileFlags.OnlyIfDoesntExist)
            flagbit(SetupFileFlags.IgnoreVersion)
            flagbit(SetupFileFlags.PromptIfOlder)
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 6, 1):
            flagbit(SetupFileFlags.DontCopy)
        if version &gt;= (4, 0, 5):
            flagbit(SetupFileFlags.UninsRemoveReadOnly)
        if version &gt;= (4, 1, 8):
            flagbit(SetupFileFlags.RecurseSubDirsExternal)
        if version &gt;= (4, 2, 1):
            flagbit(SetupFileFlags.ReplaceSameVersionIfContentsDiffer)
        if version &gt;= (4, 2, 5):
            flagbit(SetupFileFlags.DontVerifyChecksum)
        if version &gt;= (5, 0, 3):
            flagbit(SetupFileFlags.UninsNoSharedFilePrompt)
        if version &gt;= (5, 1, 0):
            flagbit(SetupFileFlags.CreateAllSubDirs)
        if version &gt;= (5, 1, 2):
            flagbit(SetupFileFlags.Bits32)
            flagbit(SetupFileFlags.Bits64)
        if version &gt;= (5, 2, 0):
            flagbit(SetupFileFlags.ExternalSizePreset)
            flagbit(SetupFileFlags.SetNtfsCompression)
            flagbit(SetupFileFlags.UnsetNtfsCompression)
        if version &gt;= (5, 2, 5):
            flagbit(SetupFileFlags.GacInstall)

        reader.byte_align()

        if reader.tell() - flagstart == 3:
            reader.u8()

        self.Type = SetupFileType(reader.u8())


class SetupIconCloseSetting(enum.IntEnum):
    NoSetting       = 0           # noqa
    CloseOnExit     = enum.auto() # noqa
    DontCloseOnExit = enum.auto() # noqa


class SetupIconFlags(enum.IntFlag):
    Empty                              = 0           # noqa
    NeverUninstall                     = enum.auto() # noqa
    RunMinimized                       = enum.auto() # noqa
    CreateOnlyIfFileExists             = enum.auto() # noqa
    UseAppPaths                        = enum.auto() # noqa
    FolderShortcut                     = enum.auto() # noqa
    ExcludeFromShowInNewInstall        = enum.auto() # noqa
    PreventPinning                     = enum.auto() # noqa
    HasAppUserModelToastActivatorCLSID = enum.auto() # noqa


class SetupIcon(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)

        if version &lt; (1, 3, 0):
            reader.u32()

        self.Name = self._read_string()
        self.FileName = self._read_string()
        self.Parameters = self._read_string()
        self.WorkingDir = self._read_string()
        self.IconFile = self._read_string()
        self.Comment = self._read_string()

        self.Condition = SetupCondition(reader, version, parent)

        if version &gt;= (5, 3, 5):
            self.AppUserModelId = self._read_string()
        if version &gt;= (6, 1, 0):
            self.AppUserModelToastActivatorCLSID = str(reader.read_guid())

        self.WindowsVersion = WinVerRange(reader, version)
        self.IconIndex = reader.i32()

        if version &gt;= (1, 3, 24):
            self.ShowCommand = reader.i32()
        else:
            self.ShowCommand = 1

        if version &gt;= (1, 3, 15):
            self.CloseOnExit = _enum(SetupIconCloseSetting, reader.u8(), SetupIconCloseSetting.NoSetting)
        else:
            self.CloseOnExit = SetupIconCloseSetting.NoSetting

        self.HotKey = reader.u16() if version &gt;= (2, 0, 7) else 0

        self.Flags = SetupIconFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0
        if True:
            flagbit(SetupIconFlags.NeverUninstall)
        if version &lt; (1, 3, 26):
            flagbit(SetupIconFlags.RunMinimized)
        if True:
            flagbit(SetupIconFlags.CreateOnlyIfFileExists)
        if version.bits &gt; 16:
            flagbit(SetupIconFlags.UseAppPaths)
        if version &gt;= (5, 0, 3) and version &lt; (6, 3, 0):
            flagbit(SetupIconFlags.FolderShortcut)
        if version &gt;= (5, 4, 2):
            flagbit(SetupIconFlags.ExcludeFromShowInNewInstall)
        if version &gt;= (5, 5, 0):
            flagbit(SetupIconFlags.PreventPinning)
        if version &gt;= (6, 1, 0):
            flagbit(SetupIconFlags.HasAppUserModelToastActivatorCLSID)
        reader.byte_align()


class SetupIniFlags(enum.IntFlag):
    Empty                     = 0           # noqa
    CreateKeyIfDoesntExist    = enum.auto() # noqa
    UninsDeleteEntry          = enum.auto() # noqa
    UninsDeleteEntireSection  = enum.auto() # noqa
    UninsDeleteSectionIfEmpty = enum.auto() # noqa
    HasValue                  = enum.auto() # noqa


class SetupIniEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)

        if version &lt; (1, 3, 0):
            reader.u8()

        if not (IniFile := self._read_string()):
            IniFile = &#39;{windows}/WIN.INI&#39;
        self.IniFile = IniFile

        self.Section = self._read_string()
        self.Key = self._read_string()
        self.Codepage = self._read_string()
        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)
        self.Flags = SetupIniFlags(reader.u8())


class SetupRegistryType(enum.IntEnum):
    Unset        = 0           # noqa
    String       = enum.auto() # noqa
    ExpandString = enum.auto() # noqa
    DWord        = enum.auto() # noqa
    Binary       = enum.auto() # noqa
    MultiString  = enum.auto() # noqa
    QWord        = enum.auto() # noqa


class SetupRegistryFlags(enum.IntFlag):
    Empty                       = 0           # noqa
    CreateValueIfDoesntExist    = enum.auto() # noqa
    UninsDeleteValue            = enum.auto() # noqa
    UninsClearValue             = enum.auto() # noqa
    UninsDeleteEntireKey        = enum.auto() # noqa
    UninsDeleteEntireKeyIfEmpty = enum.auto() # noqa
    PreserveStringType          = enum.auto() # noqa
    DeleteKey                   = enum.auto() # noqa
    DeleteValue                 = enum.auto() # noqa
    NoError                     = enum.auto() # noqa
    DontCreateKey               = enum.auto() # noqa
    Bits32                      = enum.auto() # noqa
    Bits64                      = enum.auto() # noqa


class SetupRegistryEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)

        if version &lt; (1, 3, 0):
            reader.u32()

        if True:
            self.Key = self._read_string()
        if version.bits &gt; 16:
            self.Name = self._read_string()
        if True:
            self.Value = reader.read_length_prefixed()
            self.Condition = SetupCondition(reader, version, parent)
        if (4, 0, 11) &lt;= version &lt; (4, 1, 0):
            self.Permissions = reader.read_length_prefixed()

        self.WindowsVersion = WinVerRange(reader, version)
        self.Hive = reader.u32() &amp; 0x7FFFFFFF if version.bits &gt; 16 else None
        self.Permissions = reader.u16() if version &gt;= (4, 1, 0) else None
        self.Type = SetupRegistryType(reader.u8())

        self.Flags = SetupRegistryFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        if version.bits &gt; 16:
            flagbit(SetupRegistryFlags.CreateValueIfDoesntExist)
            flagbit(SetupRegistryFlags.UninsDeleteValue)
        if True:
            flagbit(SetupRegistryFlags.UninsClearValue)
            flagbit(SetupRegistryFlags.UninsDeleteEntireKey)
            flagbit(SetupRegistryFlags.UninsDeleteEntireKeyIfEmpty)
        if version &gt;= (1, 2, 6):
            flagbit(SetupRegistryFlags.PreserveStringType)
        if version &gt;= (1, 3, 9):
            flagbit(SetupRegistryFlags.DeleteKey)
            flagbit(SetupRegistryFlags.DeleteValue)
        if version &gt;= (1, 3, 12):
            flagbit(SetupRegistryFlags.NoError)
        if version &gt;= (1, 3, 16):
            flagbit(SetupRegistryFlags.DontCreateKey)
        if version &gt;= (5, 1, 0):
            flagbit(SetupRegistryFlags.Bits32)
            flagbit(SetupRegistryFlags.Bits64)

        reader.byte_align()


class SetupDeleteType(enum.IntEnum):
    Files           = 0           # noqa
    FilesAndSubdirs = enum.auto() # noqa
    DirIfEmpty      = enum.auto() # noqa


class SetupDeleteEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        if version &lt; (1, 3, 0):
            reader.u32()
        self.Name = self._read_string()
        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)
        self.Type = SetupDeleteType(reader.u8())


class SetupRunWait(enum.IntEnum):
    UntilTerminated = 0 # noqa
    NoWait          = 1 # noqa
    UntilIdle       = 2 # noqa


class SetupRunFlags(enum.IntFlag):
    Empty             = 0           # noqa
    ShellExec         = enum.auto() # noqa
    SkipIfDoesntExist = enum.auto() # noqa
    PostInstall       = enum.auto() # noqa
    Unchecked         = enum.auto() # noqa
    SkipIfSilent      = enum.auto() # noqa
    SkipIfNotSilent   = enum.auto() # noqa
    HideWizard        = enum.auto() # noqa
    Bits32            = enum.auto() # noqa
    Bits64            = enum.auto() # noqa
    RunAsOriginalUser = enum.auto() # noqa
    DontLogParameters = enum.auto() # noqa
    LogOutput         = enum.auto() # noqa


class SetupRunEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        if version &lt; (1, 3, 0):
            reader.u8()
        self.Name = self._read_string()
        self.Parameters = self._read_string()
        self.WorkingDir = self._read_string()

        if version &gt;= (1, 3, 9):
            self.RunOnceId = self._read_string()
        if version &gt;= (2, 0, 2):
            self.StatusMessage = self._read_string()
        if version &gt;= (5, 1, 13):
            self.Verb = self._read_string()
        if version &gt;= (2, 0, 0) or version.isx:
            self.Description = self._read_string()

        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)
        self.ShowCommand = reader.u32() if version &gt;= (1, 3, 24) else 0
        self.Wait = SetupRunWait(reader.u8())

        self.Flags = SetupRunFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        if version &gt;= (1, 2, 3):
            flagbit(SetupRunFlags.ShellExec)
        if version &gt;= (1, 3, 9) or version.isx and version &gt;= (1, 3, 8):
            flagbit(SetupRunFlags.SkipIfDoesntExist)
        if version &gt;= (2, 0, 0):
            flagbit(SetupRunFlags.PostInstall)
            flagbit(SetupRunFlags.Unchecked)
            flagbit(SetupRunFlags.SkipIfSilent)
            flagbit(SetupRunFlags.SkipIfNotSilent)
        if version &gt;= (2, 0, 8):
            flagbit(SetupRunFlags.HideWizard)
        if version &gt;= (5, 1, 10):
            flagbit(SetupRunFlags.Bits32)
            flagbit(SetupRunFlags.Bits64)
        if version &gt;= (5, 2, 0):
            flagbit(SetupRunFlags.RunAsOriginalUser)
        if version &gt;= (6, 1, 0):
            flagbit(SetupRunFlags.DontLogParameters)
        if version &gt;= (6, 3, 0):
            flagbit(SetupRunFlags.LogOutput)

        reader.byte_align()


class TSetup(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.Header = h = SetupHeader(reader, version)

        def _array(count: int, parser: type[_T]) -&gt; list[_T]:
            return [parser(reader, version, self) for _ in range(count)]

        self.Languages = _array(h.LanguageCount, SetupLanguage)
        _default_codec = &#39;cp1252&#39;

        if version.unicode:
            self.Codec = &#39;utf-16le&#39;
        elif not self.Languages:
            self.Codec = _default_codec
        else:
            self.Codec = self.Languages[0].Codepage
            if any(language.Codepage == _default_codec for language in self.Languages):
                self.Codec = _default_codec

        if version.ascii:
            h.recode_strings(self.Codec)
        else:
            h.recode_strings(&#39;utf-16le&#39;)

        if h.Uninstallable == &#39;yes&#39;:
            h.Flags |= Flags.Uninstallable

        if version &lt; (4, 0, 0):
            self._load_wizard_and_decompressor(reader, version)

        self.Messages               = _array(h.MessageCount,         SetupMessage)       # noqa
        self.Permissions            = _array(h.PermissionCount,      SetupPermission)    # noqa
        self.Types                  = _array(h.TypeCount,            SetupType)          # noqa
        self.Components             = _array(h.ComponentCount,       SetupComponent)     # noqa
        self.Tasks                  = _array(h.TaskCount,            SetupTask)          # noqa
        self.Directories            = _array(h.DirectoryCount,       SetupDirectory)     # noqa
        self.Files                  = _array(h.FileCount,            SetupFile)          # noqa

        self._DecompressDLL = None
        self._DecryptionDLL = None

        self.Icons                  = _array(h.IconCount,            SetupIcon)          # noqa
        self.IniEntries             = _array(h.IniEntryCount,        SetupIniEntry)      # noqa
        self.RegistryEntries        = _array(h.RegistryCount,        SetupRegistryEntry) # noqa
        self.DeleteEntries          = _array(h.DeleteCount,          SetupDeleteEntry)   # noqa
        self.UninstallDeleteEntries = _array(h.UninstallDeleteCount, SetupDeleteEntry)   # noqa
        self.RunEntries             = _array(h.RunCount,             SetupRunEntry)      # noqa
        self.UninstallRunEntries    = _array(h.UninstallRunCount,    SetupRunEntry)      # noqa

        if version &gt;= (4, 0, 0):
            self._load_wizard_and_decompressor(reader, version)

    def get_wizard_images_large(self):
        return self._WizardImagesLarge

    def get_wizard_images_small(self):
        return self._WizardImagesSmall

    def get_decompress_dll(self):
        return self._DecompressDLL

    def get_decryption_dll(self):
        return self._DecryptionDLL

    def _load_wizard_and_decompressor(self, reader: StructReader[memoryview], version: InnoVersion):
        if True:
            self._WizardImagesLarge = self._load_wizard_images(reader, version)
        if version &gt;= (2, 0, 0) or version.isx:
            self._WizardImagesSmall = self._load_wizard_images(reader, version)
        method = self.Header.CompressionMethod
        crypto = self.Header.Flags &amp; Flags.EncryptionUsed and version &lt; (6, 4, 0)
        hasDLL = (
            method == CompressionMethod.BZip2
            or method == CompressionMethod.LZMA1 and version == (4, 1, 5)
            or method == CompressionMethod.Flate and version &gt;= (4, 2, 6))
        self._DecompressDLL = reader.read_length_prefixed() if hasDLL else None
        self._DecryptionDLL = reader.read_length_prefixed() if crypto else None

    def _load_wizard_images(self, reader: StructReader[memoryview], version: InnoVersion):
        count = reader.u32() if version &gt;= (5, 6, 0) else 1
        img = [reader.read_length_prefixed() for _ in range(count)]
        if version &lt; (5, 6, 0) and img and not img[0]:
            img.clear()
        return img


class SetupDataEntryFlags(enum.IntFlag):
    Empty                    = 0           # noqa    
    VersionInfoValid         = enum.auto() # noqa
    VersionInfoNotValid      = enum.auto() # noqa
    BZipped                  = enum.auto() # noqa
    TimeStampInUTC           = enum.auto() # noqa
    IsUninstallerExe         = enum.auto() # noqa
    CallInstructionOptimized = enum.auto() # noqa
    ApplyTouchDateTime       = enum.auto() # noqa
    ChunkEncrypted           = enum.auto() # noqa
    ChunkCompressed          = enum.auto() # noqa
    SolidBreak               = enum.auto() # noqa
    Sign                     = enum.auto() # noqa
    SignOnce                 = enum.auto() # noqa


class SetupSignMode(enum.IntEnum):
    NoSetting  = 0  # noqa
    Yes        = 1  # noqa
    Once       = 2  # noqa
    Check      = 3  # noqa


class SetupDataEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.FirstSlice = reader.u32()
        self.LastSlice = reader.u32()
        self.ChunkOffset = reader.u32()
        if version &gt;= (4, 0, 1):
            self.Offset = reader.u64()
        self.FileSize = reader.u64()
        self.ChunkSize = reader.u64()

        if version &gt;= (6, 4, 0):
            self.ChecksumType = CheckSumType.SHA256
            self.Checksum = bytes(reader.read(32))
        elif version &gt;= (5, 3, 9):
            self.ChecksumType = CheckSumType.SHA1
            self.Checksum = bytes(reader.read(20))
        elif version &gt;= (4, 2, 0):
            self.ChecksumType = CheckSumType.MD5
            self.Checksum = bytes(reader.read(16))
        elif version &gt;= (4, 0, 1):
            self.ChecksumType = CheckSumType.CRC32
            self.Checksum = reader.u32()
        else:
            self.ChecksumType = CheckSumType.Adler32
            self.Checksum = reader.u32()

        ft = reader.u64()
        ts = datetime.fromtimestamp(
            (ft - _FILE_TIME_1970_01_01) / 10000000, timezone.utc)
        self.FileTime = ts

        self.FileVersionMs = reader.u32()
        self.FileVersionLs = reader.u32()

        self.Flags = 0

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        flag_start = reader.tell()
        flagbit(SetupDataEntryFlags.VersionInfoValid)

        if version &lt; (6, 4, 3):
            flagbit(SetupDataEntryFlags.VersionInfoNotValid)
        if version &lt; (4, 0, 1):
            flagbit(SetupDataEntryFlags.BZipped)
        if (4, 0, 10) &lt;= version:
            flagbit(SetupDataEntryFlags.TimeStampInUTC)
        if (4, 1, 0) &lt;= version &lt; (6, 4, 3):
            flagbit(SetupDataEntryFlags.IsUninstallerExe)
        if (4, 1, 8) &lt;= version:
            flagbit(SetupDataEntryFlags.CallInstructionOptimized)
        if (4, 2, 0) &lt;= version &lt; (6, 4, 3):
            flagbit(SetupDataEntryFlags.ApplyTouchDateTime)
        if (4, 2, 2) &lt;= version:
            flagbit(SetupDataEntryFlags.ChunkEncrypted)
        if (4, 2, 5) &lt;= version:
            flagbit(SetupDataEntryFlags.ChunkCompressed)
        if (5, 1, 13) &lt;= version &lt; (6, 4, 3):
            flagbit(SetupDataEntryFlags.SolidBreak)
        if (5, 5, 7) &lt;= version &lt; (6, 3, 0):
            flagbit(SetupDataEntryFlags.Sign)
            flagbit(SetupDataEntryFlags.SignOnce)

        reader.byte_align()

        if (reader.tell() - flag_start) % 2:
            reader.u8()

        if (6, 3, 0) &lt;= version &lt; (6, 4, 3):
            self.SignMode = SetupSignMode(reader.u8())
        elif self.Flags &amp; SetupDataEntryFlags.SignOnce:
            self.SignMode = SetupSignMode.Once
        elif self.Flags &amp; SetupDataEntryFlags.Sign:
            self.SignMode = SetupSignMode.Yes
        else:
            self.SignMode = SetupSignMode.NoSetting


class TData(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.DataEntries: list[SetupDataEntry] = []
        while not reader.eof:
            self.DataEntries.append(SetupDataEntry(reader, version))


class InnoParseResult(NamedTuple):
    version: InnoVersion
    streams: list[InnoStream]
    files: list[InnoFile]
    warnings: int
    failures: list[str]
    setup_info: TSetup
    setup_data: TData

    def ok(self):
        return self.warnings == 0 and not self.failures


class InnoStreams(NamedTuple):
    TSetup: InnoStream
    TData: InnoStream
    Uninstaller: InnoStream


class InnoArchive:
    &#34;&#34;&#34;
    This class represents an InnoSetup archive. Optionally, a `refinery.units.Unit` can be
    passed to the class as a parameter to use its logger.
    &#34;&#34;&#34;
    OffsetsPath: ClassVar[str] = &#39;RCDATA/11111/0&#39;
    ChunkPrefix: ClassVar[bytes] = b&#39;zlb\x1a&#39;

    def __init__(
        self,
        data: bytearray,
        unit: Unit | None = None,
    ):
        if not (meta := TSetupOffsets.FindInBinary(data)):
            try:
                _meta = one(data | perc(self.OffsetsPath))
            except Exception as E:
                raise ValueError(F&#39;Could not find TSetupOffsets PE resource at {self.OffsetsPath}&#39;) from E
            else:
                meta = TSetupOffsets(_meta)

        self._password = None
        self._password_guessed = False

        leniency = unit.leniency if unit else 0
        self._log_verbose = (lambda *_: None) if unit is None else unit.log_debug
        self._log_comment = (lambda *_: None) if unit is None else unit.log_info
        self._log_warning = (lambda *_: None) if unit is None else unit.log_warn

        self.meta = meta
        self.view = view = memoryview(data)

        base = meta.base
        inno = StructReader(view[base:base + meta.total_size])

        self._decompressed = {}

        blobsize = meta.info_offset - meta.data_offset
        inno.seek(meta.data_offset)
        self.blobs = blobs = StructReader(inno.read(blobsize))

        header = bytes(inno.read(16))

        try:
            version = InnoVersion.ParseLegacy(header)
        except ValueError:
            header += bytes(inno.read(64 - 16))
            try:
                version = InnoVersion.Parse(header)
            except ValueError:
                if version := meta.iv:
                    method = &#39;magic&#39;
                else:
                    name, _, _rest = header.partition(b&#39;\0&#39;)
                    method = &#39;broken&#39;
                    if any(_rest):
                        header = name.hex()
                    else:
                        header = name.decode(&#39;latin1&#39;)
                    if leniency &lt; 1:
                        raise ValueError(F&#39;unable to parse header identifier &#34;{header}&#34;&#39;)
                    version = _DEFAULT_INNO_VERSION
            else:
                header, _, _ = header.partition(B&#39;\0&#39;)
                header = header.decode(&#39;latin1&#39;)
                method = &#39;modern&#39;
        else:
            header, _, _ = header.partition(B&#39;\x1A&#39;)
            header = header.decode(&#39;latin1&#39;)
            method = &#39;legacy&#39;

        self._log_comment(F&#39;inno {version!s} via {method} header: {header}&#39;)

        class _notok:
            def __init__(self, e: Exception):
                self.failures = [str(e)]

            def ok(self):
                return False

        def _parse(v: InnoVersion):
            inno.seekset(inno_start)
            if inno.eof:
                raise EOFError
            try:
                if v.legacy:
                    inno.seekrel(-48)
                r = self._try_parse_as(inno, blobs, v)
            except Exception as e:
                nonlocal best_error
                best_error = best_error or e
                self._log_comment(F&#39;exception while parsing as {v!s}: {exception_to_string(e)}&#39;)
                return _notok(e)
            else:
                results[v] = r
                return r

        inno_start = inno.tell()
        best_parse = None
        best_score = 0
        best_error = None
        success = False
        results: dict[InnoVersion, InnoParseResult] = {}

        VER = _VERSIONS
        AMB = _IS_AMBIGUOUS

        if not version.is_ambiguous():
            index = VER.index(version)
        else:
            try:
                index = max(k for k, v in enumerate(VER) if v &lt;= version)
            except Exception:
                index = 0

        lower = index
        upper = index + 1
        while lower &gt; 0 and AMB[VER[lower - 1]] or VER[lower - 1].semver == VER[lower].semver:
            lower -= 1

        versions = [version] + VER[lower:upper] + VER[upper:] + VER[:lower]

        for v in versions:
            if success := (result := _parse(v)).ok():
                if v != version:
                    self._log_comment(F&#39;inno {v!s} via closest match: {header}&#39;)
                break
            if not result.failures and (best_parse is None or result.warnings &lt; best_score):
                best_score = best_score
                best_parse = result

        if not success:
            if best_parse is not None:
                result = best_parse
                self._log_warning(F&#39;using parse result for {result.version!s} with {result.warnings} warnings&#39;)
            else:
                if not results:
                    if best_error:
                        raise best_error
                    raise ValueError(&#39;no parser for any known Inno version worked&#39;)
                result = min(results.values(), key=lambda result: len(result.failures))
                self._log_warning(F&#39;using parse result for {result.version!s} with {len(result.failures)} failures&#39;)
                for k, failure in enumerate(result.failures, 1):
                    self._log_comment(F&#39;failure {k}: {failure}&#39;)

        self.version = version = result.version
        self.codec = codec = result.setup_info.Codec
        self.setup_info = result.setup_info
        self.setup_data = result.setup_data
        self.files = result.files
        self.streams = InnoStreams(*result.streams)
        self.script_codec = &#39;latin1&#39; if version.unicode else codec

        try:
            emulator = self.emulator
        except Exception:
            pass
        else:
            for file in self.files:
                path = emulator.reset().expand_constant(file.path)
                path = path.replace(&#39;\\&#39;, &#39;/&#39;)
                drive, colon, path = path.rpartition(&#39;:/&#39;)
                if colon and len(drive) == 1:
                    path = F&#39;{drive}/{path}&#39;
                file.path = F&#39;data/{path}&#39;

    @cached_property
    def emulator(self):
        from refinery.lib.inno.emulator import (
            IFPSEmulatorConfig,
            InnoSetupEmulator,
        )
        return InnoSetupEmulator(self, IFPSEmulatorConfig(
            temp_path=&#39;{tmp}&#39;,
            user_name=&#39;{user}&#39;,
            host_name=&#39;{host}&#39;,
            inno_name=&#39;{name}&#39;,
            executable=&#39;{exe}&#39;,
            install_to=&#39;{app}&#39;,
            log_mutexes=False,
            log_opcodes=False,
            log_passwords=True,
        ))

    @cached_property
    def ifps(self):
        &#34;&#34;&#34;
        An `refinery.lib.inno.ifps.IFPSFile` representing the embedded IFPS script, if it exists.
        &#34;&#34;&#34;
        if script := self.setup_info.Header.get_script():
            return IFPSFile(script, self.script_codec, self.version.unicode)

    def guess_password(self, timeout: int) -&gt; bool:
        &#34;&#34;&#34;
        Attempt to guess the password by emulating the setup script.
        &#34;&#34;&#34;
        if self._password_guessed:
            return self._password is not None
        self._password_guessed = True
        if file := self.get_encrypted_sample():
            from refinery.lib.inno.emulator import NewPassword
            self._log_verbose(&#39;attempting to automatically determine password from the embedded script&#39;)
            try:
                for p in self.emulator.reset().emulate_installation():
                    if not isinstance(p, NewPassword):
                        continue
                    if self.check_password(file, p):
                        self._log_comment(&#39;found password via emulation:&#39;, p)
                        self._password = p
                        return True
                else:
                    self._log_comment(&#39;no valid password found via emulation&#39;)
                    return False
            except Exception as error:
                self._log_comment(&#39;emuluation failed:&#39;, error)
        else:
            self._password = &#39;&#39;
            return True

    def get_encrypted_sample(inno) -&gt; InnoFile | None:
        &#34;&#34;&#34;
        If the archive has a password, this function returns the smallest encrypted file record.
        &#34;&#34;&#34;
        file = min(inno.files, key=lambda f: (not f.encrypted, f.size))
        return file if file.encrypted else None

    def _try_parse_as(
        self,
        inno: StructReader,
        blobs: StructReader,
        version: InnoVersion,
        max_failures: int = 5
    ):
        streams: list[InnoStream] = []
        files: list[InnoFile] = []
        warnings = 0

        for _ in range(3):
            stream = InnoStream(StreamHeader(inno, version))
            streams.append(stream)
            to_read = stream.header.StoredSize
            while to_read &gt; 4:
                block = CrcCompressedBlock(inno, min(to_read - 4, 0x1000))
                stream.blocks.append(block)
                to_read -= len(block)

        self._log_verbose(F&#39;{version!s} parsing stream 1 (TData)&#39;)
        stream1 = TData(memoryview(self.read_stream(streams[1])), version)

        for meta in stream1.DataEntries:
            file = InnoFile(blobs, version, meta)
            files.append(file)

        self._log_verbose(F&#39;{version!s} parsing stream 0 (TSetup)&#39;)
        stream0 = TSetup(memoryview(self.read_stream(streams[0])), version)
        path_dedup: dict[str, list[SetupFile]] = {}

        for file in files:
            file.compression_method = stream0.Header.CompressionMethod
            file.password_hash = stream0.Header.PasswordHash
            file.password_type = stream0.Header.PasswordType
            file.password_salt = stream0.Header.PasswordSalt

        for sf in stream0.Files:
            sf: SetupFile
            location = sf.Location
            if location == 0xFFFFFFFF or sf.Type != SetupFileType.UserFile or sf.Source:
                msg = F&#39;skipping file: offset=0x{location:08X} type={sf.Type.name}&#39;
                if sf.Source:
                    msg = F&#39;{msg} src={sf.Source}&#39;
                self._log_verbose(msg)
                continue
            if location &gt;= len(files):
                self._log_warning(F&#39;parsed {len(file)} entries, ignoring invalid setup reference to entry {location + 1}&#39;)
                continue
            path = sf.Destination.replace(&#39;\\&#39;, &#39;/&#39;)
            path_dedup.setdefault(path, []).append(sf)
            files[location].setup = sf
            files[location].path = path

        for path, infos in list(path_dedup.items()):
            if len(infos) == 1:
                continue
            del path_dedup[path]
            for sf in infos:
                if condition := sf.Condition.Check:
                    condition = re.sub(&#39;\\s+&#39;, &#39;-&#39;, condition)
                    np = F&#39;{condition}/{path}&#39;
                    path_dedup.setdefault(np, []).append(sf)

        for path, infos in path_dedup.items():
            if len(infos) == 1:
                files[infos[0].Location].path = path
                continue
            bycheck = {}
            for info in infos:
                file = files[info.Location]
                if not file.checksum_type.strong():
                    bycheck.clear()
                    break
                dkey = (file.checksum, file.size)
                if dkey in bycheck:
                    self._log_verbose(F&#39;skipping exact duplicate: {path}&#39;)
                    file.dupe = True
                    continue
                bycheck[dkey] = info
            if bycheck:
                if len(bycheck) == 1:
                    file.path = path
                    continue
                infos = list(bycheck.values())
            for k, info in enumerate(infos):
                files[info.Location].path = F&#39;{path}[{k}]&#39;

        _width = len(str(len(files)))

        for k, file in enumerate(files):
            if file.dupe:
                continue
            if not file.path:
                self._log_verbose(F&#39;file {k} does not have a path&#39;)
                file.path = F&#39;raw/FileData{k:0{_width}d}&#39;

        warnings = sum(1 for file in files if file.setup is None)
        failures = []
        nonempty = [f for f in files if f.size &gt; 0]

        self._decompressed.clear()

        for file in nonempty:
            if len(failures) &gt;= max_failures:
                break
            if file.setup is None:
                failures.append(F&#39;file {file.path} had no associated metadata&#39;)
                continue
            if file.chunk_length &lt; 0x10000:
                try:
                    data = self.read_file(file)
                except InvalidPassword:
                    continue
                except Exception as e:
                    failures.append(F&#39;extraction error for {file.path}: {e!s}&#39;)
                    continue
                if file.check(data) != file.checksum:
                    failures.append(F&#39;invalid checksum for {file.path}&#39;)

        return InnoParseResult(
            version,
            streams,
            files,
            warnings,
            failures,
            stream0,
            stream1,
        )

    def read_stream(self, stream: InnoStream):
        &#34;&#34;&#34;
        Decompress and read the input stream.
        &#34;&#34;&#34;
        if stream.data is not None:
            return stream.data
        result = bytearray()
        it = iter(stream.blocks)
        if stream.compression == StreamCompressionMethod.Store:
            class _dummy:
                def decompress(self, b):
                    return b
            dec = _dummy()
        elif stream.compression == StreamCompressionMethod.LZMA1:
            import lzma
            first = next(it).BlockData
            prop, first = first[:5], first[5:]
            filter = parse_lzma_properties(prop, 1)
            dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[filter])
            result.extend(dec.decompress(first))
        elif stream.compression == StreamCompressionMethod.Flate:
            import zlib
            dec = zlib.decompressobj()
        for block in it:
            result.extend(dec.decompress(block.BlockData))
        stream.data = result
        return result

    def check_password(self, file: InnoFile, password: str):
        &#34;&#34;&#34;
        Returns `True` if the given password correctly decrypts the given file.
        &#34;&#34;&#34;
        try:
            self.read_chunk(file, password, check_only=True)
        except InvalidPassword:
            return False
        else:
            return True

    def read_chunk(self, file: InnoFile, password: str | None = None, check_only: bool = False):
        &#34;&#34;&#34;
        Decompress and read the chunk containing the given file. If the chunk is encrypted, the
        function requires the correct password. If the `check_only` parameter is set, then only
        a password check is performed, but the chunk is not actually decompressed.
        &#34;&#34;&#34;
        reader = file.reader
        offset = file.chunk_offset
        length = file.chunk_length
        method = file.compression

        if password is None:
            password = self._password

        if offset + length &gt; len(reader):
            span = F&#39;0x{offset:X}-0x{offset + length:X}&#39;
            raise LookupError(
                F&#39;Chunk spans 0x{len(file.reader):X} bytes; data is located at {span}.&#39;)

        reader.seek(offset)
        prefix = reader.read(4)

        if prefix != self.ChunkPrefix:
            raise ValueError(F&#39;Error reading chunk at offset 0x{offset:X}; invalid magic {prefix.hex()}.&#39;)

        if file.encrypted:
            if file.password_type == PasswordType.Nothing:
                raise RuntimeError(F&#39;File {file.path} is encrypted, but no password type was set.&#39;)
            if password is None:
                raise InvalidPassword
            if file.password_type == PasswordType.XChaCha20:
                salt, iterations, nonce = struct.unpack(&#39;=16sI24s&#39;, file.password_salt)
                key = password.encode(self.script_codec) | pbkdf2(32, salt, iterations, &#39;SHA256&#39;) | bytes
                test_nonce = list(struct.unpack(&#39;6I&#39;, nonce))
                test_nonce[2] = ~test_nonce[2]
                test_nonce = struct.pack(&#39;6I&#39;, test_nonce)
                if B&#39;\0\0\0\0&#39; | xchacha(key, nonce=test_nonce) | bytes != file.password_hash:
                    raise InvalidPassword(password)
                decryptor = xchacha(key, nonce=nonce)
            else:
                password_bytes = password.encode(
                    &#39;utf-16le&#39; if file.unicode else self.script_codec)
                algorithm = {
                    PasswordType.SHA1: sha1,
                    PasswordType.MD5 : md5,
                }[file.password_type]
                hash = algorithm(b&#39;PasswordCheckHash&#39; + file.password_salt)
                hash.update(password_bytes)
                if hash.digest() != file.password_hash:
                    raise InvalidPassword(password)
                hash = algorithm(reader.read(8))
                hash.update(password_bytes)
                decryptor = rc4(hash.digest(), discard=1000)

        if check_only:
            return

        data = reader.read_exactly(length)

        if file.encrypted:
            data = data | decryptor | bytearray

        if method is None:
            return chunk

        try:
            if method == CompressionMethod.Store:
                chunk = data
            elif method == CompressionMethod.LZMA1:
                props = parse_lzma_properties(data[0:5], 1)
                dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[props])
                chunk = dec.decompress(data[5:])
            elif method == CompressionMethod.LZMA2:
                props = parse_lzma_properties(data[0:1], 2)
                dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[props])
                chunk = dec.decompress(data[1:])
            elif method == CompressionMethod.BZip2:
                chunk = bz2.decompress(data)
            elif method == CompressionMethod.Flate:
                chunk = zlib.decompress(data)
        except Exception as E:
            if not file.encrypted:
                raise
            raise InvalidPassword(password) from E

        return chunk

    def read_file(
        self,
        file: InnoFile,
        password: str | None = None,
    ):
        &#34;&#34;&#34;
        Read the contents of the given file record from the archive without performing any checks.
        See also `refinery.lib.inno.InnoArchive.read_file_and_check`.
        &#34;&#34;&#34;
        offset = file.chunk_offset
        length = file.chunk_length

        try:
            chunk = self._decompressed[offset, length]
        except KeyError:
            chunk = self._decompressed[offset, length] = self.read_chunk(file, password)

        view = memoryview(chunk)
        data = view[file.offset:file.offset + file.size]

        if file.filtered:
            if file.version &gt;= (5, 2, 0):
                flip = (file.version &gt;= (5, 3, 9))
                data = self._filter_new(data, flip_high_byte=flip)
            else:
                data = self._filter_old(data)

        return data

    def read_file_and_check(
        self,
        file: InnoFile,
        password: str | None = None,
    ):
        &#34;&#34;&#34;
        Read the contents of the given file record from the archive. Raises a `ValueError` if the
        checksum is invalid.
        &#34;&#34;&#34;
        data = self.read_file(file, password)

        if (cs := file.check(data)) is not None and cs != file.checksum:
            if isinstance(cs, int):
                computed = F&#39;{cs:08X}&#39;
                expected = F&#39;{file.checksum:08X}&#39;
            else:
                computed = cs.hex().upper()
                expected = file.checksum.hex().upper()
            raise ValueError(F&#39;checksum error; computed:{computed} expected:{expected}&#39;)

        return data

    def _filter_new(self, data: buf, flip_high_byte=False):
        try:
            import numpy as np
        except ImportError:
            return self._filter_new_fallback(data, flip_high_byte)
        u08 = np.uint8
        u32 = np.uint32
        ab0 = bytearray()
        ab1 = bytearray()
        ab2 = bytearray()
        ab3 = bytearray()
        positions = []
        if isinstance(data, bytearray):
            out = data
        else:
            out = bytearray(data)
        mem = memoryview(out)
        for k in range(0, len(mem), 0x10000):
            for match in re.finditer(B&#39;(?s)[\xE8\xE9]....&#39;, mem[k:k + 0x10000], flags=re.DOTALL):
                a = match.start() + k
                top = mem[a + 4]
                if top != 0x00 and top != 0xFF:
                    continue
                ab0.append(mem[a + 1])
                ab1.append(mem[a + 2])
                ab2.append(mem[a + 3])
                ab3.append(top)
                positions.append(a + 5)
        ab0 = np.frombuffer(ab0, dtype=u08)
        ab1 = np.frombuffer(ab1, dtype=u08)
        low = np.frombuffer(ab2, dtype=u08).astype(u32)
        msb = np.frombuffer(ab3, dtype=u08)
        sub = np.fromiter(positions, dtype=u32)
        low &lt;&lt;= 8
        low += ab1
        low &lt;&lt;= 8
        low += ab0
        low -= sub
        low &amp;= 0xFFFFFF
        if flip_high_byte:
            flips = low &gt;&gt; 23
            keeps = 1 - flips
            keeps *= msb
            msb ^= 0xFF
            msb *= flips
            msb += keeps
        low += (msb.astype(u32) &lt;&lt; 24)
        addresses = low.tobytes()
        for k, offset in enumerate(positions):
            out[offset - 4:offset] = addresses[k * 4:(k + 1) * 4]
        return out

    def _filter_new_fallback(self, data: buf, flip_high_byte=False):
        block_size = 0x10000
        out = bytearray(data)
        i = 0
        while len(data) - i &gt;= 5:
            c = out[i]
            block_size_left = block_size - (i % block_size)
            i += 1
            if (c == 0xE8 or c == 0xE9) and block_size_left &gt;= 5:
                address = out[i:i + 4]
                i += 4
                if address[3] == 0 or address[3] == 0xFF:
                    rel = address[0] | address[1] &lt;&lt; 8 | address[2] &lt;&lt; 16
                    rel -= i &amp; 0xFFFFFF
                    out[i - 4] = rel &amp; 0xFF
                    out[i - 3] = (rel &gt;&gt; 8) &amp; 0xFF
                    out[i - 2] = (rel &gt;&gt; 16) &amp; 0xFF
                    if flip_high_byte and (rel &amp; 0x800000) != 0:
                        out[i - 1] = (~out[i - 1]) &amp; 0xFF
        return out

    @staticmethod
    def _filter_old(data: buf):
        if not isinstance(data, bytearray):
            data = bytearray(data)
        addr_bytes_left = 0
        addr_offset = 5
        addr = 0
        for i, c in enumerate(data):
            if addr_bytes_left == 0:
                if c == 0xE8 or c == 0xE9:
                    addr = (~addr_offset + 1) &amp; 0xFFFFFFFF
                    addr_bytes_left = 4
            else:
                addr = (addr + c) &amp; 0xFFFFFFFF
                c = addr &amp; 0xFF
                addr = addr &gt;&gt; 8
                addr_bytes_left -= 1
            data[i] = c
        return data


def is_inno_setup(data: bytearray):
    &#34;&#34;&#34;
    Test whether the input data is likely an Inno Setup executable.
    &#34;&#34;&#34;
    if data[:2] != B&#39;MZ&#39;:
        return False
    if re.search(re.escape(InnoArchive.ChunkPrefix), data) is None:
        return False
    for marker in [
        B&#39;Inno Setup Setup Data&#39;,
        B&#39;Inno Setup Messages&#39;,
        B&#39;&lt;description&gt;Inno Setup&lt;/description&gt;&#39;,
        B&#39;InnoSetupLdrWindow&#39;,
        B&#39;This installation was built with Inno Setup&#39;,
    ]:
        if re.search(re.escape(marker), data):
            return True
    for marker in TSetupMagicToVersion.keys():
        if re.search(re.escape(marker), data) is not None:
            return True
    return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.inno.archive.is_inno_setup"><code class="name flex">
<span>def <span class="ident">is_inno_setup</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Test whether the input data is likely an Inno Setup executable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2777-L2797" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_inno_setup(data: bytearray):
    &#34;&#34;&#34;
    Test whether the input data is likely an Inno Setup executable.
    &#34;&#34;&#34;
    if data[:2] != B&#39;MZ&#39;:
        return False
    if re.search(re.escape(InnoArchive.ChunkPrefix), data) is None:
        return False
    for marker in [
        B&#39;Inno Setup Setup Data&#39;,
        B&#39;Inno Setup Messages&#39;,
        B&#39;&lt;description&gt;Inno Setup&lt;/description&gt;&#39;,
        B&#39;InnoSetupLdrWindow&#39;,
        B&#39;This installation was built with Inno Setup&#39;,
    ]:
        if re.search(re.escape(marker), data):
            return True
    for marker in TSetupMagicToVersion.keys():
        if re.search(re.escape(marker), data) is not None:
            return True
    return False</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.inno.archive.InvalidPassword"><code class="flex name class">
<span>class <span class="ident">InvalidPassword</span></span>
<span>(</span><span>password=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Inappropriate argument value (of correct type).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L48-L53" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InvalidPassword(ValueError):
    def __init__(self, password: str | None = None):
        if password is None:
            super().__init__(&#39;A password is required and none was given.&#39;)
        else:
            super().__init__(&#39;The given password is not correct.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.IncorrectVersion"><code class="flex name class">
<span>class <span class="ident">IncorrectVersion</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Unspecified run-time error.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L56-L57" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IncorrectVersion(RuntimeError):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.RuntimeError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.FileChunkOutOfBounds"><code class="flex name class">
<span>class <span class="ident">FileChunkOutOfBounds</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for lookup errors.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L60-L61" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class FileChunkOutOfBounds(LookupError):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.LookupError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.IVF"><code class="flex name class">
<span>class <span class="ident">IVF</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L64-L72" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IVF(enum.IntFlag):
    NoFlag   = 0b0000 # noqa
    Legacy   = 0b0001 # noqa
    Bits16   = 0b0010 # noqa
    UTF_16   = 0b0100 # noqa
    InnoSX   = 0b1000 # noqa
    Legacy32 = 0b0001
    Legacy16 = 0b0011
    IsLegacy = 0b0011</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.IVF.NoFlag"><code class="name">var <span class="ident">NoFlag</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.IVF.Legacy"><code class="name">var <span class="ident">Legacy</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.IVF.Bits16"><code class="name">var <span class="ident">Bits16</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.IVF.UTF_16"><code class="name">var <span class="ident">UTF_16</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.IVF.InnoSX"><code class="name">var <span class="ident">InnoSX</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.IVF.Legacy32"><code class="name">var <span class="ident">Legacy32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.IVF.Legacy16"><code class="name">var <span class="ident">Legacy16</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.IVF.IsLegacy"><code class="name">var <span class="ident">IsLegacy</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.InnoVersion"><code class="flex name class">
<span>class <span class="ident">InnoVersion</span></span>
<span>(</span><span>major, minor, patch, build=0, flags=0)</span>
</code></dt>
<dd>
<section class="desc"><p>InnoVersion(major, minor, patch, build, flags)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L82-L166" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoVersion(NamedTuple):
    major: int
    minor: int
    patch: int
    build: int = 0
    flags: IVF = IVF.NoFlag

    @property
    def semver(self):
        return (self.major, self.minor, self.patch, self.build)

    @property
    def unicode(self):
        return self.flags &amp; IVF.UTF_16 == IVF.UTF_16

    @property
    def legacy(self):
        return self.flags &amp; IVF.Legacy

    @property
    def ascii(self):
        return self.flags &amp; IVF.UTF_16 == IVF.NoFlag

    @property
    def isx(self):
        return bool(self.flags &amp; IVF.InnoSX)

    @property
    def bits(self):
        return 0x10 if self.flags &amp; IVF.Bits16 else 0x20

    @classmethod
    def ParseLegacy(cls, dfn: bytes):
        v, s, _ = dfn.partition(B&#39;\x1A&#39;)
        if s and (m := re.fullmatch(BR&#39;i(\d+)\.(\d+)\.(\d+)--(16|32)&#39;, v)):
            major = int(m[1])
            minor = int(m[2])
            build = int(m[3])
            flags = IVF.Legacy16 if m[3] == B&#39;16&#39; else IVF.Legacy32
            return cls(major, minor, build, 0, flags)
        raise ValueError(dfn)

    @classmethod
    def Parse(cls, dfn: bytes):
        versions: list[InnoVersion] = []
        for match in [m.groups() for m in re.finditer(rb&#39;(.*?)\((\d+(?:\.\d+){2,3})(?:.*?\(([uU])\))?&#39;, dfn)]:
            sv = tuple(map(int, match[1].split(B&#39;.&#39;)))
            sv = (sv + (0,))[:4]
            vf = IVF.NoFlag
            if sv &gt;= (6, 3, 0) or match[2]:
                vf |= IVF.UTF_16
            if any(isx in match[0] for isx in (B&#39;My Inno Setup Extensions&#39;, B&#39;with ISX&#39;)):
                vf |= IVF.InnoSX
            versions.append(InnoVersion(*sv, vf))
        if len(versions) == 1:
            return versions[0]
        if len(versions) == 2:
            a, b = versions
            return InnoVersion(*max(a.semver, b.semver), a.flags | b.flags)
        raise ValueError(dfn)

    def __str__(self):
        v = F&#39;v{self.major}.{self.minor}.{self.patch:02d}.{self.build}&#39;
        a = R&#39;a&#39;
        u = R&#39;u&#39;
        if self.flags &amp; IVF.InnoSX:
            a = R&#39;&#39;
            v = F&#39;{v}x&#39;
        t = u if self.flags &amp; IVF.UTF_16 else a
        v = F&#39;{v}{t}&#39;
        if b := {
            IVF.Legacy16: &#39;16&#39;,
            IVF.Legacy32: &#39;32&#39;,
        }.get(self.flags &amp; IVF.IsLegacy):
            v = F&#39;{v}/{b}&#39;
        return v

    def __repr__(self):
        return str(self)

    def is_ambiguous(self):
        try:
            return _IS_AMBIGUOUS[self]
        except KeyError:
            return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.InnoVersion.ParseLegacy"><code class="name flex">
<span>def <span class="ident">ParseLegacy</span></span>(<span>dfn)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoVersion.Parse"><code class="name flex">
<span>def <span class="ident">Parse</span></span>(<span>dfn)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.InnoVersion.major"><code class="name">var <span class="ident">major</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L82-L166" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoVersion(NamedTuple):
    major: int
    minor: int
    patch: int
    build: int = 0
    flags: IVF = IVF.NoFlag

    @property
    def semver(self):
        return (self.major, self.minor, self.patch, self.build)

    @property
    def unicode(self):
        return self.flags &amp; IVF.UTF_16 == IVF.UTF_16

    @property
    def legacy(self):
        return self.flags &amp; IVF.Legacy

    @property
    def ascii(self):
        return self.flags &amp; IVF.UTF_16 == IVF.NoFlag

    @property
    def isx(self):
        return bool(self.flags &amp; IVF.InnoSX)

    @property
    def bits(self):
        return 0x10 if self.flags &amp; IVF.Bits16 else 0x20

    @classmethod
    def ParseLegacy(cls, dfn: bytes):
        v, s, _ = dfn.partition(B&#39;\x1A&#39;)
        if s and (m := re.fullmatch(BR&#39;i(\d+)\.(\d+)\.(\d+)--(16|32)&#39;, v)):
            major = int(m[1])
            minor = int(m[2])
            build = int(m[3])
            flags = IVF.Legacy16 if m[3] == B&#39;16&#39; else IVF.Legacy32
            return cls(major, minor, build, 0, flags)
        raise ValueError(dfn)

    @classmethod
    def Parse(cls, dfn: bytes):
        versions: list[InnoVersion] = []
        for match in [m.groups() for m in re.finditer(rb&#39;(.*?)\((\d+(?:\.\d+){2,3})(?:.*?\(([uU])\))?&#39;, dfn)]:
            sv = tuple(map(int, match[1].split(B&#39;.&#39;)))
            sv = (sv + (0,))[:4]
            vf = IVF.NoFlag
            if sv &gt;= (6, 3, 0) or match[2]:
                vf |= IVF.UTF_16
            if any(isx in match[0] for isx in (B&#39;My Inno Setup Extensions&#39;, B&#39;with ISX&#39;)):
                vf |= IVF.InnoSX
            versions.append(InnoVersion(*sv, vf))
        if len(versions) == 1:
            return versions[0]
        if len(versions) == 2:
            a, b = versions
            return InnoVersion(*max(a.semver, b.semver), a.flags | b.flags)
        raise ValueError(dfn)

    def __str__(self):
        v = F&#39;v{self.major}.{self.minor}.{self.patch:02d}.{self.build}&#39;
        a = R&#39;a&#39;
        u = R&#39;u&#39;
        if self.flags &amp; IVF.InnoSX:
            a = R&#39;&#39;
            v = F&#39;{v}x&#39;
        t = u if self.flags &amp; IVF.UTF_16 else a
        v = F&#39;{v}{t}&#39;
        if b := {
            IVF.Legacy16: &#39;16&#39;,
            IVF.Legacy32: &#39;32&#39;,
        }.get(self.flags &amp; IVF.IsLegacy):
            v = F&#39;{v}/{b}&#39;
        return v

    def __repr__(self):
        return str(self)

    def is_ambiguous(self):
        try:
            return _IS_AMBIGUOUS[self]
        except KeyError:
            return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoVersion.minor"><code class="name">var <span class="ident">minor</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L82-L166" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoVersion(NamedTuple):
    major: int
    minor: int
    patch: int
    build: int = 0
    flags: IVF = IVF.NoFlag

    @property
    def semver(self):
        return (self.major, self.minor, self.patch, self.build)

    @property
    def unicode(self):
        return self.flags &amp; IVF.UTF_16 == IVF.UTF_16

    @property
    def legacy(self):
        return self.flags &amp; IVF.Legacy

    @property
    def ascii(self):
        return self.flags &amp; IVF.UTF_16 == IVF.NoFlag

    @property
    def isx(self):
        return bool(self.flags &amp; IVF.InnoSX)

    @property
    def bits(self):
        return 0x10 if self.flags &amp; IVF.Bits16 else 0x20

    @classmethod
    def ParseLegacy(cls, dfn: bytes):
        v, s, _ = dfn.partition(B&#39;\x1A&#39;)
        if s and (m := re.fullmatch(BR&#39;i(\d+)\.(\d+)\.(\d+)--(16|32)&#39;, v)):
            major = int(m[1])
            minor = int(m[2])
            build = int(m[3])
            flags = IVF.Legacy16 if m[3] == B&#39;16&#39; else IVF.Legacy32
            return cls(major, minor, build, 0, flags)
        raise ValueError(dfn)

    @classmethod
    def Parse(cls, dfn: bytes):
        versions: list[InnoVersion] = []
        for match in [m.groups() for m in re.finditer(rb&#39;(.*?)\((\d+(?:\.\d+){2,3})(?:.*?\(([uU])\))?&#39;, dfn)]:
            sv = tuple(map(int, match[1].split(B&#39;.&#39;)))
            sv = (sv + (0,))[:4]
            vf = IVF.NoFlag
            if sv &gt;= (6, 3, 0) or match[2]:
                vf |= IVF.UTF_16
            if any(isx in match[0] for isx in (B&#39;My Inno Setup Extensions&#39;, B&#39;with ISX&#39;)):
                vf |= IVF.InnoSX
            versions.append(InnoVersion(*sv, vf))
        if len(versions) == 1:
            return versions[0]
        if len(versions) == 2:
            a, b = versions
            return InnoVersion(*max(a.semver, b.semver), a.flags | b.flags)
        raise ValueError(dfn)

    def __str__(self):
        v = F&#39;v{self.major}.{self.minor}.{self.patch:02d}.{self.build}&#39;
        a = R&#39;a&#39;
        u = R&#39;u&#39;
        if self.flags &amp; IVF.InnoSX:
            a = R&#39;&#39;
            v = F&#39;{v}x&#39;
        t = u if self.flags &amp; IVF.UTF_16 else a
        v = F&#39;{v}{t}&#39;
        if b := {
            IVF.Legacy16: &#39;16&#39;,
            IVF.Legacy32: &#39;32&#39;,
        }.get(self.flags &amp; IVF.IsLegacy):
            v = F&#39;{v}/{b}&#39;
        return v

    def __repr__(self):
        return str(self)

    def is_ambiguous(self):
        try:
            return _IS_AMBIGUOUS[self]
        except KeyError:
            return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoVersion.patch"><code class="name">var <span class="ident">patch</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L82-L166" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoVersion(NamedTuple):
    major: int
    minor: int
    patch: int
    build: int = 0
    flags: IVF = IVF.NoFlag

    @property
    def semver(self):
        return (self.major, self.minor, self.patch, self.build)

    @property
    def unicode(self):
        return self.flags &amp; IVF.UTF_16 == IVF.UTF_16

    @property
    def legacy(self):
        return self.flags &amp; IVF.Legacy

    @property
    def ascii(self):
        return self.flags &amp; IVF.UTF_16 == IVF.NoFlag

    @property
    def isx(self):
        return bool(self.flags &amp; IVF.InnoSX)

    @property
    def bits(self):
        return 0x10 if self.flags &amp; IVF.Bits16 else 0x20

    @classmethod
    def ParseLegacy(cls, dfn: bytes):
        v, s, _ = dfn.partition(B&#39;\x1A&#39;)
        if s and (m := re.fullmatch(BR&#39;i(\d+)\.(\d+)\.(\d+)--(16|32)&#39;, v)):
            major = int(m[1])
            minor = int(m[2])
            build = int(m[3])
            flags = IVF.Legacy16 if m[3] == B&#39;16&#39; else IVF.Legacy32
            return cls(major, minor, build, 0, flags)
        raise ValueError(dfn)

    @classmethod
    def Parse(cls, dfn: bytes):
        versions: list[InnoVersion] = []
        for match in [m.groups() for m in re.finditer(rb&#39;(.*?)\((\d+(?:\.\d+){2,3})(?:.*?\(([uU])\))?&#39;, dfn)]:
            sv = tuple(map(int, match[1].split(B&#39;.&#39;)))
            sv = (sv + (0,))[:4]
            vf = IVF.NoFlag
            if sv &gt;= (6, 3, 0) or match[2]:
                vf |= IVF.UTF_16
            if any(isx in match[0] for isx in (B&#39;My Inno Setup Extensions&#39;, B&#39;with ISX&#39;)):
                vf |= IVF.InnoSX
            versions.append(InnoVersion(*sv, vf))
        if len(versions) == 1:
            return versions[0]
        if len(versions) == 2:
            a, b = versions
            return InnoVersion(*max(a.semver, b.semver), a.flags | b.flags)
        raise ValueError(dfn)

    def __str__(self):
        v = F&#39;v{self.major}.{self.minor}.{self.patch:02d}.{self.build}&#39;
        a = R&#39;a&#39;
        u = R&#39;u&#39;
        if self.flags &amp; IVF.InnoSX:
            a = R&#39;&#39;
            v = F&#39;{v}x&#39;
        t = u if self.flags &amp; IVF.UTF_16 else a
        v = F&#39;{v}{t}&#39;
        if b := {
            IVF.Legacy16: &#39;16&#39;,
            IVF.Legacy32: &#39;32&#39;,
        }.get(self.flags &amp; IVF.IsLegacy):
            v = F&#39;{v}/{b}&#39;
        return v

    def __repr__(self):
        return str(self)

    def is_ambiguous(self):
        try:
            return _IS_AMBIGUOUS[self]
        except KeyError:
            return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoVersion.build"><code class="name">var <span class="ident">build</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L82-L166" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoVersion(NamedTuple):
    major: int
    minor: int
    patch: int
    build: int = 0
    flags: IVF = IVF.NoFlag

    @property
    def semver(self):
        return (self.major, self.minor, self.patch, self.build)

    @property
    def unicode(self):
        return self.flags &amp; IVF.UTF_16 == IVF.UTF_16

    @property
    def legacy(self):
        return self.flags &amp; IVF.Legacy

    @property
    def ascii(self):
        return self.flags &amp; IVF.UTF_16 == IVF.NoFlag

    @property
    def isx(self):
        return bool(self.flags &amp; IVF.InnoSX)

    @property
    def bits(self):
        return 0x10 if self.flags &amp; IVF.Bits16 else 0x20

    @classmethod
    def ParseLegacy(cls, dfn: bytes):
        v, s, _ = dfn.partition(B&#39;\x1A&#39;)
        if s and (m := re.fullmatch(BR&#39;i(\d+)\.(\d+)\.(\d+)--(16|32)&#39;, v)):
            major = int(m[1])
            minor = int(m[2])
            build = int(m[3])
            flags = IVF.Legacy16 if m[3] == B&#39;16&#39; else IVF.Legacy32
            return cls(major, minor, build, 0, flags)
        raise ValueError(dfn)

    @classmethod
    def Parse(cls, dfn: bytes):
        versions: list[InnoVersion] = []
        for match in [m.groups() for m in re.finditer(rb&#39;(.*?)\((\d+(?:\.\d+){2,3})(?:.*?\(([uU])\))?&#39;, dfn)]:
            sv = tuple(map(int, match[1].split(B&#39;.&#39;)))
            sv = (sv + (0,))[:4]
            vf = IVF.NoFlag
            if sv &gt;= (6, 3, 0) or match[2]:
                vf |= IVF.UTF_16
            if any(isx in match[0] for isx in (B&#39;My Inno Setup Extensions&#39;, B&#39;with ISX&#39;)):
                vf |= IVF.InnoSX
            versions.append(InnoVersion(*sv, vf))
        if len(versions) == 1:
            return versions[0]
        if len(versions) == 2:
            a, b = versions
            return InnoVersion(*max(a.semver, b.semver), a.flags | b.flags)
        raise ValueError(dfn)

    def __str__(self):
        v = F&#39;v{self.major}.{self.minor}.{self.patch:02d}.{self.build}&#39;
        a = R&#39;a&#39;
        u = R&#39;u&#39;
        if self.flags &amp; IVF.InnoSX:
            a = R&#39;&#39;
            v = F&#39;{v}x&#39;
        t = u if self.flags &amp; IVF.UTF_16 else a
        v = F&#39;{v}{t}&#39;
        if b := {
            IVF.Legacy16: &#39;16&#39;,
            IVF.Legacy32: &#39;32&#39;,
        }.get(self.flags &amp; IVF.IsLegacy):
            v = F&#39;{v}/{b}&#39;
        return v

    def __repr__(self):
        return str(self)

    def is_ambiguous(self):
        try:
            return _IS_AMBIGUOUS[self]
        except KeyError:
            return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoVersion.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 4</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L82-L166" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoVersion(NamedTuple):
    major: int
    minor: int
    patch: int
    build: int = 0
    flags: IVF = IVF.NoFlag

    @property
    def semver(self):
        return (self.major, self.minor, self.patch, self.build)

    @property
    def unicode(self):
        return self.flags &amp; IVF.UTF_16 == IVF.UTF_16

    @property
    def legacy(self):
        return self.flags &amp; IVF.Legacy

    @property
    def ascii(self):
        return self.flags &amp; IVF.UTF_16 == IVF.NoFlag

    @property
    def isx(self):
        return bool(self.flags &amp; IVF.InnoSX)

    @property
    def bits(self):
        return 0x10 if self.flags &amp; IVF.Bits16 else 0x20

    @classmethod
    def ParseLegacy(cls, dfn: bytes):
        v, s, _ = dfn.partition(B&#39;\x1A&#39;)
        if s and (m := re.fullmatch(BR&#39;i(\d+)\.(\d+)\.(\d+)--(16|32)&#39;, v)):
            major = int(m[1])
            minor = int(m[2])
            build = int(m[3])
            flags = IVF.Legacy16 if m[3] == B&#39;16&#39; else IVF.Legacy32
            return cls(major, minor, build, 0, flags)
        raise ValueError(dfn)

    @classmethod
    def Parse(cls, dfn: bytes):
        versions: list[InnoVersion] = []
        for match in [m.groups() for m in re.finditer(rb&#39;(.*?)\((\d+(?:\.\d+){2,3})(?:.*?\(([uU])\))?&#39;, dfn)]:
            sv = tuple(map(int, match[1].split(B&#39;.&#39;)))
            sv = (sv + (0,))[:4]
            vf = IVF.NoFlag
            if sv &gt;= (6, 3, 0) or match[2]:
                vf |= IVF.UTF_16
            if any(isx in match[0] for isx in (B&#39;My Inno Setup Extensions&#39;, B&#39;with ISX&#39;)):
                vf |= IVF.InnoSX
            versions.append(InnoVersion(*sv, vf))
        if len(versions) == 1:
            return versions[0]
        if len(versions) == 2:
            a, b = versions
            return InnoVersion(*max(a.semver, b.semver), a.flags | b.flags)
        raise ValueError(dfn)

    def __str__(self):
        v = F&#39;v{self.major}.{self.minor}.{self.patch:02d}.{self.build}&#39;
        a = R&#39;a&#39;
        u = R&#39;u&#39;
        if self.flags &amp; IVF.InnoSX:
            a = R&#39;&#39;
            v = F&#39;{v}x&#39;
        t = u if self.flags &amp; IVF.UTF_16 else a
        v = F&#39;{v}{t}&#39;
        if b := {
            IVF.Legacy16: &#39;16&#39;,
            IVF.Legacy32: &#39;32&#39;,
        }.get(self.flags &amp; IVF.IsLegacy):
            v = F&#39;{v}/{b}&#39;
        return v

    def __repr__(self):
        return str(self)

    def is_ambiguous(self):
        try:
            return _IS_AMBIGUOUS[self]
        except KeyError:
            return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoVersion.semver"><code class="name">var <span class="ident">semver</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L89-L91" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def semver(self):
    return (self.major, self.minor, self.patch, self.build)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoVersion.unicode"><code class="name">var <span class="ident">unicode</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L93-L95" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def unicode(self):
    return self.flags &amp; IVF.UTF_16 == IVF.UTF_16</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoVersion.legacy"><code class="name">var <span class="ident">legacy</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L97-L99" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def legacy(self):
    return self.flags &amp; IVF.Legacy</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoVersion.ascii"><code class="name">var <span class="ident">ascii</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L101-L103" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def ascii(self):
    return self.flags &amp; IVF.UTF_16 == IVF.NoFlag</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoVersion.isx"><code class="name">var <span class="ident">isx</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L105-L107" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def isx(self):
    return bool(self.flags &amp; IVF.InnoSX)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoVersion.bits"><code class="name">var <span class="ident">bits</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L109-L111" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def bits(self):
    return 0x10 if self.flags &amp; IVF.Bits16 else 0x20</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.InnoVersion.is_ambiguous"><code class="name flex">
<span>def <span class="ident">is_ambiguous</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L162-L166" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_ambiguous(self):
    try:
        return _IS_AMBIGUOUS[self]
    except KeyError:
        return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.JsonStruct"><code class="flex name class">
<span>class <span class="ident">JsonStruct</span></span>
<span>(</span><span>reader, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L297-L316" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class JsonStruct(Struct):
    def json(self):
        def _json(v):
            if isinstance(v, list):
                return [_json(x) for x in v]
            if isinstance(v, dict):
                return {x: _json(y) for x, y in v.items()}
            if isinstance(v, JsonStruct):
                return v.json()
            if isinstance(v, enum.IntFlag):
                return [option.name for option in v.__class__ if v &amp; option == option]
            if isinstance(v, enum.IntEnum):
                return v.name
            if isinstance(v, memoryview):
                return codecs.decode(v, &#39;latin1&#39;)
            return v
        return {
            k: _json(v) for k, v in self.__dict__.items()
            if not k.startswith(&#39;_&#39;)
        }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.CrcCompressedBlock" href="#refinery.lib.inno.archive.CrcCompressedBlock">CrcCompressedBlock</a></li>
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.LanguageId" href="#refinery.lib.inno.archive.LanguageId">LanguageId</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.JsonStruct.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L298-L316" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def json(self):
    def _json(v):
        if isinstance(v, list):
            return [_json(x) for x in v]
        if isinstance(v, dict):
            return {x: _json(y) for x, y in v.items()}
        if isinstance(v, JsonStruct):
            return v.json()
        if isinstance(v, enum.IntFlag):
            return [option.name for option in v.__class__ if v &amp; option == option]
        if isinstance(v, enum.IntEnum):
            return v.name
        if isinstance(v, memoryview):
            return codecs.decode(v, &#39;latin1&#39;)
        return v
    return {
        k: _json(v) for k, v in self.__dict__.items()
        if not k.startswith(&#39;_&#39;)
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.InnoStruct"><code class="flex name class">
<span>class <span class="ident">InnoStruct</span></span>
<span>(</span><span>reader, version, codec='latin1')</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L319-L332" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoStruct(JsonStruct):
    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, codec: str = &#39;latin1&#39;):
        if version.unicode:
            self._read_string = functools.partial(
                reader.read_length_prefixed_utf16, bytecount=True)
        else:
            def _read():
                data = reader.read_length_prefixed()
                try:
                    return codecs.decode(data, codec)
                except (LookupError, UnicodeDecodeError):
                    # TODO
                    return codecs.decode(data, &#39;latin1&#39;)
            self._read_string = _read</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.SetupComponent" href="#refinery.lib.inno.archive.SetupComponent">SetupComponent</a></li>
<li><a title="refinery.lib.inno.archive.SetupCondition" href="#refinery.lib.inno.archive.SetupCondition">SetupCondition</a></li>
<li><a title="refinery.lib.inno.archive.SetupDataEntry" href="#refinery.lib.inno.archive.SetupDataEntry">SetupDataEntry</a></li>
<li><a title="refinery.lib.inno.archive.SetupDeleteEntry" href="#refinery.lib.inno.archive.SetupDeleteEntry">SetupDeleteEntry</a></li>
<li><a title="refinery.lib.inno.archive.SetupDirectory" href="#refinery.lib.inno.archive.SetupDirectory">SetupDirectory</a></li>
<li><a title="refinery.lib.inno.archive.SetupFile" href="#refinery.lib.inno.archive.SetupFile">SetupFile</a></li>
<li><a title="refinery.lib.inno.archive.SetupHeader" href="#refinery.lib.inno.archive.SetupHeader">SetupHeader</a></li>
<li><a title="refinery.lib.inno.archive.SetupIcon" href="#refinery.lib.inno.archive.SetupIcon">SetupIcon</a></li>
<li><a title="refinery.lib.inno.archive.SetupIniEntry" href="#refinery.lib.inno.archive.SetupIniEntry">SetupIniEntry</a></li>
<li><a title="refinery.lib.inno.archive.SetupLanguage" href="#refinery.lib.inno.archive.SetupLanguage">SetupLanguage</a></li>
<li><a title="refinery.lib.inno.archive.SetupMessage" href="#refinery.lib.inno.archive.SetupMessage">SetupMessage</a></li>
<li><a title="refinery.lib.inno.archive.SetupPermission" href="#refinery.lib.inno.archive.SetupPermission">SetupPermission</a></li>
<li><a title="refinery.lib.inno.archive.SetupRegistryEntry" href="#refinery.lib.inno.archive.SetupRegistryEntry">SetupRegistryEntry</a></li>
<li><a title="refinery.lib.inno.archive.SetupRunEntry" href="#refinery.lib.inno.archive.SetupRunEntry">SetupRunEntry</a></li>
<li><a title="refinery.lib.inno.archive.SetupTask" href="#refinery.lib.inno.archive.SetupTask">SetupTask</a></li>
<li><a title="refinery.lib.inno.archive.SetupType" href="#refinery.lib.inno.archive.SetupType">SetupType</a></li>
<li><a title="refinery.lib.inno.archive.StreamHeader" href="#refinery.lib.inno.archive.StreamHeader">StreamHeader</a></li>
<li><a title="refinery.lib.inno.archive.TData" href="#refinery.lib.inno.archive.TData">TData</a></li>
<li><a title="refinery.lib.inno.archive.TSetup" href="#refinery.lib.inno.archive.TSetup">TSetup</a></li>
<li><a title="refinery.lib.inno.archive.Version" href="#refinery.lib.inno.archive.Version">Version</a></li>
<li><a title="refinery.lib.inno.archive.WinVerRange" href="#refinery.lib.inno.archive.WinVerRange">WinVerRange</a></li>
<li><a title="refinery.lib.inno.archive.WindowsVersion" href="#refinery.lib.inno.archive.WindowsVersion">WindowsVersion</a></li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.CheckSumType"><code class="flex name class">
<span>class <span class="ident">CheckSumType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L335-L344" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CheckSumType(enum.IntEnum):
    Missing = 0 # noqa
    Adler32 = 1 # noqa
    CRC32   = 2 # noqa
    MD5     = 3 # noqa
    SHA1    = 4 # noqa
    SHA256  = 5 # noqa

    def strong(self):
        return self.value &gt;= 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.CheckSumType.Missing"><code class="name">var <span class="ident">Missing</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.CheckSumType.Adler32"><code class="name">var <span class="ident">Adler32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.CheckSumType.CRC32"><code class="name">var <span class="ident">CRC32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.CheckSumType.MD5"><code class="name">var <span class="ident">MD5</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.CheckSumType.SHA1"><code class="name">var <span class="ident">SHA1</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.CheckSumType.SHA256"><code class="name">var <span class="ident">SHA256</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.CheckSumType.strong"><code class="name flex">
<span>def <span class="ident">strong</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L343-L344" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def strong(self):
    return self.value &gt;= 3</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.Flags"><code class="flex name class">
<span>class <span class="ident">Flags</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L347-L413" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Flags(enum.IntFlag):
    Empty                       = 0           # noqa
    DisableStartupPrompt        = enum.auto() # noqa
    Uninstallable               = enum.auto() # noqa
    CreateAppDir                = enum.auto() # noqa
    DisableDirPage              = enum.auto() # noqa
    DisableDirExistsWarning     = enum.auto() # noqa
    DisableProgramGroupPage     = enum.auto() # noqa
    AllowNoIcons                = enum.auto() # noqa
    AlwaysRestart               = enum.auto() # noqa
    BackSolid                   = enum.auto() # noqa
    AlwaysUsePersonalGroup      = enum.auto() # noqa
    WindowVisible               = enum.auto() # noqa
    WindowShowCaption           = enum.auto() # noqa
    WindowResizable             = enum.auto() # noqa
    WindowStartMaximized        = enum.auto() # noqa
    EnableDirDoesntExistWarning = enum.auto() # noqa
    DisableAppendDir            = enum.auto() # noqa
    Password                    = enum.auto() # noqa
    AllowRootDirectory          = enum.auto() # noqa
    DisableFinishedPage         = enum.auto() # noqa
    AdminPrivilegesRequired     = enum.auto() # noqa
    AlwaysCreateUninstallIcon   = enum.auto() # noqa
    OverwriteUninstRegEntries   = enum.auto() # noqa
    ChangesAssociations         = enum.auto() # noqa
    CreateUninstallRegKey       = enum.auto() # noqa
    UsePreviousAppDir           = enum.auto() # noqa
    BackColorHorizontal         = enum.auto() # noqa
    UsePreviousGroup            = enum.auto() # noqa
    UpdateUninstallLogAppName   = enum.auto() # noqa
    UsePreviousSetupType        = enum.auto() # noqa
    DisableReadyMemo            = enum.auto() # noqa
    AlwaysShowComponentsList    = enum.auto() # noqa
    FlatComponentsList          = enum.auto() # noqa
    ShowComponentSizes          = enum.auto() # noqa
    UsePreviousTasks            = enum.auto() # noqa
    DisableReadyPage            = enum.auto() # noqa
    AlwaysShowDirOnReadyPage    = enum.auto() # noqa
    AlwaysShowGroupOnReadyPage  = enum.auto() # noqa
    BzipUsed                    = enum.auto() # noqa
    AllowUNCPath                = enum.auto() # noqa
    UserInfoPage                = enum.auto() # noqa
    UsePreviousUserInfo         = enum.auto() # noqa
    UninstallRestartComputer    = enum.auto() # noqa
    RestartIfNeededByRun        = enum.auto() # noqa
    ShowTasksTreeLines          = enum.auto() # noqa
    ShowLanguageDialog          = enum.auto() # noqa
    DetectLanguageUsingLocale   = enum.auto() # noqa
    AllowCancelDuringInstall    = enum.auto() # noqa
    WizardImageStretch          = enum.auto() # noqa
    AppendDefaultDirName        = enum.auto() # noqa
    AppendDefaultGroupName      = enum.auto() # noqa
    EncryptionUsed              = enum.auto() # noqa
    ChangesEnvironment          = enum.auto() # noqa
    ShowUndisplayableLanguages  = enum.auto() # noqa
    SetupLogging                = enum.auto() # noqa
    SignedUninstaller           = enum.auto() # noqa
    UsePreviousLanguage         = enum.auto() # noqa
    DisableWelcomePage          = enum.auto() # noqa
    CloseApplications           = enum.auto() # noqa
    RestartApplications         = enum.auto() # noqa
    AllowNetworkDrive           = enum.auto() # noqa
    ForceCloseApplications      = enum.auto() # noqa
    AppNameHasConsts            = enum.auto() # noqa
    UsePreviousPrivileges       = enum.auto() # noqa
    WizardResizable             = enum.auto() # noqa
    UninstallLogging            = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.Flags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.DisableStartupPrompt"><code class="name">var <span class="ident">DisableStartupPrompt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.Uninstallable"><code class="name">var <span class="ident">Uninstallable</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.CreateAppDir"><code class="name">var <span class="ident">CreateAppDir</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.DisableDirPage"><code class="name">var <span class="ident">DisableDirPage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.DisableDirExistsWarning"><code class="name">var <span class="ident">DisableDirExistsWarning</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.DisableProgramGroupPage"><code class="name">var <span class="ident">DisableProgramGroupPage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AllowNoIcons"><code class="name">var <span class="ident">AllowNoIcons</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AlwaysRestart"><code class="name">var <span class="ident">AlwaysRestart</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.BackSolid"><code class="name">var <span class="ident">BackSolid</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AlwaysUsePersonalGroup"><code class="name">var <span class="ident">AlwaysUsePersonalGroup</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.WindowVisible"><code class="name">var <span class="ident">WindowVisible</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.WindowShowCaption"><code class="name">var <span class="ident">WindowShowCaption</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.WindowResizable"><code class="name">var <span class="ident">WindowResizable</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.WindowStartMaximized"><code class="name">var <span class="ident">WindowStartMaximized</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.EnableDirDoesntExistWarning"><code class="name">var <span class="ident">EnableDirDoesntExistWarning</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.DisableAppendDir"><code class="name">var <span class="ident">DisableAppendDir</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.Password"><code class="name">var <span class="ident">Password</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AllowRootDirectory"><code class="name">var <span class="ident">AllowRootDirectory</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.DisableFinishedPage"><code class="name">var <span class="ident">DisableFinishedPage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AdminPrivilegesRequired"><code class="name">var <span class="ident">AdminPrivilegesRequired</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AlwaysCreateUninstallIcon"><code class="name">var <span class="ident">AlwaysCreateUninstallIcon</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.OverwriteUninstRegEntries"><code class="name">var <span class="ident">OverwriteUninstRegEntries</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.ChangesAssociations"><code class="name">var <span class="ident">ChangesAssociations</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.CreateUninstallRegKey"><code class="name">var <span class="ident">CreateUninstallRegKey</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.UsePreviousAppDir"><code class="name">var <span class="ident">UsePreviousAppDir</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.BackColorHorizontal"><code class="name">var <span class="ident">BackColorHorizontal</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.UsePreviousGroup"><code class="name">var <span class="ident">UsePreviousGroup</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.UpdateUninstallLogAppName"><code class="name">var <span class="ident">UpdateUninstallLogAppName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.UsePreviousSetupType"><code class="name">var <span class="ident">UsePreviousSetupType</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.DisableReadyMemo"><code class="name">var <span class="ident">DisableReadyMemo</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AlwaysShowComponentsList"><code class="name">var <span class="ident">AlwaysShowComponentsList</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.FlatComponentsList"><code class="name">var <span class="ident">FlatComponentsList</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.ShowComponentSizes"><code class="name">var <span class="ident">ShowComponentSizes</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.UsePreviousTasks"><code class="name">var <span class="ident">UsePreviousTasks</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.DisableReadyPage"><code class="name">var <span class="ident">DisableReadyPage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AlwaysShowDirOnReadyPage"><code class="name">var <span class="ident">AlwaysShowDirOnReadyPage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AlwaysShowGroupOnReadyPage"><code class="name">var <span class="ident">AlwaysShowGroupOnReadyPage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.BzipUsed"><code class="name">var <span class="ident">BzipUsed</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AllowUNCPath"><code class="name">var <span class="ident">AllowUNCPath</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.UserInfoPage"><code class="name">var <span class="ident">UserInfoPage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.UsePreviousUserInfo"><code class="name">var <span class="ident">UsePreviousUserInfo</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.UninstallRestartComputer"><code class="name">var <span class="ident">UninstallRestartComputer</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.RestartIfNeededByRun"><code class="name">var <span class="ident">RestartIfNeededByRun</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.ShowTasksTreeLines"><code class="name">var <span class="ident">ShowTasksTreeLines</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.ShowLanguageDialog"><code class="name">var <span class="ident">ShowLanguageDialog</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.DetectLanguageUsingLocale"><code class="name">var <span class="ident">DetectLanguageUsingLocale</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AllowCancelDuringInstall"><code class="name">var <span class="ident">AllowCancelDuringInstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.WizardImageStretch"><code class="name">var <span class="ident">WizardImageStretch</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AppendDefaultDirName"><code class="name">var <span class="ident">AppendDefaultDirName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AppendDefaultGroupName"><code class="name">var <span class="ident">AppendDefaultGroupName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.EncryptionUsed"><code class="name">var <span class="ident">EncryptionUsed</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.ChangesEnvironment"><code class="name">var <span class="ident">ChangesEnvironment</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.ShowUndisplayableLanguages"><code class="name">var <span class="ident">ShowUndisplayableLanguages</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.SetupLogging"><code class="name">var <span class="ident">SetupLogging</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.SignedUninstaller"><code class="name">var <span class="ident">SignedUninstaller</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.UsePreviousLanguage"><code class="name">var <span class="ident">UsePreviousLanguage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.DisableWelcomePage"><code class="name">var <span class="ident">DisableWelcomePage</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.CloseApplications"><code class="name">var <span class="ident">CloseApplications</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.RestartApplications"><code class="name">var <span class="ident">RestartApplications</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AllowNetworkDrive"><code class="name">var <span class="ident">AllowNetworkDrive</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.ForceCloseApplications"><code class="name">var <span class="ident">ForceCloseApplications</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.AppNameHasConsts"><code class="name">var <span class="ident">AppNameHasConsts</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.UsePreviousPrivileges"><code class="name">var <span class="ident">UsePreviousPrivileges</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.WizardResizable"><code class="name">var <span class="ident">WizardResizable</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Flags.UninstallLogging"><code class="name">var <span class="ident">UninstallLogging</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.AutoBool"><code class="flex name class">
<span>class <span class="ident">AutoBool</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L416-L423" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class AutoBool(enum.IntEnum):
    Auto = 0
    No = 1
    Yes = 2

    @classmethod
    def From(cls, b: bool):
        return AutoBool.Yes if b else AutoBool.No</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.AutoBool.Auto"><code class="name">var <span class="ident">Auto</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.AutoBool.No"><code class="name">var <span class="ident">No</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.AutoBool.Yes"><code class="name">var <span class="ident">Yes</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.AutoBool.From"><code class="name flex">
<span>def <span class="ident">From</span></span>(<span>b)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.WizardStyle"><code class="flex name class">
<span>class <span class="ident">WizardStyle</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L426-L428" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class WizardStyle(enum.IntEnum):
    Classic = 0
    Modern = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.WizardStyle.Classic"><code class="name">var <span class="ident">Classic</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.WizardStyle.Modern"><code class="name">var <span class="ident">Modern</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.StoredAlphaFormat"><code class="flex name class">
<span>class <span class="ident">StoredAlphaFormat</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L431-L434" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StoredAlphaFormat(enum.IntEnum):
    AlphaIgnored = 0
    AlphaDefined = 1
    AlphaPremultiplied = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.StoredAlphaFormat.AlphaIgnored"><code class="name">var <span class="ident">AlphaIgnored</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.StoredAlphaFormat.AlphaDefined"><code class="name">var <span class="ident">AlphaDefined</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.StoredAlphaFormat.AlphaPremultiplied"><code class="name">var <span class="ident">AlphaPremultiplied</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.UninstallLogMode"><code class="flex name class">
<span>class <span class="ident">UninstallLogMode</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L437-L440" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class UninstallLogMode(enum.IntEnum):
    Append = 0
    New = 1
    Overwrite = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.UninstallLogMode.Append"><code class="name">var <span class="ident">Append</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.UninstallLogMode.New"><code class="name">var <span class="ident">New</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.UninstallLogMode.Overwrite"><code class="name">var <span class="ident">Overwrite</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupStyle"><code class="flex name class">
<span>class <span class="ident">SetupStyle</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L443-L445" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupStyle(enum.IntEnum):
    Classic = 0
    Modern = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupStyle.Classic"><code class="name">var <span class="ident">Classic</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupStyle.Modern"><code class="name">var <span class="ident">Modern</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.PrivilegesRequired"><code class="flex name class">
<span>class <span class="ident">PrivilegesRequired</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L448-L452" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PrivilegesRequired(enum.IntEnum):
    Nothing = 0
    PowerUser = 1
    Admin = 2
    Lowest = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.PrivilegesRequired.Nothing"><code class="name">var <span class="ident">Nothing</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.PrivilegesRequired.PowerUser"><code class="name">var <span class="ident">PowerUser</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.PrivilegesRequired.Admin"><code class="name">var <span class="ident">Admin</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.PrivilegesRequired.Lowest"><code class="name">var <span class="ident">Lowest</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.PrivilegesRequiredOverrideAllowed"><code class="flex name class">
<span>class <span class="ident">PrivilegesRequiredOverrideAllowed</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L455-L458" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PrivilegesRequiredOverrideAllowed(enum.IntFlag):
    Empty = 0
    CommandLine = 1
    Dialog = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.PrivilegesRequiredOverrideAllowed.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.PrivilegesRequiredOverrideAllowed.CommandLine"><code class="name">var <span class="ident">CommandLine</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.PrivilegesRequiredOverrideAllowed.Dialog"><code class="name">var <span class="ident">Dialog</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.LanguageDetection"><code class="flex name class">
<span>class <span class="ident">LanguageDetection</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L461-L464" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LanguageDetection(enum.IntEnum):
    UI = 0
    Locale = 1
    Nothing = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.LanguageDetection.UI"><code class="name">var <span class="ident">UI</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.LanguageDetection.Locale"><code class="name">var <span class="ident">Locale</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.LanguageDetection.Nothing"><code class="name">var <span class="ident">Nothing</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.CompressionMethod"><code class="flex name class">
<span>class <span class="ident">CompressionMethod</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L467-L488" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CompressionMethod(enum.IntEnum):
    Store = 0
    Flate = 1
    BZip2 = 2
    LZMA1 = 3
    LZMA2 = 4

    def legacy_check(self, max: int, ver: str):
        if self.value &gt; max:
            raise ValueError(F&#39;Compression method {self.value} cannot be represented before version {ver}.&#39;)
        return self

    def legacy_conversion_pre_4_2_5(self):
        return self.legacy_check(2, &#39;4.2.5&#39;).__class__(self.value + 1)

    def legacy_conversion_pre_4_2_6(self):
        if self == CompressionMethod.Store:
            return self
        return self.legacy_check(2, &#39;4.2.6&#39;).__class__(self.value + 1)

    def legacy_conversion_pre_5_3_9(self):
        return self.legacy_check(3, &#39;5.3.9&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.CompressionMethod.Store"><code class="name">var <span class="ident">Store</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.CompressionMethod.Flate"><code class="name">var <span class="ident">Flate</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.CompressionMethod.BZip2"><code class="name">var <span class="ident">BZip2</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.CompressionMethod.LZMA1"><code class="name">var <span class="ident">LZMA1</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.CompressionMethod.LZMA2"><code class="name">var <span class="ident">LZMA2</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.CompressionMethod.legacy_check"><code class="name flex">
<span>def <span class="ident">legacy_check</span></span>(<span>self, max, ver)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L474-L477" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def legacy_check(self, max: int, ver: str):
    if self.value &gt; max:
        raise ValueError(F&#39;Compression method {self.value} cannot be represented before version {ver}.&#39;)
    return self</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.CompressionMethod.legacy_conversion_pre_4_2_5"><code class="name flex">
<span>def <span class="ident">legacy_conversion_pre_4_2_5</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L479-L480" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def legacy_conversion_pre_4_2_5(self):
    return self.legacy_check(2, &#39;4.2.5&#39;).__class__(self.value + 1)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.CompressionMethod.legacy_conversion_pre_4_2_6"><code class="name flex">
<span>def <span class="ident">legacy_conversion_pre_4_2_6</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L482-L485" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def legacy_conversion_pre_4_2_6(self):
    if self == CompressionMethod.Store:
        return self
    return self.legacy_check(2, &#39;4.2.6&#39;).__class__(self.value + 1)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.CompressionMethod.legacy_conversion_pre_5_3_9"><code class="name flex">
<span>def <span class="ident">legacy_conversion_pre_5_3_9</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L487-L488" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def legacy_conversion_pre_5_3_9(self):
    return self.legacy_check(3, &#39;5.3.9&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.Architecture"><code class="flex name class">
<span>class <span class="ident">Architecture</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L491-L497" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Architecture(enum.IntFlag):
    Unknown = 0b00000 # noqa
    X86     = 0b00001 # noqa
    AMD64   = 0b00010 # noqa
    IA64    = 0b00100 # noqa
    ARM64   = 0b01000 # noqa
    All     = 0b01111 # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.Architecture.Unknown"><code class="name">var <span class="ident">Unknown</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Architecture.X86"><code class="name">var <span class="ident">X86</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Architecture.AMD64"><code class="name">var <span class="ident">AMD64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Architecture.IA64"><code class="name">var <span class="ident">IA64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Architecture.ARM64"><code class="name">var <span class="ident">ARM64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.Architecture.All"><code class="name">var <span class="ident">All</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.PasswordType"><code class="flex name class">
<span>class <span class="ident">PasswordType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L500-L505" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PasswordType(enum.IntEnum):
    CRC32     = 0           # noqa
    Nothing   = 0           # noqa
    MD5       = enum.auto() # noqa
    SHA1      = enum.auto() # noqa
    XChaCha20 = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.PasswordType.CRC32"><code class="name">var <span class="ident">CRC32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.PasswordType.Nothing"><code class="name">var <span class="ident">Nothing</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.PasswordType.MD5"><code class="name">var <span class="ident">MD5</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.PasswordType.SHA1"><code class="name">var <span class="ident">SHA1</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.PasswordType.XChaCha20"><code class="name">var <span class="ident">XChaCha20</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupTypeEnum"><code class="flex name class">
<span>class <span class="ident">SetupTypeEnum</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L508-L512" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupTypeEnum(enum.IntEnum):
    User = 0
    DefaultFull = 1
    DefaultCompact = 2
    DefaultCustom = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupTypeEnum.User"><code class="name">var <span class="ident">User</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupTypeEnum.DefaultFull"><code class="name">var <span class="ident">DefaultFull</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupTypeEnum.DefaultCompact"><code class="name">var <span class="ident">DefaultCompact</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupTypeEnum.DefaultCustom"><code class="name">var <span class="ident">DefaultCustom</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupFlags"><code class="flex name class">
<span>class <span class="ident">SetupFlags</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L515-L520" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupFlags(enum.IntFlag):
    Fixed                     = 0b00001 # noqa
    Restart                   = 0b00010 # noqa
    DisableNoUninstallWarning = 0b00100 # noqa
    Exclusive                 = 0b01000 # noqa
    DontInheritCheck          = 0b10000 # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupFlags.Fixed"><code class="name">var <span class="ident">Fixed</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFlags.Restart"><code class="name">var <span class="ident">Restart</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFlags.DisableNoUninstallWarning"><code class="name">var <span class="ident">DisableNoUninstallWarning</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFlags.Exclusive"><code class="name">var <span class="ident">Exclusive</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFlags.DontInheritCheck"><code class="name">var <span class="ident">DontInheritCheck</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.StreamCompressionMethod"><code class="flex name class">
<span>class <span class="ident">StreamCompressionMethod</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L523-L526" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StreamCompressionMethod(enum.IntEnum):
    Store = 0
    Flate = 1
    LZMA1 = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.StreamCompressionMethod.Store"><code class="name">var <span class="ident">Store</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.StreamCompressionMethod.Flate"><code class="name">var <span class="ident">Flate</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.StreamCompressionMethod.LZMA1"><code class="name">var <span class="ident">LZMA1</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.StreamHeader"><code class="flex name class">
<span>class <span class="ident">StreamHeader</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L529-L553" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StreamHeader(InnoStruct):
    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.HeaderCrc = reader.u32()
        self.CompressedSize = size = reader.u32()
        if version &gt;= (4, 0, 9):
            self.StoredSize = self.CompressedSize
            if not reader.u8():
                self.Compression = StreamCompressionMethod.Store
            elif version &gt;= (4, 1, 6):
                self.Compression = StreamCompressionMethod.LZMA1
            else:
                self.Compression = StreamCompressionMethod.Flate
        else:
            self.UncompresedSize = reader.u32()
            if size == 0xFFFFFFFF:
                self.StoredSize = self.UncompresedSize
                self.Compression = StreamCompressionMethod.Store
            else:
                self.StoredSize = size
                self.Compression = StreamCompressionMethod.Flate
            # Add the size of a CRC32 checksum for each 4KiB subblock
            block_count, _r = divmod(self.StoredSize, 4096)
            block_count += int(bool(_r))
            self.StoredSize += 4 * block_count</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.CrcCompressedBlock"><code class="flex name class">
<span>class <span class="ident">CrcCompressedBlock</span></span>
<span>(</span><span>reader, size)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L556-L559" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CrcCompressedBlock(JsonStruct):
    def __init__(self, reader: StructReader[memoryview], size: int):
        self.BlockCrc = reader.u32()
        self.BlockData = reader.read(size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.TSetupOffsets"><code class="flex name class">
<span>class <span class="ident">TSetupOffsets</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L573-L643" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TSetupOffsets(Struct):
    def __init__(self, reader: StructReader[memoryview]):
        start = reader.tell()
        check = reader.peek()

        self.id = bytes(reader.read(12))
        self.iv = iv = TSetupMagicToVersion.get(self.id)

        if iv is None:
            iv = _VERSIONS[-1]

        self.revision = reader.u32() if iv &gt;= (5, 1, 5) else None
        self.total_size = reader.u32()

        self.exe_offset = reader.u32()
        self.exe_compressed_size = None if iv &gt;= (4, 1, 6) else reader.u32()
        self.exe_uncompressed_size = reader.u32()

        if iv &gt;= (4, 0, 3):
            self.exe_checksum_type = CheckSumType.CRC32
        else:
            self.exe_checksum_type = CheckSumType.Adler32
        self.exe_checksum = reader.u32()

        self.messages = reader.u32() if iv &lt; (4, 0, 0) else None
        self.info_abs_offset = reader.u32()
        self.data_abs_offset = reader.u32()

        check = check[:reader.tell() - start]
        self.computed_checksum = zlib.crc32(check)
        self.expected_checksum = reader.u32() if (
            iv &gt;= (4, 0, 10)
        ) else self.computed_checksum

        self.base = min(
            self.exe_offset,
            self.info_abs_offset,
            self.data_abs_offset,
        )

        self.info_offset = self.info_abs_offset - self.base
        self.data_offset = self.data_abs_offset - self.base

    def Checked(self):
        if (_c := self.computed_checksum) != (_e := self.expected_checksum):
            raise ValueError(F&#39;Invalid checksum; computed {_c:08X}, header value is {_e:08X}.&#39;)
        if self.exe_uncompressed_size &lt; 0x100:
            raise ValueError(R&#39;The EXE uncompressed size value is too low.&#39;)
        if self.info_offset &lt; self.data_offset:
            raise ValueError(R&#39;TData offset is beyond TSetup offset.&#39;)
        return self

    @classmethod
    def Try(Cls, view: memoryview):
        try:
            return Cls(view).Checked()
        except ValueError:
            return None

    @classmethod
    def FindInBinary(Cls, data):
        issd = B&#39;Inno Setup Setup Data&#39;
        view = memoryview(data)
        if len(view) &lt; 0x1000:
            return None
        for magic in TSetupMagicToVersion:
            for match in re.finditer(re.escape(magic), view):
                if self := Cls.Try(view[match.start():]):
                    ip = self.base + self.info_offset
                    if view[ip:][:len(issd)] == issd:
                        return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.TSetupOffsets.Try"><code class="name flex">
<span>def <span class="ident">Try</span></span>(<span>view)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.TSetupOffsets.FindInBinary"><code class="name flex">
<span>def <span class="ident">FindInBinary</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.TSetupOffsets.Checked"><code class="name flex">
<span>def <span class="ident">Checked</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L616-L623" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def Checked(self):
    if (_c := self.computed_checksum) != (_e := self.expected_checksum):
        raise ValueError(F&#39;Invalid checksum; computed {_c:08X}, header value is {_e:08X}.&#39;)
    if self.exe_uncompressed_size &lt; 0x100:
        raise ValueError(R&#39;The EXE uncompressed size value is too low.&#39;)
    if self.info_offset &lt; self.data_offset:
        raise ValueError(R&#39;TData offset is beyond TSetup offset.&#39;)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile"><code class="flex name class">
<span>class <span class="ident">InnoFile</span></span>
<span>(</span><span>reader, version, meta, path='', dupe=False, setup=None, compression_method=None, password_hash=b'', password_salt=b'', password_type=0)</span>
</code></dt>
<dd>
<section class="desc"><p>InnoFile(reader: 'StructReader[buf]', version: 'InnoVersion', meta: 'SetupDataEntry', path: 'str' = '', dupe: 'bool' = False, setup: 'SetupFile | None' = None, compression_method: 'CompressionMethod | None' = None, password_hash: 'bytes' = b'', password_salt: 'bytes' = b'', password_type: 'PasswordType' = <PasswordType.CRC32: 0>)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L646-L726" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclasses.dataclass
class InnoFile:
    reader: StructReader[buf]
    version: InnoVersion
    meta: SetupDataEntry
    path: str = &#34;&#34;
    dupe: bool = False
    setup: SetupFile | None = None
    compression_method: CompressionMethod | None = None
    password_hash: bytes = B&#39;&#39;
    password_salt: bytes = B&#39;&#39;
    password_type: PasswordType = PasswordType.Nothing

    @property
    def tags(self):
        if s := self.setup:
            return s.Flags
        else:
            return SetupFileFlags.Empty

    @property
    def unicode(self):
        return self.version.unicode

    @property
    def compression(self):
        if self.meta.Flags &amp; SetupDataEntryFlags.ChunkCompressed:
            return self.compression_method
        return CompressionMethod.Store

    @property
    def offset(self):
        return self.meta.Offset

    @property
    def size(self):
        return self.meta.FileSize

    @property
    def date(self):
        return self.meta.FileTime

    @property
    def chunk_offset(self):
        return self.meta.ChunkOffset

    @property
    def chunk_length(self):
        return self.meta.ChunkSize

    @property
    def checksum(self):
        return self.meta.Checksum

    @property
    def checksum_type(self):
        return self.meta.ChecksumType

    @property
    def encrypted(self):
        return bool(self.meta.Flags &amp; SetupDataEntryFlags.ChunkEncrypted)

    @property
    def filtered(self):
        return bool(self.meta.Flags &amp; SetupDataEntryFlags.CallInstructionOptimized)

    def check(self, data: buf):
        t = self.checksum_type
        if t == CheckSumType.Missing:
            return None
        if t == CheckSumType.Adler32:
            return zlib.adler32(data) &amp; 0xFFFFFFFF
        if t == CheckSumType.CRC32:
            return zlib.crc32(data) &amp; 0xFFFFFFFF
        if t == CheckSumType.MD5:
            return md5(data).digest()
        if t == CheckSumType.SHA1:
            return sha1(data).digest()
        if t == CheckSumType.SHA256:
            return sha256(data).digest()
        raise ValueError(F&#39;Unknown checksum type: {t!r}&#39;)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.InnoFile.reader"><code class="name">var <span class="ident">reader</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.meta"><code class="name">var <span class="ident">meta</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.dupe"><code class="name">var <span class="ident">dupe</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.setup"><code class="name">var <span class="ident">setup</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.compression_method"><code class="name">var <span class="ident">compression_method</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.password_hash"><code class="name">var <span class="ident">password_hash</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.password_salt"><code class="name">var <span class="ident">password_salt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.password_type"><code class="name">var <span class="ident">password_type</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.tags"><code class="name">var <span class="ident">tags</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L659-L664" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def tags(self):
    if s := self.setup:
        return s.Flags
    else:
        return SetupFileFlags.Empty</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.unicode"><code class="name">var <span class="ident">unicode</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L666-L668" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def unicode(self):
    return self.version.unicode</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.compression"><code class="name">var <span class="ident">compression</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L670-L674" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def compression(self):
    if self.meta.Flags &amp; SetupDataEntryFlags.ChunkCompressed:
        return self.compression_method
    return CompressionMethod.Store</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.offset"><code class="name">var <span class="ident">offset</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L676-L678" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def offset(self):
    return self.meta.Offset</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L680-L682" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def size(self):
    return self.meta.FileSize</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.date"><code class="name">var <span class="ident">date</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L684-L686" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def date(self):
    return self.meta.FileTime</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.chunk_offset"><code class="name">var <span class="ident">chunk_offset</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L688-L690" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def chunk_offset(self):
    return self.meta.ChunkOffset</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.chunk_length"><code class="name">var <span class="ident">chunk_length</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L692-L694" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def chunk_length(self):
    return self.meta.ChunkSize</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.checksum"><code class="name">var <span class="ident">checksum</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L696-L698" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def checksum(self):
    return self.meta.Checksum</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.checksum_type"><code class="name">var <span class="ident">checksum_type</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L700-L702" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def checksum_type(self):
    return self.meta.ChecksumType</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.encrypted"><code class="name">var <span class="ident">encrypted</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L704-L706" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def encrypted(self):
    return bool(self.meta.Flags &amp; SetupDataEntryFlags.ChunkEncrypted)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoFile.filtered"><code class="name">var <span class="ident">filtered</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L708-L710" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def filtered(self):
    return bool(self.meta.Flags &amp; SetupDataEntryFlags.CallInstructionOptimized)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.InnoFile.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L712-L726" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check(self, data: buf):
    t = self.checksum_type
    if t == CheckSumType.Missing:
        return None
    if t == CheckSumType.Adler32:
        return zlib.adler32(data) &amp; 0xFFFFFFFF
    if t == CheckSumType.CRC32:
        return zlib.crc32(data) &amp; 0xFFFFFFFF
    if t == CheckSumType.MD5:
        return md5(data).digest()
    if t == CheckSumType.SHA1:
        return sha1(data).digest()
    if t == CheckSumType.SHA256:
        return sha256(data).digest()
    raise ValueError(F&#39;Unknown checksum type: {t!r}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.InnoStream"><code class="flex name class">
<span>class <span class="ident">InnoStream</span></span>
<span>(</span><span>header, blocks=&lt;factory&gt;, data=None)</span>
</code></dt>
<dd>
<section class="desc"><p>InnoStream(header: 'StreamHeader', blocks: 'list[CrcCompressedBlock]' = <factory>, data: 'bytearray | None' = None)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L729-L737" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclasses.dataclass
class InnoStream:
    header: StreamHeader
    blocks: list[CrcCompressedBlock] = dataclasses.field(default_factory=list)
    data: bytearray | None = None

    @property
    def compression(self):
        return self.header.Compression</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.InnoStream.header"><code class="name">var <span class="ident">header</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoStream.blocks"><code class="name">var <span class="ident">blocks</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoStream.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoStream.compression"><code class="name">var <span class="ident">compression</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L735-L737" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def compression(self):
    return self.header.Compression</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.InstallMode"><code class="flex name class">
<span>class <span class="ident">InstallMode</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L740-L743" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InstallMode(enum.IntEnum):
    Normal     = 0           # noqa
    Silent     = enum.auto() # noqa
    VerySilent = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.InstallMode.Normal"><code class="name">var <span class="ident">Normal</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InstallMode.Silent"><code class="name">var <span class="ident">Silent</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InstallMode.VerySilent"><code class="name">var <span class="ident">VerySilent</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupHeader"><code class="flex name class">
<span>class <span class="ident">SetupHeader</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L746-L1199" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupHeader(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)

        def read_string():
            return reader.read_length_prefixed()

        if version &lt; (1, 3, 0):
            # skip uncompressed size
            reader.u32()

        if True:
            self.AppName = read_string()
            self.AppVersionedName = read_string()
        if version &gt;= (1, 3, 0):
            self.AppId = read_string()
        if True:
            self.AppCopyright = read_string()
        if version &gt;= (1, 3, 0):
            self.AppPublisher = read_string()
            self.AppPublisherUrl = read_string()
        if version &gt;= (5, 1, 13):
            self.AppSupportPhone = read_string()
        if version &gt;= (1, 3, 0):
            self.AppSupportUrl = read_string()
            self.AppUpdatesUrl = read_string()
            self.AppVersion = read_string()
        if True:
            self.DefaultDirName = read_string()
            self.DefaultGroupName = read_string()
        if version &lt; (3, 0, 0):
            self.UninstallIconName = reader.read_length_prefixed(encoding=&#39;cp1252&#39;)
        if True:
            self.BaseFilename = read_string()
        if (1, 3, 0) &lt;= version &lt; (5, 2, 5):
            self._license = reader.read_length_prefixed_ascii()
            self.InfoHead = reader.read_length_prefixed_ascii()
            self.InfoTail = reader.read_length_prefixed_ascii()
        if version &gt;= (1, 3, 3):
            self.UninstallFilesDir = read_string()
        if version &gt;= (1, 3, 6):
            self.UninstallName = read_string()
            self.UninstallIcon = read_string()
        if version &gt;= (1, 3, 14):
            self.AppMutex = read_string()
        if version &gt;= (3, 0, 0):
            self.DefaultUsername = read_string()
            self.DefaultOrganisation = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 6, 1):
            self.DefaultSerial = read_string()
        if (4, 0, 0) &lt;= version &lt; (5, 2, 5) or version.isx and version &gt;= (1, 3, 24):
            self._CompiledCode = read_string()
        if version &gt;= (4, 2, 4):
            self.AppReadmeFile = read_string()
            self.AppContact = read_string()
            self.AppComment = read_string()
            self.AppModifyPath = read_string()
        if version &gt;= (5, 3, 8):
            self.CreateUninstallRegistryKey = read_string()
        if version &gt;= (5, 3, 10):
            self.Uninstallable = read_string()
        else:
            self.Uninstallable = B&#39;&#39;
        if version &gt;= (5, 5, 0):
            self.CloseApplicationsFilter = read_string()
        if version &gt;= (5, 5, 6):
            self.SetupMutex = read_string()
        if version &gt;= (5, 6, 1):
            self.ChangesEnvironment = read_string()
            self.ChangesAssociations = read_string()
        if version &gt;= (6, 3, 0):
            self.ArchitecturesAllowed32 = read_string()
            self.ArchitecturesAllowed64 = read_string()
        if version &gt;= (6, 4, 2):
            self.CloseApplicationsFilterExcludes = read_string()
        if version &gt;= (5, 2, 5):
            self._license = reader.read_length_prefixed_ascii()
            self.InfoHead = reader.read_length_prefixed_ascii()
            self.InfoTail = reader.read_length_prefixed_ascii()
        if version &gt;= (5, 2, 1) and version &lt; (5, 3, 10):
            self.UninstallerSignature = read_string()
        if version &gt;= (5, 2, 5):
            self._CompiledCode = read_string()

        if self._CompiledCode and self._CompiledCode[:4] != B&#39;IFPS&#39;:
            raise ValueError(&#39;Invalid signature in compiled code.&#39;)

        if version &gt;= (2, 0, 6) and version.ascii:
            self.Charset = reader.read_integer(0x100)
        else:
            self.Charset = 0

        if version &gt;= (4, 0, 0):
            self.LanguageCount = reader.u32()
        elif version &gt;= (2, 0, 1):
            self.LanguageCount = 1
        else:
            self.LanguageCount = 0

        if version &gt;= (4, 2, 1):
            self.MessageCount = reader.u32()
        else:
            self.MessageCount = 0

        if version &gt;= (4, 1, 0):
            self.PermissionCount = reader.u32()
        else:
            self.PermissionCount = 0

        if version &gt;= (2, 0, 0) or version.isx:
            self.TypeCount = reader.u32()
            self.ComponentCount = reader.u32()
        else:
            self.TypeCount = 0
            self.ComponentCount = 0

        if version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 17):
            self.TaskCount = reader.u32()
        else:
            self.TaskCount = 0

        self.DirectoryCount = reader.u32()
        self.FileCount = reader.u32()
        self.DataEntryCount = reader.u32()
        self.IconCount = reader.u32()
        self.IniEntryCount = reader.u32()
        self.RegistryCount = reader.u32()
        self.DeleteCount = reader.u32()
        self.UninstallDeleteCount = reader.u32()
        self.RunCount = reader.u32()
        self.UninstallRunCount = reader.u32()

        if version &lt; (1, 3, 0):
            _license_len = reader.u32()
            _infhead_len = reader.u32()
            _inftail_len = reader.u32()

        self.WindowsVersion = WinVerRange(reader, version)

        self.BackColor1 = reader.u32() if (0, 0, 0) &lt;= version &lt; (6, 4, 0, 1) else 0
        self.BackColor2 = reader.u32() if (1, 3, 3) &lt;= version &lt; (6, 4, 0, 1) else 0

        if version &lt; (5, 5, 7):
            self.ImageBackColor = reader.u32()
        if (2, 0, 0) &lt;= version &lt; (5, 0, 4) or version.isx:
            self.SmallImageBackColor = reader.u32()
        if version &gt;= (6, 0, 0):
            self.WizardStyle = WizardStyle(reader.u8())
            self.WizardResizePercentX = reader.u32()
            self.WizardResizePercentY = reader.u32()
        else:
            self.WizardStyle = WizardStyle.Classic
            self.WizardResizePercentX = 0
            self.WizardResizePercentY = 0

        if version &gt;= (5, 5, 7):
            self.StoredAlphaFormat = StoredAlphaFormat(reader.u8())
        else:
            self.StoredAlphaFormat = StoredAlphaFormat.AlphaIgnored

        if version &gt;= (6, 4, 0):
            self.PasswordType = PasswordType.XChaCha20
            self.PasswordHash = reader.read(4)
        elif version &gt;= (5, 3, 9):
            self.PasswordType = PasswordType.SHA1
            self.PasswordHash = reader.read(20)
        elif version &gt;= (4, 2, 0):
            self.PasswordType = PasswordType.MD5
            self.PasswordHash = reader.read(16)
        else:
            self.PasswordType = PasswordType.CRC32
            self.PasswordHash = reader.u32()

        if version &gt;= (6, 4, 0):
            self.PasswordSalt = reader.read(44)
        elif version &gt;= (4, 2, 2):
            self.PasswordSalt = reader.read(8)
        else:
            self.PasswordSalt = None

        if version &gt;= (4, 0, 0):
            self.ExtraDiskSpace = reader.i64()
            self.SlicesPerDisk = reader.u32()
        else:
            self.ExtraDiskSpace = reader.u32()
            self.SlicesPerDisk = 1

        if (2, 0, 0) &lt;= version &lt; (5, 0, 0):
            self.InstallMode = _enum(InstallMode, reader.u8(), InstallMode.Normal)
        else:
            self.InstallMode = InstallMode.Normal
        if version &gt;= (1, 3, 0):
            self.UninstallLogMode = UninstallLogMode(reader.u8())
        else:
            self.UninstallLogMode = UninstallLogMode.New

        if version &gt;= (5, 0, 0):
            self.SetupStyle = SetupStyle.Modern
        elif (2, 0, 0) &lt;= version or version.isx and version &gt;= (1, 3, 13):
            self.SetupStyle = SetupStyle(reader.u8())
        else:
            self.SetupStyle = SetupStyle.Classic

        if version &gt;= (1, 3, 6):
            self.DirExistsWarning = AutoBool(reader.u8())
        else:
            self.DirExistsWarning = AutoBool.Auto
        if version.isx and (2, 0, 10) &lt;= version &lt; (3, 0, 0):
            self.CodeLineOffset = reader.u32()

        self.Flags = Flags.Empty

        if (3, 0, 0) &lt;= version &lt; (3, 0, 3):
            val = AutoBool(reader.u8())
            if val == AutoBool.Auto:
                self.Flags |= Flags.RestartIfNeededByRun
            elif val == AutoBool.Yes:
                self.Flags |= Flags.AlwaysRestart

        if version &gt;= (3, 0, 4) or version.isx and version &gt;= (3, 0, 3):
            self.PrivilegesRequired = PrivilegesRequired(reader.u8())
        if version &gt;= (5, 7, 0):
            self.PrivilegesRequiredOverrideAllowed = PrivilegesRequiredOverrideAllowed(reader.u8())
        if version &gt;= (4, 0, 10):
            self.ShowLanguageDialog = AutoBool(reader.u8())
            self.LanguageDetection = LanguageDetection(reader.u8())

        if version &gt;= (4, 1, 5):
            method = CompressionMethod(reader.u8())
            if version &lt; (4, 2, 5):
                method = method.legacy_conversion_pre_4_2_5()
            elif version &lt; (4, 2, 6):
                method = method.legacy_conversion_pre_4_2_5()
            elif version &lt; (5, 3, 9):
                method = method.legacy_conversion_pre_5_3_9()
            self.CompressionMethod = method

        if version &gt;= (6, 3, 0):
            self.ArchitecturesAllowed = Architecture.Unknown
            self.ArchitecturesInstalled64 = Architecture.Unknown
        elif version &gt;= (5, 1, 0):
            self.ArchitecturesAllowed = Architecture(reader.u8())
            self.ArchitecturesInstalled64 = Architecture(reader.u8())
        else:
            self.ArchitecturesAllowed = Architecture.All
            self.ArchitecturesInstalled64 = Architecture.All

        if (5, 2, 1) &lt;= version &lt; (5, 3, 10):
            self.UninstallerOriginalSize = reader.u32()
            self.UninstallheaderCrc = reader.u32()
        if version &gt;= (5, 3, 3):
            self.DisableDirPage = AutoBool(reader.u8())
            self.DisableProgramGroupPage = AutoBool(reader.u8())
        if version &gt;= (5, 5, 0):
            self.UninstallDisplaySize = reader.u64()
        elif version &gt;= (5, 3, 6):
            self.UninstallDisplaySize = reader.u32()
        else:
            self.UninstallDisplaySize = 0

        flags = []
        flags.append(Flags.DisableStartupPrompt)
        if version &lt; (5, 3, 10):
            flags.append(Flags.Uninstallable)
        flags.append(Flags.CreateAppDir)
        if version &lt; (5, 3, 3):
            flags.append(Flags.DisableDirPage)
        if version &lt; (1, 3, 6):
            flags.append(Flags.DisableDirExistsWarning)
        if version &lt; (5, 3, 3):
            flags.append(Flags.DisableProgramGroupPage)
        flags.append(Flags.AllowNoIcons)
        if version &lt; (3, 0, 0) or version &gt;= (3, 0, 3):
            flags.append(Flags.AlwaysRestart)
        if version &lt; (1, 3, 3):
            flags.append(Flags.BackSolid)
        flags.append(Flags.AlwaysUsePersonalGroup)
        if version &lt; (6, 4, 0):
            flags.append(Flags.WindowVisible)
            flags.append(Flags.WindowShowCaption)
            flags.append(Flags.WindowResizable)
            flags.append(Flags.WindowStartMaximized)
        flags.append(Flags.EnableDirDoesntExistWarning)
        if version &lt; (4, 1, 2):
            flags.append(Flags.DisableAppendDir)
        flags.append(Flags.Password)
        flags.append(Flags.AllowRootDirectory)
        flags.append(Flags.DisableFinishedPage)

        if version.bits &gt; 16:
            if version &lt; (3, 0, 4):
                flags.append(Flags.AdminPrivilegesRequired)
            if version &lt; (3, 0, 0):
                flags.append(Flags.AlwaysCreateUninstallIcon)
            if version &lt; (1, 3, 6):
                flags.append(Flags.OverwriteUninstRegEntries)
            if version &lt; (5, 6, 1):
                flags.append(Flags.ChangesAssociations)

        if version &lt; (5, 3, 8):
            flags.append(Flags.CreateUninstallRegKey)

        flags.append(Flags.UsePreviousAppDir)
        if version &lt; (6, 4, 0):
            flags.append(Flags.BackColorHorizontal)
        flags.append(Flags.UsePreviousGroup)
        flags.append(Flags.UpdateUninstallLogAppName)
        flags.append(Flags.UsePreviousSetupType)
        flags.append(Flags.DisableReadyMemo)
        flags.append(Flags.AlwaysShowComponentsList)
        flags.append(Flags.FlatComponentsList)
        flags.append(Flags.ShowComponentSizes)
        flags.append(Flags.UsePreviousTasks)
        flags.append(Flags.DisableReadyPage)
        flags.append(Flags.AlwaysShowDirOnReadyPage)
        flags.append(Flags.AlwaysShowGroupOnReadyPage)
        if version &lt; (4, 1, 5):
            flags.append(Flags.BzipUsed)
        flags.append(Flags.AllowUNCPath)
        flags.append(Flags.UserInfoPage)
        flags.append(Flags.UsePreviousUserInfo)
        flags.append(Flags.UninstallRestartComputer)
        flags.append(Flags.RestartIfNeededByRun)
        flags.append(Flags.ShowTasksTreeLines)
        if version &lt; (4, 0, 10):
            flags.append(Flags.ShowLanguageDialog)
        if version &gt;= (4, 0, 1) and version &lt; (4, 0, 10):
            flags.append(Flags.DetectLanguageUsingLocale)
        if version &gt;= (4, 0, 9):
            flags.append(Flags.AllowCancelDuringInstall)
        if version &gt;= (4, 1, 3):
            flags.append(Flags.WizardImageStretch)
        if version &gt;= (4, 1, 8):
            flags.append(Flags.AppendDefaultDirName)
            flags.append(Flags.AppendDefaultGroupName)
        if version &gt;= (4, 2, 2):
            flags.append(Flags.EncryptionUsed)
        if version &gt;= (5, 0, 4) and version &lt; (5, 6, 1):
            flags.append(Flags.ChangesEnvironment)
        if version &gt;= (5, 1, 7) and version.ascii:
            flags.append(Flags.ShowUndisplayableLanguages)
        if version &gt;= (5, 1, 13):
            flags.append(Flags.SetupLogging)
        if version &gt;= (5, 2, 1):
            flags.append(Flags.SignedUninstaller)
        if version &gt;= (5, 3, 8):
            flags.append(Flags.UsePreviousLanguage)
        if version &gt;= (5, 3, 9):
            flags.append(Flags.DisableWelcomePage)
        if version &gt;= (5, 5, 0):
            flags.append(Flags.CloseApplications)
            flags.append(Flags.RestartApplications)
            flags.append(Flags.AllowNetworkDrive)
        if version &gt;= (5, 5, 7):
            flags.append(Flags.ForceCloseApplications)
        if version &gt;= (6, 0, 0):
            flags.append(Flags.AppNameHasConsts)
            flags.append(Flags.UsePreviousPrivileges)
            flags.append(Flags.WizardResizable)
        if version &gt;= (6, 3, 0):
            flags.append(Flags.UninstallLogging)

        flagsize, _r = divmod(len(flags), 8)
        flagsize += int(bool(_r))
        bytecheck = bytes(reader.peek(flagsize + 1 + 4 + 1))

        if bytecheck[0] == 0:
            if bytecheck[~0] != 0 or bytecheck[~3:~0] == B&#39;\0\0\0&#39;:
                reader.u8()

        for flag in flags:
            if reader.read_bit():
                self.Flags |= flag

        if version &lt; (3, 0, 4):
            self.PrivilegesRequired = PrivilegesRequired.Admin if (
                self.Flags &amp; Flags.AdminPrivilegesRequired
            ) else PrivilegesRequired.Nothing

        if version &lt; (4, 0, 10):
            self.ShowLanguageDialog = AutoBool.From(
                self.Flags &amp; Flags.ShowLanguageDialog)
            self.LanguageDetection = LanguageDetection.Locale if (
                self.Flags &amp; Flags.DetectLanguageUsingLocale
            ) else LanguageDetection.UI

        if version &lt; (4, 1, 5):
            self.CompressionMethod = CompressionMethod.BZip2 if (
                self.Flags &amp; Flags.BzipUsed
            ) else CompressionMethod.Flate

        if version &lt; (5, 3, 3):
            self.DisableDirPage = AutoBool.From(self.Flags &amp; Flags.DisableDirPage)
            self.DisableProgramGroupPage = AutoBool.From(self.Flags &amp; Flags.DisableProgramGroupPage)

        if version &lt; (1, 3, 0):
            def _read_ascii(n: int):
                return codecs.decode(reader.read(_license_len), &#39;cp1252&#39;)
            self._license = _read_ascii(_license_len)
            self.InfoHead = _read_ascii(_infhead_len)
            self.InfoTail = _read_ascii(_inftail_len)

        reader.byte_align()

        if flagsize == 3:
            reader.u8()

    def get_license(self):
        return self._license

    def get_script(self):
        return self._CompiledCode

    def recode_strings(self, codec: str):
        for coded_string_attribute in [
            &#39;AppComment&#39;,
            &#39;AppContact&#39;,
            &#39;AppCopyright&#39;,
            &#39;AppId&#39;,
            &#39;AppModifyPath&#39;,
            &#39;AppMutex&#39;,
            &#39;AppName&#39;,
            &#39;AppPublisher&#39;,
            &#39;AppPublisherUrl&#39;,
            &#39;AppReadmeFile&#39;,
            &#39;AppSupportPhone&#39;,
            &#39;AppSupportUrl&#39;,
            &#39;AppUpdatesUrl&#39;,
            &#39;AppVersion&#39;,
            &#39;AppVersionedName&#39;,
            &#39;BaseFilename&#39;,
            &#39;ChangesAssociations&#39;,
            &#39;ChangesEnvironment&#39;,
            &#39;CloseApplicationsFilter&#39;,
            &#39;CreateUninstallRegistryKey&#39;,
            &#39;DefaultDirName&#39;,
            &#39;DefaultGroupName&#39;,
            &#39;DefaultOrganisation&#39;,
            &#39;DefaultSerial&#39;,
            &#39;DefaultUsername&#39;,
            &#39;SetupMutex&#39;,
            &#39;Uninstallable&#39;,
            &#39;UninstallFilesDir&#39;,
            &#39;UninstallIcon&#39;,
            &#39;UninstallName&#39;,
        ]:
            try:
                value: bytes = getattr(self, coded_string_attribute)
            except AttributeError:
                continue
            if not isinstance(value, (bytes, bytearray, memoryview)):
                raise RuntimeError(F&#39;Attempting to decode {coded_string_attribute} which was already decoded.&#39;)
            setattr(self, coded_string_attribute, codecs.decode(value, codec))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupHeader.get_license"><code class="name flex">
<span>def <span class="ident">get_license</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1154-L1155" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_license(self):
    return self._license</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.SetupHeader.get_script"><code class="name flex">
<span>def <span class="ident">get_script</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1157-L1158" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_script(self):
    return self._CompiledCode</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.SetupHeader.recode_strings"><code class="name flex">
<span>def <span class="ident">recode_strings</span></span>(<span>self, codec)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1160-L1199" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def recode_strings(self, codec: str):
    for coded_string_attribute in [
        &#39;AppComment&#39;,
        &#39;AppContact&#39;,
        &#39;AppCopyright&#39;,
        &#39;AppId&#39;,
        &#39;AppModifyPath&#39;,
        &#39;AppMutex&#39;,
        &#39;AppName&#39;,
        &#39;AppPublisher&#39;,
        &#39;AppPublisherUrl&#39;,
        &#39;AppReadmeFile&#39;,
        &#39;AppSupportPhone&#39;,
        &#39;AppSupportUrl&#39;,
        &#39;AppUpdatesUrl&#39;,
        &#39;AppVersion&#39;,
        &#39;AppVersionedName&#39;,
        &#39;BaseFilename&#39;,
        &#39;ChangesAssociations&#39;,
        &#39;ChangesEnvironment&#39;,
        &#39;CloseApplicationsFilter&#39;,
        &#39;CreateUninstallRegistryKey&#39;,
        &#39;DefaultDirName&#39;,
        &#39;DefaultGroupName&#39;,
        &#39;DefaultOrganisation&#39;,
        &#39;DefaultSerial&#39;,
        &#39;DefaultUsername&#39;,
        &#39;SetupMutex&#39;,
        &#39;Uninstallable&#39;,
        &#39;UninstallFilesDir&#39;,
        &#39;UninstallIcon&#39;,
        &#39;UninstallName&#39;,
    ]:
        try:
            value: bytes = getattr(self, coded_string_attribute)
        except AttributeError:
            continue
        if not isinstance(value, (bytes, bytearray, memoryview)):
            raise RuntimeError(F&#39;Attempting to decode {coded_string_attribute} which was already decoded.&#39;)
        setattr(self, coded_string_attribute, codecs.decode(value, codec))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.Version"><code class="flex name class">
<span>class <span class="ident">Version</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1202-L1211" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Version(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.Build = reader.u16() if version &gt;= (1, 3, 19) else 0
        self.Minor = reader.u8()
        self.Major = reader.u8()

    def json(self):
        return F&#39;{self.Major:d}.{self.Minor:d}.{self.Build:04d}&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.Version.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1210-L1211" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def json(self):
    return F&#39;{self.Major:d}.{self.Minor:d}.{self.Build:04d}&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.WindowsVersion"><code class="flex name class">
<span>class <span class="ident">WindowsVersion</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1214-L1223" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class WindowsVersion(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.OS = Version(reader, version)
        self.NT = Version(reader, version)
        (
            self.ServicePackMinor,
            self.ServicePackMajor,
        ) = reader.read_struct(&#39;BB&#39;) if version &gt;= (1, 3, 19) else (0, 0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.WinVerRange"><code class="flex name class">
<span>class <span class="ident">WinVerRange</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1226-L1231" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class WinVerRange(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.Min = WindowsVersion(reader, version)
        self.Max = WindowsVersion(reader, version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.LanguageId"><code class="flex name class">
<span>class <span class="ident">LanguageId</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1234-L1237" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LanguageId(JsonStruct):
    def __init__(self, reader: StructReader[memoryview]):
        self.Value = reader.i32()
        self.Name = LCID.get(self.Value, None)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.SetupLanguage"><code class="flex name class">
<span>class <span class="ident">SetupLanguage</span></span>
<span>(</span><span>reader, version, _)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1240-L1287" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupLanguage(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, _: TSetup):
        super().__init__(reader, version)
        read_string = self._read_string

        self.Name = read_string()
        LanguageName = reader.read_length_prefixed()

        self.DialogFont = read_string()
        self.TitleFont = read_string()
        self.WelcomeFont = read_string()
        self.CopyrightFont = read_string()
        self._data = reader.read_length_prefixed()

        if version &gt;= (4, 0, 1):
            self.LicenseText = reader.read_length_prefixed_ascii()
            self.InfoBefore = reader.read_length_prefixed_ascii()
            self.InfoAfter = reader.read_length_prefixed_ascii()

        self.LanguageId = LanguageId(reader)

        if version &lt; (4, 2, 2):
            self.Codepage = DEFAULT_CODEPAGE.get(self.LanguageId.Value, &#39;cp1252&#39;)
        elif version.ascii:
            cp = reader.u32() or 1252
            self.Codepage = F&#39;cp{cp}&#39;
        else:
            if version &lt; (5, 3, 0):
                reader.u32()
            self.Codepage = &#39;utf-16le&#39;

        if version &gt;= (4, 2, 2):
            self.LanguageName = codecs.decode(LanguageName, &#39;utf-16le&#39;)
        else:
            self.LanguageName = codecs.decode(LanguageName, self.Codepage)

        self.DialogFontSize = reader.u32()

        if version &lt; (4, 1, 0):
            self.DialogFontStandardHeight = reader.u32()

        self.TitleFontSize = reader.u32()
        self.WelcomeFontSize = reader.u32()
        self.CopyrightFontSize = reader.u32()

        if version &gt;= (5, 2, 3):
            self.RightToLeft = reader.u8()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.SetupMessage"><code class="flex name class">
<span>class <span class="ident">SetupMessage</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1290-L1317" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupMessage(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        self.EncodedName = self._read_string()
        self._raw_value = reader.read_length_prefixed()
        self._language_index = reader.i32()
        try:
            self._language_value = parent.Languages[self._language_index]
        except IndexError:
            self._language_value = None
            codec = &#39;latin1&#39;
        else:
            codec = self._language_value.Codepage
        try:
            self.Value = codecs.decode(self._raw_value, codec)
        except LookupError:
            # TODO: This is a fallback
            self.Value = codecs.decode(self._raw_value, &#39;latin1&#39;)

    def get_raw_value(self):
        return self._raw_value

    def get_language_index(self):
        return self._language_index

    def get_language_value(self):
        return self._language_value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupMessage.get_raw_value"><code class="name flex">
<span>def <span class="ident">get_raw_value</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1310-L1311" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_raw_value(self):
    return self._raw_value</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.SetupMessage.get_language_index"><code class="name flex">
<span>def <span class="ident">get_language_index</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1313-L1314" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_language_index(self):
    return self._language_index</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.SetupMessage.get_language_value"><code class="name flex">
<span>def <span class="ident">get_language_value</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1316-L1317" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_language_value(self):
    return self._language_value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupType"><code class="flex name class">
<span>class <span class="ident">SetupType</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1320-L1340" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupType(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string
        self.Name = read_string()
        self.Description = read_string()
        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        self.WindowsVersion = WinVerRange(reader, version)
        self.CustsomTypeCode = reader.u8()
        if version &gt;= (4, 0, 3):
            self.SetupType = SetupTypeEnum(reader.u8())
        else:
            self.SetupType = SetupTypeEnum.User
        if version &gt;= (4, 0, 0):
            self.Size = reader.u64()
        else:
            self.Size = reader.u32()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.SetupComponent"><code class="flex name class">
<span>class <span class="ident">SetupComponent</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1343-L1371" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupComponent(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string
        self.Name = read_string()
        self.Description = read_string()
        self.Types = read_string()
        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        if version &gt;= (4, 0, 0):
            self.ExtraDiskSpace = reader.u64()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 3):
            self.Level = reader.u32()
        else:
            self.Level = 0
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 4):
            self.Used = bool(reader.u8())
        else:
            self.Used = True
        if True:
            self.WindowsVersion = WinVerRange(reader, version)
            self.Flags = SetupFlags(reader.u8())
        if version &gt;= (4, 0, 0):
            self.Size = reader.u64()
        elif version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Size = reader.u32()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.SetupTaskFlags"><code class="flex name class">
<span>class <span class="ident">SetupTaskFlags</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1374-L1380" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupTaskFlags(enum.IntFlag):
    Empty            = 0           # noqa
    Exclusive        = enum.auto() # noqa
    Unchecked        = enum.auto() # noqa
    Restart          = enum.auto() # noqa
    CheckedOne       = enum.auto() # noqa
    DontInheritCheck = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupTaskFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupTaskFlags.Exclusive"><code class="name">var <span class="ident">Exclusive</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupTaskFlags.Unchecked"><code class="name">var <span class="ident">Unchecked</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupTaskFlags.Restart"><code class="name">var <span class="ident">Restart</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupTaskFlags.CheckedOne"><code class="name">var <span class="ident">CheckedOne</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupTaskFlags.DontInheritCheck"><code class="name">var <span class="ident">DontInheritCheck</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupTask"><code class="flex name class">
<span>class <span class="ident">SetupTask</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1383-L1424" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupTask(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string

        self.Name = read_string()
        self.Description = read_string()
        self.GroupDescription = read_string()
        self.Components = read_string()

        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 3):
            self.Level = reader.u32()
        else:
            self.Level = 0
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 4):
            self.Used = bool(reader.u8())
        else:
            self.Used = True
        if True:
            self.WindowsVersion = WinVerRange(reader, version)

        self.Flags = SetupTaskFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        if True:
            flagbit(SetupTaskFlags.Exclusive)
            flagbit(SetupTaskFlags.Unchecked)
        if version &gt;= (2, 0, 5):
            flagbit(SetupTaskFlags.Restart)
        if version &gt;= (2, 0, 6):
            flagbit(SetupTaskFlags.CheckedOne)
        if version &gt;= (4, 2, 3):
            flagbit(SetupTaskFlags.DontInheritCheck)

        reader.byte_align()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.SetupCondition"><code class="flex name class">
<span>class <span class="ident">SetupCondition</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1427-L1444" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupCondition(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string
        if version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 8):
            self.Components = read_string()
        if version &gt;= (2, 0, 0) or version.isx and version &gt;= (1, 3, 17):
            self.Tasks = read_string()
        if version &gt;= (4, 0, 1):
            self.Languages = read_string()
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (1, 3, 24):
            self.Check = read_string()
        else:
            self.Check = None
        if version &gt;= (4, 1, 0):
            self.AfterInstall = read_string()
            self.BeforeInstall = read_string()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.SetupDirectoryFlags"><code class="flex name class">
<span>class <span class="ident">SetupDirectoryFlags</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1447-L1453" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupDirectoryFlags(enum.IntFlag):
    Empty                = 0           # noqa
    NeverUninstall       = enum.auto() # noqa
    DeleteAfterInstall   = enum.auto() # noqa
    AlwaysUninstall      = enum.auto() # noqa
    SetNtfsCompression   = enum.auto() # noqa
    UnsetNtfsCompression = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupDirectoryFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDirectoryFlags.NeverUninstall"><code class="name">var <span class="ident">NeverUninstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDirectoryFlags.DeleteAfterInstall"><code class="name">var <span class="ident">DeleteAfterInstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDirectoryFlags.AlwaysUninstall"><code class="name">var <span class="ident">AlwaysUninstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDirectoryFlags.SetNtfsCompression"><code class="name">var <span class="ident">SetNtfsCompression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDirectoryFlags.UnsetNtfsCompression"><code class="name">var <span class="ident">UnsetNtfsCompression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupDirectory"><code class="flex name class">
<span>class <span class="ident">SetupDirectory</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1456-L1487" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupDirectory(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string

        if version &lt; (1, 3, 0):
            self.UncompressedSize = reader.u32()
        if True:
            self.Name = read_string()
            self.Condition = SetupCondition(reader, version, parent)

        if (4, 0, 11) &lt;= version &lt; (4, 1, 0):
            self.Permissions = read_string()
        if version &gt;= (2, 0, 11):
            self.Attributes = reader.u32()

        self.WindowsVersion = WinVerRange(reader, version)

        if version &gt;= (4, 1, 0):
            self.Permissions = reader.u16()

        self.Flags = SetupDirectoryFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0
        flagbit(SetupDirectoryFlags.NeverUninstall)
        flagbit(SetupDirectoryFlags.DeleteAfterInstall)
        flagbit(SetupDirectoryFlags.AlwaysUninstall)
        flagbit(SetupDirectoryFlags.SetNtfsCompression)
        flagbit(SetupDirectoryFlags.UnsetNtfsCompression)
        reader.byte_align()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.SetupPermission"><code class="flex name class">
<span>class <span class="ident">SetupPermission</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1490-L1494" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupPermission(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        self.Permission = reader.read_length_prefixed()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags"><code class="flex name class">
<span>class <span class="ident">SetupFileFlags</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1497-L1531" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupFileFlags(enum.IntFlag):
    Empty                              = 0           # noqa
    ConfirmOverwrite                   = enum.auto() # noqa
    NeverUninstall                     = enum.auto() # noqa
    RestartReplace                     = enum.auto() # noqa
    DeleteAfterInstall                 = enum.auto() # noqa
    RegisterServer                     = enum.auto() # noqa
    RegisterTypeLib                    = enum.auto() # noqa
    SharedFile                         = enum.auto() # noqa
    IsReadmeFile                       = enum.auto() # noqa
    CompareTimeStamp                   = enum.auto() # noqa
    FontIsNotTrueType                  = enum.auto() # noqa
    SkipIfSourceDoesntExist            = enum.auto() # noqa
    OverwriteReadOnly                  = enum.auto() # noqa
    OverwriteSameVersion               = enum.auto() # noqa
    CustomDestName                     = enum.auto() # noqa
    OnlyIfDestFileExists               = enum.auto() # noqa
    NoRegError                         = enum.auto() # noqa
    UninsRestartDelete                 = enum.auto() # noqa
    OnlyIfDoesntExist                  = enum.auto() # noqa
    IgnoreVersion                      = enum.auto() # noqa
    PromptIfOlder                      = enum.auto() # noqa
    DontCopy                           = enum.auto() # noqa
    UninsRemoveReadOnly                = enum.auto() # noqa
    RecurseSubDirsExternal             = enum.auto() # noqa
    ReplaceSameVersionIfContentsDiffer = enum.auto() # noqa
    DontVerifyChecksum                 = enum.auto() # noqa
    UninsNoSharedFilePrompt            = enum.auto() # noqa
    CreateAllSubDirs                   = enum.auto() # noqa
    Bits32                             = enum.auto() # noqa
    Bits64                             = enum.auto() # noqa
    ExternalSizePreset                 = enum.auto() # noqa
    SetNtfsCompression                 = enum.auto() # noqa
    UnsetNtfsCompression               = enum.auto() # noqa
    GacInstall                         = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupFileFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.ConfirmOverwrite"><code class="name">var <span class="ident">ConfirmOverwrite</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.NeverUninstall"><code class="name">var <span class="ident">NeverUninstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.RestartReplace"><code class="name">var <span class="ident">RestartReplace</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.DeleteAfterInstall"><code class="name">var <span class="ident">DeleteAfterInstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.RegisterServer"><code class="name">var <span class="ident">RegisterServer</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.RegisterTypeLib"><code class="name">var <span class="ident">RegisterTypeLib</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.SharedFile"><code class="name">var <span class="ident">SharedFile</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.IsReadmeFile"><code class="name">var <span class="ident">IsReadmeFile</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.CompareTimeStamp"><code class="name">var <span class="ident">CompareTimeStamp</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.FontIsNotTrueType"><code class="name">var <span class="ident">FontIsNotTrueType</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.SkipIfSourceDoesntExist"><code class="name">var <span class="ident">SkipIfSourceDoesntExist</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.OverwriteReadOnly"><code class="name">var <span class="ident">OverwriteReadOnly</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.OverwriteSameVersion"><code class="name">var <span class="ident">OverwriteSameVersion</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.CustomDestName"><code class="name">var <span class="ident">CustomDestName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.OnlyIfDestFileExists"><code class="name">var <span class="ident">OnlyIfDestFileExists</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.NoRegError"><code class="name">var <span class="ident">NoRegError</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.UninsRestartDelete"><code class="name">var <span class="ident">UninsRestartDelete</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.OnlyIfDoesntExist"><code class="name">var <span class="ident">OnlyIfDoesntExist</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.IgnoreVersion"><code class="name">var <span class="ident">IgnoreVersion</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.PromptIfOlder"><code class="name">var <span class="ident">PromptIfOlder</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.DontCopy"><code class="name">var <span class="ident">DontCopy</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.UninsRemoveReadOnly"><code class="name">var <span class="ident">UninsRemoveReadOnly</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.RecurseSubDirsExternal"><code class="name">var <span class="ident">RecurseSubDirsExternal</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.ReplaceSameVersionIfContentsDiffer"><code class="name">var <span class="ident">ReplaceSameVersionIfContentsDiffer</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.DontVerifyChecksum"><code class="name">var <span class="ident">DontVerifyChecksum</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.UninsNoSharedFilePrompt"><code class="name">var <span class="ident">UninsNoSharedFilePrompt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.CreateAllSubDirs"><code class="name">var <span class="ident">CreateAllSubDirs</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.Bits32"><code class="name">var <span class="ident">Bits32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.Bits64"><code class="name">var <span class="ident">Bits64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.ExternalSizePreset"><code class="name">var <span class="ident">ExternalSizePreset</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.SetNtfsCompression"><code class="name">var <span class="ident">SetNtfsCompression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.UnsetNtfsCompression"><code class="name">var <span class="ident">UnsetNtfsCompression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileFlags.GacInstall"><code class="name">var <span class="ident">GacInstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileType"><code class="flex name class">
<span>class <span class="ident">SetupFileType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1534-L1537" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupFileType(enum.IntEnum):
    UserFile = 0
    UninstExe = 1
    RegSvrExe = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupFileType.UserFile"><code class="name">var <span class="ident">UserFile</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileType.UninstExe"><code class="name">var <span class="ident">UninstExe</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileType.RegSvrExe"><code class="name">var <span class="ident">RegSvrExe</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileCopyMode"><code class="flex name class">
<span>class <span class="ident">SetupFileCopyMode</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1540-L1544" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupFileCopyMode(enum.IntEnum):
    Normal                  = 0           # noqa
    IfDoesntExist           = enum.auto() # noqa
    AlwaysOverwrite         = enum.auto() # noqa
    AlwaysSkipIfSameOrOlder = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupFileCopyMode.Normal"><code class="name">var <span class="ident">Normal</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileCopyMode.IfDoesntExist"><code class="name">var <span class="ident">IfDoesntExist</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileCopyMode.AlwaysOverwrite"><code class="name">var <span class="ident">AlwaysOverwrite</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupFileCopyMode.AlwaysSkipIfSameOrOlder"><code class="name">var <span class="ident">AlwaysSkipIfSameOrOlder</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupFile"><code class="flex name class">
<span>class <span class="ident">SetupFile</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1547-L1650" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupFile(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        read_string = self._read_string

        if version &lt; (1, 3, 0):
            self.UncompressedSize = reader.u32()
        if True:
            self.Source = read_string()
            self.Destination = read_string()
            self.InstallFontName = read_string()
        if version &gt;= (5, 2, 5):
            self.StrongAssemblyName = read_string()

        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)

        self.Location = reader.u32()
        self.Attributes = reader.u32()
        self.ExternalSize = reader.u64() if version &gt;= (4, 0, 0) else reader.u32()

        self.Flags = SetupFileFlags.Empty

        if version &lt; (3, 0, 5):
            copy = _enum(SetupFileCopyMode, reader.u8(), SetupFileCopyMode.Normal)
            if copy == SetupFileCopyMode.AlwaysSkipIfSameOrOlder:
                pass
            elif copy == SetupFileCopyMode.Normal:
                self.Flags |= SetupFileFlags.PromptIfOlder
            elif copy == SetupFileCopyMode.IfDoesntExist:
                self.Flags |= SetupFileFlags.OnlyIfDoesntExist | SetupFileFlags.PromptIfOlder
            elif copy == SetupFileCopyMode.AlwaysOverwrite:
                self.Flags |= SetupFileFlags.IgnoreVersion | SetupFileFlags.PromptIfOlder

        if version &gt;= (4, 1, 0):
            self.Permissions = reader.u16()

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        flagstart = reader.tell()

        if True:
            flagbit(SetupFileFlags.ConfirmOverwrite)
            flagbit(SetupFileFlags.NeverUninstall)
            flagbit(SetupFileFlags.RestartReplace)
            flagbit(SetupFileFlags.DeleteAfterInstall)
        if version.bits &gt; 16:
            flagbit(SetupFileFlags.RegisterServer)
            flagbit(SetupFileFlags.RegisterTypeLib)
            flagbit(SetupFileFlags.SharedFile)
        if version &lt; (2, 0, 0) and not version.isx:
            flagbit(SetupFileFlags.IsReadmeFile)
        if True:
            flagbit(SetupFileFlags.CompareTimeStamp)
            flagbit(SetupFileFlags.FontIsNotTrueType)
        if version &gt;= (1, 2, 5):
            flagbit(SetupFileFlags.SkipIfSourceDoesntExist)
        if version &gt;= (1, 2, 6):
            flagbit(SetupFileFlags.OverwriteReadOnly)
        if version &gt;= (1, 3, 21):
            flagbit(SetupFileFlags.OverwriteSameVersion)
            flagbit(SetupFileFlags.CustomDestName)
        if version &gt;= (1, 3, 25):
            flagbit(SetupFileFlags.OnlyIfDestFileExists)
        if version &gt;= (2, 0, 5):
            flagbit(SetupFileFlags.NoRegError)
        if version &gt;= (3, 0, 1):
            flagbit(SetupFileFlags.UninsRestartDelete)
        if version &gt;= (3, 0, 5):
            flagbit(SetupFileFlags.OnlyIfDoesntExist)
            flagbit(SetupFileFlags.IgnoreVersion)
            flagbit(SetupFileFlags.PromptIfOlder)
        if version &gt;= (4, 0, 0) or version.isx and version &gt;= (3, 0, 6, 1):
            flagbit(SetupFileFlags.DontCopy)
        if version &gt;= (4, 0, 5):
            flagbit(SetupFileFlags.UninsRemoveReadOnly)
        if version &gt;= (4, 1, 8):
            flagbit(SetupFileFlags.RecurseSubDirsExternal)
        if version &gt;= (4, 2, 1):
            flagbit(SetupFileFlags.ReplaceSameVersionIfContentsDiffer)
        if version &gt;= (4, 2, 5):
            flagbit(SetupFileFlags.DontVerifyChecksum)
        if version &gt;= (5, 0, 3):
            flagbit(SetupFileFlags.UninsNoSharedFilePrompt)
        if version &gt;= (5, 1, 0):
            flagbit(SetupFileFlags.CreateAllSubDirs)
        if version &gt;= (5, 1, 2):
            flagbit(SetupFileFlags.Bits32)
            flagbit(SetupFileFlags.Bits64)
        if version &gt;= (5, 2, 0):
            flagbit(SetupFileFlags.ExternalSizePreset)
            flagbit(SetupFileFlags.SetNtfsCompression)
            flagbit(SetupFileFlags.UnsetNtfsCompression)
        if version &gt;= (5, 2, 5):
            flagbit(SetupFileFlags.GacInstall)

        reader.byte_align()

        if reader.tell() - flagstart == 3:
            reader.u8()

        self.Type = SetupFileType(reader.u8())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.SetupIconCloseSetting"><code class="flex name class">
<span>class <span class="ident">SetupIconCloseSetting</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1653-L1656" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupIconCloseSetting(enum.IntEnum):
    NoSetting       = 0           # noqa
    CloseOnExit     = enum.auto() # noqa
    DontCloseOnExit = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupIconCloseSetting.NoSetting"><code class="name">var <span class="ident">NoSetting</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIconCloseSetting.CloseOnExit"><code class="name">var <span class="ident">CloseOnExit</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIconCloseSetting.DontCloseOnExit"><code class="name">var <span class="ident">DontCloseOnExit</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupIconFlags"><code class="flex name class">
<span>class <span class="ident">SetupIconFlags</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1659-L1668" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupIconFlags(enum.IntFlag):
    Empty                              = 0           # noqa
    NeverUninstall                     = enum.auto() # noqa
    RunMinimized                       = enum.auto() # noqa
    CreateOnlyIfFileExists             = enum.auto() # noqa
    UseAppPaths                        = enum.auto() # noqa
    FolderShortcut                     = enum.auto() # noqa
    ExcludeFromShowInNewInstall        = enum.auto() # noqa
    PreventPinning                     = enum.auto() # noqa
    HasAppUserModelToastActivatorCLSID = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupIconFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIconFlags.NeverUninstall"><code class="name">var <span class="ident">NeverUninstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIconFlags.RunMinimized"><code class="name">var <span class="ident">RunMinimized</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIconFlags.CreateOnlyIfFileExists"><code class="name">var <span class="ident">CreateOnlyIfFileExists</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIconFlags.UseAppPaths"><code class="name">var <span class="ident">UseAppPaths</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIconFlags.FolderShortcut"><code class="name">var <span class="ident">FolderShortcut</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIconFlags.ExcludeFromShowInNewInstall"><code class="name">var <span class="ident">ExcludeFromShowInNewInstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIconFlags.PreventPinning"><code class="name">var <span class="ident">PreventPinning</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIconFlags.HasAppUserModelToastActivatorCLSID"><code class="name">var <span class="ident">HasAppUserModelToastActivatorCLSID</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupIcon"><code class="flex name class">
<span>class <span class="ident">SetupIcon</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1671-L1728" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupIcon(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)

        if version &lt; (1, 3, 0):
            reader.u32()

        self.Name = self._read_string()
        self.FileName = self._read_string()
        self.Parameters = self._read_string()
        self.WorkingDir = self._read_string()
        self.IconFile = self._read_string()
        self.Comment = self._read_string()

        self.Condition = SetupCondition(reader, version, parent)

        if version &gt;= (5, 3, 5):
            self.AppUserModelId = self._read_string()
        if version &gt;= (6, 1, 0):
            self.AppUserModelToastActivatorCLSID = str(reader.read_guid())

        self.WindowsVersion = WinVerRange(reader, version)
        self.IconIndex = reader.i32()

        if version &gt;= (1, 3, 24):
            self.ShowCommand = reader.i32()
        else:
            self.ShowCommand = 1

        if version &gt;= (1, 3, 15):
            self.CloseOnExit = _enum(SetupIconCloseSetting, reader.u8(), SetupIconCloseSetting.NoSetting)
        else:
            self.CloseOnExit = SetupIconCloseSetting.NoSetting

        self.HotKey = reader.u16() if version &gt;= (2, 0, 7) else 0

        self.Flags = SetupIconFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0
        if True:
            flagbit(SetupIconFlags.NeverUninstall)
        if version &lt; (1, 3, 26):
            flagbit(SetupIconFlags.RunMinimized)
        if True:
            flagbit(SetupIconFlags.CreateOnlyIfFileExists)
        if version.bits &gt; 16:
            flagbit(SetupIconFlags.UseAppPaths)
        if version &gt;= (5, 0, 3) and version &lt; (6, 3, 0):
            flagbit(SetupIconFlags.FolderShortcut)
        if version &gt;= (5, 4, 2):
            flagbit(SetupIconFlags.ExcludeFromShowInNewInstall)
        if version &gt;= (5, 5, 0):
            flagbit(SetupIconFlags.PreventPinning)
        if version &gt;= (6, 1, 0):
            flagbit(SetupIconFlags.HasAppUserModelToastActivatorCLSID)
        reader.byte_align()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.SetupIniFlags"><code class="flex name class">
<span>class <span class="ident">SetupIniFlags</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1731-L1737" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupIniFlags(enum.IntFlag):
    Empty                     = 0           # noqa
    CreateKeyIfDoesntExist    = enum.auto() # noqa
    UninsDeleteEntry          = enum.auto() # noqa
    UninsDeleteEntireSection  = enum.auto() # noqa
    UninsDeleteSectionIfEmpty = enum.auto() # noqa
    HasValue                  = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupIniFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIniFlags.CreateKeyIfDoesntExist"><code class="name">var <span class="ident">CreateKeyIfDoesntExist</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIniFlags.UninsDeleteEntry"><code class="name">var <span class="ident">UninsDeleteEntry</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIniFlags.UninsDeleteEntireSection"><code class="name">var <span class="ident">UninsDeleteEntireSection</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIniFlags.UninsDeleteSectionIfEmpty"><code class="name">var <span class="ident">UninsDeleteSectionIfEmpty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupIniFlags.HasValue"><code class="name">var <span class="ident">HasValue</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupIniEntry"><code class="flex name class">
<span>class <span class="ident">SetupIniEntry</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1740-L1757" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupIniEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)

        if version &lt; (1, 3, 0):
            reader.u8()

        if not (IniFile := self._read_string()):
            IniFile = &#39;{windows}/WIN.INI&#39;
        self.IniFile = IniFile

        self.Section = self._read_string()
        self.Key = self._read_string()
        self.Codepage = self._read_string()
        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)
        self.Flags = SetupIniFlags(reader.u8())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryType"><code class="flex name class">
<span>class <span class="ident">SetupRegistryType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1760-L1767" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupRegistryType(enum.IntEnum):
    Unset        = 0           # noqa
    String       = enum.auto() # noqa
    ExpandString = enum.auto() # noqa
    DWord        = enum.auto() # noqa
    Binary       = enum.auto() # noqa
    MultiString  = enum.auto() # noqa
    QWord        = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupRegistryType.Unset"><code class="name">var <span class="ident">Unset</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryType.String"><code class="name">var <span class="ident">String</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryType.ExpandString"><code class="name">var <span class="ident">ExpandString</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryType.DWord"><code class="name">var <span class="ident">DWord</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryType.Binary"><code class="name">var <span class="ident">Binary</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryType.MultiString"><code class="name">var <span class="ident">MultiString</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryType.QWord"><code class="name">var <span class="ident">QWord</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryFlags"><code class="flex name class">
<span>class <span class="ident">SetupRegistryFlags</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1770-L1783" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupRegistryFlags(enum.IntFlag):
    Empty                       = 0           # noqa
    CreateValueIfDoesntExist    = enum.auto() # noqa
    UninsDeleteValue            = enum.auto() # noqa
    UninsClearValue             = enum.auto() # noqa
    UninsDeleteEntireKey        = enum.auto() # noqa
    UninsDeleteEntireKeyIfEmpty = enum.auto() # noqa
    PreserveStringType          = enum.auto() # noqa
    DeleteKey                   = enum.auto() # noqa
    DeleteValue                 = enum.auto() # noqa
    NoError                     = enum.auto() # noqa
    DontCreateKey               = enum.auto() # noqa
    Bits32                      = enum.auto() # noqa
    Bits64                      = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupRegistryFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryFlags.CreateValueIfDoesntExist"><code class="name">var <span class="ident">CreateValueIfDoesntExist</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryFlags.UninsDeleteValue"><code class="name">var <span class="ident">UninsDeleteValue</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryFlags.UninsClearValue"><code class="name">var <span class="ident">UninsClearValue</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryFlags.UninsDeleteEntireKey"><code class="name">var <span class="ident">UninsDeleteEntireKey</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryFlags.UninsDeleteEntireKeyIfEmpty"><code class="name">var <span class="ident">UninsDeleteEntireKeyIfEmpty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryFlags.PreserveStringType"><code class="name">var <span class="ident">PreserveStringType</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryFlags.DeleteKey"><code class="name">var <span class="ident">DeleteKey</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryFlags.DeleteValue"><code class="name">var <span class="ident">DeleteValue</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryFlags.NoError"><code class="name">var <span class="ident">NoError</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryFlags.DontCreateKey"><code class="name">var <span class="ident">DontCreateKey</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryFlags.Bits32"><code class="name">var <span class="ident">Bits32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryFlags.Bits64"><code class="name">var <span class="ident">Bits64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupRegistryEntry"><code class="flex name class">
<span>class <span class="ident">SetupRegistryEntry</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1786-L1834" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupRegistryEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)

        if version &lt; (1, 3, 0):
            reader.u32()

        if True:
            self.Key = self._read_string()
        if version.bits &gt; 16:
            self.Name = self._read_string()
        if True:
            self.Value = reader.read_length_prefixed()
            self.Condition = SetupCondition(reader, version, parent)
        if (4, 0, 11) &lt;= version &lt; (4, 1, 0):
            self.Permissions = reader.read_length_prefixed()

        self.WindowsVersion = WinVerRange(reader, version)
        self.Hive = reader.u32() &amp; 0x7FFFFFFF if version.bits &gt; 16 else None
        self.Permissions = reader.u16() if version &gt;= (4, 1, 0) else None
        self.Type = SetupRegistryType(reader.u8())

        self.Flags = SetupRegistryFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        if version.bits &gt; 16:
            flagbit(SetupRegistryFlags.CreateValueIfDoesntExist)
            flagbit(SetupRegistryFlags.UninsDeleteValue)
        if True:
            flagbit(SetupRegistryFlags.UninsClearValue)
            flagbit(SetupRegistryFlags.UninsDeleteEntireKey)
            flagbit(SetupRegistryFlags.UninsDeleteEntireKeyIfEmpty)
        if version &gt;= (1, 2, 6):
            flagbit(SetupRegistryFlags.PreserveStringType)
        if version &gt;= (1, 3, 9):
            flagbit(SetupRegistryFlags.DeleteKey)
            flagbit(SetupRegistryFlags.DeleteValue)
        if version &gt;= (1, 3, 12):
            flagbit(SetupRegistryFlags.NoError)
        if version &gt;= (1, 3, 16):
            flagbit(SetupRegistryFlags.DontCreateKey)
        if version &gt;= (5, 1, 0):
            flagbit(SetupRegistryFlags.Bits32)
            flagbit(SetupRegistryFlags.Bits64)

        reader.byte_align()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.SetupDeleteType"><code class="flex name class">
<span>class <span class="ident">SetupDeleteType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1837-L1840" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupDeleteType(enum.IntEnum):
    Files           = 0           # noqa
    FilesAndSubdirs = enum.auto() # noqa
    DirIfEmpty      = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupDeleteType.Files"><code class="name">var <span class="ident">Files</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDeleteType.FilesAndSubdirs"><code class="name">var <span class="ident">FilesAndSubdirs</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDeleteType.DirIfEmpty"><code class="name">var <span class="ident">DirIfEmpty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupDeleteEntry"><code class="flex name class">
<span>class <span class="ident">SetupDeleteEntry</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1843-L1852" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupDeleteEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        if version &lt; (1, 3, 0):
            reader.u32()
        self.Name = self._read_string()
        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)
        self.Type = SetupDeleteType(reader.u8())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunWait"><code class="flex name class">
<span>class <span class="ident">SetupRunWait</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1855-L1858" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupRunWait(enum.IntEnum):
    UntilTerminated = 0 # noqa
    NoWait          = 1 # noqa
    UntilIdle       = 2 # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupRunWait.UntilTerminated"><code class="name">var <span class="ident">UntilTerminated</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunWait.NoWait"><code class="name">var <span class="ident">NoWait</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunWait.UntilIdle"><code class="name">var <span class="ident">UntilIdle</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunFlags"><code class="flex name class">
<span>class <span class="ident">SetupRunFlags</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1861-L1874" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupRunFlags(enum.IntFlag):
    Empty             = 0           # noqa
    ShellExec         = enum.auto() # noqa
    SkipIfDoesntExist = enum.auto() # noqa
    PostInstall       = enum.auto() # noqa
    Unchecked         = enum.auto() # noqa
    SkipIfSilent      = enum.auto() # noqa
    SkipIfNotSilent   = enum.auto() # noqa
    HideWizard        = enum.auto() # noqa
    Bits32            = enum.auto() # noqa
    Bits64            = enum.auto() # noqa
    RunAsOriginalUser = enum.auto() # noqa
    DontLogParameters = enum.auto() # noqa
    LogOutput         = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupRunFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunFlags.ShellExec"><code class="name">var <span class="ident">ShellExec</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunFlags.SkipIfDoesntExist"><code class="name">var <span class="ident">SkipIfDoesntExist</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunFlags.PostInstall"><code class="name">var <span class="ident">PostInstall</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunFlags.Unchecked"><code class="name">var <span class="ident">Unchecked</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunFlags.SkipIfSilent"><code class="name">var <span class="ident">SkipIfSilent</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunFlags.SkipIfNotSilent"><code class="name">var <span class="ident">SkipIfNotSilent</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunFlags.HideWizard"><code class="name">var <span class="ident">HideWizard</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunFlags.Bits32"><code class="name">var <span class="ident">Bits32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunFlags.Bits64"><code class="name">var <span class="ident">Bits64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunFlags.RunAsOriginalUser"><code class="name">var <span class="ident">RunAsOriginalUser</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunFlags.DontLogParameters"><code class="name">var <span class="ident">DontLogParameters</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunFlags.LogOutput"><code class="name">var <span class="ident">LogOutput</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupRunEntry"><code class="flex name class">
<span>class <span class="ident">SetupRunEntry</span></span>
<span>(</span><span>reader, version, parent)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1877-L1927" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupRunEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion, parent: TSetup):
        super().__init__(reader, version, parent.Codec)
        if version &lt; (1, 3, 0):
            reader.u8()
        self.Name = self._read_string()
        self.Parameters = self._read_string()
        self.WorkingDir = self._read_string()

        if version &gt;= (1, 3, 9):
            self.RunOnceId = self._read_string()
        if version &gt;= (2, 0, 2):
            self.StatusMessage = self._read_string()
        if version &gt;= (5, 1, 13):
            self.Verb = self._read_string()
        if version &gt;= (2, 0, 0) or version.isx:
            self.Description = self._read_string()

        self.Condition = SetupCondition(reader, version, parent)
        self.WindowsVersion = WinVerRange(reader, version)
        self.ShowCommand = reader.u32() if version &gt;= (1, 3, 24) else 0
        self.Wait = SetupRunWait(reader.u8())

        self.Flags = SetupRunFlags.Empty

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        if version &gt;= (1, 2, 3):
            flagbit(SetupRunFlags.ShellExec)
        if version &gt;= (1, 3, 9) or version.isx and version &gt;= (1, 3, 8):
            flagbit(SetupRunFlags.SkipIfDoesntExist)
        if version &gt;= (2, 0, 0):
            flagbit(SetupRunFlags.PostInstall)
            flagbit(SetupRunFlags.Unchecked)
            flagbit(SetupRunFlags.SkipIfSilent)
            flagbit(SetupRunFlags.SkipIfNotSilent)
        if version &gt;= (2, 0, 8):
            flagbit(SetupRunFlags.HideWizard)
        if version &gt;= (5, 1, 10):
            flagbit(SetupRunFlags.Bits32)
            flagbit(SetupRunFlags.Bits64)
        if version &gt;= (5, 2, 0):
            flagbit(SetupRunFlags.RunAsOriginalUser)
        if version &gt;= (6, 1, 0):
            flagbit(SetupRunFlags.DontLogParameters)
        if version &gt;= (6, 3, 0):
            flagbit(SetupRunFlags.LogOutput)

        reader.byte_align()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.TSetup"><code class="flex name class">
<span>class <span class="ident">TSetup</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1930-L2015" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TSetup(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.Header = h = SetupHeader(reader, version)

        def _array(count: int, parser: type[_T]) -&gt; list[_T]:
            return [parser(reader, version, self) for _ in range(count)]

        self.Languages = _array(h.LanguageCount, SetupLanguage)
        _default_codec = &#39;cp1252&#39;

        if version.unicode:
            self.Codec = &#39;utf-16le&#39;
        elif not self.Languages:
            self.Codec = _default_codec
        else:
            self.Codec = self.Languages[0].Codepage
            if any(language.Codepage == _default_codec for language in self.Languages):
                self.Codec = _default_codec

        if version.ascii:
            h.recode_strings(self.Codec)
        else:
            h.recode_strings(&#39;utf-16le&#39;)

        if h.Uninstallable == &#39;yes&#39;:
            h.Flags |= Flags.Uninstallable

        if version &lt; (4, 0, 0):
            self._load_wizard_and_decompressor(reader, version)

        self.Messages               = _array(h.MessageCount,         SetupMessage)       # noqa
        self.Permissions            = _array(h.PermissionCount,      SetupPermission)    # noqa
        self.Types                  = _array(h.TypeCount,            SetupType)          # noqa
        self.Components             = _array(h.ComponentCount,       SetupComponent)     # noqa
        self.Tasks                  = _array(h.TaskCount,            SetupTask)          # noqa
        self.Directories            = _array(h.DirectoryCount,       SetupDirectory)     # noqa
        self.Files                  = _array(h.FileCount,            SetupFile)          # noqa

        self._DecompressDLL = None
        self._DecryptionDLL = None

        self.Icons                  = _array(h.IconCount,            SetupIcon)          # noqa
        self.IniEntries             = _array(h.IniEntryCount,        SetupIniEntry)      # noqa
        self.RegistryEntries        = _array(h.RegistryCount,        SetupRegistryEntry) # noqa
        self.DeleteEntries          = _array(h.DeleteCount,          SetupDeleteEntry)   # noqa
        self.UninstallDeleteEntries = _array(h.UninstallDeleteCount, SetupDeleteEntry)   # noqa
        self.RunEntries             = _array(h.RunCount,             SetupRunEntry)      # noqa
        self.UninstallRunEntries    = _array(h.UninstallRunCount,    SetupRunEntry)      # noqa

        if version &gt;= (4, 0, 0):
            self._load_wizard_and_decompressor(reader, version)

    def get_wizard_images_large(self):
        return self._WizardImagesLarge

    def get_wizard_images_small(self):
        return self._WizardImagesSmall

    def get_decompress_dll(self):
        return self._DecompressDLL

    def get_decryption_dll(self):
        return self._DecryptionDLL

    def _load_wizard_and_decompressor(self, reader: StructReader[memoryview], version: InnoVersion):
        if True:
            self._WizardImagesLarge = self._load_wizard_images(reader, version)
        if version &gt;= (2, 0, 0) or version.isx:
            self._WizardImagesSmall = self._load_wizard_images(reader, version)
        method = self.Header.CompressionMethod
        crypto = self.Header.Flags &amp; Flags.EncryptionUsed and version &lt; (6, 4, 0)
        hasDLL = (
            method == CompressionMethod.BZip2
            or method == CompressionMethod.LZMA1 and version == (4, 1, 5)
            or method == CompressionMethod.Flate and version &gt;= (4, 2, 6))
        self._DecompressDLL = reader.read_length_prefixed() if hasDLL else None
        self._DecryptionDLL = reader.read_length_prefixed() if crypto else None

    def _load_wizard_images(self, reader: StructReader[memoryview], version: InnoVersion):
        count = reader.u32() if version &gt;= (5, 6, 0) else 1
        img = [reader.read_length_prefixed() for _ in range(count)]
        if version &lt; (5, 6, 0) and img and not img[0]:
            img.clear()
        return img</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.TSetup.get_wizard_images_large"><code class="name flex">
<span>def <span class="ident">get_wizard_images_large</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1984-L1985" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_wizard_images_large(self):
    return self._WizardImagesLarge</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.TSetup.get_wizard_images_small"><code class="name flex">
<span>def <span class="ident">get_wizard_images_small</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1987-L1988" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_wizard_images_small(self):
    return self._WizardImagesSmall</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.TSetup.get_decompress_dll"><code class="name flex">
<span>def <span class="ident">get_decompress_dll</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1990-L1991" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_decompress_dll(self):
    return self._DecompressDLL</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.TSetup.get_decryption_dll"><code class="name flex">
<span>def <span class="ident">get_decryption_dll</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L1993-L1994" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_decryption_dll(self):
    return self._DecryptionDLL</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupDataEntryFlags"><code class="flex name class">
<span>class <span class="ident">SetupDataEntryFlags</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2018-L2031" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupDataEntryFlags(enum.IntFlag):
    Empty                    = 0           # noqa    
    VersionInfoValid         = enum.auto() # noqa
    VersionInfoNotValid      = enum.auto() # noqa
    BZipped                  = enum.auto() # noqa
    TimeStampInUTC           = enum.auto() # noqa
    IsUninstallerExe         = enum.auto() # noqa
    CallInstructionOptimized = enum.auto() # noqa
    ApplyTouchDateTime       = enum.auto() # noqa
    ChunkEncrypted           = enum.auto() # noqa
    ChunkCompressed          = enum.auto() # noqa
    SolidBreak               = enum.auto() # noqa
    Sign                     = enum.auto() # noqa
    SignOnce                 = enum.auto() # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupDataEntryFlags.Empty"><code class="name">var <span class="ident">Empty</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDataEntryFlags.VersionInfoValid"><code class="name">var <span class="ident">VersionInfoValid</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDataEntryFlags.VersionInfoNotValid"><code class="name">var <span class="ident">VersionInfoNotValid</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDataEntryFlags.BZipped"><code class="name">var <span class="ident">BZipped</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDataEntryFlags.TimeStampInUTC"><code class="name">var <span class="ident">TimeStampInUTC</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDataEntryFlags.IsUninstallerExe"><code class="name">var <span class="ident">IsUninstallerExe</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDataEntryFlags.CallInstructionOptimized"><code class="name">var <span class="ident">CallInstructionOptimized</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDataEntryFlags.ApplyTouchDateTime"><code class="name">var <span class="ident">ApplyTouchDateTime</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDataEntryFlags.ChunkEncrypted"><code class="name">var <span class="ident">ChunkEncrypted</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDataEntryFlags.ChunkCompressed"><code class="name">var <span class="ident">ChunkCompressed</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDataEntryFlags.SolidBreak"><code class="name">var <span class="ident">SolidBreak</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDataEntryFlags.Sign"><code class="name">var <span class="ident">Sign</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupDataEntryFlags.SignOnce"><code class="name">var <span class="ident">SignOnce</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupSignMode"><code class="flex name class">
<span>class <span class="ident">SetupSignMode</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2034-L2038" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupSignMode(enum.IntEnum):
    NoSetting  = 0  # noqa
    Yes        = 1  # noqa
    Once       = 2  # noqa
    Check      = 3  # noqa</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.SetupSignMode.NoSetting"><code class="name">var <span class="ident">NoSetting</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupSignMode.Yes"><code class="name">var <span class="ident">Yes</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupSignMode.Once"><code class="name">var <span class="ident">Once</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.SetupSignMode.Check"><code class="name">var <span class="ident">Check</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.SetupDataEntry"><code class="flex name class">
<span>class <span class="ident">SetupDataEntry</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2041-L2119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SetupDataEntry(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.FirstSlice = reader.u32()
        self.LastSlice = reader.u32()
        self.ChunkOffset = reader.u32()
        if version &gt;= (4, 0, 1):
            self.Offset = reader.u64()
        self.FileSize = reader.u64()
        self.ChunkSize = reader.u64()

        if version &gt;= (6, 4, 0):
            self.ChecksumType = CheckSumType.SHA256
            self.Checksum = bytes(reader.read(32))
        elif version &gt;= (5, 3, 9):
            self.ChecksumType = CheckSumType.SHA1
            self.Checksum = bytes(reader.read(20))
        elif version &gt;= (4, 2, 0):
            self.ChecksumType = CheckSumType.MD5
            self.Checksum = bytes(reader.read(16))
        elif version &gt;= (4, 0, 1):
            self.ChecksumType = CheckSumType.CRC32
            self.Checksum = reader.u32()
        else:
            self.ChecksumType = CheckSumType.Adler32
            self.Checksum = reader.u32()

        ft = reader.u64()
        ts = datetime.fromtimestamp(
            (ft - _FILE_TIME_1970_01_01) / 10000000, timezone.utc)
        self.FileTime = ts

        self.FileVersionMs = reader.u32()
        self.FileVersionLs = reader.u32()

        self.Flags = 0

        def flagbit(f):
            self.Flags |= f if reader.read_bit() else 0

        flag_start = reader.tell()
        flagbit(SetupDataEntryFlags.VersionInfoValid)

        if version &lt; (6, 4, 3):
            flagbit(SetupDataEntryFlags.VersionInfoNotValid)
        if version &lt; (4, 0, 1):
            flagbit(SetupDataEntryFlags.BZipped)
        if (4, 0, 10) &lt;= version:
            flagbit(SetupDataEntryFlags.TimeStampInUTC)
        if (4, 1, 0) &lt;= version &lt; (6, 4, 3):
            flagbit(SetupDataEntryFlags.IsUninstallerExe)
        if (4, 1, 8) &lt;= version:
            flagbit(SetupDataEntryFlags.CallInstructionOptimized)
        if (4, 2, 0) &lt;= version &lt; (6, 4, 3):
            flagbit(SetupDataEntryFlags.ApplyTouchDateTime)
        if (4, 2, 2) &lt;= version:
            flagbit(SetupDataEntryFlags.ChunkEncrypted)
        if (4, 2, 5) &lt;= version:
            flagbit(SetupDataEntryFlags.ChunkCompressed)
        if (5, 1, 13) &lt;= version &lt; (6, 4, 3):
            flagbit(SetupDataEntryFlags.SolidBreak)
        if (5, 5, 7) &lt;= version &lt; (6, 3, 0):
            flagbit(SetupDataEntryFlags.Sign)
            flagbit(SetupDataEntryFlags.SignOnce)

        reader.byte_align()

        if (reader.tell() - flag_start) % 2:
            reader.u8()

        if (6, 3, 0) &lt;= version &lt; (6, 4, 3):
            self.SignMode = SetupSignMode(reader.u8())
        elif self.Flags &amp; SetupDataEntryFlags.SignOnce:
            self.SignMode = SetupSignMode.Once
        elif self.Flags &amp; SetupDataEntryFlags.Sign:
            self.SignMode = SetupSignMode.Yes
        else:
            self.SignMode = SetupSignMode.NoSetting</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.TData"><code class="flex name class">
<span>class <span class="ident">TData</span></span>
<span>(</span><span>reader, version)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2122-L2128" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TData(InnoStruct):

    def __init__(self, reader: StructReader[memoryview], version: InnoVersion):
        super().__init__(reader, version)
        self.DataEntries: list[SetupDataEntry] = []
        while not reader.eof:
            self.DataEntries.append(SetupDataEntry(reader, version))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></li>
<li><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></li>
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="refinery.lib.inno.archive.InnoParseResult"><code class="flex name class">
<span>class <span class="ident">InnoParseResult</span></span>
<span>(</span><span>version, streams, files, warnings, failures, setup_info, setup_data)</span>
</code></dt>
<dd>
<section class="desc"><p>InnoParseResult(version, streams, files, warnings, failures, setup_info, setup_data)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2131-L2141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoParseResult(NamedTuple):
    version: InnoVersion
    streams: list[InnoStream]
    files: list[InnoFile]
    warnings: int
    failures: list[str]
    setup_info: TSetup
    setup_data: TData

    def ok(self):
        return self.warnings == 0 and not self.failures</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.InnoParseResult.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2131-L2141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoParseResult(NamedTuple):
    version: InnoVersion
    streams: list[InnoStream]
    files: list[InnoFile]
    warnings: int
    failures: list[str]
    setup_info: TSetup
    setup_data: TData

    def ok(self):
        return self.warnings == 0 and not self.failures</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoParseResult.streams"><code class="name">var <span class="ident">streams</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2131-L2141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoParseResult(NamedTuple):
    version: InnoVersion
    streams: list[InnoStream]
    files: list[InnoFile]
    warnings: int
    failures: list[str]
    setup_info: TSetup
    setup_data: TData

    def ok(self):
        return self.warnings == 0 and not self.failures</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoParseResult.files"><code class="name">var <span class="ident">files</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2131-L2141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoParseResult(NamedTuple):
    version: InnoVersion
    streams: list[InnoStream]
    files: list[InnoFile]
    warnings: int
    failures: list[str]
    setup_info: TSetup
    setup_data: TData

    def ok(self):
        return self.warnings == 0 and not self.failures</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoParseResult.warnings"><code class="name">var <span class="ident">warnings</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2131-L2141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoParseResult(NamedTuple):
    version: InnoVersion
    streams: list[InnoStream]
    files: list[InnoFile]
    warnings: int
    failures: list[str]
    setup_info: TSetup
    setup_data: TData

    def ok(self):
        return self.warnings == 0 and not self.failures</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoParseResult.failures"><code class="name">var <span class="ident">failures</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 4</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2131-L2141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoParseResult(NamedTuple):
    version: InnoVersion
    streams: list[InnoStream]
    files: list[InnoFile]
    warnings: int
    failures: list[str]
    setup_info: TSetup
    setup_data: TData

    def ok(self):
        return self.warnings == 0 and not self.failures</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoParseResult.setup_info"><code class="name">var <span class="ident">setup_info</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 5</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2131-L2141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoParseResult(NamedTuple):
    version: InnoVersion
    streams: list[InnoStream]
    files: list[InnoFile]
    warnings: int
    failures: list[str]
    setup_info: TSetup
    setup_data: TData

    def ok(self):
        return self.warnings == 0 and not self.failures</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoParseResult.setup_data"><code class="name">var <span class="ident">setup_data</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 6</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2131-L2141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoParseResult(NamedTuple):
    version: InnoVersion
    streams: list[InnoStream]
    files: list[InnoFile]
    warnings: int
    failures: list[str]
    setup_info: TSetup
    setup_data: TData

    def ok(self):
        return self.warnings == 0 and not self.failures</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.InnoParseResult.ok"><code class="name flex">
<span>def <span class="ident">ok</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2140-L2141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ok(self):
    return self.warnings == 0 and not self.failures</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.InnoStreams"><code class="flex name class">
<span>class <span class="ident">InnoStreams</span></span>
<span>(</span><span>TSetup, TData, Uninstaller)</span>
</code></dt>
<dd>
<section class="desc"><p>InnoStreams(TSetup, TData, Uninstaller)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2144-L2147" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoStreams(NamedTuple):
    TSetup: InnoStream
    TData: InnoStream
    Uninstaller: InnoStream</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.InnoStreams.TSetup"><code class="name">var <span class="ident">TSetup</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2144-L2147" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoStreams(NamedTuple):
    TSetup: InnoStream
    TData: InnoStream
    Uninstaller: InnoStream</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoStreams.TData"><code class="name">var <span class="ident">TData</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2144-L2147" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoStreams(NamedTuple):
    TSetup: InnoStream
    TData: InnoStream
    Uninstaller: InnoStream</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoStreams.Uninstaller"><code class="name">var <span class="ident">Uninstaller</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2144-L2147" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoStreams(NamedTuple):
    TSetup: InnoStream
    TData: InnoStream
    Uninstaller: InnoStream</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.archive.InnoArchive"><code class="flex name class">
<span>class <span class="ident">InnoArchive</span></span>
<span>(</span><span>data, unit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>This class represents an InnoSetup archive. Optionally, a <code><a title="refinery.units.Unit" href="../../units/index.html#refinery.units.Unit">Unit</a></code> can be
passed to the class as a parameter to use its logger.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2150-L2774" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class InnoArchive:
    &#34;&#34;&#34;
    This class represents an InnoSetup archive. Optionally, a `refinery.units.Unit` can be
    passed to the class as a parameter to use its logger.
    &#34;&#34;&#34;
    OffsetsPath: ClassVar[str] = &#39;RCDATA/11111/0&#39;
    ChunkPrefix: ClassVar[bytes] = b&#39;zlb\x1a&#39;

    def __init__(
        self,
        data: bytearray,
        unit: Unit | None = None,
    ):
        if not (meta := TSetupOffsets.FindInBinary(data)):
            try:
                _meta = one(data | perc(self.OffsetsPath))
            except Exception as E:
                raise ValueError(F&#39;Could not find TSetupOffsets PE resource at {self.OffsetsPath}&#39;) from E
            else:
                meta = TSetupOffsets(_meta)

        self._password = None
        self._password_guessed = False

        leniency = unit.leniency if unit else 0
        self._log_verbose = (lambda *_: None) if unit is None else unit.log_debug
        self._log_comment = (lambda *_: None) if unit is None else unit.log_info
        self._log_warning = (lambda *_: None) if unit is None else unit.log_warn

        self.meta = meta
        self.view = view = memoryview(data)

        base = meta.base
        inno = StructReader(view[base:base + meta.total_size])

        self._decompressed = {}

        blobsize = meta.info_offset - meta.data_offset
        inno.seek(meta.data_offset)
        self.blobs = blobs = StructReader(inno.read(blobsize))

        header = bytes(inno.read(16))

        try:
            version = InnoVersion.ParseLegacy(header)
        except ValueError:
            header += bytes(inno.read(64 - 16))
            try:
                version = InnoVersion.Parse(header)
            except ValueError:
                if version := meta.iv:
                    method = &#39;magic&#39;
                else:
                    name, _, _rest = header.partition(b&#39;\0&#39;)
                    method = &#39;broken&#39;
                    if any(_rest):
                        header = name.hex()
                    else:
                        header = name.decode(&#39;latin1&#39;)
                    if leniency &lt; 1:
                        raise ValueError(F&#39;unable to parse header identifier &#34;{header}&#34;&#39;)
                    version = _DEFAULT_INNO_VERSION
            else:
                header, _, _ = header.partition(B&#39;\0&#39;)
                header = header.decode(&#39;latin1&#39;)
                method = &#39;modern&#39;
        else:
            header, _, _ = header.partition(B&#39;\x1A&#39;)
            header = header.decode(&#39;latin1&#39;)
            method = &#39;legacy&#39;

        self._log_comment(F&#39;inno {version!s} via {method} header: {header}&#39;)

        class _notok:
            def __init__(self, e: Exception):
                self.failures = [str(e)]

            def ok(self):
                return False

        def _parse(v: InnoVersion):
            inno.seekset(inno_start)
            if inno.eof:
                raise EOFError
            try:
                if v.legacy:
                    inno.seekrel(-48)
                r = self._try_parse_as(inno, blobs, v)
            except Exception as e:
                nonlocal best_error
                best_error = best_error or e
                self._log_comment(F&#39;exception while parsing as {v!s}: {exception_to_string(e)}&#39;)
                return _notok(e)
            else:
                results[v] = r
                return r

        inno_start = inno.tell()
        best_parse = None
        best_score = 0
        best_error = None
        success = False
        results: dict[InnoVersion, InnoParseResult] = {}

        VER = _VERSIONS
        AMB = _IS_AMBIGUOUS

        if not version.is_ambiguous():
            index = VER.index(version)
        else:
            try:
                index = max(k for k, v in enumerate(VER) if v &lt;= version)
            except Exception:
                index = 0

        lower = index
        upper = index + 1
        while lower &gt; 0 and AMB[VER[lower - 1]] or VER[lower - 1].semver == VER[lower].semver:
            lower -= 1

        versions = [version] + VER[lower:upper] + VER[upper:] + VER[:lower]

        for v in versions:
            if success := (result := _parse(v)).ok():
                if v != version:
                    self._log_comment(F&#39;inno {v!s} via closest match: {header}&#39;)
                break
            if not result.failures and (best_parse is None or result.warnings &lt; best_score):
                best_score = best_score
                best_parse = result

        if not success:
            if best_parse is not None:
                result = best_parse
                self._log_warning(F&#39;using parse result for {result.version!s} with {result.warnings} warnings&#39;)
            else:
                if not results:
                    if best_error:
                        raise best_error
                    raise ValueError(&#39;no parser for any known Inno version worked&#39;)
                result = min(results.values(), key=lambda result: len(result.failures))
                self._log_warning(F&#39;using parse result for {result.version!s} with {len(result.failures)} failures&#39;)
                for k, failure in enumerate(result.failures, 1):
                    self._log_comment(F&#39;failure {k}: {failure}&#39;)

        self.version = version = result.version
        self.codec = codec = result.setup_info.Codec
        self.setup_info = result.setup_info
        self.setup_data = result.setup_data
        self.files = result.files
        self.streams = InnoStreams(*result.streams)
        self.script_codec = &#39;latin1&#39; if version.unicode else codec

        try:
            emulator = self.emulator
        except Exception:
            pass
        else:
            for file in self.files:
                path = emulator.reset().expand_constant(file.path)
                path = path.replace(&#39;\\&#39;, &#39;/&#39;)
                drive, colon, path = path.rpartition(&#39;:/&#39;)
                if colon and len(drive) == 1:
                    path = F&#39;{drive}/{path}&#39;
                file.path = F&#39;data/{path}&#39;

    @cached_property
    def emulator(self):
        from refinery.lib.inno.emulator import (
            IFPSEmulatorConfig,
            InnoSetupEmulator,
        )
        return InnoSetupEmulator(self, IFPSEmulatorConfig(
            temp_path=&#39;{tmp}&#39;,
            user_name=&#39;{user}&#39;,
            host_name=&#39;{host}&#39;,
            inno_name=&#39;{name}&#39;,
            executable=&#39;{exe}&#39;,
            install_to=&#39;{app}&#39;,
            log_mutexes=False,
            log_opcodes=False,
            log_passwords=True,
        ))

    @cached_property
    def ifps(self):
        &#34;&#34;&#34;
        An `refinery.lib.inno.ifps.IFPSFile` representing the embedded IFPS script, if it exists.
        &#34;&#34;&#34;
        if script := self.setup_info.Header.get_script():
            return IFPSFile(script, self.script_codec, self.version.unicode)

    def guess_password(self, timeout: int) -&gt; bool:
        &#34;&#34;&#34;
        Attempt to guess the password by emulating the setup script.
        &#34;&#34;&#34;
        if self._password_guessed:
            return self._password is not None
        self._password_guessed = True
        if file := self.get_encrypted_sample():
            from refinery.lib.inno.emulator import NewPassword
            self._log_verbose(&#39;attempting to automatically determine password from the embedded script&#39;)
            try:
                for p in self.emulator.reset().emulate_installation():
                    if not isinstance(p, NewPassword):
                        continue
                    if self.check_password(file, p):
                        self._log_comment(&#39;found password via emulation:&#39;, p)
                        self._password = p
                        return True
                else:
                    self._log_comment(&#39;no valid password found via emulation&#39;)
                    return False
            except Exception as error:
                self._log_comment(&#39;emuluation failed:&#39;, error)
        else:
            self._password = &#39;&#39;
            return True

    def get_encrypted_sample(inno) -&gt; InnoFile | None:
        &#34;&#34;&#34;
        If the archive has a password, this function returns the smallest encrypted file record.
        &#34;&#34;&#34;
        file = min(inno.files, key=lambda f: (not f.encrypted, f.size))
        return file if file.encrypted else None

    def _try_parse_as(
        self,
        inno: StructReader,
        blobs: StructReader,
        version: InnoVersion,
        max_failures: int = 5
    ):
        streams: list[InnoStream] = []
        files: list[InnoFile] = []
        warnings = 0

        for _ in range(3):
            stream = InnoStream(StreamHeader(inno, version))
            streams.append(stream)
            to_read = stream.header.StoredSize
            while to_read &gt; 4:
                block = CrcCompressedBlock(inno, min(to_read - 4, 0x1000))
                stream.blocks.append(block)
                to_read -= len(block)

        self._log_verbose(F&#39;{version!s} parsing stream 1 (TData)&#39;)
        stream1 = TData(memoryview(self.read_stream(streams[1])), version)

        for meta in stream1.DataEntries:
            file = InnoFile(blobs, version, meta)
            files.append(file)

        self._log_verbose(F&#39;{version!s} parsing stream 0 (TSetup)&#39;)
        stream0 = TSetup(memoryview(self.read_stream(streams[0])), version)
        path_dedup: dict[str, list[SetupFile]] = {}

        for file in files:
            file.compression_method = stream0.Header.CompressionMethod
            file.password_hash = stream0.Header.PasswordHash
            file.password_type = stream0.Header.PasswordType
            file.password_salt = stream0.Header.PasswordSalt

        for sf in stream0.Files:
            sf: SetupFile
            location = sf.Location
            if location == 0xFFFFFFFF or sf.Type != SetupFileType.UserFile or sf.Source:
                msg = F&#39;skipping file: offset=0x{location:08X} type={sf.Type.name}&#39;
                if sf.Source:
                    msg = F&#39;{msg} src={sf.Source}&#39;
                self._log_verbose(msg)
                continue
            if location &gt;= len(files):
                self._log_warning(F&#39;parsed {len(file)} entries, ignoring invalid setup reference to entry {location + 1}&#39;)
                continue
            path = sf.Destination.replace(&#39;\\&#39;, &#39;/&#39;)
            path_dedup.setdefault(path, []).append(sf)
            files[location].setup = sf
            files[location].path = path

        for path, infos in list(path_dedup.items()):
            if len(infos) == 1:
                continue
            del path_dedup[path]
            for sf in infos:
                if condition := sf.Condition.Check:
                    condition = re.sub(&#39;\\s+&#39;, &#39;-&#39;, condition)
                    np = F&#39;{condition}/{path}&#39;
                    path_dedup.setdefault(np, []).append(sf)

        for path, infos in path_dedup.items():
            if len(infos) == 1:
                files[infos[0].Location].path = path
                continue
            bycheck = {}
            for info in infos:
                file = files[info.Location]
                if not file.checksum_type.strong():
                    bycheck.clear()
                    break
                dkey = (file.checksum, file.size)
                if dkey in bycheck:
                    self._log_verbose(F&#39;skipping exact duplicate: {path}&#39;)
                    file.dupe = True
                    continue
                bycheck[dkey] = info
            if bycheck:
                if len(bycheck) == 1:
                    file.path = path
                    continue
                infos = list(bycheck.values())
            for k, info in enumerate(infos):
                files[info.Location].path = F&#39;{path}[{k}]&#39;

        _width = len(str(len(files)))

        for k, file in enumerate(files):
            if file.dupe:
                continue
            if not file.path:
                self._log_verbose(F&#39;file {k} does not have a path&#39;)
                file.path = F&#39;raw/FileData{k:0{_width}d}&#39;

        warnings = sum(1 for file in files if file.setup is None)
        failures = []
        nonempty = [f for f in files if f.size &gt; 0]

        self._decompressed.clear()

        for file in nonempty:
            if len(failures) &gt;= max_failures:
                break
            if file.setup is None:
                failures.append(F&#39;file {file.path} had no associated metadata&#39;)
                continue
            if file.chunk_length &lt; 0x10000:
                try:
                    data = self.read_file(file)
                except InvalidPassword:
                    continue
                except Exception as e:
                    failures.append(F&#39;extraction error for {file.path}: {e!s}&#39;)
                    continue
                if file.check(data) != file.checksum:
                    failures.append(F&#39;invalid checksum for {file.path}&#39;)

        return InnoParseResult(
            version,
            streams,
            files,
            warnings,
            failures,
            stream0,
            stream1,
        )

    def read_stream(self, stream: InnoStream):
        &#34;&#34;&#34;
        Decompress and read the input stream.
        &#34;&#34;&#34;
        if stream.data is not None:
            return stream.data
        result = bytearray()
        it = iter(stream.blocks)
        if stream.compression == StreamCompressionMethod.Store:
            class _dummy:
                def decompress(self, b):
                    return b
            dec = _dummy()
        elif stream.compression == StreamCompressionMethod.LZMA1:
            import lzma
            first = next(it).BlockData
            prop, first = first[:5], first[5:]
            filter = parse_lzma_properties(prop, 1)
            dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[filter])
            result.extend(dec.decompress(first))
        elif stream.compression == StreamCompressionMethod.Flate:
            import zlib
            dec = zlib.decompressobj()
        for block in it:
            result.extend(dec.decompress(block.BlockData))
        stream.data = result
        return result

    def check_password(self, file: InnoFile, password: str):
        &#34;&#34;&#34;
        Returns `True` if the given password correctly decrypts the given file.
        &#34;&#34;&#34;
        try:
            self.read_chunk(file, password, check_only=True)
        except InvalidPassword:
            return False
        else:
            return True

    def read_chunk(self, file: InnoFile, password: str | None = None, check_only: bool = False):
        &#34;&#34;&#34;
        Decompress and read the chunk containing the given file. If the chunk is encrypted, the
        function requires the correct password. If the `check_only` parameter is set, then only
        a password check is performed, but the chunk is not actually decompressed.
        &#34;&#34;&#34;
        reader = file.reader
        offset = file.chunk_offset
        length = file.chunk_length
        method = file.compression

        if password is None:
            password = self._password

        if offset + length &gt; len(reader):
            span = F&#39;0x{offset:X}-0x{offset + length:X}&#39;
            raise LookupError(
                F&#39;Chunk spans 0x{len(file.reader):X} bytes; data is located at {span}.&#39;)

        reader.seek(offset)
        prefix = reader.read(4)

        if prefix != self.ChunkPrefix:
            raise ValueError(F&#39;Error reading chunk at offset 0x{offset:X}; invalid magic {prefix.hex()}.&#39;)

        if file.encrypted:
            if file.password_type == PasswordType.Nothing:
                raise RuntimeError(F&#39;File {file.path} is encrypted, but no password type was set.&#39;)
            if password is None:
                raise InvalidPassword
            if file.password_type == PasswordType.XChaCha20:
                salt, iterations, nonce = struct.unpack(&#39;=16sI24s&#39;, file.password_salt)
                key = password.encode(self.script_codec) | pbkdf2(32, salt, iterations, &#39;SHA256&#39;) | bytes
                test_nonce = list(struct.unpack(&#39;6I&#39;, nonce))
                test_nonce[2] = ~test_nonce[2]
                test_nonce = struct.pack(&#39;6I&#39;, test_nonce)
                if B&#39;\0\0\0\0&#39; | xchacha(key, nonce=test_nonce) | bytes != file.password_hash:
                    raise InvalidPassword(password)
                decryptor = xchacha(key, nonce=nonce)
            else:
                password_bytes = password.encode(
                    &#39;utf-16le&#39; if file.unicode else self.script_codec)
                algorithm = {
                    PasswordType.SHA1: sha1,
                    PasswordType.MD5 : md5,
                }[file.password_type]
                hash = algorithm(b&#39;PasswordCheckHash&#39; + file.password_salt)
                hash.update(password_bytes)
                if hash.digest() != file.password_hash:
                    raise InvalidPassword(password)
                hash = algorithm(reader.read(8))
                hash.update(password_bytes)
                decryptor = rc4(hash.digest(), discard=1000)

        if check_only:
            return

        data = reader.read_exactly(length)

        if file.encrypted:
            data = data | decryptor | bytearray

        if method is None:
            return chunk

        try:
            if method == CompressionMethod.Store:
                chunk = data
            elif method == CompressionMethod.LZMA1:
                props = parse_lzma_properties(data[0:5], 1)
                dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[props])
                chunk = dec.decompress(data[5:])
            elif method == CompressionMethod.LZMA2:
                props = parse_lzma_properties(data[0:1], 2)
                dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[props])
                chunk = dec.decompress(data[1:])
            elif method == CompressionMethod.BZip2:
                chunk = bz2.decompress(data)
            elif method == CompressionMethod.Flate:
                chunk = zlib.decompress(data)
        except Exception as E:
            if not file.encrypted:
                raise
            raise InvalidPassword(password) from E

        return chunk

    def read_file(
        self,
        file: InnoFile,
        password: str | None = None,
    ):
        &#34;&#34;&#34;
        Read the contents of the given file record from the archive without performing any checks.
        See also `refinery.lib.inno.InnoArchive.read_file_and_check`.
        &#34;&#34;&#34;
        offset = file.chunk_offset
        length = file.chunk_length

        try:
            chunk = self._decompressed[offset, length]
        except KeyError:
            chunk = self._decompressed[offset, length] = self.read_chunk(file, password)

        view = memoryview(chunk)
        data = view[file.offset:file.offset + file.size]

        if file.filtered:
            if file.version &gt;= (5, 2, 0):
                flip = (file.version &gt;= (5, 3, 9))
                data = self._filter_new(data, flip_high_byte=flip)
            else:
                data = self._filter_old(data)

        return data

    def read_file_and_check(
        self,
        file: InnoFile,
        password: str | None = None,
    ):
        &#34;&#34;&#34;
        Read the contents of the given file record from the archive. Raises a `ValueError` if the
        checksum is invalid.
        &#34;&#34;&#34;
        data = self.read_file(file, password)

        if (cs := file.check(data)) is not None and cs != file.checksum:
            if isinstance(cs, int):
                computed = F&#39;{cs:08X}&#39;
                expected = F&#39;{file.checksum:08X}&#39;
            else:
                computed = cs.hex().upper()
                expected = file.checksum.hex().upper()
            raise ValueError(F&#39;checksum error; computed:{computed} expected:{expected}&#39;)

        return data

    def _filter_new(self, data: buf, flip_high_byte=False):
        try:
            import numpy as np
        except ImportError:
            return self._filter_new_fallback(data, flip_high_byte)
        u08 = np.uint8
        u32 = np.uint32
        ab0 = bytearray()
        ab1 = bytearray()
        ab2 = bytearray()
        ab3 = bytearray()
        positions = []
        if isinstance(data, bytearray):
            out = data
        else:
            out = bytearray(data)
        mem = memoryview(out)
        for k in range(0, len(mem), 0x10000):
            for match in re.finditer(B&#39;(?s)[\xE8\xE9]....&#39;, mem[k:k + 0x10000], flags=re.DOTALL):
                a = match.start() + k
                top = mem[a + 4]
                if top != 0x00 and top != 0xFF:
                    continue
                ab0.append(mem[a + 1])
                ab1.append(mem[a + 2])
                ab2.append(mem[a + 3])
                ab3.append(top)
                positions.append(a + 5)
        ab0 = np.frombuffer(ab0, dtype=u08)
        ab1 = np.frombuffer(ab1, dtype=u08)
        low = np.frombuffer(ab2, dtype=u08).astype(u32)
        msb = np.frombuffer(ab3, dtype=u08)
        sub = np.fromiter(positions, dtype=u32)
        low &lt;&lt;= 8
        low += ab1
        low &lt;&lt;= 8
        low += ab0
        low -= sub
        low &amp;= 0xFFFFFF
        if flip_high_byte:
            flips = low &gt;&gt; 23
            keeps = 1 - flips
            keeps *= msb
            msb ^= 0xFF
            msb *= flips
            msb += keeps
        low += (msb.astype(u32) &lt;&lt; 24)
        addresses = low.tobytes()
        for k, offset in enumerate(positions):
            out[offset - 4:offset] = addresses[k * 4:(k + 1) * 4]
        return out

    def _filter_new_fallback(self, data: buf, flip_high_byte=False):
        block_size = 0x10000
        out = bytearray(data)
        i = 0
        while len(data) - i &gt;= 5:
            c = out[i]
            block_size_left = block_size - (i % block_size)
            i += 1
            if (c == 0xE8 or c == 0xE9) and block_size_left &gt;= 5:
                address = out[i:i + 4]
                i += 4
                if address[3] == 0 or address[3] == 0xFF:
                    rel = address[0] | address[1] &lt;&lt; 8 | address[2] &lt;&lt; 16
                    rel -= i &amp; 0xFFFFFF
                    out[i - 4] = rel &amp; 0xFF
                    out[i - 3] = (rel &gt;&gt; 8) &amp; 0xFF
                    out[i - 2] = (rel &gt;&gt; 16) &amp; 0xFF
                    if flip_high_byte and (rel &amp; 0x800000) != 0:
                        out[i - 1] = (~out[i - 1]) &amp; 0xFF
        return out

    @staticmethod
    def _filter_old(data: buf):
        if not isinstance(data, bytearray):
            data = bytearray(data)
        addr_bytes_left = 0
        addr_offset = 5
        addr = 0
        for i, c in enumerate(data):
            if addr_bytes_left == 0:
                if c == 0xE8 or c == 0xE9:
                    addr = (~addr_offset + 1) &amp; 0xFFFFFFFF
                    addr_bytes_left = 4
            else:
                addr = (addr + c) &amp; 0xFFFFFFFF
                c = addr &amp; 0xFF
                addr = addr &gt;&gt; 8
                addr_bytes_left -= 1
            data[i] = c
        return data</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.InnoArchive.OffsetsPath"><code class="name">var <span class="ident">OffsetsPath</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.archive.InnoArchive.ChunkPrefix"><code class="name">var <span class="ident">ChunkPrefix</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.archive.InnoArchive.emulator"><code class="name">var <span class="ident">emulator</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2316-L2332" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cached_property
def emulator(self):
    from refinery.lib.inno.emulator import (
        IFPSEmulatorConfig,
        InnoSetupEmulator,
    )
    return InnoSetupEmulator(self, IFPSEmulatorConfig(
        temp_path=&#39;{tmp}&#39;,
        user_name=&#39;{user}&#39;,
        host_name=&#39;{host}&#39;,
        inno_name=&#39;{name}&#39;,
        executable=&#39;{exe}&#39;,
        install_to=&#39;{app}&#39;,
        log_mutexes=False,
        log_opcodes=False,
        log_passwords=True,
    ))</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoArchive.ifps"><code class="name">var <span class="ident">ifps</span></code></dt>
<dd>
<section class="desc"><p>An <code><a title="refinery.lib.inno.ifps.IFPSFile" href="ifps.html#refinery.lib.inno.ifps.IFPSFile">IFPSFile</a></code> representing the embedded IFPS script, if it exists.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2334-L2340" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@cached_property
def ifps(self):
    &#34;&#34;&#34;
    An `refinery.lib.inno.ifps.IFPSFile` representing the embedded IFPS script, if it exists.
    &#34;&#34;&#34;
    if script := self.setup_info.Header.get_script():
        return IFPSFile(script, self.script_codec, self.version.unicode)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.archive.InnoArchive.guess_password"><code class="name flex">
<span>def <span class="ident">guess_password</span></span>(<span>self, timeout)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempt to guess the password by emulating the setup script.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2342-L2367" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def guess_password(self, timeout: int) -&gt; bool:
    &#34;&#34;&#34;
    Attempt to guess the password by emulating the setup script.
    &#34;&#34;&#34;
    if self._password_guessed:
        return self._password is not None
    self._password_guessed = True
    if file := self.get_encrypted_sample():
        from refinery.lib.inno.emulator import NewPassword
        self._log_verbose(&#39;attempting to automatically determine password from the embedded script&#39;)
        try:
            for p in self.emulator.reset().emulate_installation():
                if not isinstance(p, NewPassword):
                    continue
                if self.check_password(file, p):
                    self._log_comment(&#39;found password via emulation:&#39;, p)
                    self._password = p
                    return True
            else:
                self._log_comment(&#39;no valid password found via emulation&#39;)
                return False
        except Exception as error:
            self._log_comment(&#39;emuluation failed:&#39;, error)
    else:
        self._password = &#39;&#39;
        return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoArchive.get_encrypted_sample"><code class="name flex">
<span>def <span class="ident">get_encrypted_sample</span></span>(<span>inno)</span>
</code></dt>
<dd>
<section class="desc"><p>If the archive has a password, this function returns the smallest encrypted file record.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2369-L2374" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_encrypted_sample(inno) -&gt; InnoFile | None:
    &#34;&#34;&#34;
    If the archive has a password, this function returns the smallest encrypted file record.
    &#34;&#34;&#34;
    file = min(inno.files, key=lambda f: (not f.encrypted, f.size))
    return file if file.encrypted else None</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoArchive.read_stream"><code class="name flex">
<span>def <span class="ident">read_stream</span></span>(<span>self, stream)</span>
</code></dt>
<dd>
<section class="desc"><p>Decompress and read the input stream.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2506-L2532" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_stream(self, stream: InnoStream):
    &#34;&#34;&#34;
    Decompress and read the input stream.
    &#34;&#34;&#34;
    if stream.data is not None:
        return stream.data
    result = bytearray()
    it = iter(stream.blocks)
    if stream.compression == StreamCompressionMethod.Store:
        class _dummy:
            def decompress(self, b):
                return b
        dec = _dummy()
    elif stream.compression == StreamCompressionMethod.LZMA1:
        import lzma
        first = next(it).BlockData
        prop, first = first[:5], first[5:]
        filter = parse_lzma_properties(prop, 1)
        dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[filter])
        result.extend(dec.decompress(first))
    elif stream.compression == StreamCompressionMethod.Flate:
        import zlib
        dec = zlib.decompressobj()
    for block in it:
        result.extend(dec.decompress(block.BlockData))
    stream.data = result
    return result</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoArchive.check_password"><code class="name flex">
<span>def <span class="ident">check_password</span></span>(<span>self, file, password)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns <code>True</code> if the given password correctly decrypts the given file.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2534-L2543" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check_password(self, file: InnoFile, password: str):
    &#34;&#34;&#34;
    Returns `True` if the given password correctly decrypts the given file.
    &#34;&#34;&#34;
    try:
        self.read_chunk(file, password, check_only=True)
    except InvalidPassword:
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoArchive.read_chunk"><code class="name flex">
<span>def <span class="ident">read_chunk</span></span>(<span>self, file, password=None, check_only=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Decompress and read the chunk containing the given file. If the chunk is encrypted, the
function requires the correct password. If the <code>check_only</code> parameter is set, then only
a password check is performed, but the chunk is not actually decompressed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2545-L2630" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_chunk(self, file: InnoFile, password: str | None = None, check_only: bool = False):
    &#34;&#34;&#34;
    Decompress and read the chunk containing the given file. If the chunk is encrypted, the
    function requires the correct password. If the `check_only` parameter is set, then only
    a password check is performed, but the chunk is not actually decompressed.
    &#34;&#34;&#34;
    reader = file.reader
    offset = file.chunk_offset
    length = file.chunk_length
    method = file.compression

    if password is None:
        password = self._password

    if offset + length &gt; len(reader):
        span = F&#39;0x{offset:X}-0x{offset + length:X}&#39;
        raise LookupError(
            F&#39;Chunk spans 0x{len(file.reader):X} bytes; data is located at {span}.&#39;)

    reader.seek(offset)
    prefix = reader.read(4)

    if prefix != self.ChunkPrefix:
        raise ValueError(F&#39;Error reading chunk at offset 0x{offset:X}; invalid magic {prefix.hex()}.&#39;)

    if file.encrypted:
        if file.password_type == PasswordType.Nothing:
            raise RuntimeError(F&#39;File {file.path} is encrypted, but no password type was set.&#39;)
        if password is None:
            raise InvalidPassword
        if file.password_type == PasswordType.XChaCha20:
            salt, iterations, nonce = struct.unpack(&#39;=16sI24s&#39;, file.password_salt)
            key = password.encode(self.script_codec) | pbkdf2(32, salt, iterations, &#39;SHA256&#39;) | bytes
            test_nonce = list(struct.unpack(&#39;6I&#39;, nonce))
            test_nonce[2] = ~test_nonce[2]
            test_nonce = struct.pack(&#39;6I&#39;, test_nonce)
            if B&#39;\0\0\0\0&#39; | xchacha(key, nonce=test_nonce) | bytes != file.password_hash:
                raise InvalidPassword(password)
            decryptor = xchacha(key, nonce=nonce)
        else:
            password_bytes = password.encode(
                &#39;utf-16le&#39; if file.unicode else self.script_codec)
            algorithm = {
                PasswordType.SHA1: sha1,
                PasswordType.MD5 : md5,
            }[file.password_type]
            hash = algorithm(b&#39;PasswordCheckHash&#39; + file.password_salt)
            hash.update(password_bytes)
            if hash.digest() != file.password_hash:
                raise InvalidPassword(password)
            hash = algorithm(reader.read(8))
            hash.update(password_bytes)
            decryptor = rc4(hash.digest(), discard=1000)

    if check_only:
        return

    data = reader.read_exactly(length)

    if file.encrypted:
        data = data | decryptor | bytearray

    if method is None:
        return chunk

    try:
        if method == CompressionMethod.Store:
            chunk = data
        elif method == CompressionMethod.LZMA1:
            props = parse_lzma_properties(data[0:5], 1)
            dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[props])
            chunk = dec.decompress(data[5:])
        elif method == CompressionMethod.LZMA2:
            props = parse_lzma_properties(data[0:1], 2)
            dec = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[props])
            chunk = dec.decompress(data[1:])
        elif method == CompressionMethod.BZip2:
            chunk = bz2.decompress(data)
        elif method == CompressionMethod.Flate:
            chunk = zlib.decompress(data)
    except Exception as E:
        if not file.encrypted:
            raise
        raise InvalidPassword(password) from E

    return chunk</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoArchive.read_file"><code class="name flex">
<span>def <span class="ident">read_file</span></span>(<span>self, file, password=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Read the contents of the given file record from the archive without performing any checks.
See also <code>refinery.lib.inno.InnoArchive.read_file_and_check</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2632-L2659" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_file(
    self,
    file: InnoFile,
    password: str | None = None,
):
    &#34;&#34;&#34;
    Read the contents of the given file record from the archive without performing any checks.
    See also `refinery.lib.inno.InnoArchive.read_file_and_check`.
    &#34;&#34;&#34;
    offset = file.chunk_offset
    length = file.chunk_length

    try:
        chunk = self._decompressed[offset, length]
    except KeyError:
        chunk = self._decompressed[offset, length] = self.read_chunk(file, password)

    view = memoryview(chunk)
    data = view[file.offset:file.offset + file.size]

    if file.filtered:
        if file.version &gt;= (5, 2, 0):
            flip = (file.version &gt;= (5, 3, 9))
            data = self._filter_new(data, flip_high_byte=flip)
        else:
            data = self._filter_old(data)

    return data</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.archive.InnoArchive.read_file_and_check"><code class="name flex">
<span>def <span class="ident">read_file_and_check</span></span>(<span>self, file, password=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Read the contents of the given file record from the archive. Raises a <code>ValueError</code> if the
checksum is invalid.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/archive.py#L2661-L2681" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_file_and_check(
    self,
    file: InnoFile,
    password: str | None = None,
):
    &#34;&#34;&#34;
    Read the contents of the given file record from the archive. Raises a `ValueError` if the
    checksum is invalid.
    &#34;&#34;&#34;
    data = self.read_file(file, password)

    if (cs := file.check(data)) is not None and cs != file.checksum:
        if isinstance(cs, int):
            computed = F&#39;{cs:08X}&#39;
            expected = F&#39;{file.checksum:08X}&#39;
        else:
            computed = cs.hex().upper()
            expected = file.checksum.hex().upper()
        raise ValueError(F&#39;checksum error; computed:{computed} expected:{expected}&#39;)

    return data</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib.inno" href="index.html">refinery.lib.inno</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.inno.archive.is_inno_setup" href="#refinery.lib.inno.archive.is_inno_setup">is_inno_setup</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.inno.archive.InvalidPassword" href="#refinery.lib.inno.archive.InvalidPassword">InvalidPassword</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.IncorrectVersion" href="#refinery.lib.inno.archive.IncorrectVersion">IncorrectVersion</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.FileChunkOutOfBounds" href="#refinery.lib.inno.archive.FileChunkOutOfBounds">FileChunkOutOfBounds</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.IVF" href="#refinery.lib.inno.archive.IVF">IVF</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.InnoVersion" href="#refinery.lib.inno.archive.InnoVersion">InnoVersion</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.archive.InnoVersion.ParseLegacy" href="#refinery.lib.inno.archive.InnoVersion.ParseLegacy">ParseLegacy</a></code></li>
<li><code><a title="refinery.lib.inno.archive.InnoVersion.Parse" href="#refinery.lib.inno.archive.InnoVersion.Parse">Parse</a></code></li>
<li><code><a title="refinery.lib.inno.archive.InnoVersion.is_ambiguous" href="#refinery.lib.inno.archive.InnoVersion.is_ambiguous">is_ambiguous</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.JsonStruct" href="#refinery.lib.inno.archive.JsonStruct">JsonStruct</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.archive.JsonStruct.json" href="#refinery.lib.inno.archive.JsonStruct.json">json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.InnoStruct" href="#refinery.lib.inno.archive.InnoStruct">InnoStruct</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.CheckSumType" href="#refinery.lib.inno.archive.CheckSumType">CheckSumType</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.archive.CheckSumType.strong" href="#refinery.lib.inno.archive.CheckSumType.strong">strong</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.Flags" href="#refinery.lib.inno.archive.Flags">Flags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.AutoBool" href="#refinery.lib.inno.archive.AutoBool">AutoBool</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.archive.AutoBool.From" href="#refinery.lib.inno.archive.AutoBool.From">From</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.WizardStyle" href="#refinery.lib.inno.archive.WizardStyle">WizardStyle</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.StoredAlphaFormat" href="#refinery.lib.inno.archive.StoredAlphaFormat">StoredAlphaFormat</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.UninstallLogMode" href="#refinery.lib.inno.archive.UninstallLogMode">UninstallLogMode</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupStyle" href="#refinery.lib.inno.archive.SetupStyle">SetupStyle</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.PrivilegesRequired" href="#refinery.lib.inno.archive.PrivilegesRequired">PrivilegesRequired</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.PrivilegesRequiredOverrideAllowed" href="#refinery.lib.inno.archive.PrivilegesRequiredOverrideAllowed">PrivilegesRequiredOverrideAllowed</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.LanguageDetection" href="#refinery.lib.inno.archive.LanguageDetection">LanguageDetection</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.CompressionMethod" href="#refinery.lib.inno.archive.CompressionMethod">CompressionMethod</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.archive.CompressionMethod.legacy_check" href="#refinery.lib.inno.archive.CompressionMethod.legacy_check">legacy_check</a></code></li>
<li><code><a title="refinery.lib.inno.archive.CompressionMethod.legacy_conversion_pre_4_2_5" href="#refinery.lib.inno.archive.CompressionMethod.legacy_conversion_pre_4_2_5">legacy_conversion_pre_4_2_5</a></code></li>
<li><code><a title="refinery.lib.inno.archive.CompressionMethod.legacy_conversion_pre_4_2_6" href="#refinery.lib.inno.archive.CompressionMethod.legacy_conversion_pre_4_2_6">legacy_conversion_pre_4_2_6</a></code></li>
<li><code><a title="refinery.lib.inno.archive.CompressionMethod.legacy_conversion_pre_5_3_9" href="#refinery.lib.inno.archive.CompressionMethod.legacy_conversion_pre_5_3_9">legacy_conversion_pre_5_3_9</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.Architecture" href="#refinery.lib.inno.archive.Architecture">Architecture</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.PasswordType" href="#refinery.lib.inno.archive.PasswordType">PasswordType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupTypeEnum" href="#refinery.lib.inno.archive.SetupTypeEnum">SetupTypeEnum</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupFlags" href="#refinery.lib.inno.archive.SetupFlags">SetupFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.StreamCompressionMethod" href="#refinery.lib.inno.archive.StreamCompressionMethod">StreamCompressionMethod</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.StreamHeader" href="#refinery.lib.inno.archive.StreamHeader">StreamHeader</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.CrcCompressedBlock" href="#refinery.lib.inno.archive.CrcCompressedBlock">CrcCompressedBlock</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.TSetupOffsets" href="#refinery.lib.inno.archive.TSetupOffsets">TSetupOffsets</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.archive.TSetupOffsets.Try" href="#refinery.lib.inno.archive.TSetupOffsets.Try">Try</a></code></li>
<li><code><a title="refinery.lib.inno.archive.TSetupOffsets.FindInBinary" href="#refinery.lib.inno.archive.TSetupOffsets.FindInBinary">FindInBinary</a></code></li>
<li><code><a title="refinery.lib.inno.archive.TSetupOffsets.Checked" href="#refinery.lib.inno.archive.TSetupOffsets.Checked">Checked</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.InnoFile" href="#refinery.lib.inno.archive.InnoFile">InnoFile</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.archive.InnoFile.check" href="#refinery.lib.inno.archive.InnoFile.check">check</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.InnoStream" href="#refinery.lib.inno.archive.InnoStream">InnoStream</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.InstallMode" href="#refinery.lib.inno.archive.InstallMode">InstallMode</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupHeader" href="#refinery.lib.inno.archive.SetupHeader">SetupHeader</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.archive.SetupHeader.get_license" href="#refinery.lib.inno.archive.SetupHeader.get_license">get_license</a></code></li>
<li><code><a title="refinery.lib.inno.archive.SetupHeader.get_script" href="#refinery.lib.inno.archive.SetupHeader.get_script">get_script</a></code></li>
<li><code><a title="refinery.lib.inno.archive.SetupHeader.recode_strings" href="#refinery.lib.inno.archive.SetupHeader.recode_strings">recode_strings</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.Version" href="#refinery.lib.inno.archive.Version">Version</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.archive.Version.json" href="#refinery.lib.inno.archive.Version.json">json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.WindowsVersion" href="#refinery.lib.inno.archive.WindowsVersion">WindowsVersion</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.WinVerRange" href="#refinery.lib.inno.archive.WinVerRange">WinVerRange</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.LanguageId" href="#refinery.lib.inno.archive.LanguageId">LanguageId</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupLanguage" href="#refinery.lib.inno.archive.SetupLanguage">SetupLanguage</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupMessage" href="#refinery.lib.inno.archive.SetupMessage">SetupMessage</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.archive.SetupMessage.get_raw_value" href="#refinery.lib.inno.archive.SetupMessage.get_raw_value">get_raw_value</a></code></li>
<li><code><a title="refinery.lib.inno.archive.SetupMessage.get_language_index" href="#refinery.lib.inno.archive.SetupMessage.get_language_index">get_language_index</a></code></li>
<li><code><a title="refinery.lib.inno.archive.SetupMessage.get_language_value" href="#refinery.lib.inno.archive.SetupMessage.get_language_value">get_language_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupType" href="#refinery.lib.inno.archive.SetupType">SetupType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupComponent" href="#refinery.lib.inno.archive.SetupComponent">SetupComponent</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupTaskFlags" href="#refinery.lib.inno.archive.SetupTaskFlags">SetupTaskFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupTask" href="#refinery.lib.inno.archive.SetupTask">SetupTask</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupCondition" href="#refinery.lib.inno.archive.SetupCondition">SetupCondition</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupDirectoryFlags" href="#refinery.lib.inno.archive.SetupDirectoryFlags">SetupDirectoryFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupDirectory" href="#refinery.lib.inno.archive.SetupDirectory">SetupDirectory</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupPermission" href="#refinery.lib.inno.archive.SetupPermission">SetupPermission</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupFileFlags" href="#refinery.lib.inno.archive.SetupFileFlags">SetupFileFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupFileType" href="#refinery.lib.inno.archive.SetupFileType">SetupFileType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupFileCopyMode" href="#refinery.lib.inno.archive.SetupFileCopyMode">SetupFileCopyMode</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupFile" href="#refinery.lib.inno.archive.SetupFile">SetupFile</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupIconCloseSetting" href="#refinery.lib.inno.archive.SetupIconCloseSetting">SetupIconCloseSetting</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupIconFlags" href="#refinery.lib.inno.archive.SetupIconFlags">SetupIconFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupIcon" href="#refinery.lib.inno.archive.SetupIcon">SetupIcon</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupIniFlags" href="#refinery.lib.inno.archive.SetupIniFlags">SetupIniFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupIniEntry" href="#refinery.lib.inno.archive.SetupIniEntry">SetupIniEntry</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupRegistryType" href="#refinery.lib.inno.archive.SetupRegistryType">SetupRegistryType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupRegistryFlags" href="#refinery.lib.inno.archive.SetupRegistryFlags">SetupRegistryFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupRegistryEntry" href="#refinery.lib.inno.archive.SetupRegistryEntry">SetupRegistryEntry</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupDeleteType" href="#refinery.lib.inno.archive.SetupDeleteType">SetupDeleteType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupDeleteEntry" href="#refinery.lib.inno.archive.SetupDeleteEntry">SetupDeleteEntry</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupRunWait" href="#refinery.lib.inno.archive.SetupRunWait">SetupRunWait</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupRunFlags" href="#refinery.lib.inno.archive.SetupRunFlags">SetupRunFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupRunEntry" href="#refinery.lib.inno.archive.SetupRunEntry">SetupRunEntry</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.TSetup" href="#refinery.lib.inno.archive.TSetup">TSetup</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.archive.TSetup.get_wizard_images_large" href="#refinery.lib.inno.archive.TSetup.get_wizard_images_large">get_wizard_images_large</a></code></li>
<li><code><a title="refinery.lib.inno.archive.TSetup.get_wizard_images_small" href="#refinery.lib.inno.archive.TSetup.get_wizard_images_small">get_wizard_images_small</a></code></li>
<li><code><a title="refinery.lib.inno.archive.TSetup.get_decompress_dll" href="#refinery.lib.inno.archive.TSetup.get_decompress_dll">get_decompress_dll</a></code></li>
<li><code><a title="refinery.lib.inno.archive.TSetup.get_decryption_dll" href="#refinery.lib.inno.archive.TSetup.get_decryption_dll">get_decryption_dll</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupDataEntryFlags" href="#refinery.lib.inno.archive.SetupDataEntryFlags">SetupDataEntryFlags</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupSignMode" href="#refinery.lib.inno.archive.SetupSignMode">SetupSignMode</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.SetupDataEntry" href="#refinery.lib.inno.archive.SetupDataEntry">SetupDataEntry</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.TData" href="#refinery.lib.inno.archive.TData">TData</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.InnoParseResult" href="#refinery.lib.inno.archive.InnoParseResult">InnoParseResult</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.archive.InnoParseResult.ok" href="#refinery.lib.inno.archive.InnoParseResult.ok">ok</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.InnoStreams" href="#refinery.lib.inno.archive.InnoStreams">InnoStreams</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.archive.InnoArchive" href="#refinery.lib.inno.archive.InnoArchive">InnoArchive</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.archive.InnoArchive.guess_password" href="#refinery.lib.inno.archive.InnoArchive.guess_password">guess_password</a></code></li>
<li><code><a title="refinery.lib.inno.archive.InnoArchive.get_encrypted_sample" href="#refinery.lib.inno.archive.InnoArchive.get_encrypted_sample">get_encrypted_sample</a></code></li>
<li><code><a title="refinery.lib.inno.archive.InnoArchive.read_stream" href="#refinery.lib.inno.archive.InnoArchive.read_stream">read_stream</a></code></li>
<li><code><a title="refinery.lib.inno.archive.InnoArchive.check_password" href="#refinery.lib.inno.archive.InnoArchive.check_password">check_password</a></code></li>
<li><code><a title="refinery.lib.inno.archive.InnoArchive.read_chunk" href="#refinery.lib.inno.archive.InnoArchive.read_chunk">read_chunk</a></code></li>
<li><code><a title="refinery.lib.inno.archive.InnoArchive.read_file" href="#refinery.lib.inno.archive.InnoArchive.read_file">read_file</a></code></li>
<li><code><a title="refinery.lib.inno.archive.InnoArchive.read_file_and_check" href="#refinery.lib.inno.archive.InnoArchive.read_file_and_check">read_file_and_check</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
