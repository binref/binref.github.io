<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.inno.ifps documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.inno.ifps</code></h1>
</header>
<section id="section-intro">
<p>The code is based on the logic implemented in IFPSTools:
<a href="https://github.com/Wack0/IFPSTools">https://github.com/Wack0/IFPSTools</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1-L1842" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The code is based on the logic implemented in IFPSTools:
 https://github.com/Wack0/IFPSTools
&#34;&#34;&#34;
from __future__ import annotations

import abc
import enum
import io
import itertools

from collections import OrderedDict
from dataclasses import dataclass, field
from functools import WRAPPER_ASSIGNMENTS, update_wrapper
from typing import (
    Callable,
    Generator,
    NamedTuple,
    Type,
    TypeVar,
    Union,
)
from uuid import UUID

from refinery.lib.inno import CaseInsensitiveDict
from refinery.lib.inno.symbols import IFPSAPI, IFPSClasses, IFPSEvents
from refinery.lib.structures import Struct, StructReader

_E = TypeVar(&#39;_E&#39;, bound=Type[enum.Enum])
_C = TypeVar(&#39;_C&#39;, bound=Type)

_TAB = &#39;\x20\x20&#39;


def extended(_data: bytes):
    &#34;&#34;&#34;
    A helper function to parse 10 bytes into an extended type float value within the IFPS runtime.
    &#34;&#34;&#34;
    if len(_data) != 10:
        raise ValueError
    data = int.from_bytes(_data, &#39;little&#39;)
    sign = data &gt;&gt; 79
    data = data ^ (sign &lt;&lt; 79)
    sign = -1.0 if sign else +1.0
    exponent = data &gt;&gt; 64
    data = data ^ (exponent &lt;&lt; 64)
    if exponent == 0:
        if data == 0:
            return sign * 0
        exponent = -16382
    elif exponent == 0b111111111111111:
        if data == 0:
            return sign * float(&#39;Inf&#39;)
        else:
            return sign * float(&#39;NaN&#39;)
    else:
        exponent = exponent - 16383
    mantissa = data / (1 &lt;&lt; 64)
    return sign * mantissa * (2 ** exponent)


def represent(cls: _E) -&gt; _E:
    &#34;&#34;&#34;
    A decorator for various IFPS integer enumeration classes to change the default string
    representation.
    &#34;&#34;&#34;
    cls.__repr__ = lambda self: F&#39;{self.__class__.__name__}.{self.name}&#39;
    cls. __str__ = lambda self: self.name
    return cls


@represent
class Op(enum.IntEnum):
    &#34;&#34;&#34;
    An enumeration of all known IFPS opcodes.
    &#34;&#34;&#34;
    Assign       = 0x00  # noqa
    Calculate    = 0x01  # noqa
    Push         = 0x02  # noqa
    PushVar      = 0x03  # noqa
    Pop          = 0x04  # noqa
    Call         = 0x05  # noqa
    Jump         = 0x06  # noqa
    JumpTrue     = 0x07  # noqa
    JumpFalse    = 0x08  # noqa
    Ret          = 0x09  # noqa
    StackType    = 0x0A  # noqa
    PushType     = 0x0B  # noqa
    Compare      = 0x0C  # noqa
    CallVar      = 0x0D  # noqa
    SetPtr       = 0x0E  # noqa
    BooleanNot   = 0x0F  # noqa
    Neg          = 0x10  # noqa
    SetFlag      = 0x11  # noqa
    JumpFlag     = 0x12  # noqa
    PushEH       = 0x13  # noqa
    PopEH        = 0x14  # noqa
    IntegerNot   = 0x15  # noqa
    SetPtrToCopy = 0x16  # noqa
    Inc          = 0x17  # noqa
    Dec          = 0x18  # noqa
    JumpPop1     = 0x19  # noqa
    JumpPop2     = 0x1A  # noqa
    Nop          = 0xFF  # noqa
    _INVALID     = 0xDD  # noqa

    @classmethod
    def FromInt(cls, code: int):
        try:
            return cls(code)
        except ValueError:
            return cls._INVALID


class AOp(enum.IntEnum):
    &#34;&#34;&#34;
    An enumeration of all known IFPS arithmetic opcodes.
    &#34;&#34;&#34;
    Add = 0
    Sub = 1
    Mul = 2
    Div = 3
    Mod = 4
    Shl = 5
    Shr = 6
    And = 7
    BOr = 8
    Xor = 9

    def __str__(self):
        glyph = (&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;%&#39;, &#39;&lt;&lt;&#39;, &#39;&gt;&gt;&#39;, &#39;&amp;&#39;, &#39;|&#39;, &#39;^&#39;)[self]
        return F&#39;{glyph}=&#39;


class COp(enum.IntEnum):
    &#34;&#34;&#34;
    An enumeration of all known IFPS comparison opcodes.
    &#34;&#34;&#34;
    GE = 0
    LE = 1
    GT = 2
    LT = 3
    NE = 4
    EQ = 5
    IN = 6
    IS = 7

    def __str__(self):
        return (&#39;&gt;=&#39;, &#39;&lt;=&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;!=&#39;, &#39;==&#39;, &#39;in&#39;, &#39;is&#39;)[self]


@represent
class TC(enum.IntEnum):
    &#34;&#34;&#34;
    An enumeration of all known IFPS type codes.
    &#34;&#34;&#34;
    ReturnAddress       = 0x00  # noqa
    U08                 = 0x01  # noqa
    S08                 = 0x02  # noqa
    U16                 = 0x03  # noqa
    S16                 = 0x04  # noqa
    U32                 = 0x05  # noqa
    S32                 = 0x06  # noqa
    Single              = 0x07  # noqa
    Double              = 0x08  # noqa
    Extended            = 0x09  # noqa
    AnsiString          = 0x0A  # noqa
    Record              = 0x0B  # noqa
    Array               = 0x0C  # noqa
    Pointer             = 0x0D  # noqa
    PChar               = 0x0E  # noqa
    ResourcePointer     = 0x0F  # noqa
    Variant             = 0x10  # noqa
    S64                 = 0x11  # noqa
    Char                = 0x12  # noqa
    WideString          = 0x13  # noqa
    WideChar            = 0x14  # noqa
    ProcPtr             = 0x15  # noqa
    StaticArray         = 0x16  # noqa
    Set                 = 0x17  # noqa
    Currency            = 0x18  # noqa
    Class               = 0x19  # noqa
    Interface           = 0x1A  # noqa
    NotificationVariant = 0x1B  # noqa
    UnicodeString       = 0x1C  # noqa
    Enum                = 0x81  # noqa
    Type                = 0x82  # noqa
    ExtClass            = 0x83  # noqa

    @property
    def primitive(self) -&gt; bool:
        &#34;&#34;&#34;
        Indicates whether the code represents a primitive type.
        &#34;&#34;&#34;
        return self not in {
            TC.Class,
            TC.ProcPtr,
            TC.Interface,
            TC.Set,
            TC.StaticArray,
            TC.Array,
            TC.Record,
        }

    @property
    def container(self) -&gt; bool:
        &#34;&#34;&#34;
        Indicates whether the code represents a container type.
        &#34;&#34;&#34;
        return self in {
            TC.StaticArray,
            TC.Array,
            TC.Record,
        }

    @property
    def width(self):
        &#34;&#34;&#34;
        For primitive types, this gives the size of an immediate of this type in bytes.
        &#34;&#34;&#34;
        return {
            TC.Variant       : 0x10,
            TC.Char          : 0x01,
            TC.S08           : 0x01,
            TC.U08           : 0x01,
            TC.WideChar      : 0x02,
            TC.S16           : 0x02,
            TC.U16           : 0x02,
            TC.WideString    : 0x04,
            TC.UnicodeString : 0x04,
            TC.Interface     : 0x04,
            TC.Class         : 0x04,
            TC.PChar         : 0x04,
            TC.AnsiString    : 0x04,
            TC.Single        : 0x04,
            TC.S32           : 0x04,
            TC.U32           : 0x04,
            TC.ProcPtr       : 0x0C,
            TC.Currency      : 0x08,
            TC.Pointer       : 0x0C,
            TC.Double        : 0x08,
            TC.S64           : 0x08,
            TC.Extended      : 0x0A,
            TC.ReturnAddress : 0x1C,
        }.get(self, 0)


@dataclass
class IFPSTypeMixin:
    &#34;&#34;&#34;
    A helper class to mix additional properties into various IFPS type classes.
    &#34;&#34;&#34;
    symbol: str | None = None
    attributes: list[FunctionAttribute] | None = None

    def __str__(self):
        if self.symbol is not None:
            return self.symbol
        return super().__str__()


@dataclass
class IFPSTypeBase(abc.ABC):
    &#34;&#34;&#34;
    The base class for any IFPS type.
    &#34;&#34;&#34;
    code: TC

    def simple(self, nested=False):
        &#34;&#34;&#34;
        Indicate whether the type requires more than one line to pretty print.
        &#34;&#34;&#34;
        return True

    def display(self, indent=0):
        &#34;&#34;&#34;
        Compute a display string that can be used to represent the type in disassembly.
        &#34;&#34;&#34;
        return indent * _TAB + self.code.name

    @abc.abstractmethod
    def py_type(self, key: int | None = None) -&gt; type | None:
        &#34;&#34;&#34;
        If possible, provide a Python type equivalent for this IFPS type. The optional key argument
        is required only for the `refinery.lib.inno.ifps.TRecord` class.
        &#34;&#34;&#34;
        ...

    @abc.abstractmethod
    def default(self, key: int | None = None):
        &#34;&#34;&#34;
        Compute the default value for this type. The optional key argument is required only for the
        `refinery.lib.inno.ifps.TRecord` class.
        &#34;&#34;&#34;
        ...

    @property
    def primitive(self) -&gt; bool:
        &#34;&#34;&#34;
        Indicates whether the type is primitive.
        &#34;&#34;&#34;
        return self.code.primitive

    @property
    def container(self) -&gt; bool:
        &#34;&#34;&#34;
        Indicates whether the type is a container.
        &#34;&#34;&#34;
        return self.code.container

    def __str__(self):
        return self.display(0)


def ifpstype(cls: _C) -&gt; _C | type[IFPSTypeMixin]:
    &#34;&#34;&#34;
    A decorator for IFPS types to mix the `refinery.lib.inno.ifps.IFPSTypeMixin` into the dataclass
    definition.
    &#34;&#34;&#34;
    cls = dataclass(cls)
    mix = type(cls.__qualname__, (IFPSTypeMixin, cls), {})
    assigned = set(WRAPPER_ASSIGNMENTS) - {&#39;__annotations__&#39;}
    update_wrapper(mix, cls, assigned=assigned, updated=())
    return dataclass(mix)


@ifpstype
class TPrimitive(IFPSTypeBase):
    &#34;&#34;&#34;
    A primitive IFPS type.
    &#34;&#34;&#34;
    def py_type(self, *_) -&gt; type | None:
        return {
            TC.ReturnAddress       : int,
            TC.U08                 : int,
            TC.S08                 : int,
            TC.U16                 : int,
            TC.S16                 : int,
            TC.U32                 : int,
            TC.S32                 : int,
            TC.Single              : float,
            TC.Double              : float,
            TC.Extended            : float,
            TC.AnsiString          : str,
            TC.Pointer             : VariableBase,
            TC.PChar               : str,
            TC.ResourcePointer     : VariableBase,
            TC.Variant             : object,
            TC.S64                 : int,
            TC.Char                : str,
            TC.WideString          : str,
            TC.WideChar            : str,
            TC.Currency            : float,
            TC.UnicodeString       : str,
            TC.Enum                : int,
            TC.Type                : IFPSType,
        }.get(self.code)

    def default(self, *_):
        if self.code in (TC.Char, TC.WideChar, TC.PChar):
            return &#39;\0&#39;
        tc = self.py_type()
        if issubclass(tc, (int, float, str)):
            return tc()


@ifpstype
class TProcPtr(IFPSTypeBase):
    &#34;&#34;&#34;
    The procedure pointer IFPS type.
    &#34;&#34;&#34;
    void: bool
    args: tuple[DeclSpecParam, ...]

    def py_type(self, *_):
        return None

    def default(self, *_):
        return None

    def display(self, indent=0):
        name = super().display(indent)
        args = []
        for k, spec in enumerate(self.args, 1):
            arg = F&#39;Arg{k}&#39;
            if not spec.const:
                arg = F&#39;*{arg}&#39;
            if spec.type is not None:
                arg = F&#39;{spec.type!s} {arg}&#39;
            args.append(arg)
        args = &#39;, &#39;.join(args)
        return F&#39;{name}({args})&#39;


@ifpstype
class TInterface(IFPSTypeBase):
    &#34;&#34;&#34;
    An IFPS type representing a COM interface.
    &#34;&#34;&#34;
    uuid: UUID

    def py_type(self, *_):
        return object

    def default(self, *_):
        return None

    def display(self, indent=0):
        display = super().display(indent)
        return F&#39;{display}({self.uuid!s})&#39;


@ifpstype
class TClass(IFPSTypeBase):
    &#34;&#34;&#34;
    An IFPS type representing an IFPS class.
    &#34;&#34;&#34;
    name: str

    def py_type(self, *_):
        return None

    def default(self, *_):
        return None


@ifpstype
class TSet(IFPSTypeBase):
    &#34;&#34;&#34;
    An IFPS type representing a bit vector.
    &#34;&#34;&#34;
    size: int

    def py_type(self, *_):
        return int

    def default(self, *_):
        return 0

    @property
    def size_in_bytes(self):
        q, r = divmod(self.size, 8)
        return q + (r and 1 or 0)

    def display(self, indent=0):
        display = super().display(indent)
        return F&#39;{display}({self.size})&#39;


@ifpstype
class TArray(IFPSTypeBase):
    &#34;&#34;&#34;
    An IFPS type representing a dynamic array.
    &#34;&#34;&#34;
    type: TPrimitive

    def py_type(self, key: int | None = None):
        if key is None:
            return list
        return self.type.py_type()

    def default(self, key: int | None = None):
        if key is None:
            return []
        return self.type.default()

    def display(self, indent=0):
        display = F&#39;{_TAB * indent}{self.type!s}&#39;
        return F&#39;array of {display}&#39;

    def simple(self, nested=False):
        return self.type.simple(nested)


@ifpstype
class TStaticArray(IFPSTypeBase):
    &#34;&#34;&#34;
    An IFPS type representing a static array (i.e. a tuple).
    &#34;&#34;&#34;
    type: TPrimitive
    size: int
    offset: int | None = None

    def py_type(self, key: int | None = None):
        if key is None:
            return list
        return self.type.py_type(key)

    def default(self, key: int | None = None):
        if key is None:
            return [self.type.default() for _ in range(self.size)]
        return self.type.default()

    def display(self, indent=0):
        display = F&#39;{_TAB * indent}{self.type!s}&#39;
        return F&#39;{display}[{self.size}]&#39;

    def simple(self, nested=False):
        return self.type.simple(nested)


@ifpstype
class TRecord(IFPSTypeBase):
    &#34;&#34;&#34;
    An IFPS type representing a structure.
    &#34;&#34;&#34;
    members: tuple[TPrimitive, ...]

    @property
    def size(self):
        return len(self.members)

    def py_type(self, key: int | None = None):
        if key is None:
            return list
        return self.members[key].py_type()

    def default(self, key: int | None = None):
        if key is None:
            return [member.default() for member in self.members]
        return self.members[key].default()

    def simple(self, nested=False):
        if nested:
            return False
        if len(self.members) &gt; 10:
            return False
        return all(m.simple(True) for m in self.members)

    def display(self, indent=0):
        output = io.StringIO()
        output.write(indent * _TAB)
        output.write(&#39;struct {&#39;)
        if self.simple():
            output.write(&#39;, &#39;.join(str(m) for m in self.members))
        else:
            for k, member in enumerate(self.members):
                if k &gt; 0:
                    output.write(&#39;,&#39;)
                output.write(&#39;\n&#39;)
                output.write(member.display(indent + 1))
            if self.members:
                output.write(F&#39;\n{_TAB * indent}&#39;)
        output.write(&#39;}&#39;)
        return output.getvalue()


IFPSType = Union[
    TRecord,
    TStaticArray,
    TArray,
    TSet,
    TProcPtr,
    TClass,
    TInterface,
    TPrimitive,
]
&#34;&#34;&#34;
Represents any of the possible IFPS data types:

- `refinery.lib.inno.ifps.TRecord`
- `refinery.lib.inno.ifps.TStaticArray`
- `refinery.lib.inno.ifps.TArray`
- `refinery.lib.inno.ifps.TSet`
- `refinery.lib.inno.ifps.TProcPtr`
- `refinery.lib.inno.ifps.TClass`
- `refinery.lib.inno.ifps.TInterface`
- `refinery.lib.inno.ifps.TPrimitive`
&#34;&#34;&#34;


class Value(NamedTuple):
    &#34;&#34;&#34;
    A value of the given type within the IFPS runtime.
    &#34;&#34;&#34;
    type: IFPSType
    value: str | int | float | bytes | Function

    def convert(self, *_):
        return self.type.py_type()

    def default(self, *_):
        return self.type.default()

    def __repr__(self):
        value = self.value
        if isinstance(value, bytes):
            value = value.hex()
        return F&#39;{self.type.code.name}({value!r})&#39;

    def __str__(self):
        v = self.value
        if isinstance(v, Function):
            return F&#39;&amp;{v!s}&#39;
        return repr(v)


class FunctionAttribute(NamedTuple):
    &#34;&#34;&#34;
    A function attribute.
    &#34;&#34;&#34;
    name: str
    fields: tuple[Value, ...]

    def __repr__(self):
        name = self.name
        if self.fields:
            name += &#39;[{}]&#39;.format(&#39;,&#39;.join(repr(f) for f in self.fields))
        return name


@dataclass
class DeclSpecParam:
    &#34;&#34;&#34;
    A function parameter specification.
    &#34;&#34;&#34;
    const: bool
    &#34;&#34;&#34;
    True if this parameter is passed by value, not by reference.
    &#34;&#34;&#34;
    type: TPrimitive | None = None
    &#34;&#34;&#34;
    The type of this parameter.
    &#34;&#34;&#34;
    name: str | None = None
    &#34;&#34;&#34;
    The name of this parameter.
    &#34;&#34;&#34;


class CallType(str, enum.Enum):
    &#34;&#34;&#34;
    This enumeration classifies the different call types.
    &#34;&#34;&#34;
    Symbol = &#39;symbol&#39;
    Procedure = &#39;procedure&#39;
    Function = &#39;function&#39;
    Property = &#39;property&#39;

    def __str__(self):
        return self.value


@dataclass
class DeclSpec:
    &#34;&#34;&#34;
    This class captures the declaration info of a function symbol.
    &#34;&#34;&#34;
    void: bool
    parameters: list[DeclSpecParam] = field(default_factory=list)
    name: str = &#39;&#39;
    calling_convention: str | None = None
    return_type: IFPSType | None = None
    module: str | None = None
    classname: str | None = None
    delay_load: bool = False
    vtable_index: int | None = None
    load_with_altered_search_path: bool = False
    is_property: bool = False
    is_accessor: bool = False

    @property
    def argc(self):
        return len(self.parameters)

    def represent(self, name: str, ref: bool = False, rel: bool = False):
        def pparam(k: int, p: DeclSpecParam):
            name = p.name or F&#39;{VariableType.Argument!s}{k}&#39;
            if p.type is not None:
                name = F&#39;{name}: {p.type!s}&#39;
            if not p.const:
                name = F&#39;*{name}&#39;
            return name
        if self.name and name in self.name:
            name = self.name
        spec = name
        if self.vtable_index is not None:
            spec = F&#39;{self.name}[{self.vtable_index}]&#39;
        if not rel and self.classname:
            spec = F&#39;{self.classname}.{spec}&#39;
        if not rel and self.module:
            spec = F&#39;{self.module}::{spec}&#39;
        if not ref:
            if self.delay_load:
                spec = F&#39;__delay_load {spec}&#39;
            if self.calling_convention and not self.is_property:
                spec = F&#39;__{self.calling_convention} {spec}&#39;
            spec = F&#39;{self.type} {spec}&#39;
            args = self.parameters
            args = args and &#39;, &#39;.join(pparam(*t) for t in enumerate(args, 1)) or &#39;&#39;
            if self.is_property:
                if args:
                    spec = F&#39;{spec}[{args}]&#39;
            else:
                spec = F&#39;{spec}({args})&#39;
            if self.return_type:
                spec = F&#39;{spec}: {self.return_type!s}&#39;
        return spec

    @property
    def type(self):
        if self.is_property:
            return CallType.Property
        if self.void:
            return CallType.Procedure
        return CallType.Function

    def __repr__(self):
        return self.represent(self.name or &#39;(*)&#39;)

    @classmethod
    def ParseF(cls, reader: StructReader[bytes], load_flags: bool):
        def ascii():
            return reader.read_c_string(&#39;latin1&#39;)

        def boolean():
            return bool(reader.u8())

        def cc():
            return {
                0: &#39;register&#39;,
                1: &#39;pascal&#39;,
                2: &#39;cdecl&#39;,
                3: &#39;stdcall&#39;,
            }.get(reader.u8(), cls.calling_convention)

        def read_parameters():
            nonlocal void
            void = not boolean()
            parameters.extend(DeclSpecParam(not b) for b in reader.read())

        void = True
        name = None
        properties = {}
        parameters = []

        if reader.readif(b&#39;dll:&#39;):
            reader.readif(B&#39;files:&#39;)
            if (module := ascii()).lower().endswith(&#39;.dll&#39;):
                module = module[:-4]
            properties.update(module=module)
            name = ascii()
            properties.update(calling_convention=cc())
            if load_flags:
                properties.update(delay_load=boolean(), load_with_altered_search_path=boolean())
            read_parameters()
        elif reader.readif(b&#39;class:&#39;):
            if reader.remaining_bytes == 1:
                spec = reader.peek(1)
                void = False
                parameters.append(DeclSpecParam(False))
                name = {
                    b&#39;+&#39;: &#39;CastToType&#39;,
                    B&#39;-&#39;: &#39;SetNil&#39;
                }.get(spec)
                properties.update(classname=&#39;Class&#39;, calling_convention=&#39;pascal&#39;)
            else:
                properties.update(classname=reader.read_terminated_array(b&#39;|&#39;).decode(&#39;latin1&#39;))
                name = reader.read_terminated_array(b&#39;|&#39;).decode(&#39;latin1&#39;)
                if name[-1] == &#39;@&#39;:
                    properties.update(is_property=True)
                    name = name[:-1]
                properties.update(calling_convention=cc())
                read_parameters()
        elif reader.readif(b&#39;intf:.&#39;):
            name = &#39;CoInterface&#39;
            properties.update(vtable_index=reader.u32())
            properties.update(calling_convention=cc())
            read_parameters()
        else:
            read_parameters()
        return cls(void, parameters, name=name, **properties)

    @classmethod
    def ParseE(cls, data: bytes, ipfs: IFPSFile):
        decl = data.split(B&#39;\x20&#39;)
        try:
            return_type = int(decl.pop(0))
        except Exception:
            void = True
        else:
            void = return_type &lt; 0
        if not void:
            return_type = ipfs.types[return_type]
        else:
            return_type = None
        parameters = []
        for param in decl:
            try:
                i = int(param[1:])
            except Exception:
                tv = None
            else:
                tv = ipfs.types[i]
            parameters.append(
                DeclSpecParam(param[:1] == B&#39;@&#39;, tv))
        return cls(void, parameters, return_type=return_type)


@dataclass
class Function:
    &#34;&#34;&#34;
    Represents a function in the IFPS runtime.
    &#34;&#34;&#34;
    symbol: str = &#39;&#39;
    decl: DeclSpec | None = None
    body: list[Instruction] | None = None
    attributes: list[FunctionAttribute] | None = None
    _bbs: dict[int, BasicBlock] | None = None
    _ins: dict[int, Instruction] | None = None
    getter: Function | None = None
    setter: Function | None = None

    @property
    def is_property(self):
        if decl := self.decl:
            return decl.is_property
        else:
            return False

    @property
    def name(self):
        symbol = self.symbol
        if (decl := self.decl) and (name := decl.name) and (symbol in name):
            symbol = name
        return symbol

    @property
    def code(self):
        if code := self._ins:
            return code
        self._ins = code = {i.offset: i for i in self.body}
        return code

    def reference(self, rel: bool = False) -&gt; str:
        if self.decl is None:
            return self.symbol
        return self.decl.represent(self.symbol, ref=True, rel=rel)

    def __repr__(self):
        if self.decl is None:
            return F&#39;symbol {self.symbol}&#39;
        return self.decl.represent(self.symbol)

    def __str__(self):
        return self.reference()

    @property
    def type(self):
        if self.decl is None:
            return CallType.Symbol
        return self.decl.type

    def get_basic_blocks(self) -&gt; dict[int, BasicBlock]:
        if (bbs := self._bbs) is not None:
            return bbs
        if self.body is None:
            bbs = self._bbs = {}
            return bbs

        bbs: dict[int, BasicBlock] = {0: (bb := BasicBlock(0))}
        self._bbs = bbs
        jump = False

        for insn in self.body:
            try:
                bb = bbs[insn.offset]
            except KeyError:
                if jump or insn.jumptarget:
                    nb = bbs[insn.offset] = BasicBlock(insn.offset)
                    if not jump:
                        nb.sources[bb.offset] = bb
                        bb.targets[nb.offset] = nb
                    bb = nb
            bb.body.append(insn)
            if not insn.branches:
                jump = False
                continue
            targets = [insn.operands[0]]
            sequence = insn.offset + insn.size
            jump = insn.jumps
            if not jump and insn.opcode != Op.Ret:
                targets.append(sequence)
            for t in targets:
                if not (bt := bbs.get(t)):
                    bt = bbs[t] = BasicBlock(t)
                bb.targets[t] = bt
                bt.sources[bb.offset] = bb

        for offset, bb in list(bbs.items()):
            if bb.body:
                continue
            del bbs[offset]
            for source in bb.sources.values():
                source.targets.pop(offset, None)

        visited: set[int] = set()
        errored: set[int] = set()

        def trace_stack(offset: int, stack: int | None):
            if offset in errored:
                return
            bb = bbs[offset]
            if bb.stack is not None and stack != bb.stack:
                stack = None
            if stack is None:
                errored.add(offset)
            elif offset in visited:
                return
            else:
                visited.add(offset)
            bb.stack = stack
            body = [] if stack is None else bb.body
            for insn in body:
                insn.stack = stack
                stack += insn.stack_delta
            for t in bb.targets:
                trace_stack(t, stack)

        trace_stack(0, 0)

        for insn in self.body:
            if (stack := insn.stack) is None:
                continue
            for k, op in enumerate(insn.operands):
                if not isinstance(op, Operand):
                    continue
                if not (v := op.variable) or v.type != VariableType.Local:
                    continue
                if v.index &lt;= stack:
                    continue
                raise IndexError(
                    F&#39;Instruction {op!s} at offset 0x{insn.offset:X} in function {self.name} has &#39;
                    F&#39;variable operand {k} whose index {v.index} exceeds the stack depth {stack}.&#39;)

        return bbs


class VariableBase:
    &#34;&#34;&#34;
    This class represents a variable within the IFPS runtime. This is primarily a base class for
    the more sophisticated `refinery.lib.inno.emulator.Variable`.
    &#34;&#34;&#34;
    type: IFPSType
    &#34;&#34;&#34;
    The type of the variable, see `refinery.lib.inno.ifps.IFPSType`.
    &#34;&#34;&#34;
    spec: VariableSpec | None
    &#34;&#34;&#34;
    A `refinery.lib.inno.ifps.VariableSpec` that uniquely identifies the base variable. If this
    property is `None`, the variable is unbound: The `refinery.lib.inno.ifps.Op.SetPtrToCopy`
    opcode can create such variables.
    &#34;&#34;&#34;

    __slots__ = &#39;type&#39;, &#39;spec&#39;

    def __init__(self, type: IFPSType, spec: VariableSpec):
        self.type = type
        self.spec = spec

    def __str__(self):
        return F&#39;{self.spec}: {self.type!s}&#39;


@represent
class OperandType(enum.IntEnum):
    &#34;&#34;&#34;
    Classifies the type of an `refinery.lib.inno.ifps.Operand`.
    &#34;&#34;&#34;
    Variable = 0
    Value = 1
    IndexedByInt = 2
    IndexedByVar = 3


@represent
class EHType(enum.IntEnum):
    &#34;&#34;&#34;
    This enumeration lists the possible types of code region covered by an exception handler.
    &#34;&#34;&#34;
    Try = 0
    Finally = 1
    Catch = 2
    SecondFinally = 3


@represent
class NewEH(enum.IntEnum):
    &#34;&#34;&#34;
    This enumeration gives names to the 4 arguments of the opcode responsible for registering a new
    exception handler. The first argument specifies the location of a finally, the second argument
    specifies the location of a catch handler, and so on.
    &#34;&#34;&#34;
    Finally = 0
    CatchAt = 1
    SecondFinally = 2
    End = 3


class VariableType(str, enum.Enum):
    Global = &#39;GlobalVar&#39;
    Local = &#39;LocalVar&#39;
    Argument = &#39;Argument&#39;

    def __repr__(self):
        return self.name

    def __str__(self):
        return self.value


class VariableSpec(NamedTuple):
    &#34;&#34;&#34;
    Represents a reference to a variable within the IFPS runtime. There are three variable types:
    Locals, globals, and function arguments; see `refinery.lib.inno.ifps.VariableType`. A variable
    is then uniquely defined by its type and index within the (localized) list of such variables.
    The function argument of index zero is the return value of a function.
    &#34;&#34;&#34;
    index: int
    type: VariableType

    def __repr__(self):
        if self.index == 0 and self.type == VariableType.Argument:
            return &#39;ReturnValue&#39;
        return F&#39;{self.type!s}{self.index}&#39;


class Operand(NamedTuple):
    &#34;&#34;&#34;
    Represends an operand to an IFPS opcode. An operand can either contain a value, which is an
    immediate that is encoded into the opcode, or a reference to a variable. A variable is given
    by its `refinery.lib.inno.ifps.VariableSpec`. Additionally, the operand can specify an index
    for this variable which can either be given by an immediate, or by another variable. In the
    latter case, the encoded index is also a `refinery.lib.inno.ifps.VariableSpec`. The type of
    operand is encoded as an `refinery.lib.inno.ifps.OperandType`.
    &#34;&#34;&#34;
    type: OperandType
    variable: VariableSpec | None = None
    value: Value | None = None
    index: VariableSpec | int | None = None

    def __repr__(self):
        return self.__tostring(repr)

    def __str__(self):
        return self.__tostring(str)

    @property
    def immediate(self):
        return self.type == OperandType.Value

    def __tostring(self, converter):
        if self.type is OperandType.Value:
            return converter(self.value)
        if self.type is OperandType.Variable:
            return converter(self.variable)
        if self.type is OperandType.IndexedByInt:
            return F&#39;{converter(self.variable)}[0x{self.index:02X}]&#39;
        if self.type is OperandType.IndexedByVar:
            return F&#39;{converter(self.variable)}[{self.index!s}]&#39;
        raise RuntimeError(F&#39;Unexpected OperandType {self.type!r} in {self.__class__.__name__}&#39;)


_Op_Maxlen = max(len(op.name) for op in Op)
_Op_StackD = {
    Op.Push     : +1,
    Op.PushVar  : +1,
    Op.PushType : +1,
    Op.Pop      : -1,
    Op.JumpPop1 : -1,
    Op.JumpPop2 : -2,
}


@dataclass
class Instruction:
    offset: int
    opcode: Op
    encoded: bytes = B&#39;&#39;
    stack: int | None = None
    operands: list[str | bool | int | float | Operand | IFPSType | Function | None] = field(default_factory=list)
    operator: AOp | COp | None = None
    jumptarget: bool = False

    def op(self, index: int):
        arg = self.operands[index]
        if not isinstance(arg, Operand):
            raise TypeError
        return arg

    @property
    def size(self):
        return len(self.encoded)

    @property
    def branches(self):
        return self.opcode in (
            Op.Jump,
            Op.JumpFalse,
            Op.JumpTrue,
            Op.JumpFlag,
            Op.JumpPop1,
            Op.JumpPop2,
        )

    @property
    def jumps(self):
        return self.opcode in (
            Op.Jump,
            Op.JumpPop1,
            Op.JumpPop2,
        )

    @property
    def stack_delta(self):
        return _Op_StackD.get(self.opcode, 0)

    def oprep(self, labels: dict[int, str] | None = None):
        if self.branches:
            dst = self.operands[0]
            if not labels or not (label := labels.get(dst)):
                label = F&#39;0x{dst:X}&#39;
            var = [str(op) for op in self.operands[1:]]
            return &#39;, &#39;.join((label, *var))
        elif self.opcode is Op.PushEH:
            ops = []
            for op, name in reversed(list(zip(self.operands, NewEH))):
                if op is None:
                    continue
                ops.append(F&#39;{name}:0x{op:X}&#39;)
            return &#39;\x20&#39;.join(ops)
        elif self.opcode is Op.PopEH:
            return F&#39;End{EHType(self.operands[0])}&#39;
        elif self.opcode is Op.SetFlag:
            rep, negated = self.operands
            return F&#39;!{rep}&#39; if negated else str(rep)
        elif self.opcode is Op.Compare:
            dst, a, b = self.operands
            return F&#39;{dst!s} := {a!s} {self.operator!s} {b!s}&#39;
        elif self.opcode is Op.Calculate:
            dst, src = self.operands
            return F&#39;{dst!s} {self.operator!s} {src!s}&#39;
        elif self.opcode in (Op.Assign, Op.SetPtr, Op.SetPtrToCopy):
            dst, src = self.operands
            return F&#39;{dst!s} := {src!s}&#39;
        else:
            return &#39;, &#39;.join(str(op) for op in self.operands)

    def pretty(self, labels: dict[int, str] | None = None):
        return F&#39;{self.opcode!s:&lt;{_Op_Maxlen}}{_TAB}{self.oprep(labels)}&#39;.strip()

    def __repr__(self):
        return F&#39;{self.opcode.name}({self.oprep()})&#39;

    def __str__(self):
        return self.pretty()


@dataclass
class BasicBlock:
    offset: int
    stack: int | None = None
    body: list[Instruction] = field(default_factory=list)
    sources: dict[int, BasicBlock] = field(default_factory=dict)
    targets: dict[int, BasicBlock] = field(default_factory=dict)

    @property
    def stack_delta(self):
        return sum(insn.stack_delta for insn in self.body)

    @property
    def size(self):
        return sum(insn.size for insn in self.body)


class FTag(enum.IntFlag):
    External = 0b0001
    Exported = 0b0010
    HasAttrs = 0b0100

    def check(self, v):
        return bool(self &amp; v)


class IFPSFile(Struct):
    MinVer = 12
    MaxVer = 23

    Magic = B&#39;IFPS&#39;

    def __init__(self, reader: StructReader[memoryview], codec: str = &#39;latin1&#39;, unicode: bool = True):
        self.codec = codec
        self.unicode = unicode
        self.types: list[IFPSType] = []
        self.functions: list[Function] = []
        self.globals: list[VariableBase] = []
        self.strings: list[str] = []
        self.reader = reader
        if reader.remaining_bytes &lt; 28:
            raise ValueError(&#39;Less than 28 bytes in file, not enough data to parse.&#39;)
        magic = reader.read(4)
        if magic != self.Magic:
            raise ValueError(F&#39;Invalid magic sequence: {magic.hex()}&#39;)
        self.version = reader.u32()
        self.count_types = reader.u32()
        self.count_functions = reader.u32()
        self.count_variables = reader.u32()
        self.entry = reader.u32()
        self.import_size = reader.u32()

        if self.version not in range(self.MinVer, self.MaxVer + 1):
            raise NotImplementedError(
                F&#39;This IFPS file has version {self.version}, which is not in the supported range &#39;
                F&#39;[{self.MinVer},{self.MaxVer}].&#39;)

        self._known_type_names = {
            TC.U08   : {&#39;Byte&#39;, &#39;Boolean&#39;},
            TC.S08   : {&#39;ShortInt&#39;},
            TC.U16   : {&#39;Word&#39;},
            TC.S16   : {&#39;SmallInt&#39;},
            TC.S32   : {&#39;Integer&#39;, &#39;LongInt&#39;},
            TC.U32   : {&#39;LongWord&#39;, &#39;Cardinal&#39;, &#39;HWND&#39;, &#39;TSetupProcessorArchitecture&#39;},
            TC.Char  : {&#39;AnsiChar&#39;},
            TC.PChar : {&#39;PAnsiChar&#39;},
            TC.S64   : {&#39;Int64&#39;},
        }

        self._load_types()
        self._name_types()
        self._load_functions()
        self._load_variables()

        del self._known_type_names

    def _name_types(self, missing_types: set[str] | None = None):
        tbn: dict[str, IFPSType] = CaseInsensitiveDict()
        self.types_by_name = tbn
        for t in self.types:
            name = str(t)
            code = t.code
            known = self._known_type_names.get(code)
            if known:
                known.discard(name)
            tbn[name] = t

        if missing_types:
            def add_type(name: str, type: IFPSType):
                tbn[name] = type
                self.types.append(type)
                return type

            def make_string(name: str = &#39;String&#39;):
                try:
                    return tbn[name]
                except KeyError:
                    pass
                for type in tbn.values():
                    if type.code in (
                        TC.AnsiString,
                        TC.WideString,
                        TC.UnicodeString,
                    ):
                        break
                else:
                    code = TC.WideString if self.unicode else TC.AnsiString
                    type = TPrimitive(code, symbol=name)
                return add_type(name, type)

            for name in tbn:
                missing_types.discard(name)

            if &#39;TGUID&#39; in missing_types:
                missing_types |= {&#39;LongWord&#39;, &#39;Word&#39;, &#39;Byte&#39;}

            for code in TC:
                name = code.name
                if name not in missing_types:
                    continue
                missing_types.discard(name)
                add_type(name, TPrimitive(code, symbol=name))

            for code, names in self._known_type_names.items():
                for name in names:
                    if name not in missing_types:
                        continue
                    missing_types.discard(name)
                    add_type(name, TPrimitive(code, symbol=name))

            for name in [
                &#39;TVarType&#39;,
                &#39;TInputQueryWizardPage&#39;,
                &#39;TInputOptionWizardPage&#39;,
                &#39;TInputDirWizardPage&#39;,
                &#39;TInputFileWizardPage&#39;,
                &#39;TOutputMsgWizardPage&#39;,
                &#39;TOutputMsgMemoWizardPage&#39;,
                &#39;TOutputProgressWizardPage&#39;,
                &#39;TOutputMarqueeProgressWizardPage&#39;,
                &#39;TDownloadWizardPage&#39;,
                &#39;ExtractionWizardPage&#39;,
                &#39;TWizardPage&#39;,
                &#39;TSetupForm&#39;,
                &#39;TComponent&#39;,
                &#39;TNewNotebookPage&#39;,
            ]:
                if name not in missing_types:
                    continue
                add_type(name, TClass(TC.Class, name, symbol=name))

            if (name := &#39;String&#39;) in missing_types:
                make_string(name)

            if (name := &#39;AnyString&#39;) in missing_types:
                make_string(name)

            if (name := &#39;TArrayOfString&#39;) in missing_types:
                add_type(name, TArray(TC.Array, make_string()))

            if (name := &#39;IUnknown&#39;) in missing_types:
                add_type(name, TInterface(TC.Interface, UUID(&#39;{00000000-0000-0000-C000-000000000046}&#39;)))

            if (name := &#39;TGUID&#39;) in missing_types:
                add_type(name, TRecord(TC.Record, (
                    tbn[&#39;LongWord&#39;],
                    tbn[&#39;Word&#39;],
                    tbn[&#39;Word&#39;],
                    TStaticArray(tbn[&#39;Byte&#39;], 8)
                ), symbol=name))

    def _load_types(self):
        def _normalize(n: str):
            return IFPSClasses.Types.get(n.casefold(), n)
        reader = self.reader
        types = self.types
        for k in range(self.count_types):
            typecode = reader.u8()
            exported = bool(typecode &amp; 0x80)
            typecode = typecode &amp; 0x7F
            try:
                code = TC(typecode)
            except ValueError as V:
                raise ValueError(F&#39;Unknown type code value 0x{typecode:02X}.&#39;) from V
            if code in (TC.Class, TC.ExtClass):
                t = TClass(code, _normalize(reader.read_length_prefixed_ascii()))
            elif code is TC.ProcPtr:
                spec = reader.read_length_prefixed()
                void = bool(spec[0])
                args = tuple(DeclSpecParam(not b) for b in spec[1:])
                t = TProcPtr(code, void, args)
            elif code is TC.Interface:
                guid = UUID(bytes=bytes(reader.read(0x10)))
                t = TInterface(code, guid)
            elif code is TC.Set:
                t = TSet(code, reader.u32())
            elif code is TC.StaticArray:
                type = types[reader.u32()]
                size = reader.u32()
                offset = None if self.version &lt;= 22 else reader.u32()
                t = TStaticArray(code, type, size, offset)
            elif code is TC.Array:
                t = TArray(code, types[reader.u32()])
            elif code is TC.Record:
                length = reader.u32()
                members = tuple(types[reader.u32()] for _ in range(length))
                t = TRecord(code, members, symbol=F&#39;RECORD{k}&#39;)
            else:
                t = TPrimitive(code, symbol=code.name)
            if exported:
                t.symbol = _normalize(reader.read_length_prefixed_ascii())
                if self.version &lt;= 21:
                    t.name = _normalize(reader.read_length_prefixed_ascii())
            types.append(t)
            if self.version &gt;= 21:
                t.attributes = list(self._read_attributes())

    def _read_value(self, reader: StructReader | None = None) -&gt; Value:
        if reader is None:
            reader = self.reader
        type = self.types[reader.u32()]
        size = type.code.width
        processor: Callable[[], int | float | str | bytes] | None = {
            TC.U08           : reader.u8,
            TC.S08           : reader.i8,
            TC.U16           : reader.u16,
            TC.S16           : reader.i16,
            TC.U32           : reader.u32,
            TC.S32           : reader.i32,
            TC.S64           : reader.i64,
            TC.Single        : reader.f32,
            TC.Double        : reader.f64,
            TC.Extended      : lambda: extended(reader.read(10)),
            TC.AnsiString    : lambda: reader.read_length_prefixed(encoding=self.codec),
            TC.PChar         : lambda: reader.read_length_prefixed(encoding=self.codec),
            TC.WideString    : reader.read_length_prefixed_utf16,
            TC.UnicodeString : reader.read_length_prefixed_utf16,
            TC.Char          : lambda: chr(reader.u8()),
            TC.WideChar      : lambda: chr(reader.u16()),
            TC.ProcPtr       : lambda: self.functions[reader.u32()],
            TC.Set           : lambda: int.from_bytes(reader.read(type.size_in_bytes), &#39;little&#39;),
            TC.Currency      : lambda: reader.u64() / 10_000,
        }.get(type.code, None)
        if processor is not None:
            data = processor()
        elif size &gt; 0:
            data = bytes(reader.read(size))
        else:
            raise ValueError(F&#39;Unable to read attribute of type {type!s}.&#39;)
        if isinstance(data, str) and data not in self.strings:
            self.strings.append(data)
        return Value(type, data)

    def _read_attributes(self) -&gt; Generator[FunctionAttribute]:
        reader = self.reader
        count = reader.u32()
        for _ in range(count):
            name = reader.read_length_prefixed_ascii()
            fields = tuple(self._read_value() for _ in range(reader.u32()))
            yield FunctionAttribute(name, fields)

    def _load_functions(self):
        def _signature(name: str, decl: DeclSpec | None):
            signature = IFPSAPI.get(name, IFPSEvents.get(name)) if name else None
            if decl and decl.classname and (ic := IFPSClasses.Classes.get(decl.classname)):
                if ic.name not in self.types_by_name:
                    missing_types.add(ic.name)
                signature = ic.members.get(decl.name, signature)
                decl.classname = ic.name
            return signature

        reader = self.reader
        rewind = reader.tell()
        width = len(F&#39;{self.count_functions:X}&#39;)
        missing_types = set()
        load_flags = (self.version &gt;= 23)

        reparsed = False
        all_void = True
        all_long = True
        has_dll_imports = False

        while True:
            for k in range(self.count_functions):
                decl = None
                body = None
                name = F&#39;F{k:0{width}X}&#39;
                tags = reader.u8()
                attributes = None
                exported = FTag.Exported.check(tags)
                if FTag.External.check(tags):
                    name = reader.read_length_prefixed_ascii(8)
                    if exported:
                        read = StructReader(bytes(reader.read_length_prefixed()))
                        decl = DeclSpec.ParseF(read, load_flags)
                        if not reparsed and decl.module is not None:
                            has_dll_imports = True
                            # inno: 0d13564460b4cca289ac60221e86ca5719d7217a8eb76671b4b2a8407c2af6b4
                            # ifps: 6c211c02652317903b23c827cbc311a258fcd6197eec6a3d2f91986bd8accb0e
                            # This script reports version 22 and therefore, load_flags starts as False.
                            # However, it should be true; the reasons are unclear. The code below is
                            # an attempt to identify incorrect load_flags values heuristically. When
                            # there are no __delay_load functions present, reading them with load_flags
                            # set to False will result in only procedures (void=True) with at least
                            # 2 arguments.
                            if not decl.void:
                                all_void = False
                            if len(decl.parameters) &lt; 2:
                                all_long = False
                else:
                    offset = reader.u32()
                    length = reader.u32()
                    if exported:
                        name = reader.read_length_prefixed_ascii()
                        decl = DeclSpec.ParseE(bytes(reader.read_length_prefixed()), self)
                    with reader.detour(offset):
                        body = reader.read(length)
                if FTag.HasAttrs.check(tags):
                    attributes = list(self._read_attributes())
                fn = Function(name, decl=decl, body=body, attributes=attributes)
                self.functions.append(fn)
            if has_dll_imports and all_long and all_void and not reparsed:
                load_flags = True
                reparsed = True
                reader.seekset(rewind)
                self.functions.clear()
            else:
                break

        byfqn: dict[str, list[Function]] = {}

        for function in self.functions:
            key = str(function)
            byfqn.setdefault(key, []).append(function)
            if body := function.body:
                void = decl.void if (decl := function.decl) else False
                function.body = list(self._parse_bytecode(body, void))

        for functions in byfqn.values():
            if len(functions) != 2:
                continue
            getter, setter = functions
            if not (s_decl := setter.decl):
                continue
            if not (g_decl := getter.decl):
                continue
            if setter.decl.is_property:
                setter, getter = getter, setter
                s_decl, g_decl = g_decl, s_decl
            if s_decl.is_property:
                continue
            if not g_decl.is_property:
                continue
            g_decl.is_property = False
            g_decl.name = F&#39;Get{g_decl.name}&#39;
            s_decl.name = F&#39;Set{s_decl.name}&#39;

        for function in self.functions:
            name = function.symbol
            decl = function.decl
            if (signature := _signature(name, decl)) and decl:
                if signature.argc == decl.argc:
                    for old, new in itertools.zip_longest(decl.parameters, signature.parameters):
                        if not new:
                            break
                        if old and (t := old.type):
                            t.symbol = new.type
                            continue
                        if t := self.types_by_name.get(new.type):
                            t.symbol = new.type
                        else:
                            missing_types.add(new.type)
                if sr := signature.return_type:
                    if (dr := decl.return_type) or (dr := self.types_by_name.get(sr)):
                        dr.symbol = sr
                    else:
                        missing_types.add(sr)

        self.type_name_conflicts = self._name_types(missing_types)

        for function in self.functions:
            decl = function.decl
            if signature := _signature(function.name, decl):
                decl = decl or DeclSpec(True)
                decl.void = signature.void
                parameters = decl.parameters
                if signature.argc != len(parameters):
                    decl.parameters = parameters = [DeclSpecParam(True) for _ in range(signature.argc)]
                for old, new in zip(parameters, signature.parameters):
                    if old.type is None:
                        old.type = self.types_by_name.get(new.type)
                    old.name = new.name or old.name
                    old.const = new.const
                function.symbol = decl.name = signature.name
                if (rt := signature.return_type) and (decl.return_type is None):
                    decl.return_type = self.types_by_name.get(rt, decl.return_type)
                function.decl = decl
            elif decl and decl.is_property and decl.argc &gt;= (k := decl.void + 1):
                del decl.parameters[:k]

        for function in self.functions:
            if (decl := function.decl) and decl.is_property:
                classname = decl.classname
                this = DeclSpecParam(True, self.types_by_name.get(classname), &#39;This&#39;)
                nval = DeclSpecParam(True, decl.return_type, &#39;NewValue&#39;)
                info = IFPSClasses.Classes.get(classname)
                info = info and info.members.get(decl.name)
                if not info or info.writable:
                    function.setter = Function(decl=DeclSpec(
                        void=True,
                        parameters=[this, *decl.parameters, nval],
                        name=F&#39;Set{decl.name}&#39;,
                        calling_convention=None,
                        return_type=None,
                        classname=classname,
                        is_accessor=True
                    ))
                if not info or info.readable:
                    function.getter = Function(decl=DeclSpec(
                        void=False,
                        parameters=[this, *decl.parameters],
                        name=F&#39;Get{decl.name}&#39;,
                        calling_convention=None,
                        return_type=decl.return_type,
                        classname=classname,
                        is_accessor=True
                    ))

            if function.body is None:
                continue
            for instruction in function.body:
                if instruction.opcode is Op.Call:
                    t: Function = self.functions[instruction.operands[0]]
                    instruction.operands[0] = t

    def _load_variables(self):
        reader = self.reader
        for index in range(self.count_variables):
            code = reader.u32()
            spec = VariableSpec(index, VariableType.Global)
            if reader.u8() &amp; 1:
                spec = reader.read_length_prefixed_ascii()
            self.globals.append(VariableBase(self.types[code], spec))

    def _read_variable_spec(self, index: int, void: bool) -&gt; VariableSpec:
        if index &lt; 0x40000000:
            return VariableSpec(index, VariableType.Global)
        index -= 0x60000000
        if index &gt;= 0:
            return VariableSpec(index, VariableType.Local)
        index = -index if void else ~index
        return VariableSpec(index, VariableType.Argument)

    def _read_operand(self, reader: StructReader, void: bool) -&gt; Operand:
        ot = OperandType(reader.u8())
        kw = {}
        if ot is OperandType.Variable:
            kw.update(variable=self._read_variable_spec(reader.u32(), void))
        if ot is OperandType.Value:
            kw.update(value=self._read_value(reader))
        if ot &gt;= OperandType.IndexedByInt:
            kw.update(variable=self._read_variable_spec(reader.u32(), void))
            index = reader.u32()
            if ot is OperandType.IndexedByVar:
                index = self._read_variable_spec(index, void)
            kw.update(index=index)
        return Operand(ot, **kw)

    def _parse_bytecode(self, data: memoryview, void: bool) -&gt; Generator[Instruction]:
        disassembly: dict[int, Instruction] = OrderedDict()
        reader = StructReader(data)

        argcount = {
            Op.Assign: 2,
            Op.CallVar: 1,
            Op.Dec: 1,
            Op.Inc: 1,
            Op.BooleanNot: 1,
            Op.Neg: 1,
            Op.IntegerNot: 1,
            Op.SetPtrToCopy: 2,
            Op.SetPtr: 2,
        }

        while not reader.eof:
            def arg(k=1):
                for _ in range(k):
                    args.append(self._read_operand(reader, void))
            addr = reader.tell()
            cval = reader.u8()
            code = Op.FromInt(cval)
            insn = Instruction(addr, code)
            args = insn.operands
            disassembly[insn.offset] = insn
            aryness = argcount.get(code)
            if aryness is not None:
                arg(aryness)
            elif code in (Op.Ret, Op.Nop, Op.Pop):
                pass
            elif code is Op.Calculate:
                insn.operator = AOp(reader.u8())
                arg(2)
            elif code in (Op.Push, Op.PushVar):
                arg()
            elif code in (Op.Jump, Op.JumpFlag):
                target = reader.i32()
                args.append(reader.tell() + target)
            elif code is Op.Call:
                args.append(reader.u32())
            elif code in (Op.JumpTrue, Op.JumpFalse):
                target = reader.i32()
                val = self._read_operand(reader, void)
                args.append(reader.tell() + target)
                args.append(val)
            elif code is Op.JumpPop1:
                target = reader.i32()
                args.append(reader.tell() + target)
            elif code is Op.JumpPop2:
                target = reader.i32()
                args.append(reader.tell() + target)
            elif code is Op.StackType:
                args.append(self._read_variable_spec(reader.u32(), void))
                args.append(reader.u32())
            elif code is Op.PushType:
                args.append(self.types[reader.u32()])
            elif code is Op.Compare:
                insn.operator = COp(reader.u8())
                arg(3)
            elif code is Op.SetFlag:
                arg()
                args.append(bool(reader.u8()))
            elif code is Op.PushEH:
                args.extend(reader.i32() for _ in range(4))
                for k, a in enumerate(args):
                    args[k] = a + reader.tell() if a &gt;= 0 else None
            elif code is Op.PopEH:
                args.append(reader.u8())
            elif code is Op._INVALID:
                raise ValueError(F&#39;Unsupported opcode: 0x{cval:02X}&#39;)
            else:
                raise ValueError(F&#39;Unhandled opcode: {code.name}&#39;)
            size = reader.tell() - addr
            reader.seekrel(-size)
            insn.encoded = bytes(reader.read(size))

        for k, instruction in enumerate(disassembly.values()):
            if not instruction.branches:
                continue
            target = instruction.operands[0]
            try:
                disassembly[target].jumptarget = True
            except KeyError as K:
                raise RuntimeError(
                    F&#39;The jump target of instruction {k} at 0x{instruction.offset:X} is invalid; &#39;
                    F&#39;the invalid instruction is a {instruction.opcode.name} to 0x{target:X}.&#39;
                ) from K

        yield from disassembly.values()

    def __str__(self):
        return self.disassembly()

    def disassembly(self, print_bytes: bool = False, print_bytes_count: int = 12) -&gt; str:
        def sortkey(f: Function):
            d = (d.module or &#39;&#39;, d.classname or &#39;&#39;, d.void) if (d := f.decl) else (&#39;&#39;, &#39;&#39;, True)
            return (*d, f.name)

        for function in self.functions:
            function.get_basic_blocks()

        classes: dict[str, dict[str, Function]] = {}
        external: list[Function] = []
        internal: list[Function] = []

        for t in self.types:
            if isinstance(t, TClass):
                classes[t.name] = {}

        for function in self.functions:
            if (decl := function.decl) and (name := decl.classname):
                try:
                    members = classes[name]
                except KeyError:
                    members = classes[name] = {}
                members[decl.name] = function
                continue
            dl = internal if function.body else external
            dl.append(function)

        external.sort(key=sortkey)

        output = io.StringIO()
        _omax = max((
            max(insn.offset for insn in fn.body)
            for fn in self.functions if fn.body
        ), default=0)
        _smax = max((
            max((insn.stack for insn in fn.body if insn.stack is not None), default=1)
            for fn in self.functions if fn.body
        ), default=0)
        _omax = max(len(self.types), len(self.globals), _omax)
        _omax = len(F&#39;{_omax:X}&#39;)
        _smax = len(F&#39;{_smax:d}&#39;)

        if classes:
            for name, members in classes.items():
                if not members:
                    output.write(F&#39;external class {name};\n&#39;)
            output.write(&#39;\n&#39;)
            for name, members in classes.items():
                if not members:
                    continue
                output.write(F&#39;external class {name}&#39;)
                if members:
                    for spec in members.values():
                        if spec.decl.is_accessor:
                            continue
                        output.write(F&#39;\n{_TAB}{spec.decl.represent(spec.symbol, rel=True)}&#39;)
                    output.write(&#39;\nend&#39;)
                output.write(&#39;;\n\n&#39;)

        if self.types:
            typedefs = []
            for type in self.types:
                if type.code != TC.Record and type.symbol in (type.code.name, None):
                    continue
                if isinstance(type, TClass):
                    continue
                typedefs.append((type.symbol, type.display()))
            typedefs.sort()
            for symbol, display in typedefs:
                output.write(F&#39;typedef {symbol} = {display}\n&#39;)
            output.write(&#39;\n&#39;)

        if self.globals:
            for variable in self.globals:
                output.write(F&#39;global {variable!s}\n&#39;)
            output.write(&#39;\n&#39;)

        if external:
            for function in external:
                output.write(F&#39;external {function!r}\n&#39;)
            output.write(&#39;\n&#39;)

        if internal:
            def create_prefix(instruction: Instruction):
                stack = instruction.stack
                stack = &#39;?&#39; * _smax if stack is None else F&#39;{stack:&gt;{_smax}d}&#39;
                return F&#39;{_TAB}0x{instruction.offset:0{_omax}X}{_TAB}{stack}{_TAB}&#39;

            for function in internal:
                labels = [insn.offset for insn in function.body if insn.jumptarget]
                labelw = max(len(str(len(labels))), 2)
                labeld = {v: F&#39;JumpDestination{k:0{labelw}d}&#39; for k, v in enumerate(labels, 1)}

                output.write(F&#39;{function!r}\nbegin\n&#39;)
                labelc = 0

                for instruction in function.body:
                    prefix = create_prefix(instruction)
                    if instruction.jumptarget:
                        output.write(F&#39;{labeld[labels[labelc]]}:\n&#39;)
                        labelc += 1
                    if print_bytes:
                        hexbytes = instruction.encoded.hex(&#39; &#39;).split()
                    else:
                        hexbytes = [&#39;&#39;]
                    hexbytes_iter = iter(hexbytes)
                    instruction_written = False
                    prefix_length = len(prefix)
                    ic = instruction.pretty(labeld)
                    while line := list(itertools.islice(hexbytes_iter, 0, print_bytes_count)):
                        output.write(prefix)
                        if print_bytes:
                            prefix = prefix_length * &#39;\x20&#39;
                            output.write(&#39;\x20&#39;.join(line).ljust(3 * print_bytes_count - 1))
                        if not instruction_written:
                            output.write(ic)
                            instruction_written = True
                        output.write(&#39;\n&#39;)

                output.write(&#39;end;\n\n&#39;)

        return output.getvalue().strip()</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="refinery.lib.inno.ifps.IFPSType"><code class="name">var <span class="ident">IFPSType</span></code></dt>
<dd>
<section class="desc"><p>Represents any of the possible IFPS data types:</p>
<ul>
<li><code><a title="refinery.lib.inno.ifps.TRecord" href="#refinery.lib.inno.ifps.TRecord">TRecord</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.TStaticArray" href="#refinery.lib.inno.ifps.TStaticArray">TStaticArray</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.TArray" href="#refinery.lib.inno.ifps.TArray">TArray</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.TSet" href="#refinery.lib.inno.ifps.TSet">TSet</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.TProcPtr" href="#refinery.lib.inno.ifps.TProcPtr">TProcPtr</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.TClass" href="#refinery.lib.inno.ifps.TClass">TClass</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.TInterface" href="#refinery.lib.inno.ifps.TInterface">TInterface</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.TPrimitive" href="#refinery.lib.inno.ifps.TPrimitive">TPrimitive</a></code></li>
</ul></section>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.inno.ifps.extended"><code class="name flex">
<span>def <span class="ident">extended</span></span>(<span>_data)</span>
</code></dt>
<dd>
<section class="desc"><p>A helper function to parse 10 bytes into an extended type float value within the IFPS runtime.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L35-L59" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def extended(_data: bytes):
    &#34;&#34;&#34;
    A helper function to parse 10 bytes into an extended type float value within the IFPS runtime.
    &#34;&#34;&#34;
    if len(_data) != 10:
        raise ValueError
    data = int.from_bytes(_data, &#39;little&#39;)
    sign = data &gt;&gt; 79
    data = data ^ (sign &lt;&lt; 79)
    sign = -1.0 if sign else +1.0
    exponent = data &gt;&gt; 64
    data = data ^ (exponent &lt;&lt; 64)
    if exponent == 0:
        if data == 0:
            return sign * 0
        exponent = -16382
    elif exponent == 0b111111111111111:
        if data == 0:
            return sign * float(&#39;Inf&#39;)
        else:
            return sign * float(&#39;NaN&#39;)
    else:
        exponent = exponent - 16383
    mantissa = data / (1 &lt;&lt; 64)
    return sign * mantissa * (2 ** exponent)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.represent"><code class="name flex">
<span>def <span class="ident">represent</span></span>(<span>cls)</span>
</code></dt>
<dd>
<section class="desc"><p>A decorator for various IFPS integer enumeration classes to change the default string
representation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L62-L69" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def represent(cls: _E) -&gt; _E:
    &#34;&#34;&#34;
    A decorator for various IFPS integer enumeration classes to change the default string
    representation.
    &#34;&#34;&#34;
    cls.__repr__ = lambda self: F&#39;{self.__class__.__name__}.{self.name}&#39;
    cls. __str__ = lambda self: self.name
    return cls</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.ifpstype"><code class="name flex">
<span>def <span class="ident">ifpstype</span></span>(<span>cls)</span>
</code></dt>
<dd>
<section class="desc"><p>A decorator for IFPS types to mix the <code><a title="refinery.lib.inno.ifps.IFPSTypeMixin" href="#refinery.lib.inno.ifps.IFPSTypeMixin">IFPSTypeMixin</a></code> into the dataclass
definition.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L315-L324" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ifpstype(cls: _C) -&gt; _C | type[IFPSTypeMixin]:
    &#34;&#34;&#34;
    A decorator for IFPS types to mix the `refinery.lib.inno.ifps.IFPSTypeMixin` into the dataclass
    definition.
    &#34;&#34;&#34;
    cls = dataclass(cls)
    mix = type(cls.__qualname__, (IFPSTypeMixin, cls), {})
    assigned = set(WRAPPER_ASSIGNMENTS) - {&#39;__annotations__&#39;}
    update_wrapper(mix, cls, assigned=assigned, updated=())
    return dataclass(mix)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.inno.ifps.Op"><code class="flex name class">
<span>class <span class="ident">Op</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration of all known IFPS opcodes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L72-L112" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@represent
class Op(enum.IntEnum):
    &#34;&#34;&#34;
    An enumeration of all known IFPS opcodes.
    &#34;&#34;&#34;
    Assign       = 0x00  # noqa
    Calculate    = 0x01  # noqa
    Push         = 0x02  # noqa
    PushVar      = 0x03  # noqa
    Pop          = 0x04  # noqa
    Call         = 0x05  # noqa
    Jump         = 0x06  # noqa
    JumpTrue     = 0x07  # noqa
    JumpFalse    = 0x08  # noqa
    Ret          = 0x09  # noqa
    StackType    = 0x0A  # noqa
    PushType     = 0x0B  # noqa
    Compare      = 0x0C  # noqa
    CallVar      = 0x0D  # noqa
    SetPtr       = 0x0E  # noqa
    BooleanNot   = 0x0F  # noqa
    Neg          = 0x10  # noqa
    SetFlag      = 0x11  # noqa
    JumpFlag     = 0x12  # noqa
    PushEH       = 0x13  # noqa
    PopEH        = 0x14  # noqa
    IntegerNot   = 0x15  # noqa
    SetPtrToCopy = 0x16  # noqa
    Inc          = 0x17  # noqa
    Dec          = 0x18  # noqa
    JumpPop1     = 0x19  # noqa
    JumpPop2     = 0x1A  # noqa
    Nop          = 0xFF  # noqa
    _INVALID     = 0xDD  # noqa

    @classmethod
    def FromInt(cls, code: int):
        try:
            return cls(code)
        except ValueError:
            return cls._INVALID</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.Op.Assign"><code class="name">var <span class="ident">Assign</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.Calculate"><code class="name">var <span class="ident">Calculate</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.Push"><code class="name">var <span class="ident">Push</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.PushVar"><code class="name">var <span class="ident">PushVar</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.Pop"><code class="name">var <span class="ident">Pop</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.Call"><code class="name">var <span class="ident">Call</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.Jump"><code class="name">var <span class="ident">Jump</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.JumpTrue"><code class="name">var <span class="ident">JumpTrue</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.JumpFalse"><code class="name">var <span class="ident">JumpFalse</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.Ret"><code class="name">var <span class="ident">Ret</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.StackType"><code class="name">var <span class="ident">StackType</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.PushType"><code class="name">var <span class="ident">PushType</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.Compare"><code class="name">var <span class="ident">Compare</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.CallVar"><code class="name">var <span class="ident">CallVar</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.SetPtr"><code class="name">var <span class="ident">SetPtr</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.BooleanNot"><code class="name">var <span class="ident">BooleanNot</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.Neg"><code class="name">var <span class="ident">Neg</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.SetFlag"><code class="name">var <span class="ident">SetFlag</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.JumpFlag"><code class="name">var <span class="ident">JumpFlag</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.PushEH"><code class="name">var <span class="ident">PushEH</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.PopEH"><code class="name">var <span class="ident">PopEH</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.IntegerNot"><code class="name">var <span class="ident">IntegerNot</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.SetPtrToCopy"><code class="name">var <span class="ident">SetPtrToCopy</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.Inc"><code class="name">var <span class="ident">Inc</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.Dec"><code class="name">var <span class="ident">Dec</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.JumpPop1"><code class="name">var <span class="ident">JumpPop1</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.JumpPop2"><code class="name">var <span class="ident">JumpPop2</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Op.Nop"><code class="name">var <span class="ident">Nop</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.inno.ifps.Op.FromInt"><code class="name flex">
<span>def <span class="ident">FromInt</span></span>(<span>code)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.AOp"><code class="flex name class">
<span>class <span class="ident">AOp</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration of all known IFPS arithmetic opcodes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L115-L132" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class AOp(enum.IntEnum):
    &#34;&#34;&#34;
    An enumeration of all known IFPS arithmetic opcodes.
    &#34;&#34;&#34;
    Add = 0
    Sub = 1
    Mul = 2
    Div = 3
    Mod = 4
    Shl = 5
    Shr = 6
    And = 7
    BOr = 8
    Xor = 9

    def __str__(self):
        glyph = (&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;%&#39;, &#39;&lt;&lt;&#39;, &#39;&gt;&gt;&#39;, &#39;&amp;&#39;, &#39;|&#39;, &#39;^&#39;)[self]
        return F&#39;{glyph}=&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.AOp.Add"><code class="name">var <span class="ident">Add</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.AOp.Sub"><code class="name">var <span class="ident">Sub</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.AOp.Mul"><code class="name">var <span class="ident">Mul</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.AOp.Div"><code class="name">var <span class="ident">Div</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.AOp.Mod"><code class="name">var <span class="ident">Mod</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.AOp.Shl"><code class="name">var <span class="ident">Shl</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.AOp.Shr"><code class="name">var <span class="ident">Shr</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.AOp.And"><code class="name">var <span class="ident">And</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.AOp.BOr"><code class="name">var <span class="ident">BOr</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.AOp.Xor"><code class="name">var <span class="ident">Xor</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.COp"><code class="flex name class">
<span>class <span class="ident">COp</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration of all known IFPS comparison opcodes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L135-L149" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class COp(enum.IntEnum):
    &#34;&#34;&#34;
    An enumeration of all known IFPS comparison opcodes.
    &#34;&#34;&#34;
    GE = 0
    LE = 1
    GT = 2
    LT = 3
    NE = 4
    EQ = 5
    IN = 6
    IS = 7

    def __str__(self):
        return (&#39;&gt;=&#39;, &#39;&lt;=&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;!=&#39;, &#39;==&#39;, &#39;in&#39;, &#39;is&#39;)[self]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.COp.GE"><code class="name">var <span class="ident">GE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.COp.LE"><code class="name">var <span class="ident">LE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.COp.GT"><code class="name">var <span class="ident">GT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.COp.LT"><code class="name">var <span class="ident">LT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.COp.NE"><code class="name">var <span class="ident">NE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.COp.EQ"><code class="name">var <span class="ident">EQ</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.COp.IN"><code class="name">var <span class="ident">IN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.COp.IS"><code class="name">var <span class="ident">IS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.TC"><code class="flex name class">
<span>class <span class="ident">TC</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>An enumeration of all known IFPS type codes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L152-L245" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@represent
class TC(enum.IntEnum):
    &#34;&#34;&#34;
    An enumeration of all known IFPS type codes.
    &#34;&#34;&#34;
    ReturnAddress       = 0x00  # noqa
    U08                 = 0x01  # noqa
    S08                 = 0x02  # noqa
    U16                 = 0x03  # noqa
    S16                 = 0x04  # noqa
    U32                 = 0x05  # noqa
    S32                 = 0x06  # noqa
    Single              = 0x07  # noqa
    Double              = 0x08  # noqa
    Extended            = 0x09  # noqa
    AnsiString          = 0x0A  # noqa
    Record              = 0x0B  # noqa
    Array               = 0x0C  # noqa
    Pointer             = 0x0D  # noqa
    PChar               = 0x0E  # noqa
    ResourcePointer     = 0x0F  # noqa
    Variant             = 0x10  # noqa
    S64                 = 0x11  # noqa
    Char                = 0x12  # noqa
    WideString          = 0x13  # noqa
    WideChar            = 0x14  # noqa
    ProcPtr             = 0x15  # noqa
    StaticArray         = 0x16  # noqa
    Set                 = 0x17  # noqa
    Currency            = 0x18  # noqa
    Class               = 0x19  # noqa
    Interface           = 0x1A  # noqa
    NotificationVariant = 0x1B  # noqa
    UnicodeString       = 0x1C  # noqa
    Enum                = 0x81  # noqa
    Type                = 0x82  # noqa
    ExtClass            = 0x83  # noqa

    @property
    def primitive(self) -&gt; bool:
        &#34;&#34;&#34;
        Indicates whether the code represents a primitive type.
        &#34;&#34;&#34;
        return self not in {
            TC.Class,
            TC.ProcPtr,
            TC.Interface,
            TC.Set,
            TC.StaticArray,
            TC.Array,
            TC.Record,
        }

    @property
    def container(self) -&gt; bool:
        &#34;&#34;&#34;
        Indicates whether the code represents a container type.
        &#34;&#34;&#34;
        return self in {
            TC.StaticArray,
            TC.Array,
            TC.Record,
        }

    @property
    def width(self):
        &#34;&#34;&#34;
        For primitive types, this gives the size of an immediate of this type in bytes.
        &#34;&#34;&#34;
        return {
            TC.Variant       : 0x10,
            TC.Char          : 0x01,
            TC.S08           : 0x01,
            TC.U08           : 0x01,
            TC.WideChar      : 0x02,
            TC.S16           : 0x02,
            TC.U16           : 0x02,
            TC.WideString    : 0x04,
            TC.UnicodeString : 0x04,
            TC.Interface     : 0x04,
            TC.Class         : 0x04,
            TC.PChar         : 0x04,
            TC.AnsiString    : 0x04,
            TC.Single        : 0x04,
            TC.S32           : 0x04,
            TC.U32           : 0x04,
            TC.ProcPtr       : 0x0C,
            TC.Currency      : 0x08,
            TC.Pointer       : 0x0C,
            TC.Double        : 0x08,
            TC.S64           : 0x08,
            TC.Extended      : 0x0A,
            TC.ReturnAddress : 0x1C,
        }.get(self, 0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.TC.ReturnAddress"><code class="name">var <span class="ident">ReturnAddress</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.U08"><code class="name">var <span class="ident">U08</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.S08"><code class="name">var <span class="ident">S08</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.U16"><code class="name">var <span class="ident">U16</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.S16"><code class="name">var <span class="ident">S16</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.U32"><code class="name">var <span class="ident">U32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.S32"><code class="name">var <span class="ident">S32</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.Single"><code class="name">var <span class="ident">Single</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.Double"><code class="name">var <span class="ident">Double</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.Extended"><code class="name">var <span class="ident">Extended</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.AnsiString"><code class="name">var <span class="ident">AnsiString</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.Record"><code class="name">var <span class="ident">Record</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.Array"><code class="name">var <span class="ident">Array</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.Pointer"><code class="name">var <span class="ident">Pointer</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.PChar"><code class="name">var <span class="ident">PChar</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.ResourcePointer"><code class="name">var <span class="ident">ResourcePointer</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.Variant"><code class="name">var <span class="ident">Variant</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.S64"><code class="name">var <span class="ident">S64</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.Char"><code class="name">var <span class="ident">Char</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.WideString"><code class="name">var <span class="ident">WideString</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.WideChar"><code class="name">var <span class="ident">WideChar</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.ProcPtr"><code class="name">var <span class="ident">ProcPtr</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.StaticArray"><code class="name">var <span class="ident">StaticArray</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.Set"><code class="name">var <span class="ident">Set</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.Currency"><code class="name">var <span class="ident">Currency</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.Class"><code class="name">var <span class="ident">Class</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.Interface"><code class="name">var <span class="ident">Interface</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.NotificationVariant"><code class="name">var <span class="ident">NotificationVariant</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.UnicodeString"><code class="name">var <span class="ident">UnicodeString</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.Enum"><code class="name">var <span class="ident">Enum</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.Type"><code class="name">var <span class="ident">Type</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.TC.ExtClass"><code class="name">var <span class="ident">ExtClass</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.TC.primitive"><code class="name">var <span class="ident">primitive</span></code></dt>
<dd>
<section class="desc"><p>Indicates whether the code represents a primitive type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L190-L203" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def primitive(self) -&gt; bool:
    &#34;&#34;&#34;
    Indicates whether the code represents a primitive type.
    &#34;&#34;&#34;
    return self not in {
        TC.Class,
        TC.ProcPtr,
        TC.Interface,
        TC.Set,
        TC.StaticArray,
        TC.Array,
        TC.Record,
    }</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.TC.container"><code class="name">var <span class="ident">container</span></code></dt>
<dd>
<section class="desc"><p>Indicates whether the code represents a container type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L205-L214" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def container(self) -&gt; bool:
    &#34;&#34;&#34;
    Indicates whether the code represents a container type.
    &#34;&#34;&#34;
    return self in {
        TC.StaticArray,
        TC.Array,
        TC.Record,
    }</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.TC.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<section class="desc"><p>For primitive types, this gives the size of an immediate of this type in bytes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L216-L245" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def width(self):
    &#34;&#34;&#34;
    For primitive types, this gives the size of an immediate of this type in bytes.
    &#34;&#34;&#34;
    return {
        TC.Variant       : 0x10,
        TC.Char          : 0x01,
        TC.S08           : 0x01,
        TC.U08           : 0x01,
        TC.WideChar      : 0x02,
        TC.S16           : 0x02,
        TC.U16           : 0x02,
        TC.WideString    : 0x04,
        TC.UnicodeString : 0x04,
        TC.Interface     : 0x04,
        TC.Class         : 0x04,
        TC.PChar         : 0x04,
        TC.AnsiString    : 0x04,
        TC.Single        : 0x04,
        TC.S32           : 0x04,
        TC.U32           : 0x04,
        TC.ProcPtr       : 0x0C,
        TC.Currency      : 0x08,
        TC.Pointer       : 0x0C,
        TC.Double        : 0x08,
        TC.S64           : 0x08,
        TC.Extended      : 0x0A,
        TC.ReturnAddress : 0x1C,
    }.get(self, 0)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.IFPSTypeMixin"><code class="flex name class">
<span>class <span class="ident">IFPSTypeMixin</span></span>
<span>(</span><span>symbol=None, attributes=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A helper class to mix additional properties into various IFPS type classes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L248-L259" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class IFPSTypeMixin:
    &#34;&#34;&#34;
    A helper class to mix additional properties into various IFPS type classes.
    &#34;&#34;&#34;
    symbol: str | None = None
    attributes: list[FunctionAttribute] | None = None

    def __str__(self):
        if self.symbol is not None:
            return self.symbol
        return super().__str__()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.ifps.TArray" href="#refinery.lib.inno.ifps.TArray">TArray</a></li>
<li><a title="refinery.lib.inno.ifps.TClass" href="#refinery.lib.inno.ifps.TClass">TClass</a></li>
<li><a title="refinery.lib.inno.ifps.TInterface" href="#refinery.lib.inno.ifps.TInterface">TInterface</a></li>
<li><a title="refinery.lib.inno.ifps.TPrimitive" href="#refinery.lib.inno.ifps.TPrimitive">TPrimitive</a></li>
<li><a title="refinery.lib.inno.ifps.TProcPtr" href="#refinery.lib.inno.ifps.TProcPtr">TProcPtr</a></li>
<li><a title="refinery.lib.inno.ifps.TRecord" href="#refinery.lib.inno.ifps.TRecord">TRecord</a></li>
<li><a title="refinery.lib.inno.ifps.TSet" href="#refinery.lib.inno.ifps.TSet">TSet</a></li>
<li><a title="refinery.lib.inno.ifps.TStaticArray" href="#refinery.lib.inno.ifps.TStaticArray">TStaticArray</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.IFPSTypeMixin.symbol"><code class="name">var <span class="ident">symbol</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.IFPSTypeMixin.attributes"><code class="name">var <span class="ident">attributes</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.IFPSTypeBase"><code class="flex name class">
<span>class <span class="ident">IFPSTypeBase</span></span>
<span>(</span><span>code)</span>
</code></dt>
<dd>
<section class="desc"><p>The base class for any IFPS type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L262-L312" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class IFPSTypeBase(abc.ABC):
    &#34;&#34;&#34;
    The base class for any IFPS type.
    &#34;&#34;&#34;
    code: TC

    def simple(self, nested=False):
        &#34;&#34;&#34;
        Indicate whether the type requires more than one line to pretty print.
        &#34;&#34;&#34;
        return True

    def display(self, indent=0):
        &#34;&#34;&#34;
        Compute a display string that can be used to represent the type in disassembly.
        &#34;&#34;&#34;
        return indent * _TAB + self.code.name

    @abc.abstractmethod
    def py_type(self, key: int | None = None) -&gt; type | None:
        &#34;&#34;&#34;
        If possible, provide a Python type equivalent for this IFPS type. The optional key argument
        is required only for the `refinery.lib.inno.ifps.TRecord` class.
        &#34;&#34;&#34;
        ...

    @abc.abstractmethod
    def default(self, key: int | None = None):
        &#34;&#34;&#34;
        Compute the default value for this type. The optional key argument is required only for the
        `refinery.lib.inno.ifps.TRecord` class.
        &#34;&#34;&#34;
        ...

    @property
    def primitive(self) -&gt; bool:
        &#34;&#34;&#34;
        Indicates whether the type is primitive.
        &#34;&#34;&#34;
        return self.code.primitive

    @property
    def container(self) -&gt; bool:
        &#34;&#34;&#34;
        Indicates whether the type is a container.
        &#34;&#34;&#34;
        return self.code.container

    def __str__(self):
        return self.display(0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.ifps.TArray" href="#refinery.lib.inno.ifps.TArray">TArray</a></li>
<li><a title="refinery.lib.inno.ifps.TClass" href="#refinery.lib.inno.ifps.TClass">TClass</a></li>
<li><a title="refinery.lib.inno.ifps.TInterface" href="#refinery.lib.inno.ifps.TInterface">TInterface</a></li>
<li><a title="refinery.lib.inno.ifps.TPrimitive" href="#refinery.lib.inno.ifps.TPrimitive">TPrimitive</a></li>
<li><a title="refinery.lib.inno.ifps.TProcPtr" href="#refinery.lib.inno.ifps.TProcPtr">TProcPtr</a></li>
<li><a title="refinery.lib.inno.ifps.TRecord" href="#refinery.lib.inno.ifps.TRecord">TRecord</a></li>
<li><a title="refinery.lib.inno.ifps.TSet" href="#refinery.lib.inno.ifps.TSet">TSet</a></li>
<li><a title="refinery.lib.inno.ifps.TStaticArray" href="#refinery.lib.inno.ifps.TStaticArray">TStaticArray</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.IFPSTypeBase.code"><code class="name">var <span class="ident">code</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.IFPSTypeBase.primitive"><code class="name">var <span class="ident">primitive</span></code></dt>
<dd>
<section class="desc"><p>Indicates whether the type is primitive.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L297-L302" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def primitive(self) -&gt; bool:
    &#34;&#34;&#34;
    Indicates whether the type is primitive.
    &#34;&#34;&#34;
    return self.code.primitive</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.IFPSTypeBase.container"><code class="name">var <span class="ident">container</span></code></dt>
<dd>
<section class="desc"><p>Indicates whether the type is a container.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L304-L309" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def container(self) -&gt; bool:
    &#34;&#34;&#34;
    Indicates whether the type is a container.
    &#34;&#34;&#34;
    return self.code.container</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.ifps.IFPSTypeBase.simple"><code class="name flex">
<span>def <span class="ident">simple</span></span>(<span>self, nested=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Indicate whether the type requires more than one line to pretty print.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L269-L273" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def simple(self, nested=False):
    &#34;&#34;&#34;
    Indicate whether the type requires more than one line to pretty print.
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.IFPSTypeBase.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute a display string that can be used to represent the type in disassembly.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L275-L279" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def display(self, indent=0):
    &#34;&#34;&#34;
    Compute a display string that can be used to represent the type in disassembly.
    &#34;&#34;&#34;
    return indent * _TAB + self.code.name</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.IFPSTypeBase.py_type"><code class="name flex">
<span>def <span class="ident">py_type</span></span>(<span>self, key=None)</span>
</code></dt>
<dd>
<section class="desc"><p>If possible, provide a Python type equivalent for this IFPS type. The optional key argument
is required only for the <code><a title="refinery.lib.inno.ifps.TRecord" href="#refinery.lib.inno.ifps.TRecord">TRecord</a></code> class.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L281-L287" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def py_type(self, key: int | None = None) -&gt; type | None:
    &#34;&#34;&#34;
    If possible, provide a Python type equivalent for this IFPS type. The optional key argument
    is required only for the `refinery.lib.inno.ifps.TRecord` class.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.IFPSTypeBase.default"><code class="name flex">
<span>def <span class="ident">default</span></span>(<span>self, key=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the default value for this type. The optional key argument is required only for the
<code><a title="refinery.lib.inno.ifps.TRecord" href="#refinery.lib.inno.ifps.TRecord">TRecord</a></code> class.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L289-L295" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def default(self, key: int | None = None):
    &#34;&#34;&#34;
    Compute the default value for this type. The optional key argument is required only for the
    `refinery.lib.inno.ifps.TRecord` class.
    &#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.TPrimitive"><code class="flex name class">
<span>class <span class="ident">TPrimitive</span></span>
<span>(</span><span>code, symbol=None, attributes=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A primitive IFPS type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L327-L364" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@ifpstype
class TPrimitive(IFPSTypeBase):
    &#34;&#34;&#34;
    A primitive IFPS type.
    &#34;&#34;&#34;
    def py_type(self, *_) -&gt; type | None:
        return {
            TC.ReturnAddress       : int,
            TC.U08                 : int,
            TC.S08                 : int,
            TC.U16                 : int,
            TC.S16                 : int,
            TC.U32                 : int,
            TC.S32                 : int,
            TC.Single              : float,
            TC.Double              : float,
            TC.Extended            : float,
            TC.AnsiString          : str,
            TC.Pointer             : VariableBase,
            TC.PChar               : str,
            TC.ResourcePointer     : VariableBase,
            TC.Variant             : object,
            TC.S64                 : int,
            TC.Char                : str,
            TC.WideString          : str,
            TC.WideChar            : str,
            TC.Currency            : float,
            TC.UnicodeString       : str,
            TC.Enum                : int,
            TC.Type                : IFPSType,
        }.get(self.code)

    def default(self, *_):
        if self.code in (TC.Char, TC.WideChar, TC.PChar):
            return &#39;\0&#39;
        tc = self.py_type()
        if issubclass(tc, (int, float, str)):
            return tc()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.ifps.IFPSTypeMixin" href="#refinery.lib.inno.ifps.IFPSTypeMixin">IFPSTypeMixin</a></li>
<li><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.container" href="#refinery.lib.inno.ifps.IFPSTypeBase.container">container</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.default" href="#refinery.lib.inno.ifps.IFPSTypeBase.default">default</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.display" href="#refinery.lib.inno.ifps.IFPSTypeBase.display">display</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.primitive" href="#refinery.lib.inno.ifps.IFPSTypeBase.primitive">primitive</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.py_type" href="#refinery.lib.inno.ifps.IFPSTypeBase.py_type">py_type</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.simple" href="#refinery.lib.inno.ifps.IFPSTypeBase.simple">simple</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.inno.ifps.TProcPtr"><code class="flex name class">
<span>class <span class="ident">TProcPtr</span></span>
<span>(</span><span>code, void, args, symbol=None, attributes=None)</span>
</code></dt>
<dd>
<section class="desc"><p>The procedure pointer IFPS type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L367-L392" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@ifpstype
class TProcPtr(IFPSTypeBase):
    &#34;&#34;&#34;
    The procedure pointer IFPS type.
    &#34;&#34;&#34;
    void: bool
    args: tuple[DeclSpecParam, ...]

    def py_type(self, *_):
        return None

    def default(self, *_):
        return None

    def display(self, indent=0):
        name = super().display(indent)
        args = []
        for k, spec in enumerate(self.args, 1):
            arg = F&#39;Arg{k}&#39;
            if not spec.const:
                arg = F&#39;*{arg}&#39;
            if spec.type is not None:
                arg = F&#39;{spec.type!s} {arg}&#39;
            args.append(arg)
        args = &#39;, &#39;.join(args)
        return F&#39;{name}({args})&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.ifps.IFPSTypeMixin" href="#refinery.lib.inno.ifps.IFPSTypeMixin">IFPSTypeMixin</a></li>
<li><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.container" href="#refinery.lib.inno.ifps.IFPSTypeBase.container">container</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.default" href="#refinery.lib.inno.ifps.IFPSTypeBase.default">default</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.display" href="#refinery.lib.inno.ifps.IFPSTypeBase.display">display</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.primitive" href="#refinery.lib.inno.ifps.IFPSTypeBase.primitive">primitive</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.py_type" href="#refinery.lib.inno.ifps.IFPSTypeBase.py_type">py_type</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.simple" href="#refinery.lib.inno.ifps.IFPSTypeBase.simple">simple</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.inno.ifps.TInterface"><code class="flex name class">
<span>class <span class="ident">TInterface</span></span>
<span>(</span><span>code, uuid, symbol=None, attributes=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An IFPS type representing a COM interface.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L395-L410" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@ifpstype
class TInterface(IFPSTypeBase):
    &#34;&#34;&#34;
    An IFPS type representing a COM interface.
    &#34;&#34;&#34;
    uuid: UUID

    def py_type(self, *_):
        return object

    def default(self, *_):
        return None

    def display(self, indent=0):
        display = super().display(indent)
        return F&#39;{display}({self.uuid!s})&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.ifps.IFPSTypeMixin" href="#refinery.lib.inno.ifps.IFPSTypeMixin">IFPSTypeMixin</a></li>
<li><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.container" href="#refinery.lib.inno.ifps.IFPSTypeBase.container">container</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.default" href="#refinery.lib.inno.ifps.IFPSTypeBase.default">default</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.display" href="#refinery.lib.inno.ifps.IFPSTypeBase.display">display</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.primitive" href="#refinery.lib.inno.ifps.IFPSTypeBase.primitive">primitive</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.py_type" href="#refinery.lib.inno.ifps.IFPSTypeBase.py_type">py_type</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.simple" href="#refinery.lib.inno.ifps.IFPSTypeBase.simple">simple</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.inno.ifps.TClass"><code class="flex name class">
<span>class <span class="ident">TClass</span></span>
<span>(</span><span>code, name, symbol=None, attributes=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An IFPS type representing an IFPS class.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L413-L424" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@ifpstype
class TClass(IFPSTypeBase):
    &#34;&#34;&#34;
    An IFPS type representing an IFPS class.
    &#34;&#34;&#34;
    name: str

    def py_type(self, *_):
        return None

    def default(self, *_):
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.ifps.IFPSTypeMixin" href="#refinery.lib.inno.ifps.IFPSTypeMixin">IFPSTypeMixin</a></li>
<li><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.container" href="#refinery.lib.inno.ifps.IFPSTypeBase.container">container</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.default" href="#refinery.lib.inno.ifps.IFPSTypeBase.default">default</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.display" href="#refinery.lib.inno.ifps.IFPSTypeBase.display">display</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.primitive" href="#refinery.lib.inno.ifps.IFPSTypeBase.primitive">primitive</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.py_type" href="#refinery.lib.inno.ifps.IFPSTypeBase.py_type">py_type</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.simple" href="#refinery.lib.inno.ifps.IFPSTypeBase.simple">simple</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.inno.ifps.TSet"><code class="flex name class">
<span>class <span class="ident">TSet</span></span>
<span>(</span><span>code, size, symbol=None, attributes=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An IFPS type representing a bit vector.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L427-L447" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@ifpstype
class TSet(IFPSTypeBase):
    &#34;&#34;&#34;
    An IFPS type representing a bit vector.
    &#34;&#34;&#34;
    size: int

    def py_type(self, *_):
        return int

    def default(self, *_):
        return 0

    @property
    def size_in_bytes(self):
        q, r = divmod(self.size, 8)
        return q + (r and 1 or 0)

    def display(self, indent=0):
        display = super().display(indent)
        return F&#39;{display}({self.size})&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.ifps.IFPSTypeMixin" href="#refinery.lib.inno.ifps.IFPSTypeMixin">IFPSTypeMixin</a></li>
<li><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.container" href="#refinery.lib.inno.ifps.IFPSTypeBase.container">container</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.default" href="#refinery.lib.inno.ifps.IFPSTypeBase.default">default</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.display" href="#refinery.lib.inno.ifps.IFPSTypeBase.display">display</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.primitive" href="#refinery.lib.inno.ifps.IFPSTypeBase.primitive">primitive</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.py_type" href="#refinery.lib.inno.ifps.IFPSTypeBase.py_type">py_type</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.simple" href="#refinery.lib.inno.ifps.IFPSTypeBase.simple">simple</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.inno.ifps.TArray"><code class="flex name class">
<span>class <span class="ident">TArray</span></span>
<span>(</span><span>code, type, symbol=None, attributes=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An IFPS type representing a dynamic array.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L450-L472" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@ifpstype
class TArray(IFPSTypeBase):
    &#34;&#34;&#34;
    An IFPS type representing a dynamic array.
    &#34;&#34;&#34;
    type: TPrimitive

    def py_type(self, key: int | None = None):
        if key is None:
            return list
        return self.type.py_type()

    def default(self, key: int | None = None):
        if key is None:
            return []
        return self.type.default()

    def display(self, indent=0):
        display = F&#39;{_TAB * indent}{self.type!s}&#39;
        return F&#39;array of {display}&#39;

    def simple(self, nested=False):
        return self.type.simple(nested)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.ifps.IFPSTypeMixin" href="#refinery.lib.inno.ifps.IFPSTypeMixin">IFPSTypeMixin</a></li>
<li><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.container" href="#refinery.lib.inno.ifps.IFPSTypeBase.container">container</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.default" href="#refinery.lib.inno.ifps.IFPSTypeBase.default">default</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.display" href="#refinery.lib.inno.ifps.IFPSTypeBase.display">display</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.primitive" href="#refinery.lib.inno.ifps.IFPSTypeBase.primitive">primitive</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.py_type" href="#refinery.lib.inno.ifps.IFPSTypeBase.py_type">py_type</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.simple" href="#refinery.lib.inno.ifps.IFPSTypeBase.simple">simple</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.inno.ifps.TStaticArray"><code class="flex name class">
<span>class <span class="ident">TStaticArray</span></span>
<span>(</span><span>code, type, size, offset=None, symbol=None, attributes=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An IFPS type representing a static array (i.e. a tuple).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L475-L499" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@ifpstype
class TStaticArray(IFPSTypeBase):
    &#34;&#34;&#34;
    An IFPS type representing a static array (i.e. a tuple).
    &#34;&#34;&#34;
    type: TPrimitive
    size: int
    offset: int | None = None

    def py_type(self, key: int | None = None):
        if key is None:
            return list
        return self.type.py_type(key)

    def default(self, key: int | None = None):
        if key is None:
            return [self.type.default() for _ in range(self.size)]
        return self.type.default()

    def display(self, indent=0):
        display = F&#39;{_TAB * indent}{self.type!s}&#39;
        return F&#39;{display}[{self.size}]&#39;

    def simple(self, nested=False):
        return self.type.simple(nested)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.ifps.IFPSTypeMixin" href="#refinery.lib.inno.ifps.IFPSTypeMixin">IFPSTypeMixin</a></li>
<li><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.container" href="#refinery.lib.inno.ifps.IFPSTypeBase.container">container</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.default" href="#refinery.lib.inno.ifps.IFPSTypeBase.default">default</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.display" href="#refinery.lib.inno.ifps.IFPSTypeBase.display">display</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.primitive" href="#refinery.lib.inno.ifps.IFPSTypeBase.primitive">primitive</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.py_type" href="#refinery.lib.inno.ifps.IFPSTypeBase.py_type">py_type</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.simple" href="#refinery.lib.inno.ifps.IFPSTypeBase.simple">simple</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.inno.ifps.TRecord"><code class="flex name class">
<span>class <span class="ident">TRecord</span></span>
<span>(</span><span>code, members, symbol=None, attributes=None)</span>
</code></dt>
<dd>
<section class="desc"><p>An IFPS type representing a structure.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L502-L545" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@ifpstype
class TRecord(IFPSTypeBase):
    &#34;&#34;&#34;
    An IFPS type representing a structure.
    &#34;&#34;&#34;
    members: tuple[TPrimitive, ...]

    @property
    def size(self):
        return len(self.members)

    def py_type(self, key: int | None = None):
        if key is None:
            return list
        return self.members[key].py_type()

    def default(self, key: int | None = None):
        if key is None:
            return [member.default() for member in self.members]
        return self.members[key].default()

    def simple(self, nested=False):
        if nested:
            return False
        if len(self.members) &gt; 10:
            return False
        return all(m.simple(True) for m in self.members)

    def display(self, indent=0):
        output = io.StringIO()
        output.write(indent * _TAB)
        output.write(&#39;struct {&#39;)
        if self.simple():
            output.write(&#39;, &#39;.join(str(m) for m in self.members))
        else:
            for k, member in enumerate(self.members):
                if k &gt; 0:
                    output.write(&#39;,&#39;)
                output.write(&#39;\n&#39;)
                output.write(member.display(indent + 1))
            if self.members:
                output.write(F&#39;\n{_TAB * indent}&#39;)
        output.write(&#39;}&#39;)
        return output.getvalue()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.ifps.IFPSTypeMixin" href="#refinery.lib.inno.ifps.IFPSTypeMixin">IFPSTypeMixin</a></li>
<li><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.container" href="#refinery.lib.inno.ifps.IFPSTypeBase.container">container</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.default" href="#refinery.lib.inno.ifps.IFPSTypeBase.default">default</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.display" href="#refinery.lib.inno.ifps.IFPSTypeBase.display">display</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.primitive" href="#refinery.lib.inno.ifps.IFPSTypeBase.primitive">primitive</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.py_type" href="#refinery.lib.inno.ifps.IFPSTypeBase.py_type">py_type</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.simple" href="#refinery.lib.inno.ifps.IFPSTypeBase.simple">simple</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.inno.ifps.Value"><code class="flex name class">
<span>class <span class="ident">Value</span></span>
<span>(</span><span>type, value)</span>
</code></dt>
<dd>
<section class="desc"><p>A value of the given type within the IFPS runtime.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L572-L595" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Value(NamedTuple):
    &#34;&#34;&#34;
    A value of the given type within the IFPS runtime.
    &#34;&#34;&#34;
    type: IFPSType
    value: str | int | float | bytes | Function

    def convert(self, *_):
        return self.type.py_type()

    def default(self, *_):
        return self.type.default()

    def __repr__(self):
        value = self.value
        if isinstance(value, bytes):
            value = value.hex()
        return F&#39;{self.type.code.name}({value!r})&#39;

    def __str__(self):
        v = self.value
        if isinstance(v, Function):
            return F&#39;&amp;{v!s}&#39;
        return repr(v)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.Value.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L572-L595" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Value(NamedTuple):
    &#34;&#34;&#34;
    A value of the given type within the IFPS runtime.
    &#34;&#34;&#34;
    type: IFPSType
    value: str | int | float | bytes | Function

    def convert(self, *_):
        return self.type.py_type()

    def default(self, *_):
        return self.type.default()

    def __repr__(self):
        value = self.value
        if isinstance(value, bytes):
            value = value.hex()
        return F&#39;{self.type.code.name}({value!r})&#39;

    def __str__(self):
        v = self.value
        if isinstance(v, Function):
            return F&#39;&amp;{v!s}&#39;
        return repr(v)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Value.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L572-L595" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Value(NamedTuple):
    &#34;&#34;&#34;
    A value of the given type within the IFPS runtime.
    &#34;&#34;&#34;
    type: IFPSType
    value: str | int | float | bytes | Function

    def convert(self, *_):
        return self.type.py_type()

    def default(self, *_):
        return self.type.default()

    def __repr__(self):
        value = self.value
        if isinstance(value, bytes):
            value = value.hex()
        return F&#39;{self.type.code.name}({value!r})&#39;

    def __str__(self):
        v = self.value
        if isinstance(v, Function):
            return F&#39;&amp;{v!s}&#39;
        return repr(v)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.ifps.Value.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>self, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L579-L580" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def convert(self, *_):
    return self.type.py_type()</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Value.default"><code class="name flex">
<span>def <span class="ident">default</span></span>(<span>self, *_)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L582-L583" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def default(self, *_):
    return self.type.default()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.FunctionAttribute"><code class="flex name class">
<span>class <span class="ident">FunctionAttribute</span></span>
<span>(</span><span>name, fields)</span>
</code></dt>
<dd>
<section class="desc"><p>A function attribute.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L598-L609" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class FunctionAttribute(NamedTuple):
    &#34;&#34;&#34;
    A function attribute.
    &#34;&#34;&#34;
    name: str
    fields: tuple[Value, ...]

    def __repr__(self):
        name = self.name
        if self.fields:
            name += &#39;[{}]&#39;.format(&#39;,&#39;.join(repr(f) for f in self.fields))
        return name</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.FunctionAttribute.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L598-L609" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class FunctionAttribute(NamedTuple):
    &#34;&#34;&#34;
    A function attribute.
    &#34;&#34;&#34;
    name: str
    fields: tuple[Value, ...]

    def __repr__(self):
        name = self.name
        if self.fields:
            name += &#39;[{}]&#39;.format(&#39;,&#39;.join(repr(f) for f in self.fields))
        return name</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.FunctionAttribute.fields"><code class="name">var <span class="ident">fields</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L598-L609" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class FunctionAttribute(NamedTuple):
    &#34;&#34;&#34;
    A function attribute.
    &#34;&#34;&#34;
    name: str
    fields: tuple[Value, ...]

    def __repr__(self):
        name = self.name
        if self.fields:
            name += &#39;[{}]&#39;.format(&#39;,&#39;.join(repr(f) for f in self.fields))
        return name</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpecParam"><code class="flex name class">
<span>class <span class="ident">DeclSpecParam</span></span>
<span>(</span><span>const, type=None, name=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A function parameter specification.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L612-L628" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class DeclSpecParam:
    &#34;&#34;&#34;
    A function parameter specification.
    &#34;&#34;&#34;
    const: bool
    &#34;&#34;&#34;
    True if this parameter is passed by value, not by reference.
    &#34;&#34;&#34;
    type: TPrimitive | None = None
    &#34;&#34;&#34;
    The type of this parameter.
    &#34;&#34;&#34;
    name: str | None = None
    &#34;&#34;&#34;
    The name of this parameter.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.DeclSpecParam.const"><code class="name">var <span class="ident">const</span></code></dt>
<dd>
<section class="desc"><p>True if this parameter is passed by value, not by reference.</p></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpecParam.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"><p>The type of this parameter.</p></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpecParam.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>The name of this parameter.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.CallType"><code class="flex name class">
<span>class <span class="ident">CallType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>This enumeration classifies the different call types.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L631-L641" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CallType(str, enum.Enum):
    &#34;&#34;&#34;
    This enumeration classifies the different call types.
    &#34;&#34;&#34;
    Symbol = &#39;symbol&#39;
    Procedure = &#39;procedure&#39;
    Function = &#39;function&#39;
    Property = &#39;property&#39;

    def __str__(self):
        return self.value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.CallType.Symbol"><code class="name">var <span class="ident">Symbol</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.CallType.Procedure"><code class="name">var <span class="ident">Procedure</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.CallType.Function"><code class="name">var <span class="ident">Function</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.CallType.Property"><code class="name">var <span class="ident">Property</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec"><code class="flex name class">
<span>class <span class="ident">DeclSpec</span></span>
<span>(</span><span>void, parameters=&lt;factory&gt;, name='', calling_convention=None, return_type=None, module=None, classname=None, delay_load=False, vtable_index=None, load_with_altered_search_path=False, is_property=False, is_accessor=False)</span>
</code></dt>
<dd>
<section class="desc"><p>This class captures the declaration info of a function symbol.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L644-L797" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class DeclSpec:
    &#34;&#34;&#34;
    This class captures the declaration info of a function symbol.
    &#34;&#34;&#34;
    void: bool
    parameters: list[DeclSpecParam] = field(default_factory=list)
    name: str = &#39;&#39;
    calling_convention: str | None = None
    return_type: IFPSType | None = None
    module: str | None = None
    classname: str | None = None
    delay_load: bool = False
    vtable_index: int | None = None
    load_with_altered_search_path: bool = False
    is_property: bool = False
    is_accessor: bool = False

    @property
    def argc(self):
        return len(self.parameters)

    def represent(self, name: str, ref: bool = False, rel: bool = False):
        def pparam(k: int, p: DeclSpecParam):
            name = p.name or F&#39;{VariableType.Argument!s}{k}&#39;
            if p.type is not None:
                name = F&#39;{name}: {p.type!s}&#39;
            if not p.const:
                name = F&#39;*{name}&#39;
            return name
        if self.name and name in self.name:
            name = self.name
        spec = name
        if self.vtable_index is not None:
            spec = F&#39;{self.name}[{self.vtable_index}]&#39;
        if not rel and self.classname:
            spec = F&#39;{self.classname}.{spec}&#39;
        if not rel and self.module:
            spec = F&#39;{self.module}::{spec}&#39;
        if not ref:
            if self.delay_load:
                spec = F&#39;__delay_load {spec}&#39;
            if self.calling_convention and not self.is_property:
                spec = F&#39;__{self.calling_convention} {spec}&#39;
            spec = F&#39;{self.type} {spec}&#39;
            args = self.parameters
            args = args and &#39;, &#39;.join(pparam(*t) for t in enumerate(args, 1)) or &#39;&#39;
            if self.is_property:
                if args:
                    spec = F&#39;{spec}[{args}]&#39;
            else:
                spec = F&#39;{spec}({args})&#39;
            if self.return_type:
                spec = F&#39;{spec}: {self.return_type!s}&#39;
        return spec

    @property
    def type(self):
        if self.is_property:
            return CallType.Property
        if self.void:
            return CallType.Procedure
        return CallType.Function

    def __repr__(self):
        return self.represent(self.name or &#39;(*)&#39;)

    @classmethod
    def ParseF(cls, reader: StructReader[bytes], load_flags: bool):
        def ascii():
            return reader.read_c_string(&#39;latin1&#39;)

        def boolean():
            return bool(reader.u8())

        def cc():
            return {
                0: &#39;register&#39;,
                1: &#39;pascal&#39;,
                2: &#39;cdecl&#39;,
                3: &#39;stdcall&#39;,
            }.get(reader.u8(), cls.calling_convention)

        def read_parameters():
            nonlocal void
            void = not boolean()
            parameters.extend(DeclSpecParam(not b) for b in reader.read())

        void = True
        name = None
        properties = {}
        parameters = []

        if reader.readif(b&#39;dll:&#39;):
            reader.readif(B&#39;files:&#39;)
            if (module := ascii()).lower().endswith(&#39;.dll&#39;):
                module = module[:-4]
            properties.update(module=module)
            name = ascii()
            properties.update(calling_convention=cc())
            if load_flags:
                properties.update(delay_load=boolean(), load_with_altered_search_path=boolean())
            read_parameters()
        elif reader.readif(b&#39;class:&#39;):
            if reader.remaining_bytes == 1:
                spec = reader.peek(1)
                void = False
                parameters.append(DeclSpecParam(False))
                name = {
                    b&#39;+&#39;: &#39;CastToType&#39;,
                    B&#39;-&#39;: &#39;SetNil&#39;
                }.get(spec)
                properties.update(classname=&#39;Class&#39;, calling_convention=&#39;pascal&#39;)
            else:
                properties.update(classname=reader.read_terminated_array(b&#39;|&#39;).decode(&#39;latin1&#39;))
                name = reader.read_terminated_array(b&#39;|&#39;).decode(&#39;latin1&#39;)
                if name[-1] == &#39;@&#39;:
                    properties.update(is_property=True)
                    name = name[:-1]
                properties.update(calling_convention=cc())
                read_parameters()
        elif reader.readif(b&#39;intf:.&#39;):
            name = &#39;CoInterface&#39;
            properties.update(vtable_index=reader.u32())
            properties.update(calling_convention=cc())
            read_parameters()
        else:
            read_parameters()
        return cls(void, parameters, name=name, **properties)

    @classmethod
    def ParseE(cls, data: bytes, ipfs: IFPSFile):
        decl = data.split(B&#39;\x20&#39;)
        try:
            return_type = int(decl.pop(0))
        except Exception:
            void = True
        else:
            void = return_type &lt; 0
        if not void:
            return_type = ipfs.types[return_type]
        else:
            return_type = None
        parameters = []
        for param in decl:
            try:
                i = int(param[1:])
            except Exception:
                tv = None
            else:
                tv = ipfs.types[i]
            parameters.append(
                DeclSpecParam(param[:1] == B&#39;@&#39;, tv))
        return cls(void, parameters, return_type=return_type)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.inno.ifps.DeclSpec.ParseF"><code class="name flex">
<span>def <span class="ident">ParseF</span></span>(<span>reader, load_flags)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec.ParseE"><code class="name flex">
<span>def <span class="ident">ParseE</span></span>(<span>data, ipfs)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.DeclSpec.void"><code class="name">var <span class="ident">void</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec.parameters"><code class="name">var <span class="ident">parameters</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec.calling_convention"><code class="name">var <span class="ident">calling_convention</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec.return_type"><code class="name">var <span class="ident">return_type</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec.module"><code class="name">var <span class="ident">module</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec.classname"><code class="name">var <span class="ident">classname</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec.delay_load"><code class="name">var <span class="ident">delay_load</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec.vtable_index"><code class="name">var <span class="ident">vtable_index</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec.load_with_altered_search_path"><code class="name">var <span class="ident">load_with_altered_search_path</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec.is_property"><code class="name">var <span class="ident">is_property</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec.is_accessor"><code class="name">var <span class="ident">is_accessor</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec.argc"><code class="name">var <span class="ident">argc</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L662-L664" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def argc(self):
    return len(self.parameters)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.DeclSpec.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L700-L706" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def type(self):
    if self.is_property:
        return CallType.Property
    if self.void:
        return CallType.Procedure
    return CallType.Function</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.ifps.DeclSpec.represent"><code class="name flex">
<span>def <span class="ident">represent</span></span>(<span>self, name, ref=False, rel=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L666-L698" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def represent(self, name: str, ref: bool = False, rel: bool = False):
    def pparam(k: int, p: DeclSpecParam):
        name = p.name or F&#39;{VariableType.Argument!s}{k}&#39;
        if p.type is not None:
            name = F&#39;{name}: {p.type!s}&#39;
        if not p.const:
            name = F&#39;*{name}&#39;
        return name
    if self.name and name in self.name:
        name = self.name
    spec = name
    if self.vtable_index is not None:
        spec = F&#39;{self.name}[{self.vtable_index}]&#39;
    if not rel and self.classname:
        spec = F&#39;{self.classname}.{spec}&#39;
    if not rel and self.module:
        spec = F&#39;{self.module}::{spec}&#39;
    if not ref:
        if self.delay_load:
            spec = F&#39;__delay_load {spec}&#39;
        if self.calling_convention and not self.is_property:
            spec = F&#39;__{self.calling_convention} {spec}&#39;
        spec = F&#39;{self.type} {spec}&#39;
        args = self.parameters
        args = args and &#39;, &#39;.join(pparam(*t) for t in enumerate(args, 1)) or &#39;&#39;
        if self.is_property:
            if args:
                spec = F&#39;{spec}[{args}]&#39;
        else:
            spec = F&#39;{spec}({args})&#39;
        if self.return_type:
            spec = F&#39;{spec}: {self.return_type!s}&#39;
    return spec</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.Function"><code class="flex name class">
<span>class <span class="ident">Function</span></span>
<span>(</span><span>symbol='', decl=None, body=None, attributes=None, getter=None, setter=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Represents a function in the IFPS runtime.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L800-L936" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class Function:
    &#34;&#34;&#34;
    Represents a function in the IFPS runtime.
    &#34;&#34;&#34;
    symbol: str = &#39;&#39;
    decl: DeclSpec | None = None
    body: list[Instruction] | None = None
    attributes: list[FunctionAttribute] | None = None
    _bbs: dict[int, BasicBlock] | None = None
    _ins: dict[int, Instruction] | None = None
    getter: Function | None = None
    setter: Function | None = None

    @property
    def is_property(self):
        if decl := self.decl:
            return decl.is_property
        else:
            return False

    @property
    def name(self):
        symbol = self.symbol
        if (decl := self.decl) and (name := decl.name) and (symbol in name):
            symbol = name
        return symbol

    @property
    def code(self):
        if code := self._ins:
            return code
        self._ins = code = {i.offset: i for i in self.body}
        return code

    def reference(self, rel: bool = False) -&gt; str:
        if self.decl is None:
            return self.symbol
        return self.decl.represent(self.symbol, ref=True, rel=rel)

    def __repr__(self):
        if self.decl is None:
            return F&#39;symbol {self.symbol}&#39;
        return self.decl.represent(self.symbol)

    def __str__(self):
        return self.reference()

    @property
    def type(self):
        if self.decl is None:
            return CallType.Symbol
        return self.decl.type

    def get_basic_blocks(self) -&gt; dict[int, BasicBlock]:
        if (bbs := self._bbs) is not None:
            return bbs
        if self.body is None:
            bbs = self._bbs = {}
            return bbs

        bbs: dict[int, BasicBlock] = {0: (bb := BasicBlock(0))}
        self._bbs = bbs
        jump = False

        for insn in self.body:
            try:
                bb = bbs[insn.offset]
            except KeyError:
                if jump or insn.jumptarget:
                    nb = bbs[insn.offset] = BasicBlock(insn.offset)
                    if not jump:
                        nb.sources[bb.offset] = bb
                        bb.targets[nb.offset] = nb
                    bb = nb
            bb.body.append(insn)
            if not insn.branches:
                jump = False
                continue
            targets = [insn.operands[0]]
            sequence = insn.offset + insn.size
            jump = insn.jumps
            if not jump and insn.opcode != Op.Ret:
                targets.append(sequence)
            for t in targets:
                if not (bt := bbs.get(t)):
                    bt = bbs[t] = BasicBlock(t)
                bb.targets[t] = bt
                bt.sources[bb.offset] = bb

        for offset, bb in list(bbs.items()):
            if bb.body:
                continue
            del bbs[offset]
            for source in bb.sources.values():
                source.targets.pop(offset, None)

        visited: set[int] = set()
        errored: set[int] = set()

        def trace_stack(offset: int, stack: int | None):
            if offset in errored:
                return
            bb = bbs[offset]
            if bb.stack is not None and stack != bb.stack:
                stack = None
            if stack is None:
                errored.add(offset)
            elif offset in visited:
                return
            else:
                visited.add(offset)
            bb.stack = stack
            body = [] if stack is None else bb.body
            for insn in body:
                insn.stack = stack
                stack += insn.stack_delta
            for t in bb.targets:
                trace_stack(t, stack)

        trace_stack(0, 0)

        for insn in self.body:
            if (stack := insn.stack) is None:
                continue
            for k, op in enumerate(insn.operands):
                if not isinstance(op, Operand):
                    continue
                if not (v := op.variable) or v.type != VariableType.Local:
                    continue
                if v.index &lt;= stack:
                    continue
                raise IndexError(
                    F&#39;Instruction {op!s} at offset 0x{insn.offset:X} in function {self.name} has &#39;
                    F&#39;variable operand {k} whose index {v.index} exceeds the stack depth {stack}.&#39;)

        return bbs</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.Function.symbol"><code class="name">var <span class="ident">symbol</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Function.decl"><code class="name">var <span class="ident">decl</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Function.body"><code class="name">var <span class="ident">body</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Function.attributes"><code class="name">var <span class="ident">attributes</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Function.getter"><code class="name">var <span class="ident">getter</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Function.setter"><code class="name">var <span class="ident">setter</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Function.is_property"><code class="name">var <span class="ident">is_property</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L814-L819" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def is_property(self):
    if decl := self.decl:
        return decl.is_property
    else:
        return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Function.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L821-L826" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def name(self):
    symbol = self.symbol
    if (decl := self.decl) and (name := decl.name) and (symbol in name):
        symbol = name
    return symbol</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Function.code"><code class="name">var <span class="ident">code</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L828-L833" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def code(self):
    if code := self._ins:
        return code
    self._ins = code = {i.offset: i for i in self.body}
    return code</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Function.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L848-L852" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def type(self):
    if self.decl is None:
        return CallType.Symbol
    return self.decl.type</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.ifps.Function.reference"><code class="name flex">
<span>def <span class="ident">reference</span></span>(<span>self, rel=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L835-L838" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reference(self, rel: bool = False) -&gt; str:
    if self.decl is None:
        return self.symbol
    return self.decl.represent(self.symbol, ref=True, rel=rel)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Function.get_basic_blocks"><code class="name flex">
<span>def <span class="ident">get_basic_blocks</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L854-L936" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_basic_blocks(self) -&gt; dict[int, BasicBlock]:
    if (bbs := self._bbs) is not None:
        return bbs
    if self.body is None:
        bbs = self._bbs = {}
        return bbs

    bbs: dict[int, BasicBlock] = {0: (bb := BasicBlock(0))}
    self._bbs = bbs
    jump = False

    for insn in self.body:
        try:
            bb = bbs[insn.offset]
        except KeyError:
            if jump or insn.jumptarget:
                nb = bbs[insn.offset] = BasicBlock(insn.offset)
                if not jump:
                    nb.sources[bb.offset] = bb
                    bb.targets[nb.offset] = nb
                bb = nb
        bb.body.append(insn)
        if not insn.branches:
            jump = False
            continue
        targets = [insn.operands[0]]
        sequence = insn.offset + insn.size
        jump = insn.jumps
        if not jump and insn.opcode != Op.Ret:
            targets.append(sequence)
        for t in targets:
            if not (bt := bbs.get(t)):
                bt = bbs[t] = BasicBlock(t)
            bb.targets[t] = bt
            bt.sources[bb.offset] = bb

    for offset, bb in list(bbs.items()):
        if bb.body:
            continue
        del bbs[offset]
        for source in bb.sources.values():
            source.targets.pop(offset, None)

    visited: set[int] = set()
    errored: set[int] = set()

    def trace_stack(offset: int, stack: int | None):
        if offset in errored:
            return
        bb = bbs[offset]
        if bb.stack is not None and stack != bb.stack:
            stack = None
        if stack is None:
            errored.add(offset)
        elif offset in visited:
            return
        else:
            visited.add(offset)
        bb.stack = stack
        body = [] if stack is None else bb.body
        for insn in body:
            insn.stack = stack
            stack += insn.stack_delta
        for t in bb.targets:
            trace_stack(t, stack)

    trace_stack(0, 0)

    for insn in self.body:
        if (stack := insn.stack) is None:
            continue
        for k, op in enumerate(insn.operands):
            if not isinstance(op, Operand):
                continue
            if not (v := op.variable) or v.type != VariableType.Local:
                continue
            if v.index &lt;= stack:
                continue
            raise IndexError(
                F&#39;Instruction {op!s} at offset 0x{insn.offset:X} in function {self.name} has &#39;
                F&#39;variable operand {k} whose index {v.index} exceeds the stack depth {stack}.&#39;)

    return bbs</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.VariableBase"><code class="flex name class">
<span>class <span class="ident">VariableBase</span></span>
<span>(</span><span>type, spec)</span>
</code></dt>
<dd>
<section class="desc"><p>This class represents a variable within the IFPS runtime. This is primarily a base class for
the more sophisticated <code><a title="refinery.lib.inno.emulator.Variable" href="emulator.html#refinery.lib.inno.emulator.Variable">Variable</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L939-L962" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class VariableBase:
    &#34;&#34;&#34;
    This class represents a variable within the IFPS runtime. This is primarily a base class for
    the more sophisticated `refinery.lib.inno.emulator.Variable`.
    &#34;&#34;&#34;
    type: IFPSType
    &#34;&#34;&#34;
    The type of the variable, see `refinery.lib.inno.ifps.IFPSType`.
    &#34;&#34;&#34;
    spec: VariableSpec | None
    &#34;&#34;&#34;
    A `refinery.lib.inno.ifps.VariableSpec` that uniquely identifies the base variable. If this
    property is `None`, the variable is unbound: The `refinery.lib.inno.ifps.Op.SetPtrToCopy`
    opcode can create such variables.
    &#34;&#34;&#34;

    __slots__ = &#39;type&#39;, &#39;spec&#39;

    def __init__(self, type: IFPSType, spec: VariableSpec):
        self.type = type
        self.spec = spec

    def __str__(self):
        return F&#39;{self.spec}: {self.type!s}&#39;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.inno.emulator.Variable" href="emulator.html#refinery.lib.inno.emulator.Variable">Variable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.VariableBase.spec"><code class="name">var <span class="ident">spec</span></code></dt>
<dd>
<section class="desc"><p>A <code><a title="refinery.lib.inno.ifps.VariableSpec" href="#refinery.lib.inno.ifps.VariableSpec">VariableSpec</a></code> that uniquely identifies the base variable. If this
property is <code>None</code>, the variable is unbound: The <code><a title="refinery.lib.inno.ifps.Op.SetPtrToCopy" href="#refinery.lib.inno.ifps.Op.SetPtrToCopy">Op.SetPtrToCopy</a></code>
opcode can create such variables.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L939-L962" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class VariableBase:
    &#34;&#34;&#34;
    This class represents a variable within the IFPS runtime. This is primarily a base class for
    the more sophisticated `refinery.lib.inno.emulator.Variable`.
    &#34;&#34;&#34;
    type: IFPSType
    &#34;&#34;&#34;
    The type of the variable, see `refinery.lib.inno.ifps.IFPSType`.
    &#34;&#34;&#34;
    spec: VariableSpec | None
    &#34;&#34;&#34;
    A `refinery.lib.inno.ifps.VariableSpec` that uniquely identifies the base variable. If this
    property is `None`, the variable is unbound: The `refinery.lib.inno.ifps.Op.SetPtrToCopy`
    opcode can create such variables.
    &#34;&#34;&#34;

    __slots__ = &#39;type&#39;, &#39;spec&#39;

    def __init__(self, type: IFPSType, spec: VariableSpec):
        self.type = type
        self.spec = spec

    def __str__(self):
        return F&#39;{self.spec}: {self.type!s}&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.VariableBase.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"><p>The type of the variable, see <code><a title="refinery.lib.inno.ifps.IFPSType" href="#refinery.lib.inno.ifps.IFPSType">IFPSType</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L939-L962" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class VariableBase:
    &#34;&#34;&#34;
    This class represents a variable within the IFPS runtime. This is primarily a base class for
    the more sophisticated `refinery.lib.inno.emulator.Variable`.
    &#34;&#34;&#34;
    type: IFPSType
    &#34;&#34;&#34;
    The type of the variable, see `refinery.lib.inno.ifps.IFPSType`.
    &#34;&#34;&#34;
    spec: VariableSpec | None
    &#34;&#34;&#34;
    A `refinery.lib.inno.ifps.VariableSpec` that uniquely identifies the base variable. If this
    property is `None`, the variable is unbound: The `refinery.lib.inno.ifps.Op.SetPtrToCopy`
    opcode can create such variables.
    &#34;&#34;&#34;

    __slots__ = &#39;type&#39;, &#39;spec&#39;

    def __init__(self, type: IFPSType, spec: VariableSpec):
        self.type = type
        self.spec = spec

    def __str__(self):
        return F&#39;{self.spec}: {self.type!s}&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.OperandType"><code class="flex name class">
<span>class <span class="ident">OperandType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Classifies the type of an <code><a title="refinery.lib.inno.ifps.Operand" href="#refinery.lib.inno.ifps.Operand">Operand</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L965-L973" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@represent
class OperandType(enum.IntEnum):
    &#34;&#34;&#34;
    Classifies the type of an `refinery.lib.inno.ifps.Operand`.
    &#34;&#34;&#34;
    Variable = 0
    Value = 1
    IndexedByInt = 2
    IndexedByVar = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.OperandType.Variable"><code class="name">var <span class="ident">Variable</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.OperandType.Value"><code class="name">var <span class="ident">Value</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.OperandType.IndexedByInt"><code class="name">var <span class="ident">IndexedByInt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.OperandType.IndexedByVar"><code class="name">var <span class="ident">IndexedByVar</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.EHType"><code class="flex name class">
<span>class <span class="ident">EHType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>This enumeration lists the possible types of code region covered by an exception handler.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L976-L984" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@represent
class EHType(enum.IntEnum):
    &#34;&#34;&#34;
    This enumeration lists the possible types of code region covered by an exception handler.
    &#34;&#34;&#34;
    Try = 0
    Finally = 1
    Catch = 2
    SecondFinally = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.EHType.Try"><code class="name">var <span class="ident">Try</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.EHType.Finally"><code class="name">var <span class="ident">Finally</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.EHType.Catch"><code class="name">var <span class="ident">Catch</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.EHType.SecondFinally"><code class="name">var <span class="ident">SecondFinally</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.NewEH"><code class="flex name class">
<span>class <span class="ident">NewEH</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>This enumeration gives names to the 4 arguments of the opcode responsible for registering a new
exception handler. The first argument specifies the location of a finally, the second argument
specifies the location of a catch handler, and so on.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L987-L997" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@represent
class NewEH(enum.IntEnum):
    &#34;&#34;&#34;
    This enumeration gives names to the 4 arguments of the opcode responsible for registering a new
    exception handler. The first argument specifies the location of a finally, the second argument
    specifies the location of a catch handler, and so on.
    &#34;&#34;&#34;
    Finally = 0
    CatchAt = 1
    SecondFinally = 2
    End = 3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.NewEH.Finally"><code class="name">var <span class="ident">Finally</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.NewEH.CatchAt"><code class="name">var <span class="ident">CatchAt</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.NewEH.SecondFinally"><code class="name">var <span class="ident">SecondFinally</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.NewEH.End"><code class="name">var <span class="ident">End</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.VariableType"><code class="flex name class">
<span>class <span class="ident">VariableType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1000-L1009" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class VariableType(str, enum.Enum):
    Global = &#39;GlobalVar&#39;
    Local = &#39;LocalVar&#39;
    Argument = &#39;Argument&#39;

    def __repr__(self):
        return self.name

    def __str__(self):
        return self.value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.VariableType.Global"><code class="name">var <span class="ident">Global</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.VariableType.Local"><code class="name">var <span class="ident">Local</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.VariableType.Argument"><code class="name">var <span class="ident">Argument</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.VariableSpec"><code class="flex name class">
<span>class <span class="ident">VariableSpec</span></span>
<span>(</span><span>index, type)</span>
</code></dt>
<dd>
<section class="desc"><p>Represents a reference to a variable within the IFPS runtime. There are three variable types:
Locals, globals, and function arguments; see <code><a title="refinery.lib.inno.ifps.VariableType" href="#refinery.lib.inno.ifps.VariableType">VariableType</a></code>. A variable
is then uniquely defined by its type and index within the (localized) list of such variables.
The function argument of index zero is the return value of a function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1012-L1025" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class VariableSpec(NamedTuple):
    &#34;&#34;&#34;
    Represents a reference to a variable within the IFPS runtime. There are three variable types:
    Locals, globals, and function arguments; see `refinery.lib.inno.ifps.VariableType`. A variable
    is then uniquely defined by its type and index within the (localized) list of such variables.
    The function argument of index zero is the return value of a function.
    &#34;&#34;&#34;
    index: int
    type: VariableType

    def __repr__(self):
        if self.index == 0 and self.type == VariableType.Argument:
            return &#39;ReturnValue&#39;
        return F&#39;{self.type!s}{self.index}&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.VariableSpec.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1012-L1025" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class VariableSpec(NamedTuple):
    &#34;&#34;&#34;
    Represents a reference to a variable within the IFPS runtime. There are three variable types:
    Locals, globals, and function arguments; see `refinery.lib.inno.ifps.VariableType`. A variable
    is then uniquely defined by its type and index within the (localized) list of such variables.
    The function argument of index zero is the return value of a function.
    &#34;&#34;&#34;
    index: int
    type: VariableType

    def __repr__(self):
        if self.index == 0 and self.type == VariableType.Argument:
            return &#39;ReturnValue&#39;
        return F&#39;{self.type!s}{self.index}&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.VariableSpec.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1012-L1025" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class VariableSpec(NamedTuple):
    &#34;&#34;&#34;
    Represents a reference to a variable within the IFPS runtime. There are three variable types:
    Locals, globals, and function arguments; see `refinery.lib.inno.ifps.VariableType`. A variable
    is then uniquely defined by its type and index within the (localized) list of such variables.
    The function argument of index zero is the return value of a function.
    &#34;&#34;&#34;
    index: int
    type: VariableType

    def __repr__(self):
        if self.index == 0 and self.type == VariableType.Argument:
            return &#39;ReturnValue&#39;
        return F&#39;{self.type!s}{self.index}&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.Operand"><code class="flex name class">
<span>class <span class="ident">Operand</span></span>
<span>(</span><span>type, variable=None, value=None, index=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Represends an operand to an IFPS opcode. An operand can either contain a value, which is an
immediate that is encoded into the opcode, or a reference to a variable. A variable is given
by its <code><a title="refinery.lib.inno.ifps.VariableSpec" href="#refinery.lib.inno.ifps.VariableSpec">VariableSpec</a></code>. Additionally, the operand can specify an index
for this variable which can either be given by an immediate, or by another variable. In the
latter case, the encoded index is also a <code><a title="refinery.lib.inno.ifps.VariableSpec" href="#refinery.lib.inno.ifps.VariableSpec">VariableSpec</a></code>. The type of
operand is encoded as an <code><a title="refinery.lib.inno.ifps.OperandType" href="#refinery.lib.inno.ifps.OperandType">OperandType</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1028-L1061" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Operand(NamedTuple):
    &#34;&#34;&#34;
    Represends an operand to an IFPS opcode. An operand can either contain a value, which is an
    immediate that is encoded into the opcode, or a reference to a variable. A variable is given
    by its `refinery.lib.inno.ifps.VariableSpec`. Additionally, the operand can specify an index
    for this variable which can either be given by an immediate, or by another variable. In the
    latter case, the encoded index is also a `refinery.lib.inno.ifps.VariableSpec`. The type of
    operand is encoded as an `refinery.lib.inno.ifps.OperandType`.
    &#34;&#34;&#34;
    type: OperandType
    variable: VariableSpec | None = None
    value: Value | None = None
    index: VariableSpec | int | None = None

    def __repr__(self):
        return self.__tostring(repr)

    def __str__(self):
        return self.__tostring(str)

    @property
    def immediate(self):
        return self.type == OperandType.Value

    def __tostring(self, converter):
        if self.type is OperandType.Value:
            return converter(self.value)
        if self.type is OperandType.Variable:
            return converter(self.variable)
        if self.type is OperandType.IndexedByInt:
            return F&#39;{converter(self.variable)}[0x{self.index:02X}]&#39;
        if self.type is OperandType.IndexedByVar:
            return F&#39;{converter(self.variable)}[{self.index!s}]&#39;
        raise RuntimeError(F&#39;Unexpected OperandType {self.type!r} in {self.__class__.__name__}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.Operand.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1028-L1061" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Operand(NamedTuple):
    &#34;&#34;&#34;
    Represends an operand to an IFPS opcode. An operand can either contain a value, which is an
    immediate that is encoded into the opcode, or a reference to a variable. A variable is given
    by its `refinery.lib.inno.ifps.VariableSpec`. Additionally, the operand can specify an index
    for this variable which can either be given by an immediate, or by another variable. In the
    latter case, the encoded index is also a `refinery.lib.inno.ifps.VariableSpec`. The type of
    operand is encoded as an `refinery.lib.inno.ifps.OperandType`.
    &#34;&#34;&#34;
    type: OperandType
    variable: VariableSpec | None = None
    value: Value | None = None
    index: VariableSpec | int | None = None

    def __repr__(self):
        return self.__tostring(repr)

    def __str__(self):
        return self.__tostring(str)

    @property
    def immediate(self):
        return self.type == OperandType.Value

    def __tostring(self, converter):
        if self.type is OperandType.Value:
            return converter(self.value)
        if self.type is OperandType.Variable:
            return converter(self.variable)
        if self.type is OperandType.IndexedByInt:
            return F&#39;{converter(self.variable)}[0x{self.index:02X}]&#39;
        if self.type is OperandType.IndexedByVar:
            return F&#39;{converter(self.variable)}[{self.index!s}]&#39;
        raise RuntimeError(F&#39;Unexpected OperandType {self.type!r} in {self.__class__.__name__}&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Operand.variable"><code class="name">var <span class="ident">variable</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1028-L1061" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Operand(NamedTuple):
    &#34;&#34;&#34;
    Represends an operand to an IFPS opcode. An operand can either contain a value, which is an
    immediate that is encoded into the opcode, or a reference to a variable. A variable is given
    by its `refinery.lib.inno.ifps.VariableSpec`. Additionally, the operand can specify an index
    for this variable which can either be given by an immediate, or by another variable. In the
    latter case, the encoded index is also a `refinery.lib.inno.ifps.VariableSpec`. The type of
    operand is encoded as an `refinery.lib.inno.ifps.OperandType`.
    &#34;&#34;&#34;
    type: OperandType
    variable: VariableSpec | None = None
    value: Value | None = None
    index: VariableSpec | int | None = None

    def __repr__(self):
        return self.__tostring(repr)

    def __str__(self):
        return self.__tostring(str)

    @property
    def immediate(self):
        return self.type == OperandType.Value

    def __tostring(self, converter):
        if self.type is OperandType.Value:
            return converter(self.value)
        if self.type is OperandType.Variable:
            return converter(self.variable)
        if self.type is OperandType.IndexedByInt:
            return F&#39;{converter(self.variable)}[0x{self.index:02X}]&#39;
        if self.type is OperandType.IndexedByVar:
            return F&#39;{converter(self.variable)}[{self.index!s}]&#39;
        raise RuntimeError(F&#39;Unexpected OperandType {self.type!r} in {self.__class__.__name__}&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Operand.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 2</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1028-L1061" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Operand(NamedTuple):
    &#34;&#34;&#34;
    Represends an operand to an IFPS opcode. An operand can either contain a value, which is an
    immediate that is encoded into the opcode, or a reference to a variable. A variable is given
    by its `refinery.lib.inno.ifps.VariableSpec`. Additionally, the operand can specify an index
    for this variable which can either be given by an immediate, or by another variable. In the
    latter case, the encoded index is also a `refinery.lib.inno.ifps.VariableSpec`. The type of
    operand is encoded as an `refinery.lib.inno.ifps.OperandType`.
    &#34;&#34;&#34;
    type: OperandType
    variable: VariableSpec | None = None
    value: Value | None = None
    index: VariableSpec | int | None = None

    def __repr__(self):
        return self.__tostring(repr)

    def __str__(self):
        return self.__tostring(str)

    @property
    def immediate(self):
        return self.type == OperandType.Value

    def __tostring(self, converter):
        if self.type is OperandType.Value:
            return converter(self.value)
        if self.type is OperandType.Variable:
            return converter(self.variable)
        if self.type is OperandType.IndexedByInt:
            return F&#39;{converter(self.variable)}[0x{self.index:02X}]&#39;
        if self.type is OperandType.IndexedByVar:
            return F&#39;{converter(self.variable)}[{self.index!s}]&#39;
        raise RuntimeError(F&#39;Unexpected OperandType {self.type!r} in {self.__class__.__name__}&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Operand.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 3</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1028-L1061" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Operand(NamedTuple):
    &#34;&#34;&#34;
    Represends an operand to an IFPS opcode. An operand can either contain a value, which is an
    immediate that is encoded into the opcode, or a reference to a variable. A variable is given
    by its `refinery.lib.inno.ifps.VariableSpec`. Additionally, the operand can specify an index
    for this variable which can either be given by an immediate, or by another variable. In the
    latter case, the encoded index is also a `refinery.lib.inno.ifps.VariableSpec`. The type of
    operand is encoded as an `refinery.lib.inno.ifps.OperandType`.
    &#34;&#34;&#34;
    type: OperandType
    variable: VariableSpec | None = None
    value: Value | None = None
    index: VariableSpec | int | None = None

    def __repr__(self):
        return self.__tostring(repr)

    def __str__(self):
        return self.__tostring(str)

    @property
    def immediate(self):
        return self.type == OperandType.Value

    def __tostring(self, converter):
        if self.type is OperandType.Value:
            return converter(self.value)
        if self.type is OperandType.Variable:
            return converter(self.variable)
        if self.type is OperandType.IndexedByInt:
            return F&#39;{converter(self.variable)}[0x{self.index:02X}]&#39;
        if self.type is OperandType.IndexedByVar:
            return F&#39;{converter(self.variable)}[{self.index!s}]&#39;
        raise RuntimeError(F&#39;Unexpected OperandType {self.type!r} in {self.__class__.__name__}&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Operand.immediate"><code class="name">var <span class="ident">immediate</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1048-L1050" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def immediate(self):
    return self.type == OperandType.Value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.Instruction"><code class="flex name class">
<span>class <span class="ident">Instruction</span></span>
<span>(</span><span>offset, opcode, encoded=b'', stack=None, operands=&lt;factory&gt;, operator=None, jumptarget=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Instruction(offset: 'int', opcode: 'Op', encoded: 'bytes' = b'', stack: 'int | None' = None, operands: 'list[str | bool | int | float | Operand | IFPSType | Function | None]' = <factory>, operator: 'AOp | COp | None' = None, jumptarget: 'bool' = False)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1075-L1156" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class Instruction:
    offset: int
    opcode: Op
    encoded: bytes = B&#39;&#39;
    stack: int | None = None
    operands: list[str | bool | int | float | Operand | IFPSType | Function | None] = field(default_factory=list)
    operator: AOp | COp | None = None
    jumptarget: bool = False

    def op(self, index: int):
        arg = self.operands[index]
        if not isinstance(arg, Operand):
            raise TypeError
        return arg

    @property
    def size(self):
        return len(self.encoded)

    @property
    def branches(self):
        return self.opcode in (
            Op.Jump,
            Op.JumpFalse,
            Op.JumpTrue,
            Op.JumpFlag,
            Op.JumpPop1,
            Op.JumpPop2,
        )

    @property
    def jumps(self):
        return self.opcode in (
            Op.Jump,
            Op.JumpPop1,
            Op.JumpPop2,
        )

    @property
    def stack_delta(self):
        return _Op_StackD.get(self.opcode, 0)

    def oprep(self, labels: dict[int, str] | None = None):
        if self.branches:
            dst = self.operands[0]
            if not labels or not (label := labels.get(dst)):
                label = F&#39;0x{dst:X}&#39;
            var = [str(op) for op in self.operands[1:]]
            return &#39;, &#39;.join((label, *var))
        elif self.opcode is Op.PushEH:
            ops = []
            for op, name in reversed(list(zip(self.operands, NewEH))):
                if op is None:
                    continue
                ops.append(F&#39;{name}:0x{op:X}&#39;)
            return &#39;\x20&#39;.join(ops)
        elif self.opcode is Op.PopEH:
            return F&#39;End{EHType(self.operands[0])}&#39;
        elif self.opcode is Op.SetFlag:
            rep, negated = self.operands
            return F&#39;!{rep}&#39; if negated else str(rep)
        elif self.opcode is Op.Compare:
            dst, a, b = self.operands
            return F&#39;{dst!s} := {a!s} {self.operator!s} {b!s}&#39;
        elif self.opcode is Op.Calculate:
            dst, src = self.operands
            return F&#39;{dst!s} {self.operator!s} {src!s}&#39;
        elif self.opcode in (Op.Assign, Op.SetPtr, Op.SetPtrToCopy):
            dst, src = self.operands
            return F&#39;{dst!s} := {src!s}&#39;
        else:
            return &#39;, &#39;.join(str(op) for op in self.operands)

    def pretty(self, labels: dict[int, str] | None = None):
        return F&#39;{self.opcode!s:&lt;{_Op_Maxlen}}{_TAB}{self.oprep(labels)}&#39;.strip()

    def __repr__(self):
        return F&#39;{self.opcode.name}({self.oprep()})&#39;

    def __str__(self):
        return self.pretty()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.Instruction.offset"><code class="name">var <span class="ident">offset</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Instruction.opcode"><code class="name">var <span class="ident">opcode</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Instruction.operands"><code class="name">var <span class="ident">operands</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Instruction.encoded"><code class="name">var <span class="ident">encoded</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Instruction.stack"><code class="name">var <span class="ident">stack</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Instruction.operator"><code class="name">var <span class="ident">operator</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Instruction.jumptarget"><code class="name">var <span class="ident">jumptarget</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.Instruction.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1091-L1093" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def size(self):
    return len(self.encoded)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Instruction.branches"><code class="name">var <span class="ident">branches</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1095-L1104" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def branches(self):
    return self.opcode in (
        Op.Jump,
        Op.JumpFalse,
        Op.JumpTrue,
        Op.JumpFlag,
        Op.JumpPop1,
        Op.JumpPop2,
    )</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Instruction.jumps"><code class="name">var <span class="ident">jumps</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1106-L1112" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def jumps(self):
    return self.opcode in (
        Op.Jump,
        Op.JumpPop1,
        Op.JumpPop2,
    )</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Instruction.stack_delta"><code class="name">var <span class="ident">stack_delta</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1114-L1116" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def stack_delta(self):
    return _Op_StackD.get(self.opcode, 0)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.ifps.Instruction.op"><code class="name flex">
<span>def <span class="ident">op</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1085-L1089" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def op(self, index: int):
    arg = self.operands[index]
    if not isinstance(arg, Operand):
        raise TypeError
    return arg</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Instruction.oprep"><code class="name flex">
<span>def <span class="ident">oprep</span></span>(<span>self, labels=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1118-L1147" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def oprep(self, labels: dict[int, str] | None = None):
    if self.branches:
        dst = self.operands[0]
        if not labels or not (label := labels.get(dst)):
            label = F&#39;0x{dst:X}&#39;
        var = [str(op) for op in self.operands[1:]]
        return &#39;, &#39;.join((label, *var))
    elif self.opcode is Op.PushEH:
        ops = []
        for op, name in reversed(list(zip(self.operands, NewEH))):
            if op is None:
                continue
            ops.append(F&#39;{name}:0x{op:X}&#39;)
        return &#39;\x20&#39;.join(ops)
    elif self.opcode is Op.PopEH:
        return F&#39;End{EHType(self.operands[0])}&#39;
    elif self.opcode is Op.SetFlag:
        rep, negated = self.operands
        return F&#39;!{rep}&#39; if negated else str(rep)
    elif self.opcode is Op.Compare:
        dst, a, b = self.operands
        return F&#39;{dst!s} := {a!s} {self.operator!s} {b!s}&#39;
    elif self.opcode is Op.Calculate:
        dst, src = self.operands
        return F&#39;{dst!s} {self.operator!s} {src!s}&#39;
    elif self.opcode in (Op.Assign, Op.SetPtr, Op.SetPtrToCopy):
        dst, src = self.operands
        return F&#39;{dst!s} := {src!s}&#39;
    else:
        return &#39;, &#39;.join(str(op) for op in self.operands)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.Instruction.pretty"><code class="name flex">
<span>def <span class="ident">pretty</span></span>(<span>self, labels=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1149-L1150" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pretty(self, labels: dict[int, str] | None = None):
    return F&#39;{self.opcode!s:&lt;{_Op_Maxlen}}{_TAB}{self.oprep(labels)}&#39;.strip()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.BasicBlock"><code class="flex name class">
<span>class <span class="ident">BasicBlock</span></span>
<span>(</span><span>offset, stack=None, body=&lt;factory&gt;, sources=&lt;factory&gt;, targets=&lt;factory&gt;)</span>
</code></dt>
<dd>
<section class="desc"><p>BasicBlock(offset: 'int', stack: 'int | None' = None, body: 'list[Instruction]' = <factory>, sources: 'dict[int, BasicBlock]' = <factory>, targets: 'dict[int, BasicBlock]' = <factory>)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1159-L1173" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class BasicBlock:
    offset: int
    stack: int | None = None
    body: list[Instruction] = field(default_factory=list)
    sources: dict[int, BasicBlock] = field(default_factory=dict)
    targets: dict[int, BasicBlock] = field(default_factory=dict)

    @property
    def stack_delta(self):
        return sum(insn.stack_delta for insn in self.body)

    @property
    def size(self):
        return sum(insn.size for insn in self.body)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.BasicBlock.offset"><code class="name">var <span class="ident">offset</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.BasicBlock.body"><code class="name">var <span class="ident">body</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.BasicBlock.sources"><code class="name">var <span class="ident">sources</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.BasicBlock.targets"><code class="name">var <span class="ident">targets</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.BasicBlock.stack"><code class="name">var <span class="ident">stack</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.BasicBlock.stack_delta"><code class="name">var <span class="ident">stack_delta</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1167-L1169" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def stack_delta(self):
    return sum(insn.stack_delta for insn in self.body)</code></pre>
</details>
</dd>
<dt id="refinery.lib.inno.ifps.BasicBlock.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1171-L1173" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def size(self):
    return sum(insn.size for insn in self.body)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.FTag"><code class="flex name class">
<span>class <span class="ident">FTag</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Support for integer-based Flags</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1176-L1182" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class FTag(enum.IntFlag):
    External = 0b0001
    Exported = 0b0010
    HasAttrs = 0b0100

    def check(self, v):
        return bool(self &amp; v)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntFlag</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Flag</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.FTag.External"><code class="name">var <span class="ident">External</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.FTag.Exported"><code class="name">var <span class="ident">Exported</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.FTag.HasAttrs"><code class="name">var <span class="ident">HasAttrs</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.ifps.FTag.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, v)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1181-L1182" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check(self, v):
    return bool(self &amp; v)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.inno.ifps.IFPSFile"><code class="flex name class">
<span>class <span class="ident">IFPSFile</span></span>
<span>(</span><span>reader, codec='latin1', unicode=True)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to parse structured data. A <code><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></code> class can be instantiated
as follows:</p>
<pre><code>foo = Struct(data, bar=29)
</code></pre>
<p>The initialization routine of the structure will be called with a single argument <code>reader</code>. If
the object <code>data</code> is already a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>, then it will be passed
as <code>reader</code>. Otherwise, the argument will be wrapped in a <code><a title="refinery.lib.structures.StructReader" href="../structures.html#refinery.lib.structures.StructReader">StructReader</a></code>.
Additional arguments to the struct are passed through.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1185-L1842" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IFPSFile(Struct):
    MinVer = 12
    MaxVer = 23

    Magic = B&#39;IFPS&#39;

    def __init__(self, reader: StructReader[memoryview], codec: str = &#39;latin1&#39;, unicode: bool = True):
        self.codec = codec
        self.unicode = unicode
        self.types: list[IFPSType] = []
        self.functions: list[Function] = []
        self.globals: list[VariableBase] = []
        self.strings: list[str] = []
        self.reader = reader
        if reader.remaining_bytes &lt; 28:
            raise ValueError(&#39;Less than 28 bytes in file, not enough data to parse.&#39;)
        magic = reader.read(4)
        if magic != self.Magic:
            raise ValueError(F&#39;Invalid magic sequence: {magic.hex()}&#39;)
        self.version = reader.u32()
        self.count_types = reader.u32()
        self.count_functions = reader.u32()
        self.count_variables = reader.u32()
        self.entry = reader.u32()
        self.import_size = reader.u32()

        if self.version not in range(self.MinVer, self.MaxVer + 1):
            raise NotImplementedError(
                F&#39;This IFPS file has version {self.version}, which is not in the supported range &#39;
                F&#39;[{self.MinVer},{self.MaxVer}].&#39;)

        self._known_type_names = {
            TC.U08   : {&#39;Byte&#39;, &#39;Boolean&#39;},
            TC.S08   : {&#39;ShortInt&#39;},
            TC.U16   : {&#39;Word&#39;},
            TC.S16   : {&#39;SmallInt&#39;},
            TC.S32   : {&#39;Integer&#39;, &#39;LongInt&#39;},
            TC.U32   : {&#39;LongWord&#39;, &#39;Cardinal&#39;, &#39;HWND&#39;, &#39;TSetupProcessorArchitecture&#39;},
            TC.Char  : {&#39;AnsiChar&#39;},
            TC.PChar : {&#39;PAnsiChar&#39;},
            TC.S64   : {&#39;Int64&#39;},
        }

        self._load_types()
        self._name_types()
        self._load_functions()
        self._load_variables()

        del self._known_type_names

    def _name_types(self, missing_types: set[str] | None = None):
        tbn: dict[str, IFPSType] = CaseInsensitiveDict()
        self.types_by_name = tbn
        for t in self.types:
            name = str(t)
            code = t.code
            known = self._known_type_names.get(code)
            if known:
                known.discard(name)
            tbn[name] = t

        if missing_types:
            def add_type(name: str, type: IFPSType):
                tbn[name] = type
                self.types.append(type)
                return type

            def make_string(name: str = &#39;String&#39;):
                try:
                    return tbn[name]
                except KeyError:
                    pass
                for type in tbn.values():
                    if type.code in (
                        TC.AnsiString,
                        TC.WideString,
                        TC.UnicodeString,
                    ):
                        break
                else:
                    code = TC.WideString if self.unicode else TC.AnsiString
                    type = TPrimitive(code, symbol=name)
                return add_type(name, type)

            for name in tbn:
                missing_types.discard(name)

            if &#39;TGUID&#39; in missing_types:
                missing_types |= {&#39;LongWord&#39;, &#39;Word&#39;, &#39;Byte&#39;}

            for code in TC:
                name = code.name
                if name not in missing_types:
                    continue
                missing_types.discard(name)
                add_type(name, TPrimitive(code, symbol=name))

            for code, names in self._known_type_names.items():
                for name in names:
                    if name not in missing_types:
                        continue
                    missing_types.discard(name)
                    add_type(name, TPrimitive(code, symbol=name))

            for name in [
                &#39;TVarType&#39;,
                &#39;TInputQueryWizardPage&#39;,
                &#39;TInputOptionWizardPage&#39;,
                &#39;TInputDirWizardPage&#39;,
                &#39;TInputFileWizardPage&#39;,
                &#39;TOutputMsgWizardPage&#39;,
                &#39;TOutputMsgMemoWizardPage&#39;,
                &#39;TOutputProgressWizardPage&#39;,
                &#39;TOutputMarqueeProgressWizardPage&#39;,
                &#39;TDownloadWizardPage&#39;,
                &#39;ExtractionWizardPage&#39;,
                &#39;TWizardPage&#39;,
                &#39;TSetupForm&#39;,
                &#39;TComponent&#39;,
                &#39;TNewNotebookPage&#39;,
            ]:
                if name not in missing_types:
                    continue
                add_type(name, TClass(TC.Class, name, symbol=name))

            if (name := &#39;String&#39;) in missing_types:
                make_string(name)

            if (name := &#39;AnyString&#39;) in missing_types:
                make_string(name)

            if (name := &#39;TArrayOfString&#39;) in missing_types:
                add_type(name, TArray(TC.Array, make_string()))

            if (name := &#39;IUnknown&#39;) in missing_types:
                add_type(name, TInterface(TC.Interface, UUID(&#39;{00000000-0000-0000-C000-000000000046}&#39;)))

            if (name := &#39;TGUID&#39;) in missing_types:
                add_type(name, TRecord(TC.Record, (
                    tbn[&#39;LongWord&#39;],
                    tbn[&#39;Word&#39;],
                    tbn[&#39;Word&#39;],
                    TStaticArray(tbn[&#39;Byte&#39;], 8)
                ), symbol=name))

    def _load_types(self):
        def _normalize(n: str):
            return IFPSClasses.Types.get(n.casefold(), n)
        reader = self.reader
        types = self.types
        for k in range(self.count_types):
            typecode = reader.u8()
            exported = bool(typecode &amp; 0x80)
            typecode = typecode &amp; 0x7F
            try:
                code = TC(typecode)
            except ValueError as V:
                raise ValueError(F&#39;Unknown type code value 0x{typecode:02X}.&#39;) from V
            if code in (TC.Class, TC.ExtClass):
                t = TClass(code, _normalize(reader.read_length_prefixed_ascii()))
            elif code is TC.ProcPtr:
                spec = reader.read_length_prefixed()
                void = bool(spec[0])
                args = tuple(DeclSpecParam(not b) for b in spec[1:])
                t = TProcPtr(code, void, args)
            elif code is TC.Interface:
                guid = UUID(bytes=bytes(reader.read(0x10)))
                t = TInterface(code, guid)
            elif code is TC.Set:
                t = TSet(code, reader.u32())
            elif code is TC.StaticArray:
                type = types[reader.u32()]
                size = reader.u32()
                offset = None if self.version &lt;= 22 else reader.u32()
                t = TStaticArray(code, type, size, offset)
            elif code is TC.Array:
                t = TArray(code, types[reader.u32()])
            elif code is TC.Record:
                length = reader.u32()
                members = tuple(types[reader.u32()] for _ in range(length))
                t = TRecord(code, members, symbol=F&#39;RECORD{k}&#39;)
            else:
                t = TPrimitive(code, symbol=code.name)
            if exported:
                t.symbol = _normalize(reader.read_length_prefixed_ascii())
                if self.version &lt;= 21:
                    t.name = _normalize(reader.read_length_prefixed_ascii())
            types.append(t)
            if self.version &gt;= 21:
                t.attributes = list(self._read_attributes())

    def _read_value(self, reader: StructReader | None = None) -&gt; Value:
        if reader is None:
            reader = self.reader
        type = self.types[reader.u32()]
        size = type.code.width
        processor: Callable[[], int | float | str | bytes] | None = {
            TC.U08           : reader.u8,
            TC.S08           : reader.i8,
            TC.U16           : reader.u16,
            TC.S16           : reader.i16,
            TC.U32           : reader.u32,
            TC.S32           : reader.i32,
            TC.S64           : reader.i64,
            TC.Single        : reader.f32,
            TC.Double        : reader.f64,
            TC.Extended      : lambda: extended(reader.read(10)),
            TC.AnsiString    : lambda: reader.read_length_prefixed(encoding=self.codec),
            TC.PChar         : lambda: reader.read_length_prefixed(encoding=self.codec),
            TC.WideString    : reader.read_length_prefixed_utf16,
            TC.UnicodeString : reader.read_length_prefixed_utf16,
            TC.Char          : lambda: chr(reader.u8()),
            TC.WideChar      : lambda: chr(reader.u16()),
            TC.ProcPtr       : lambda: self.functions[reader.u32()],
            TC.Set           : lambda: int.from_bytes(reader.read(type.size_in_bytes), &#39;little&#39;),
            TC.Currency      : lambda: reader.u64() / 10_000,
        }.get(type.code, None)
        if processor is not None:
            data = processor()
        elif size &gt; 0:
            data = bytes(reader.read(size))
        else:
            raise ValueError(F&#39;Unable to read attribute of type {type!s}.&#39;)
        if isinstance(data, str) and data not in self.strings:
            self.strings.append(data)
        return Value(type, data)

    def _read_attributes(self) -&gt; Generator[FunctionAttribute]:
        reader = self.reader
        count = reader.u32()
        for _ in range(count):
            name = reader.read_length_prefixed_ascii()
            fields = tuple(self._read_value() for _ in range(reader.u32()))
            yield FunctionAttribute(name, fields)

    def _load_functions(self):
        def _signature(name: str, decl: DeclSpec | None):
            signature = IFPSAPI.get(name, IFPSEvents.get(name)) if name else None
            if decl and decl.classname and (ic := IFPSClasses.Classes.get(decl.classname)):
                if ic.name not in self.types_by_name:
                    missing_types.add(ic.name)
                signature = ic.members.get(decl.name, signature)
                decl.classname = ic.name
            return signature

        reader = self.reader
        rewind = reader.tell()
        width = len(F&#39;{self.count_functions:X}&#39;)
        missing_types = set()
        load_flags = (self.version &gt;= 23)

        reparsed = False
        all_void = True
        all_long = True
        has_dll_imports = False

        while True:
            for k in range(self.count_functions):
                decl = None
                body = None
                name = F&#39;F{k:0{width}X}&#39;
                tags = reader.u8()
                attributes = None
                exported = FTag.Exported.check(tags)
                if FTag.External.check(tags):
                    name = reader.read_length_prefixed_ascii(8)
                    if exported:
                        read = StructReader(bytes(reader.read_length_prefixed()))
                        decl = DeclSpec.ParseF(read, load_flags)
                        if not reparsed and decl.module is not None:
                            has_dll_imports = True
                            # inno: 0d13564460b4cca289ac60221e86ca5719d7217a8eb76671b4b2a8407c2af6b4
                            # ifps: 6c211c02652317903b23c827cbc311a258fcd6197eec6a3d2f91986bd8accb0e
                            # This script reports version 22 and therefore, load_flags starts as False.
                            # However, it should be true; the reasons are unclear. The code below is
                            # an attempt to identify incorrect load_flags values heuristically. When
                            # there are no __delay_load functions present, reading them with load_flags
                            # set to False will result in only procedures (void=True) with at least
                            # 2 arguments.
                            if not decl.void:
                                all_void = False
                            if len(decl.parameters) &lt; 2:
                                all_long = False
                else:
                    offset = reader.u32()
                    length = reader.u32()
                    if exported:
                        name = reader.read_length_prefixed_ascii()
                        decl = DeclSpec.ParseE(bytes(reader.read_length_prefixed()), self)
                    with reader.detour(offset):
                        body = reader.read(length)
                if FTag.HasAttrs.check(tags):
                    attributes = list(self._read_attributes())
                fn = Function(name, decl=decl, body=body, attributes=attributes)
                self.functions.append(fn)
            if has_dll_imports and all_long and all_void and not reparsed:
                load_flags = True
                reparsed = True
                reader.seekset(rewind)
                self.functions.clear()
            else:
                break

        byfqn: dict[str, list[Function]] = {}

        for function in self.functions:
            key = str(function)
            byfqn.setdefault(key, []).append(function)
            if body := function.body:
                void = decl.void if (decl := function.decl) else False
                function.body = list(self._parse_bytecode(body, void))

        for functions in byfqn.values():
            if len(functions) != 2:
                continue
            getter, setter = functions
            if not (s_decl := setter.decl):
                continue
            if not (g_decl := getter.decl):
                continue
            if setter.decl.is_property:
                setter, getter = getter, setter
                s_decl, g_decl = g_decl, s_decl
            if s_decl.is_property:
                continue
            if not g_decl.is_property:
                continue
            g_decl.is_property = False
            g_decl.name = F&#39;Get{g_decl.name}&#39;
            s_decl.name = F&#39;Set{s_decl.name}&#39;

        for function in self.functions:
            name = function.symbol
            decl = function.decl
            if (signature := _signature(name, decl)) and decl:
                if signature.argc == decl.argc:
                    for old, new in itertools.zip_longest(decl.parameters, signature.parameters):
                        if not new:
                            break
                        if old and (t := old.type):
                            t.symbol = new.type
                            continue
                        if t := self.types_by_name.get(new.type):
                            t.symbol = new.type
                        else:
                            missing_types.add(new.type)
                if sr := signature.return_type:
                    if (dr := decl.return_type) or (dr := self.types_by_name.get(sr)):
                        dr.symbol = sr
                    else:
                        missing_types.add(sr)

        self.type_name_conflicts = self._name_types(missing_types)

        for function in self.functions:
            decl = function.decl
            if signature := _signature(function.name, decl):
                decl = decl or DeclSpec(True)
                decl.void = signature.void
                parameters = decl.parameters
                if signature.argc != len(parameters):
                    decl.parameters = parameters = [DeclSpecParam(True) for _ in range(signature.argc)]
                for old, new in zip(parameters, signature.parameters):
                    if old.type is None:
                        old.type = self.types_by_name.get(new.type)
                    old.name = new.name or old.name
                    old.const = new.const
                function.symbol = decl.name = signature.name
                if (rt := signature.return_type) and (decl.return_type is None):
                    decl.return_type = self.types_by_name.get(rt, decl.return_type)
                function.decl = decl
            elif decl and decl.is_property and decl.argc &gt;= (k := decl.void + 1):
                del decl.parameters[:k]

        for function in self.functions:
            if (decl := function.decl) and decl.is_property:
                classname = decl.classname
                this = DeclSpecParam(True, self.types_by_name.get(classname), &#39;This&#39;)
                nval = DeclSpecParam(True, decl.return_type, &#39;NewValue&#39;)
                info = IFPSClasses.Classes.get(classname)
                info = info and info.members.get(decl.name)
                if not info or info.writable:
                    function.setter = Function(decl=DeclSpec(
                        void=True,
                        parameters=[this, *decl.parameters, nval],
                        name=F&#39;Set{decl.name}&#39;,
                        calling_convention=None,
                        return_type=None,
                        classname=classname,
                        is_accessor=True
                    ))
                if not info or info.readable:
                    function.getter = Function(decl=DeclSpec(
                        void=False,
                        parameters=[this, *decl.parameters],
                        name=F&#39;Get{decl.name}&#39;,
                        calling_convention=None,
                        return_type=decl.return_type,
                        classname=classname,
                        is_accessor=True
                    ))

            if function.body is None:
                continue
            for instruction in function.body:
                if instruction.opcode is Op.Call:
                    t: Function = self.functions[instruction.operands[0]]
                    instruction.operands[0] = t

    def _load_variables(self):
        reader = self.reader
        for index in range(self.count_variables):
            code = reader.u32()
            spec = VariableSpec(index, VariableType.Global)
            if reader.u8() &amp; 1:
                spec = reader.read_length_prefixed_ascii()
            self.globals.append(VariableBase(self.types[code], spec))

    def _read_variable_spec(self, index: int, void: bool) -&gt; VariableSpec:
        if index &lt; 0x40000000:
            return VariableSpec(index, VariableType.Global)
        index -= 0x60000000
        if index &gt;= 0:
            return VariableSpec(index, VariableType.Local)
        index = -index if void else ~index
        return VariableSpec(index, VariableType.Argument)

    def _read_operand(self, reader: StructReader, void: bool) -&gt; Operand:
        ot = OperandType(reader.u8())
        kw = {}
        if ot is OperandType.Variable:
            kw.update(variable=self._read_variable_spec(reader.u32(), void))
        if ot is OperandType.Value:
            kw.update(value=self._read_value(reader))
        if ot &gt;= OperandType.IndexedByInt:
            kw.update(variable=self._read_variable_spec(reader.u32(), void))
            index = reader.u32()
            if ot is OperandType.IndexedByVar:
                index = self._read_variable_spec(index, void)
            kw.update(index=index)
        return Operand(ot, **kw)

    def _parse_bytecode(self, data: memoryview, void: bool) -&gt; Generator[Instruction]:
        disassembly: dict[int, Instruction] = OrderedDict()
        reader = StructReader(data)

        argcount = {
            Op.Assign: 2,
            Op.CallVar: 1,
            Op.Dec: 1,
            Op.Inc: 1,
            Op.BooleanNot: 1,
            Op.Neg: 1,
            Op.IntegerNot: 1,
            Op.SetPtrToCopy: 2,
            Op.SetPtr: 2,
        }

        while not reader.eof:
            def arg(k=1):
                for _ in range(k):
                    args.append(self._read_operand(reader, void))
            addr = reader.tell()
            cval = reader.u8()
            code = Op.FromInt(cval)
            insn = Instruction(addr, code)
            args = insn.operands
            disassembly[insn.offset] = insn
            aryness = argcount.get(code)
            if aryness is not None:
                arg(aryness)
            elif code in (Op.Ret, Op.Nop, Op.Pop):
                pass
            elif code is Op.Calculate:
                insn.operator = AOp(reader.u8())
                arg(2)
            elif code in (Op.Push, Op.PushVar):
                arg()
            elif code in (Op.Jump, Op.JumpFlag):
                target = reader.i32()
                args.append(reader.tell() + target)
            elif code is Op.Call:
                args.append(reader.u32())
            elif code in (Op.JumpTrue, Op.JumpFalse):
                target = reader.i32()
                val = self._read_operand(reader, void)
                args.append(reader.tell() + target)
                args.append(val)
            elif code is Op.JumpPop1:
                target = reader.i32()
                args.append(reader.tell() + target)
            elif code is Op.JumpPop2:
                target = reader.i32()
                args.append(reader.tell() + target)
            elif code is Op.StackType:
                args.append(self._read_variable_spec(reader.u32(), void))
                args.append(reader.u32())
            elif code is Op.PushType:
                args.append(self.types[reader.u32()])
            elif code is Op.Compare:
                insn.operator = COp(reader.u8())
                arg(3)
            elif code is Op.SetFlag:
                arg()
                args.append(bool(reader.u8()))
            elif code is Op.PushEH:
                args.extend(reader.i32() for _ in range(4))
                for k, a in enumerate(args):
                    args[k] = a + reader.tell() if a &gt;= 0 else None
            elif code is Op.PopEH:
                args.append(reader.u8())
            elif code is Op._INVALID:
                raise ValueError(F&#39;Unsupported opcode: 0x{cval:02X}&#39;)
            else:
                raise ValueError(F&#39;Unhandled opcode: {code.name}&#39;)
            size = reader.tell() - addr
            reader.seekrel(-size)
            insn.encoded = bytes(reader.read(size))

        for k, instruction in enumerate(disassembly.values()):
            if not instruction.branches:
                continue
            target = instruction.operands[0]
            try:
                disassembly[target].jumptarget = True
            except KeyError as K:
                raise RuntimeError(
                    F&#39;The jump target of instruction {k} at 0x{instruction.offset:X} is invalid; &#39;
                    F&#39;the invalid instruction is a {instruction.opcode.name} to 0x{target:X}.&#39;
                ) from K

        yield from disassembly.values()

    def __str__(self):
        return self.disassembly()

    def disassembly(self, print_bytes: bool = False, print_bytes_count: int = 12) -&gt; str:
        def sortkey(f: Function):
            d = (d.module or &#39;&#39;, d.classname or &#39;&#39;, d.void) if (d := f.decl) else (&#39;&#39;, &#39;&#39;, True)
            return (*d, f.name)

        for function in self.functions:
            function.get_basic_blocks()

        classes: dict[str, dict[str, Function]] = {}
        external: list[Function] = []
        internal: list[Function] = []

        for t in self.types:
            if isinstance(t, TClass):
                classes[t.name] = {}

        for function in self.functions:
            if (decl := function.decl) and (name := decl.classname):
                try:
                    members = classes[name]
                except KeyError:
                    members = classes[name] = {}
                members[decl.name] = function
                continue
            dl = internal if function.body else external
            dl.append(function)

        external.sort(key=sortkey)

        output = io.StringIO()
        _omax = max((
            max(insn.offset for insn in fn.body)
            for fn in self.functions if fn.body
        ), default=0)
        _smax = max((
            max((insn.stack for insn in fn.body if insn.stack is not None), default=1)
            for fn in self.functions if fn.body
        ), default=0)
        _omax = max(len(self.types), len(self.globals), _omax)
        _omax = len(F&#39;{_omax:X}&#39;)
        _smax = len(F&#39;{_smax:d}&#39;)

        if classes:
            for name, members in classes.items():
                if not members:
                    output.write(F&#39;external class {name};\n&#39;)
            output.write(&#39;\n&#39;)
            for name, members in classes.items():
                if not members:
                    continue
                output.write(F&#39;external class {name}&#39;)
                if members:
                    for spec in members.values():
                        if spec.decl.is_accessor:
                            continue
                        output.write(F&#39;\n{_TAB}{spec.decl.represent(spec.symbol, rel=True)}&#39;)
                    output.write(&#39;\nend&#39;)
                output.write(&#39;;\n\n&#39;)

        if self.types:
            typedefs = []
            for type in self.types:
                if type.code != TC.Record and type.symbol in (type.code.name, None):
                    continue
                if isinstance(type, TClass):
                    continue
                typedefs.append((type.symbol, type.display()))
            typedefs.sort()
            for symbol, display in typedefs:
                output.write(F&#39;typedef {symbol} = {display}\n&#39;)
            output.write(&#39;\n&#39;)

        if self.globals:
            for variable in self.globals:
                output.write(F&#39;global {variable!s}\n&#39;)
            output.write(&#39;\n&#39;)

        if external:
            for function in external:
                output.write(F&#39;external {function!r}\n&#39;)
            output.write(&#39;\n&#39;)

        if internal:
            def create_prefix(instruction: Instruction):
                stack = instruction.stack
                stack = &#39;?&#39; * _smax if stack is None else F&#39;{stack:&gt;{_smax}d}&#39;
                return F&#39;{_TAB}0x{instruction.offset:0{_omax}X}{_TAB}{stack}{_TAB}&#39;

            for function in internal:
                labels = [insn.offset for insn in function.body if insn.jumptarget]
                labelw = max(len(str(len(labels))), 2)
                labeld = {v: F&#39;JumpDestination{k:0{labelw}d}&#39; for k, v in enumerate(labels, 1)}

                output.write(F&#39;{function!r}\nbegin\n&#39;)
                labelc = 0

                for instruction in function.body:
                    prefix = create_prefix(instruction)
                    if instruction.jumptarget:
                        output.write(F&#39;{labeld[labels[labelc]]}:\n&#39;)
                        labelc += 1
                    if print_bytes:
                        hexbytes = instruction.encoded.hex(&#39; &#39;).split()
                    else:
                        hexbytes = [&#39;&#39;]
                    hexbytes_iter = iter(hexbytes)
                    instruction_written = False
                    prefix_length = len(prefix)
                    ic = instruction.pretty(labeld)
                    while line := list(itertools.islice(hexbytes_iter, 0, print_bytes_count)):
                        output.write(prefix)
                        if print_bytes:
                            prefix = prefix_length * &#39;\x20&#39;
                            output.write(&#39;\x20&#39;.join(line).ljust(3 * print_bytes_count - 1))
                        if not instruction_written:
                            output.write(ic)
                            instruction_written = True
                        output.write(&#39;\n&#39;)

                output.write(&#39;end;\n\n&#39;)

        return output.getvalue().strip()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.structures.Struct" href="../structures.html#refinery.lib.structures.Struct">Struct</a></li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.inno.ifps.IFPSFile.MinVer"><code class="name">var <span class="ident">MinVer</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.IFPSFile.MaxVer"><code class="name">var <span class="ident">MaxVer</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.inno.ifps.IFPSFile.Magic"><code class="name">var <span class="ident">Magic</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.inno.ifps.IFPSFile.disassembly"><code class="name flex">
<span>def <span class="ident">disassembly</span></span>(<span>self, print_bytes=False, print_bytes_count=12)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/inno/ifps.py#L1721-L1842" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def disassembly(self, print_bytes: bool = False, print_bytes_count: int = 12) -&gt; str:
    def sortkey(f: Function):
        d = (d.module or &#39;&#39;, d.classname or &#39;&#39;, d.void) if (d := f.decl) else (&#39;&#39;, &#39;&#39;, True)
        return (*d, f.name)

    for function in self.functions:
        function.get_basic_blocks()

    classes: dict[str, dict[str, Function]] = {}
    external: list[Function] = []
    internal: list[Function] = []

    for t in self.types:
        if isinstance(t, TClass):
            classes[t.name] = {}

    for function in self.functions:
        if (decl := function.decl) and (name := decl.classname):
            try:
                members = classes[name]
            except KeyError:
                members = classes[name] = {}
            members[decl.name] = function
            continue
        dl = internal if function.body else external
        dl.append(function)

    external.sort(key=sortkey)

    output = io.StringIO()
    _omax = max((
        max(insn.offset for insn in fn.body)
        for fn in self.functions if fn.body
    ), default=0)
    _smax = max((
        max((insn.stack for insn in fn.body if insn.stack is not None), default=1)
        for fn in self.functions if fn.body
    ), default=0)
    _omax = max(len(self.types), len(self.globals), _omax)
    _omax = len(F&#39;{_omax:X}&#39;)
    _smax = len(F&#39;{_smax:d}&#39;)

    if classes:
        for name, members in classes.items():
            if not members:
                output.write(F&#39;external class {name};\n&#39;)
        output.write(&#39;\n&#39;)
        for name, members in classes.items():
            if not members:
                continue
            output.write(F&#39;external class {name}&#39;)
            if members:
                for spec in members.values():
                    if spec.decl.is_accessor:
                        continue
                    output.write(F&#39;\n{_TAB}{spec.decl.represent(spec.symbol, rel=True)}&#39;)
                output.write(&#39;\nend&#39;)
            output.write(&#39;;\n\n&#39;)

    if self.types:
        typedefs = []
        for type in self.types:
            if type.code != TC.Record and type.symbol in (type.code.name, None):
                continue
            if isinstance(type, TClass):
                continue
            typedefs.append((type.symbol, type.display()))
        typedefs.sort()
        for symbol, display in typedefs:
            output.write(F&#39;typedef {symbol} = {display}\n&#39;)
        output.write(&#39;\n&#39;)

    if self.globals:
        for variable in self.globals:
            output.write(F&#39;global {variable!s}\n&#39;)
        output.write(&#39;\n&#39;)

    if external:
        for function in external:
            output.write(F&#39;external {function!r}\n&#39;)
        output.write(&#39;\n&#39;)

    if internal:
        def create_prefix(instruction: Instruction):
            stack = instruction.stack
            stack = &#39;?&#39; * _smax if stack is None else F&#39;{stack:&gt;{_smax}d}&#39;
            return F&#39;{_TAB}0x{instruction.offset:0{_omax}X}{_TAB}{stack}{_TAB}&#39;

        for function in internal:
            labels = [insn.offset for insn in function.body if insn.jumptarget]
            labelw = max(len(str(len(labels))), 2)
            labeld = {v: F&#39;JumpDestination{k:0{labelw}d}&#39; for k, v in enumerate(labels, 1)}

            output.write(F&#39;{function!r}\nbegin\n&#39;)
            labelc = 0

            for instruction in function.body:
                prefix = create_prefix(instruction)
                if instruction.jumptarget:
                    output.write(F&#39;{labeld[labels[labelc]]}:\n&#39;)
                    labelc += 1
                if print_bytes:
                    hexbytes = instruction.encoded.hex(&#39; &#39;).split()
                else:
                    hexbytes = [&#39;&#39;]
                hexbytes_iter = iter(hexbytes)
                instruction_written = False
                prefix_length = len(prefix)
                ic = instruction.pretty(labeld)
                while line := list(itertools.islice(hexbytes_iter, 0, print_bytes_count)):
                    output.write(prefix)
                    if print_bytes:
                        prefix = prefix_length * &#39;\x20&#39;
                        output.write(&#39;\x20&#39;.join(line).ljust(3 * print_bytes_count - 1))
                    if not instruction_written:
                        output.write(ic)
                        instruction_written = True
                    output.write(&#39;\n&#39;)

            output.write(&#39;end;\n\n&#39;)

    return output.getvalue().strip()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib.inno" href="index.html">refinery.lib.inno</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="refinery.lib.inno.ifps.IFPSType" href="#refinery.lib.inno.ifps.IFPSType">IFPSType</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.inno.ifps.extended" href="#refinery.lib.inno.ifps.extended">extended</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.represent" href="#refinery.lib.inno.ifps.represent">represent</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.ifpstype" href="#refinery.lib.inno.ifps.ifpstype">ifpstype</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.inno.ifps.Op" href="#refinery.lib.inno.ifps.Op">Op</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.ifps.Op.FromInt" href="#refinery.lib.inno.ifps.Op.FromInt">FromInt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.AOp" href="#refinery.lib.inno.ifps.AOp">AOp</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.COp" href="#refinery.lib.inno.ifps.COp">COp</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.TC" href="#refinery.lib.inno.ifps.TC">TC</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.IFPSTypeMixin" href="#refinery.lib.inno.ifps.IFPSTypeMixin">IFPSTypeMixin</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.IFPSTypeBase" href="#refinery.lib.inno.ifps.IFPSTypeBase">IFPSTypeBase</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.simple" href="#refinery.lib.inno.ifps.IFPSTypeBase.simple">simple</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.display" href="#refinery.lib.inno.ifps.IFPSTypeBase.display">display</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.py_type" href="#refinery.lib.inno.ifps.IFPSTypeBase.py_type">py_type</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.IFPSTypeBase.default" href="#refinery.lib.inno.ifps.IFPSTypeBase.default">default</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.TPrimitive" href="#refinery.lib.inno.ifps.TPrimitive">TPrimitive</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.TProcPtr" href="#refinery.lib.inno.ifps.TProcPtr">TProcPtr</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.TInterface" href="#refinery.lib.inno.ifps.TInterface">TInterface</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.TClass" href="#refinery.lib.inno.ifps.TClass">TClass</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.TSet" href="#refinery.lib.inno.ifps.TSet">TSet</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.TArray" href="#refinery.lib.inno.ifps.TArray">TArray</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.TStaticArray" href="#refinery.lib.inno.ifps.TStaticArray">TStaticArray</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.TRecord" href="#refinery.lib.inno.ifps.TRecord">TRecord</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.Value" href="#refinery.lib.inno.ifps.Value">Value</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.ifps.Value.convert" href="#refinery.lib.inno.ifps.Value.convert">convert</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.Value.default" href="#refinery.lib.inno.ifps.Value.default">default</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.FunctionAttribute" href="#refinery.lib.inno.ifps.FunctionAttribute">FunctionAttribute</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.DeclSpecParam" href="#refinery.lib.inno.ifps.DeclSpecParam">DeclSpecParam</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.CallType" href="#refinery.lib.inno.ifps.CallType">CallType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.DeclSpec" href="#refinery.lib.inno.ifps.DeclSpec">DeclSpec</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.ifps.DeclSpec.ParseF" href="#refinery.lib.inno.ifps.DeclSpec.ParseF">ParseF</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.DeclSpec.ParseE" href="#refinery.lib.inno.ifps.DeclSpec.ParseE">ParseE</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.DeclSpec.represent" href="#refinery.lib.inno.ifps.DeclSpec.represent">represent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.Function" href="#refinery.lib.inno.ifps.Function">Function</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.ifps.Function.reference" href="#refinery.lib.inno.ifps.Function.reference">reference</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.Function.get_basic_blocks" href="#refinery.lib.inno.ifps.Function.get_basic_blocks">get_basic_blocks</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.VariableBase" href="#refinery.lib.inno.ifps.VariableBase">VariableBase</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.OperandType" href="#refinery.lib.inno.ifps.OperandType">OperandType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.EHType" href="#refinery.lib.inno.ifps.EHType">EHType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.NewEH" href="#refinery.lib.inno.ifps.NewEH">NewEH</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.VariableType" href="#refinery.lib.inno.ifps.VariableType">VariableType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.VariableSpec" href="#refinery.lib.inno.ifps.VariableSpec">VariableSpec</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.Operand" href="#refinery.lib.inno.ifps.Operand">Operand</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.Instruction" href="#refinery.lib.inno.ifps.Instruction">Instruction</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.ifps.Instruction.op" href="#refinery.lib.inno.ifps.Instruction.op">op</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.Instruction.oprep" href="#refinery.lib.inno.ifps.Instruction.oprep">oprep</a></code></li>
<li><code><a title="refinery.lib.inno.ifps.Instruction.pretty" href="#refinery.lib.inno.ifps.Instruction.pretty">pretty</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.BasicBlock" href="#refinery.lib.inno.ifps.BasicBlock">BasicBlock</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.FTag" href="#refinery.lib.inno.ifps.FTag">FTag</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.ifps.FTag.check" href="#refinery.lib.inno.ifps.FTag.check">check</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.inno.ifps.IFPSFile" href="#refinery.lib.inno.ifps.IFPSFile">IFPSFile</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.inno.ifps.IFPSFile.disassembly" href="#refinery.lib.inno.ifps.IFPSFile.disassembly">disassembly</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
