<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.types documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.types</code></h1>
</header>
<section id="section-intro">
<p>This module is used as a unified resource for various types that are primarily used for type hints.
It also exports important singleton types used throughout refinery.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/types.py#L1-L365" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module is used as a unified resource for various types that are primarily used for type hints.
It also exports important singleton types used throughout refinery.
&#34;&#34;&#34;
from __future__ import annotations

from typing import TYPE_CHECKING, Any, NamedTuple, TypeVar

_T = TypeVar(&#39;_T&#39;)

if TYPE_CHECKING:
    from typing import (
        Annotated,
        Callable,
        ClassVar,
        Collection,
        Generator,
        Iterable,
        Self,
        Union,
    )

    Param = Annotated
    JSON = Union[
        None,
        str,
        int,
        float,
        bool,
        dict[str, &#39;JSON&#39;],
        list[&#39;JSON&#39;],
        list[int],
        list[str],
        list[float],
        list[bool],
        dict[str, int],
        dict[str, str],
        dict[str, int | str],
    ]
    JSONDict = dict[str, JSON]

    buf = Union[bytes, bytearray, memoryview]
    isq = Union[int, Iterable[int]]

else:
    class __P:
        def __getitem__(self, annotation):
            return annotation[1]

    Param = __P()
    JSON = Any
    JSONDict = Any
    buf = Any
    isq = Any

    Callable = Any
    ClassVar = Any
    Collection = Any
    Iterable = Any
    Self = Any
    Generator = Any


__all__ = [
    &#39;asbuffer&#39;,
    &#39;AST&#39;,
    &#39;bounds&#39;,
    &#39;BoundsType&#39;,
    &#39;buf&#39;,
    &#39;Callable&#39;,
    &#39;ClassVar&#39;,
    &#39;Collection&#39;,
    &#39;convert&#39;,
    &#39;Generator&#39;,
    &#39;INF&#39;,
    &#39;isbuffer&#39;,
    &#39;isq&#39;,
    &#39;isstream&#39;,
    &#39;Iterable&#39;,
    &#39;JSON&#39;,
    &#39;JSONDict&#39;,
    &#39;NamedTuple&#39;,
    &#39;Param&#39;,
    &#39;RepeatedInteger&#39;,
    &#39;Self&#39;,
    &#39;Singleton&#39;,
    &#39;typename&#39;,
]


def isstream(obj) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether `obj` is a stream. This is currently done by simply testing whether the object
    has an attribute called `read`.
    &#34;&#34;&#34;
    return hasattr(obj, &#39;read&#39;)


def isbuffer(obj) -&gt; bool:
    &#34;&#34;&#34;
    Test whether `obj` is an object that supports the buffer API, like a bytes or bytearray object.
    &#34;&#34;&#34;
    try:
        with memoryview(obj):
            return True
    except TypeError:
        return False


def asbuffer(obj) -&gt; memoryview | None:
    &#34;&#34;&#34;
    Attempts to acquire a memoryview of the given object. This works for bytes and bytearrays, or
    memoryview objects themselves. The return value is `None` for objects that do not support the
    buffer protocol.
    &#34;&#34;&#34;
    try:
        return memoryview(obj)
    except TypeError:
        return None


def typename(thing):
    &#34;&#34;&#34;
    Determines the name of the type of an object.
    &#34;&#34;&#34;
    if not isinstance(thing, type):
        thing = type(thing)
    mro = [c for c in thing.__mro__ if c is not object]
    if mro:
        thing = mro[~0]
    try:
        return thing.__name__
    except AttributeError:
        return repr(thing)


def convert(x: _T | Any, t: type[_T]) -&gt; _T:
    &#34;&#34;&#34;
    Convert the given object `x` to the type `t`.
    &#34;&#34;&#34;
    return x if isinstance(x, t) else t(x) # type:ignore


class Singleton(type):
    &#34;&#34;&#34;
    A metaclass that can be used to define singleton classes.
    &#34;&#34;&#34;

    def __new__(mcs, name: str, bases: tuple[type, ...], namespace: dict[str, Any]):
        def __new__(cls):
            return cls

        def __getstate__(self):
            return None

        def __setstate__(self, _):
            pass

        def __call__(self, *_):
            return self

        namespace.setdefault(&#39;__call__&#39;, __call__)
        operator_overloads = {}

        for op, method in namespace.items():
            if op[:2] == op[-2:] == &#39;__&#39; and callable(method):
                operator_overloads[op] = method

        if operator_overloads:
            custom_meta_dict = {}
            for method_name, method in operator_overloads.items():
                def make_method(orig_method):
                    def meta_method(cls, *args, **kwargs):
                        return orig_method(cls, *args, **kwargs)
                    return meta_method
                custom_meta_dict[method_name] = make_method(method)
            mcs = type(f&#39;{name}Meta&#39;, (mcs,), custom_meta_dict)

        namespace.update(
            __new__=__new__,
            __slots__=(),
            __getstate__=__getstate__,
            __setstate__=__setstate__,
        )

        return type.__new__(mcs, name, bases, namespace)


class INF(metaclass=Singleton):
    &#34;&#34;&#34;
    A crude object representing infinity, which is greater than anything it is compared to, and
    only equal to itself.
    &#34;&#34;&#34;

    def __lt__(self, _: Any):
        return False

    def __le__(self, _: Any):
        return False

    def __gt__(self, _: Any):
        return True

    def __ge__(self, _: Any):
        return True

    def __eq__(self, other: Any):
        return other is INF

    def __rmul__(self, _: Any):
        return self

    def __radd__(self, _: Any):
        return self

    def __mul__(self, _: Any):
        return self

    def __add__(self, _: Any):
        return self

    def __sub__(self, _: Any):
        return self

    def __div__(self, _: Any):
        return self

    def __mod__(self, _: Any):
        return self

    def __pow__(self, _: Any):
        return self

    def __iadd__(self, _: Any):
        return self

    def __isub__(self, _: Any):
        return self

    def __imul__(self, _: Any):
        return self

    def __imod__(self, _: Any):
        return self

    def __abs__(self):
        return None

    def __repr__(self):
        return &#39;∞&#39;

    def __truediv__(self, _: Any):
        return self

    def __floordiv__(self, _: Any):
        return self

    def __rrshift__(self, _: Any):
        return 0

    def __rlshift__(self, _: Any):
        return 0

    def __format__(self, *_):
        return str(self)


class AST(metaclass=Singleton):
    &#34;&#34;&#34;
    A wildcard object which is equal to everything.
    &#34;&#34;&#34;
    def __eq__(self, _: Any):
        return True

    def __ne__(self, _: Any):
        return False

    def __or__(self, x: Any):
        return x

    def __contains__(self, _: Any):
        return True

    def __repr__(self):
        return &#39;*&#39;


class RepeatedInteger(int):
    &#34;&#34;&#34;
    This class serves as a dual-purpose result for `refinery.lib.argformats.numseq` types. It
    is an integer, but can be infinitely iterated.
    &#34;&#34;&#34;
    def __iter__(self):
        return self

    def __next__(self):
        return self


class NoDefault(metaclass=Singleton):
    &#34;&#34;&#34;
    A sentinel singleton that can be used as a no-default marker when &#34;None&#34; is a valid option.
    &#34;&#34;&#34;
    pass


class BoundsType:
    &#34;&#34;&#34;
    Can be used to specify certain upper and lower bounds. For example, the following is `True`:

        5 in bounds[3:5]

    This is notably different from how a `range` object functions since the upper bound is included
    in the valid range, and it is also permitted to be `None` for an unbounded range.
    &#34;&#34;&#34;
    __name__ = &#39;bounds&#39;

    min: int
    max: int | INF
    inc: int

    def __getitem__(self, k: slice):
        return BoundsType(k)

    def __init__(self, bounds: int | slice[int, int | None | INF, int | None] | None):
        if bounds is None:
            self.min = 0
            self.max = INF()
            self.inc = 1
        elif isinstance(bounds, int):
            self.min = self.max = bounds
            self.inc = 1
        else:
            _min, _max, _inc = bounds.start, bounds.stop, bounds.step
            self.min = _min or 0
            self.max = _max or INF()
            self.inc = _inc or 1
            if _max and _max &lt; self.min:
                raise ValueError(F&#39;The maximum {self.max} is lesser than the minimum {self.min}.&#39;)
            if self.inc &lt; 0:
                raise ValueError(&#39;Negative step size not supported for range expressions.&#39;)

    def __iter__(self):
        k = self.min
        i = self.inc
        if (m := self.max) is INF:
            import itertools
            yield from itertools.count(k, i)
        else:
            while k &lt;= m:
                yield k
                k += i

    def __repr__(self):
        return F&#39;[{self.min}:{self.max}:{self.inc}]&#39;

    def __contains__(self, value: int):
        if value &lt; self.min:
            return False
        if (m := self.max) and value &gt; m:
            return False
        return (value - self.min) % self.inc == 0


bounds = BoundsType(slice(None, None))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.types.asbuffer"><code class="name flex">
<span>def <span class="ident">asbuffer</span></span>(<span>obj)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempts to acquire a memoryview of the given object. This works for bytes and bytearrays, or
memoryview objects themselves. The return value is <code>None</code> for objects that do not support the
buffer protocol.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/types.py#L110-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def asbuffer(obj) -&gt; memoryview | None:
    &#34;&#34;&#34;
    Attempts to acquire a memoryview of the given object. This works for bytes and bytearrays, or
    memoryview objects themselves. The return value is `None` for objects that do not support the
    buffer protocol.
    &#34;&#34;&#34;
    try:
        return memoryview(obj)
    except TypeError:
        return None</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>x, t)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert the given object <code>x</code> to the type <code>t</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/types.py#L137-L141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def convert(x: _T | Any, t: type[_T]) -&gt; _T:
    &#34;&#34;&#34;
    Convert the given object `x` to the type `t`.
    &#34;&#34;&#34;
    return x if isinstance(x, t) else t(x) # type:ignore</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.isbuffer"><code class="name flex">
<span>def <span class="ident">isbuffer</span></span>(<span>obj)</span>
</code></dt>
<dd>
<section class="desc"><p>Test whether <code>obj</code> is an object that supports the buffer API, like a bytes or bytearray object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/types.py#L99-L107" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isbuffer(obj) -&gt; bool:
    &#34;&#34;&#34;
    Test whether `obj` is an object that supports the buffer API, like a bytes or bytearray object.
    &#34;&#34;&#34;
    try:
        with memoryview(obj):
            return True
    except TypeError:
        return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.isstream"><code class="name flex">
<span>def <span class="ident">isstream</span></span>(<span>obj)</span>
</code></dt>
<dd>
<section class="desc"><p>Tests whether <code>obj</code> is a stream. This is currently done by simply testing whether the object
has an attribute called <code>read</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/types.py#L91-L96" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isstream(obj) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether `obj` is a stream. This is currently done by simply testing whether the object
    has an attribute called `read`.
    &#34;&#34;&#34;
    return hasattr(obj, &#39;read&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.NamedTuple"><code class="name flex">
<span>def <span class="ident">NamedTuple</span></span>(<span>typename, fields=&lt;sentinel&gt;, /, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Typed version of namedtuple.</p>
<p>Usage::</p>
<pre><code>class Employee(NamedTuple):
    name: str
    id: int
</code></pre>
<p>This is equivalent to::</p>
<pre><code>Employee = collections.namedtuple('Employee', ['name', 'id'])
</code></pre>
<p>The resulting class has an extra <strong>annotations</strong> attribute, giving a
dict that maps field names to types.
(The field names are also in
the _fields attribute, which is part of the namedtuple API.)
An alternative equivalent functional syntax is also accepted::</p>
<pre><code>Employee = NamedTuple('Employee', [('name', str), ('id', int)])
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NamedTuple(typename, fields=_sentinel, /, **kwargs):
    &#34;&#34;&#34;Typed version of namedtuple.

    Usage::

        class Employee(NamedTuple):
            name: str
            id: int

    This is equivalent to::

        Employee = collections.namedtuple(&#39;Employee&#39;, [&#39;name&#39;, &#39;id&#39;])

    The resulting class has an extra __annotations__ attribute, giving a
    dict that maps field names to types.  (The field names are also in
    the _fields attribute, which is part of the namedtuple API.)
    An alternative equivalent functional syntax is also accepted::

        Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])
    &#34;&#34;&#34;
    if fields is _sentinel:
        if kwargs:
            deprecated_thing = &#34;Creating NamedTuple classes using keyword arguments&#34;
            deprecation_msg = (
                &#34;{name} is deprecated and will be disallowed in Python {remove}. &#34;
                &#34;Use the class-based or functional syntax instead.&#34;
            )
        else:
            deprecated_thing = &#34;Failing to pass a value for the &#39;fields&#39; parameter&#34;
            example = f&#34;`{typename} = NamedTuple({typename!r}, [])`&#34;
            deprecation_msg = (
                &#34;{name} is deprecated and will be disallowed in Python {remove}. &#34;
                &#34;To create a NamedTuple class with 0 fields &#34;
                &#34;using the functional syntax, &#34;
                &#34;pass an empty list, e.g. &#34;
            ) + example + &#34;.&#34;
    elif fields is None:
        if kwargs:
            raise TypeError(
                &#34;Cannot pass `None` as the &#39;fields&#39; parameter &#34;
                &#34;and also specify fields using keyword arguments&#34;
            )
        else:
            deprecated_thing = &#34;Passing `None` as the &#39;fields&#39; parameter&#34;
            example = f&#34;`{typename} = NamedTuple({typename!r}, [])`&#34;
            deprecation_msg = (
                &#34;{name} is deprecated and will be disallowed in Python {remove}. &#34;
                &#34;To create a NamedTuple class with 0 fields &#34;
                &#34;using the functional syntax, &#34;
                &#34;pass an empty list, e.g. &#34;
            ) + example + &#34;.&#34;
    elif kwargs:
        raise TypeError(&#34;Either list of fields or keywords&#34;
                        &#34; can be provided to NamedTuple, not both&#34;)
    if fields is _sentinel or fields is None:
        import warnings
        warnings._deprecated(deprecated_thing, message=deprecation_msg, remove=(3, 15))
        fields = kwargs.items()
    nt = _make_nmtuple(typename, fields, module=_caller())
    nt.__orig_bases__ = (NamedTuple,)
    return nt</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.typename"><code class="name flex">
<span>def <span class="ident">typename</span></span>(<span>thing)</span>
</code></dt>
<dd>
<section class="desc"><p>Determines the name of the type of an object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/types.py#L122-L134" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def typename(thing):
    &#34;&#34;&#34;
    Determines the name of the type of an object.
    &#34;&#34;&#34;
    if not isinstance(thing, type):
        thing = type(thing)
    mro = [c for c in thing.__mro__ if c is not object]
    if mro:
        thing = mro[~0]
    try:
        return thing.__name__
    except AttributeError:
        return repr(thing)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.types.AST"><code class="flex name class">
<span>class <span class="ident">AST</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A wildcard object which is equal to everything.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/types.py#L268-L285" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class AST(metaclass=Singleton):
    &#34;&#34;&#34;
    A wildcard object which is equal to everything.
    &#34;&#34;&#34;
    def __eq__(self, _: Any):
        return True

    def __ne__(self, _: Any):
        return False

    def __or__(self, x: Any):
        return x

    def __contains__(self, _: Any):
        return True

    def __repr__(self):
        return &#39;*&#39;</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.BoundsType"><code class="flex name class">
<span>class <span class="ident">BoundsType</span></span>
<span>(</span><span>bounds)</span>
</code></dt>
<dd>
<section class="desc"><p>Can be used to specify certain upper and lower bounds. For example, the following is <code>True</code>:</p>
<pre><code>5 in bounds[3:5]
</code></pre>
<p>This is notably different from how a <code>range</code> object functions since the upper bound is included
in the valid range, and it is also permitted to be <code>None</code> for an unbounded range.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/types.py#L307-L362" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BoundsType:
    &#34;&#34;&#34;
    Can be used to specify certain upper and lower bounds. For example, the following is `True`:

        5 in bounds[3:5]

    This is notably different from how a `range` object functions since the upper bound is included
    in the valid range, and it is also permitted to be `None` for an unbounded range.
    &#34;&#34;&#34;
    __name__ = &#39;bounds&#39;

    min: int
    max: int | INF
    inc: int

    def __getitem__(self, k: slice):
        return BoundsType(k)

    def __init__(self, bounds: int | slice[int, int | None | INF, int | None] | None):
        if bounds is None:
            self.min = 0
            self.max = INF()
            self.inc = 1
        elif isinstance(bounds, int):
            self.min = self.max = bounds
            self.inc = 1
        else:
            _min, _max, _inc = bounds.start, bounds.stop, bounds.step
            self.min = _min or 0
            self.max = _max or INF()
            self.inc = _inc or 1
            if _max and _max &lt; self.min:
                raise ValueError(F&#39;The maximum {self.max} is lesser than the minimum {self.min}.&#39;)
            if self.inc &lt; 0:
                raise ValueError(&#39;Negative step size not supported for range expressions.&#39;)

    def __iter__(self):
        k = self.min
        i = self.inc
        if (m := self.max) is INF:
            import itertools
            yield from itertools.count(k, i)
        else:
            while k &lt;= m:
                yield k
                k += i

    def __repr__(self):
        return F&#39;[{self.min}:{self.max}:{self.inc}]&#39;

    def __contains__(self, value: int):
        if value &lt; self.min:
            return False
        if (m := self.max) and value &gt; m:
            return False
        return (value - self.min) % self.inc == 0</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.types.BoundsType.min"><code class="name">var <span class="ident">min</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.types.BoundsType.max"><code class="name">var <span class="ident">max</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.types.BoundsType.inc"><code class="name">var <span class="ident">inc</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.types.Any"><code class="flex name class">
<span>class <span class="ident">buf</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Special type indicating an unconstrained type.</p>
<ul>
<li>Any is compatible with every type.</li>
<li>Any assumed to have all methods.</li>
<li>All values assumed to be instances of Any.</li>
</ul>
<p>Note that all the above statements are true from the point of view of
static type checkers. At runtime, Any should not be used with instance
checks.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Any(metaclass=_AnyMeta):
    &#34;&#34;&#34;Special type indicating an unconstrained type.

    - Any is compatible with every type.
    - Any assumed to have all methods.
    - All values assumed to be instances of Any.

    Note that all the above statements are true from the point of view of
    static type checkers. At runtime, Any should not be used with instance
    checks.
    &#34;&#34;&#34;

    def __new__(cls, *args, **kwargs):
        if cls is Any:
            raise TypeError(&#34;Any cannot be instantiated&#34;)
        return super().__new__(cls)</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.Any"><code class="flex name class">
<span>class <span class="ident">Callable</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Special type indicating an unconstrained type.</p>
<ul>
<li>Any is compatible with every type.</li>
<li>Any assumed to have all methods.</li>
<li>All values assumed to be instances of Any.</li>
</ul>
<p>Note that all the above statements are true from the point of view of
static type checkers. At runtime, Any should not be used with instance
checks.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Any(metaclass=_AnyMeta):
    &#34;&#34;&#34;Special type indicating an unconstrained type.

    - Any is compatible with every type.
    - Any assumed to have all methods.
    - All values assumed to be instances of Any.

    Note that all the above statements are true from the point of view of
    static type checkers. At runtime, Any should not be used with instance
    checks.
    &#34;&#34;&#34;

    def __new__(cls, *args, **kwargs):
        if cls is Any:
            raise TypeError(&#34;Any cannot be instantiated&#34;)
        return super().__new__(cls)</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.Any"><code class="flex name class">
<span>class <span class="ident">ClassVar</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Special type indicating an unconstrained type.</p>
<ul>
<li>Any is compatible with every type.</li>
<li>Any assumed to have all methods.</li>
<li>All values assumed to be instances of Any.</li>
</ul>
<p>Note that all the above statements are true from the point of view of
static type checkers. At runtime, Any should not be used with instance
checks.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Any(metaclass=_AnyMeta):
    &#34;&#34;&#34;Special type indicating an unconstrained type.

    - Any is compatible with every type.
    - Any assumed to have all methods.
    - All values assumed to be instances of Any.

    Note that all the above statements are true from the point of view of
    static type checkers. At runtime, Any should not be used with instance
    checks.
    &#34;&#34;&#34;

    def __new__(cls, *args, **kwargs):
        if cls is Any:
            raise TypeError(&#34;Any cannot be instantiated&#34;)
        return super().__new__(cls)</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.Any"><code class="flex name class">
<span>class <span class="ident">Collection</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Special type indicating an unconstrained type.</p>
<ul>
<li>Any is compatible with every type.</li>
<li>Any assumed to have all methods.</li>
<li>All values assumed to be instances of Any.</li>
</ul>
<p>Note that all the above statements are true from the point of view of
static type checkers. At runtime, Any should not be used with instance
checks.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Any(metaclass=_AnyMeta):
    &#34;&#34;&#34;Special type indicating an unconstrained type.

    - Any is compatible with every type.
    - Any assumed to have all methods.
    - All values assumed to be instances of Any.

    Note that all the above statements are true from the point of view of
    static type checkers. At runtime, Any should not be used with instance
    checks.
    &#34;&#34;&#34;

    def __new__(cls, *args, **kwargs):
        if cls is Any:
            raise TypeError(&#34;Any cannot be instantiated&#34;)
        return super().__new__(cls)</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.Any"><code class="flex name class">
<span>class <span class="ident">Generator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Special type indicating an unconstrained type.</p>
<ul>
<li>Any is compatible with every type.</li>
<li>Any assumed to have all methods.</li>
<li>All values assumed to be instances of Any.</li>
</ul>
<p>Note that all the above statements are true from the point of view of
static type checkers. At runtime, Any should not be used with instance
checks.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Any(metaclass=_AnyMeta):
    &#34;&#34;&#34;Special type indicating an unconstrained type.

    - Any is compatible with every type.
    - Any assumed to have all methods.
    - All values assumed to be instances of Any.

    Note that all the above statements are true from the point of view of
    static type checkers. At runtime, Any should not be used with instance
    checks.
    &#34;&#34;&#34;

    def __new__(cls, *args, **kwargs):
        if cls is Any:
            raise TypeError(&#34;Any cannot be instantiated&#34;)
        return super().__new__(cls)</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.INF"><code class="flex name class">
<span>class <span class="ident">INF</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A crude object representing infinity, which is greater than anything it is compared to, and
only equal to itself.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/types.py#L189-L265" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class INF(metaclass=Singleton):
    &#34;&#34;&#34;
    A crude object representing infinity, which is greater than anything it is compared to, and
    only equal to itself.
    &#34;&#34;&#34;

    def __lt__(self, _: Any):
        return False

    def __le__(self, _: Any):
        return False

    def __gt__(self, _: Any):
        return True

    def __ge__(self, _: Any):
        return True

    def __eq__(self, other: Any):
        return other is INF

    def __rmul__(self, _: Any):
        return self

    def __radd__(self, _: Any):
        return self

    def __mul__(self, _: Any):
        return self

    def __add__(self, _: Any):
        return self

    def __sub__(self, _: Any):
        return self

    def __div__(self, _: Any):
        return self

    def __mod__(self, _: Any):
        return self

    def __pow__(self, _: Any):
        return self

    def __iadd__(self, _: Any):
        return self

    def __isub__(self, _: Any):
        return self

    def __imul__(self, _: Any):
        return self

    def __imod__(self, _: Any):
        return self

    def __abs__(self):
        return None

    def __repr__(self):
        return &#39;∞&#39;

    def __truediv__(self, _: Any):
        return self

    def __floordiv__(self, _: Any):
        return self

    def __rrshift__(self, _: Any):
        return 0

    def __rlshift__(self, _: Any):
        return 0

    def __format__(self, *_):
        return str(self)</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.Any"><code class="flex name class">
<span>class <span class="ident">isq</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Special type indicating an unconstrained type.</p>
<ul>
<li>Any is compatible with every type.</li>
<li>Any assumed to have all methods.</li>
<li>All values assumed to be instances of Any.</li>
</ul>
<p>Note that all the above statements are true from the point of view of
static type checkers. At runtime, Any should not be used with instance
checks.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Any(metaclass=_AnyMeta):
    &#34;&#34;&#34;Special type indicating an unconstrained type.

    - Any is compatible with every type.
    - Any assumed to have all methods.
    - All values assumed to be instances of Any.

    Note that all the above statements are true from the point of view of
    static type checkers. At runtime, Any should not be used with instance
    checks.
    &#34;&#34;&#34;

    def __new__(cls, *args, **kwargs):
        if cls is Any:
            raise TypeError(&#34;Any cannot be instantiated&#34;)
        return super().__new__(cls)</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.Any"><code class="flex name class">
<span>class <span class="ident">Iterable</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Special type indicating an unconstrained type.</p>
<ul>
<li>Any is compatible with every type.</li>
<li>Any assumed to have all methods.</li>
<li>All values assumed to be instances of Any.</li>
</ul>
<p>Note that all the above statements are true from the point of view of
static type checkers. At runtime, Any should not be used with instance
checks.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Any(metaclass=_AnyMeta):
    &#34;&#34;&#34;Special type indicating an unconstrained type.

    - Any is compatible with every type.
    - Any assumed to have all methods.
    - All values assumed to be instances of Any.

    Note that all the above statements are true from the point of view of
    static type checkers. At runtime, Any should not be used with instance
    checks.
    &#34;&#34;&#34;

    def __new__(cls, *args, **kwargs):
        if cls is Any:
            raise TypeError(&#34;Any cannot be instantiated&#34;)
        return super().__new__(cls)</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.Any"><code class="flex name class">
<span>class <span class="ident">JSON</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Special type indicating an unconstrained type.</p>
<ul>
<li>Any is compatible with every type.</li>
<li>Any assumed to have all methods.</li>
<li>All values assumed to be instances of Any.</li>
</ul>
<p>Note that all the above statements are true from the point of view of
static type checkers. At runtime, Any should not be used with instance
checks.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Any(metaclass=_AnyMeta):
    &#34;&#34;&#34;Special type indicating an unconstrained type.

    - Any is compatible with every type.
    - Any assumed to have all methods.
    - All values assumed to be instances of Any.

    Note that all the above statements are true from the point of view of
    static type checkers. At runtime, Any should not be used with instance
    checks.
    &#34;&#34;&#34;

    def __new__(cls, *args, **kwargs):
        if cls is Any:
            raise TypeError(&#34;Any cannot be instantiated&#34;)
        return super().__new__(cls)</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.Any"><code class="flex name class">
<span>class <span class="ident">JSONDict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Special type indicating an unconstrained type.</p>
<ul>
<li>Any is compatible with every type.</li>
<li>Any assumed to have all methods.</li>
<li>All values assumed to be instances of Any.</li>
</ul>
<p>Note that all the above statements are true from the point of view of
static type checkers. At runtime, Any should not be used with instance
checks.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Any(metaclass=_AnyMeta):
    &#34;&#34;&#34;Special type indicating an unconstrained type.

    - Any is compatible with every type.
    - Any assumed to have all methods.
    - All values assumed to be instances of Any.

    Note that all the above statements are true from the point of view of
    static type checkers. At runtime, Any should not be used with instance
    checks.
    &#34;&#34;&#34;

    def __new__(cls, *args, **kwargs):
        if cls is Any:
            raise TypeError(&#34;Any cannot be instantiated&#34;)
        return super().__new__(cls)</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.RepeatedInteger"><code class="flex name class">
<span>class <span class="ident">RepeatedInteger</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>This class serves as a dual-purpose result for <code><a title="refinery.lib.argformats.numseq" href="argformats.html#refinery.lib.argformats.numseq">numseq()</a></code> types. It
is an integer, but can be infinitely iterated.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/types.py#L288-L297" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RepeatedInteger(int):
    &#34;&#34;&#34;
    This class serves as a dual-purpose result for `refinery.lib.argformats.numseq` types. It
    is an integer, but can be infinitely iterated.
    &#34;&#34;&#34;
    def __iter__(self):
        return self

    def __next__(self):
        return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.int</li>
</ul>
</dd>
<dt id="refinery.lib.types.Any"><code class="flex name class">
<span>class <span class="ident">Self</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Special type indicating an unconstrained type.</p>
<ul>
<li>Any is compatible with every type.</li>
<li>Any assumed to have all methods.</li>
<li>All values assumed to be instances of Any.</li>
</ul>
<p>Note that all the above statements are true from the point of view of
static type checkers. At runtime, Any should not be used with instance
checks.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Any(metaclass=_AnyMeta):
    &#34;&#34;&#34;Special type indicating an unconstrained type.

    - Any is compatible with every type.
    - Any assumed to have all methods.
    - All values assumed to be instances of Any.

    Note that all the above statements are true from the point of view of
    static type checkers. At runtime, Any should not be used with instance
    checks.
    &#34;&#34;&#34;

    def __new__(cls, *args, **kwargs):
        if cls is Any:
            raise TypeError(&#34;Any cannot be instantiated&#34;)
        return super().__new__(cls)</code></pre>
</details>
</dd>
<dt id="refinery.lib.types.Singleton"><code class="flex name class">
<span>class <span class="ident">Singleton</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A metaclass that can be used to define singleton classes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/types.py#L144-L186" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Singleton(type):
    &#34;&#34;&#34;
    A metaclass that can be used to define singleton classes.
    &#34;&#34;&#34;

    def __new__(mcs, name: str, bases: tuple[type, ...], namespace: dict[str, Any]):
        def __new__(cls):
            return cls

        def __getstate__(self):
            return None

        def __setstate__(self, _):
            pass

        def __call__(self, *_):
            return self

        namespace.setdefault(&#39;__call__&#39;, __call__)
        operator_overloads = {}

        for op, method in namespace.items():
            if op[:2] == op[-2:] == &#39;__&#39; and callable(method):
                operator_overloads[op] = method

        if operator_overloads:
            custom_meta_dict = {}
            for method_name, method in operator_overloads.items():
                def make_method(orig_method):
                    def meta_method(cls, *args, **kwargs):
                        return orig_method(cls, *args, **kwargs)
                    return meta_method
                custom_meta_dict[method_name] = make_method(method)
            mcs = type(f&#39;{name}Meta&#39;, (mcs,), custom_meta_dict)

        namespace.update(
            __new__=__new__,
            __slots__=(),
            __getstate__=__getstate__,
            __setstate__=__setstate__,
        )

        return type.__new__(mcs, name, bases, namespace)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>refinery.lib.types.ASTMeta</li>
<li>refinery.lib.types.INFMeta</li>
<li>refinery.lib.types.NoDefaultMeta</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="refinery.lib.types.asbuffer" href="#refinery.lib.types.asbuffer">asbuffer</a></code></li>
<li><code><a title="refinery.lib.types.convert" href="#refinery.lib.types.convert">convert</a></code></li>
<li><code><a title="refinery.lib.types.isbuffer" href="#refinery.lib.types.isbuffer">isbuffer</a></code></li>
<li><code><a title="refinery.lib.types.isstream" href="#refinery.lib.types.isstream">isstream</a></code></li>
<li><code><a title="refinery.lib.types.NamedTuple" href="#refinery.lib.types.NamedTuple">NamedTuple</a></code></li>
<li><code><a title="refinery.lib.types.typename" href="#refinery.lib.types.typename">typename</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.types.AST" href="#refinery.lib.types.AST">AST</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.types.BoundsType" href="#refinery.lib.types.BoundsType">BoundsType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.types.Any" href="#refinery.lib.types.Any">Any</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.types.Any" href="#refinery.lib.types.Any">Any</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.types.Any" href="#refinery.lib.types.Any">Any</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.types.Any" href="#refinery.lib.types.Any">Any</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.types.Any" href="#refinery.lib.types.Any">Any</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.types.INF" href="#refinery.lib.types.INF">INF</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.types.Any" href="#refinery.lib.types.Any">Any</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.types.Any" href="#refinery.lib.types.Any">Any</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.types.Any" href="#refinery.lib.types.Any">Any</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.types.Any" href="#refinery.lib.types.Any">Any</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.types.RepeatedInteger" href="#refinery.lib.types.RepeatedInteger">RepeatedInteger</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.types.Any" href="#refinery.lib.types.Any">Any</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.types.Singleton" href="#refinery.lib.types.Singleton">Singleton</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
