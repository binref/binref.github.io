<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.argformats documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.argformats</code></h1>
</header>
<section id="section-intro">
<h2 id="multibin-syntax">Multibin Syntax</h2>
<p>Many refinery units receive arguments which represent binary data, and usually these arguments can
be given in <strong>multibin</strong> format, which is a special syntax which allows to preprocess data with a
number of <strong>handlers</strong>. For example, the multibin expression <code>md5:password</code> preprocesses the
argument <code>password</code> (which is understood as its UTF8 encoding by default) using the <code>md5</code> handler,
which returns the MD5 hash of the input data. Consequently, the output of</p>
<pre><code>emit md5:password | hex -R
</code></pre>
<p>would be the string <code>5F4DCC3B5AA765D61D8327DEB882CF99</code>. The most important basic handlers to know
are:</p>
<ul>
<li><code>s:string</code> disables all further preprocessing and interprets <code>string</code> as an UTF8 encoded string</li>
<li><code>u:string</code> same, but as an UTF16-LE encoded string</li>
<li><code>h:string</code> assumes that <code>string</code> is a hexadecimal string and returns the decoded byte sequence.</li>
<li>any unit's name can be prefixed to the string, i.e. <code>esc:\n</code> corresponds to the line break character.</li>
</ul>
<p>If a multibin argument does not use any handler, refinery first interprets the string as the path
of an existing file on disk and attempts to return the contents of this file. If this fails, the
UTF8 encoding of the string is returned.</p>
<p>The handlers <code>copy</code> and <code>cut</code> as well as their shortcuts <code>c</code> and <code>x</code> are <strong>final</strong> handlers like
the above example <code>s</code>, i.e. the string that follows <code>copy:</code> will not be interpreted as a multibin
expression. Indeed, <code>copy</code> and <code>cut</code> expect the remaining string to be in Python slice syntax,
where the second part of the slice specifies the length rather than the end of the buffer. For
example, <code>copy:5:4</code> would copy four bytes from the input data at offset 5. When <code>cut</code> us used instead,
these four bytes are also removed from the input data after copying them. All <code>cut</code> operations are
performed in the order in which the arguments are specified on the command line. For example:</p>
<pre><code>emit 1234 | cca x::1 x::1
</code></pre>
<p>will output the string <code>3412</code>.</p>
<p>The modifiers <code>s</code>, <code>u</code>, <code>h</code>, <code>copy</code> (or <code>c</code>), and <code>cut</code> (or <code>x</code>) along with using unit modifiers
should cover most use cases. To learn about other existing modifiers, refer to the rest of this
documentation.</p>
<h2 id="arguments-for-handlers">Arguments For Handlers</h2>
<p>Neither <code><a title="refinery.lib.argformats.DelayedArgument.s" href="#refinery.lib.argformats.DelayedArgument.s">DelayedArgument.s()</a></code>, <code><a title="refinery.lib.argformats.DelayedArgument.u" href="#refinery.lib.argformats.DelayedArgument.u">DelayedArgument.u()</a></code>,
nor <code><a title="refinery.lib.argformats.DelayedArgument.h" href="#refinery.lib.argformats.DelayedArgument.h">DelayedArgument.h()</a></code> require any additional arguments except for the
input string that they are applied to. However, if a refinery unit is used as a handler, there is
an option to add arguments to the handler that will be passed to the unit as command-line
arguments. For example, the following will output the hexadecimal text representation of the MD5
hash of the string "password":</p>
<pre><code>emit md5[-t]:password
</code></pre>
<p>Inside the square brackets that follow the handler name, arguments are separated by commas. This
also means that arguments passed to handlers in this way cannot contain any commas. There is no
escape sequence, but it is possible to use nested multibin expressions to work around this. For
example, the multibin expression <code>q:1%2c2%2c3</code> corresponds to the string <code>1,2,3</code> and the output
of the following command will be <code>2,4,5</code>:</p>
<pre><code>emit repl[q:1%2c2%2c3,2]:1,2,3,4,5
</code></pre>
<p>The first argument to the <code><a title="refinery.repl" href="../index.html#refinery.repl">repl</a></code> unit is the multibin argument <code>q:1%2c2%2c3</code>, which uses
the <code><a title="refinery.lib.argformats.DelayedArgument.q" href="#refinery.lib.argformats.DelayedArgument.q">DelayedArgument.q()</a></code> handler to return <code>1,2,3</code>. The second argument to
this unit-based handler is <code>2</code>, separated from the previous one by a comma. Hence, <code><a title="refinery.repl" href="../index.html#refinery.repl">repl</a></code>
will replace all occurrences of <code>1,2,3</code> in the input with just <code>2</code>.</p>
<p>Some of the more complex non-unit handlers also have optional arguments.</p>
<h2 id="technical-details">Technical Details</h2>
<p>This module implements all argument parser types for the binary refinery. Notable classes for the
command line use are the following:</p>
<ul>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument" href="#refinery.lib.argformats.DelayedBinaryArgument">DelayedBinaryArgument</a></code> (used almost everywhere)</li>
<li><code><a title="refinery.lib.argformats.DelayedNumSeqArgument" href="#refinery.lib.argformats.DelayedNumSeqArgument">DelayedNumSeqArgument</a></code> (used by children of <code><a title="refinery.units.blockwise.ArithmeticUnit" href="../units/blockwise/index.html#refinery.units.blockwise.ArithmeticUnit">ArithmeticUnit</a></code>)</li>
<li><code><a title="refinery.lib.argformats.DelayedRegexpArgument" href="#refinery.lib.argformats.DelayedRegexpArgument">DelayedRegexpArgument</a></code> (used by <code><a title="refinery.rex" href="../index.html#refinery.rex">rex</a></code>, <code><a title="refinery.resub" href="../index.html#refinery.resub">resub</a></code>)</li>
</ul>
<p>All of the above classes inherit from <code><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></code>. The following
mainly applies to <code><a title="refinery.lib.argformats.DelayedBinaryArgument" href="#refinery.lib.argformats.DelayedBinaryArgument">DelayedBinaryArgument</a></code>, but the other two parsers work
similar. The classes implement the various modifiers which are available to multibin expressions.</p>
<p>The reason why these parsers have <strong>"delayed"</strong> in their name is that they allow the implementation
of handlers which require input data to be present, like the handlers <code>copy</code> and <code>cut</code>, which are
implemented in <code><a title="refinery.lib.argformats.DelayedBinaryArgument.copy" href="#refinery.lib.argformats.DelayedArgument.copy">DelayedArgument.copy()</a></code> and
<code><a title="refinery.lib.argformats.DelayedBinaryArgument.cut" href="#refinery.lib.argformats.DelayedArgument.cut">DelayedArgument.cut()</a></code>, respectively. These expressions can not be
evaluated immediately after the command line is parsed, but only as soon as input data becomes
available for processing.</p>
<p>As explained above, each refinery unit defines a (non-final) modifier. The expression <code>b64:Zm9v</code>,
for example, corresponds to the binary string <code>foo</code> - the unit <code><a title="refinery.b64" href="../index.html#refinery.b64">b64</a></code> is used to decode the
string <code>Zm9v</code> to <code>foo</code>. Arguments can be passed to units in square brackets and separated by commas,
but there is no support for escaping comma characters (see the previous section for more details).</p>
<h2 id="examples">Examples</h2>
<ol>
<li>The multibin expression <code>xor[0xAA]:b64:2c/J2M/e</code> will return the binary string <code>secret</code>; the
string <code>2c/J2M/e</code> is base64-decoded using <code><a title="refinery.b64" href="../index.html#refinery.b64">b64</a></code> and then each byte is xor'ed with the
key <code>0xAA</code> by the unit <code><a title="refinery.xor" href="../index.html#refinery.xor">xor</a></code>.</li>
<li>The expression <code>hex[-R]:sha256:read:foobar.txt</code> is the hexadecimal representation of the SHA256
hash of the contents of the file <code>foobar.txt</code> on disk.</li>
</ol>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1-L1862" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
## Multibin Syntax

Many refinery units receive arguments which represent binary data, and usually these arguments can
be given in **multibin** format, which is a special syntax which allows to preprocess data with a
number of **handlers**. For example, the multibin expression `md5:password` preprocesses the
argument `password` (which is understood as its UTF8 encoding by default) using the `md5` handler,
which returns the MD5 hash of the input data. Consequently, the output of

    emit md5:password | hex -R

would be the string `5F4DCC3B5AA765D61D8327DEB882CF99`. The most important basic handlers to know
are:

- `s:string` disables all further preprocessing and interprets `string` as an UTF8 encoded string
- `u:string` same, but as an UTF16-LE encoded string
- `h:string` assumes that `string` is a hexadecimal string and returns the decoded byte sequence.
- any unit&#39;s name can be prefixed to the string, i.e. `esc:\\n` corresponds to the line break character.

If a multibin argument does not use any handler, refinery first interprets the string as the path
of an existing file on disk and attempts to return the contents of this file. If this fails, the
UTF8 encoding of the string is returned.

The handlers `copy` and `cut` as well as their shortcuts `c` and `x` are **final** handlers like
the above example `s`, i.e. the string that follows `copy:` will not be interpreted as a multibin
expression. Indeed, `copy` and `cut` expect the remaining string to be in Python slice syntax,
where the second part of the slice specifies the length rather than the end of the buffer. For
example, `copy:5:4` would copy four bytes from the input data at offset 5. When `cut` us used instead,
these four bytes are also removed from the input data after copying them. All `cut` operations are
performed in the order in which the arguments are specified on the command line. For example:
```
emit 1234 | cca x::1 x::1
```
will output the string `3412`.

The modifiers `s`, `u`, `h`, `copy` (or `c`), and `cut` (or `x`) along with using unit modifiers
should cover most use cases. To learn about other existing modifiers, refer to the rest of this
documentation.

## Arguments For Handlers

Neither `refinery.lib.argformats.DelayedArgument.s`, `refinery.lib.argformats.DelayedArgument.u`,
nor `refinery.lib.argformats.DelayedArgument.h` require any additional arguments except for the
input string that they are applied to. However, if a refinery unit is used as a handler, there is
an option to add arguments to the handler that will be passed to the unit as command-line
arguments. For example, the following will output the hexadecimal text representation of the MD5
hash of the string &#34;password&#34;:

    emit md5[-t]:password

Inside the square brackets that follow the handler name, arguments are separated by commas. This
also means that arguments passed to handlers in this way cannot contain any commas. There is no
escape sequence, but it is possible to use nested multibin expressions to work around this. For
example, the multibin expression `q:1%2c2%2c3` corresponds to the string `1,2,3` and the output
of the following command will be `2,4,5`:

    emit repl[q:1%2c2%2c3,2]:1,2,3,4,5

The first argument to the `refinery.repl` unit is the multibin argument `q:1%2c2%2c3`, which uses
the `refinery.lib.argformats.DelayedArgument.q` handler to return `1,2,3`. The second argument to
this unit-based handler is `2`, separated from the previous one by a comma. Hence, `refinery.repl`
will replace all occurrences of `1,2,3` in the input with just `2`.

Some of the more complex non-unit handlers also have optional arguments.

## Technical Details

This module implements all argument parser types for the binary refinery. Notable classes for the
command line use are the following:

- `refinery.lib.argformats.DelayedBinaryArgument` (used almost everywhere)
- `refinery.lib.argformats.DelayedNumSeqArgument` (used by children of `refinery.units.blockwise.ArithmeticUnit`)
- `refinery.lib.argformats.DelayedRegexpArgument` (used by `refinery.rex`, `refinery.resub`)

All of the above classes inherit from `refinery.lib.argformats.DelayedArgument`. The following
mainly applies to `refinery.lib.argformats.DelayedBinaryArgument`, but the other two parsers work
similar. The classes implement the various modifiers which are available to multibin expressions.

The reason why these parsers have **&#34;delayed&#34;** in their name is that they allow the implementation
of handlers which require input data to be present, like the handlers `copy` and `cut`, which are
implemented in `refinery.lib.argformats.DelayedBinaryArgument.copy` and
`refinery.lib.argformats.DelayedBinaryArgument.cut`, respectively. These expressions can not be
evaluated immediately after the command line is parsed, but only as soon as input data becomes
available for processing.

As explained above, each refinery unit defines a (non-final) modifier. The expression `b64:Zm9v`,
for example, corresponds to the binary string `foo` - the unit `refinery.b64` is used to decode the
string `Zm9v` to `foo`. Arguments can be passed to units in square brackets and separated by commas,
but there is no support for escaping comma characters (see the previous section for more details).

## Examples

1. The multibin expression `xor[0xAA]:b64:2c/J2M/e` will return the binary string `secret`; the
   string `2c/J2M/e` is base64-decoded using `refinery.b64` and then each byte is xor&#39;ed with the
   key `0xAA` by the unit `refinery.xor`.
2. The expression `hex[-R]:sha256:read:foobar.txt` is the hexadecimal representation of the SHA256
   hash of the contents of the file `foobar.txt` on disk.
&#34;&#34;&#34;
from __future__ import annotations

import ast
import builtins
import codecs
import inspect
import itertools
import re

from abc import ABC, abstractmethod
from argparse import ArgumentTypeError
from contextlib import suppress
from functools import lru_cache, reduce, update_wrapper
from pathlib import Path
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Deque,
    Iterable,
    Mapping,
    TypeVar,
    Union,
    overload,
)

from refinery.lib.annotations import get_type_hints
from refinery.lib.frame import Chunk
from refinery.lib.meta import Percentage, is_valid_variable_name, metavars
from refinery.lib.patterns import formats
from refinery.lib.tools import (
    exception_to_string,
    infinitize,
    normalize_to_identifier,
    one,
)
from refinery.lib.types import RepeatedInteger, bounds, buf, isbuffer

if TYPE_CHECKING:
    from refinery import Unit

FinalType = TypeVar(&#39;FinalType&#39;)
DelayedType = Callable[[buf], FinalType]
MaybeDelayedType = Union[DelayedType[FinalType], FinalType]

_DEFAULT_BITS = 64
_REVERSE_SIGN = &#39;!&#39;


class ParserError(ArgumentTypeError):
    &#34;&#34;&#34;
    An exception raised by the `refinery.lib.argformats.PythonExpression` parser.
    &#34;&#34;&#34;


class ParserVariableMissing(ParserError):
    &#34;&#34;&#34;
    Raised when the `refinery.lib.argformats.PythonExpression` parser fails to evaluate an
    expression because of a missing variable.
    &#34;&#34;&#34;


class LazyEvaluation:
    &#34;&#34;&#34;
    Empty parent class for any parse result that throws `refinery.lib.argformats.TooLazy`.
    &#34;&#34;&#34;


class PythonExpression:
    &#34;&#34;&#34;
    Implements a parser for any Python expression with a prescribed set of variable names permitted
    to occur in the expression. The resulting object is a callable which can be given the string
    representation of such an expression. In turn, the result of this operation is either the value
    of the expression if no variables were present, or a callable which expects keyword arguments
    corresponding to the permitted variable names.
    &#34;&#34;&#34;
    def __init__(self, definition: str | buf, *variables, constants=None, all_variables_allowed=False, modulus=None, mask=-1):
        if not isinstance(definition, str):
            definition = codecs.decode(definition, &#39;utf8&#39;)
        self.definition = definition = definition.strip()
        constants = constants or {}
        variables = set(variables) | set(constants)
        try:
            expression = ast.parse(definition, mode=&#39;eval&#39;)
        except Exception as error:
            raise ParserError(F&#39;The provided expression could not be parsed: {definition!s}; {exception_to_string(error)}&#39;)

        if mask &gt; 0 and modulus is not None:
            raise ValueError(&#39;Cannot specify both modulus and mask.&#39;)

        class Postprocessor(ast.NodeTransformer):
            def visit_Constant(self, node: ast.Constant):
                if not isinstance(node.value, str):
                    return node
                return ast.Constant(value=node.value.encode(&#39;utf8&#39;))

            def visit_MatMult(self, node: ast.MatMult) -&gt; Any:
                return ast.BitXor()

            def visit_BinOp(self, node: ast.BinOp) -&gt; Any:
                self.generic_visit(node)
                if not isinstance(node.op, (ast.Add, ast.Mult, ast.Sub, ast.LShift, ast.Pow)):
                    return node
                if modulus is not None:
                    return ast.BinOp(node, ast.Mod(), ast.Constant(modulus))
                elif mask &gt; 0:
                    return ast.BinOp(node, ast.BitAnd(), ast.Constant(mask))
                else:
                    return node

            def visit_UnaryOp(self, node: ast.UnaryOp) -&gt; Any:
                self.generic_visit(node)
                if not isinstance(node.op, (ast.UAdd, ast.USub, ast.Invert)):
                    return node
                if modulus is not None:
                    return ast.BinOp(node, ast.Mod(), ast.Constant(modulus))
                elif mask &gt; 0:
                    return ast.BinOp(node, ast.BitAnd(), ast.Constant(mask))
                else:
                    return node

        expression = ast.fix_missing_locations(Postprocessor().visit(expression))
        nodes = ast.walk(expression)

        try:
            if type(next(nodes)) != ast.Expression:
                raise ParserError(F&#39;Unknown error parsing the expression: {definition!s}&#39;)
        except StopIteration:
            raise ParserError(&#39;The input string is not a Python expression.&#39;)

        names = {node for node in nodes if isinstance(node, ast.Name)}
        names = {node.id for node in names} - {node.id for node in names if isinstance(node.ctx, ast.Store)}
        names.difference_update(dir(builtins))
        names.difference_update(globals())
        if not all_variables_allowed and not names &lt;= variables:
            raise ParserVariableMissing(
                &#39;the following variable names are unknown: {}&#39;.format(&#39;, &#39;.join(names - variables)))

        self.variables = names
        self.constants = constants
        self.expression = compile(expression, &#39;&lt;string&gt;&#39;, &#39;eval&#39;)

    def __str__(self):
        return self.definition

    def __call__(self, mapping: dict | None = None, **values):
        if mapping is not None:
            values, tmp = mapping, values
            values.update(tmp)
        variables = dict(values)
        for v in self.variables.difference(variables):
            try:
                variables[v] = values[v]
            except KeyError:
                raise ParserVariableMissing(v)
        variables.update(self.constants)
        return eval(self.expression, None, variables)

    @classmethod
    def Lazy(cls, definition: str):
        return cls(definition, all_variables_allowed=True)

    @classmethod
    def Evaluate(cls, definition: str, values: dict):
        &#34;&#34;&#34;
        Creates a new `refinery.lib.argformats.PythonExpression` object based on `definition` and
        evaluates it based on the variable mapping `values`. If a variable used in the expression
        is missing, a `refinery.lib.argformats.ParserVariableMissing` exception is raised.
        &#34;&#34;&#34;
        expression = cls(definition, all_variables_allowed=True)
        for name in expression.variables:
            if name not in values:
                raise ParserVariableMissing(name)
        return expression(values)


class SliceAgain(LazyEvaluation):
    &#34;&#34;&#34;
    Raised by `refinery.lib.argformats.sliceobj` to indicate that meta variables are required to
    compute this slice.
    &#34;&#34;&#34;
    def __init__(self, expr: DelayedBinaryArgument | str, intok: bool = False):
        self.expr = expr
        self.intok = intok

    def __call__(self, data):
        expression = self.expr
        if pending(expression):
            expression = expression(data).decode(&#39;utf8&#39;)
        return sliceobj(expression, data, intok=self.intok)


def percent(expression: str):
    &#34;&#34;&#34;
    Allows specification of percentages.
    &#34;&#34;&#34;
    if expression.endswith(&#39;%&#39;):
        return float(expression[:-1].strip()) / 100
    return float(expression)


@overload
def relslice(expression: int | str | slice, data: Chunk) -&gt; slice:
    ...


@overload
def relslice(expression: int | str | slice) -&gt; slice | SliceAgain:
    ...


def relslice(expression: int | str | slice, data: Chunk | None = None) -&gt; slice | SliceAgain:
    &#34;&#34;&#34;
    Uses `refinery.lib.argformats.sliceobj` to parse a slice from the input, but
    interprets the second part of the slice as a relative length (which can also
    be negative).
    &#34;&#34;&#34;
    s = sliceobj(expression, data)
    if isinstance(s, slice) and (stop := s.stop) is not None:
        start = s.start or 0
        stop += start
        if (step := s.step) is None and stop &lt; start:
            step = -1
        s = slice(start, stop, step)
    return s


@overload
def sliceobj(
    expression: int | str | slice,
    data: Chunk,
    intok: bool = False,
    final: bool = False,
) -&gt; slice | int:
    ...


@overload
def sliceobj(
    expression: int | str | slice,
    data: Chunk | None = None,
    intok: bool = False,
    final: bool = False,
) -&gt; slice | int | SliceAgain:
    ...


def sliceobj(
    expression: int | str | slice,
    data: Chunk | None = None,
    intok: bool = False,
    final: bool = False,
) -&gt; slice | int | SliceAgain:
    &#34;&#34;&#34;
    Uses `refinery.lib.argformats.PythonExpression` to parse slice expressions
    where the bounds can be given as arithmetic expressions. For example, this
    argument format type will process the string `0x11:0x11+4*0x34` as the slice
    object `slice(17, 225, None)`.
    &#34;&#34;&#34;
    if isinstance(expression, (slice, SliceAgain)):
        return expression
    if isinstance(expression, int):
        if intok:
            return expression
        return slice(expression, expression + 1, 1)
    if isinstance(expression, (bytes, bytearray)):
        expression = expression.decode(&#39;utf8&#39;)

    if data is None:
        variables = {}
    else:
        variables = metavars(data)
        if is_valid_variable_name(expression):
            try:
                return sliceobj(variables[expression], data, intok=intok, final=True)
            except Exception:
                pass

    sliced = expression and expression.split(&#39;:&#39;) or [&#39;&#39;, &#39;&#39;]

    if not sliced or len(sliced) &gt; 3:
        raise ArgumentTypeError(F&#39;The expression &#34;{expression}&#34; is not a valid slice.&#39;)
    try:
        sliced = [None if not t else LazyPythonExpression(t, variables) for t in sliced]
    except ParserVariableMissing:
        if final:
            raise
        elif data is not None:
            parser = DelayedNumSeqArgument(expression)
            return sliceobj(parser(data), data, intok=intok, final=True)
        else:
            return SliceAgain(expression, intok)
    if len(sliced) == 1:
        k = sliced[0]
        if intok:
            return k
        return slice(k, k + 1) if k + 1 else slice(k, None, None)
    for k, item in enumerate(sliced):
        if item is None:
            continue
        if isinstance(item, int):
            continue
        if isbuffer(item) and len(item) in (1, 2, 4, 8, 16):
            sliced[k] = int.from_bytes(item, &#39;little&#39;)
            continue
        raise TypeError(F&#39;The value {item!r} of type {type(item).__name__} cannot be used as a slice index.&#39;)
    return slice(*sliced)


def utf8(x: str):
    &#34;&#34;&#34;
    Returns the UTF8 encoding of the given string.
    &#34;&#34;&#34;
    return x.encode(&#39;UTF8&#39;)


class IncompatibleHandler(ArgumentTypeError):
    &#34;&#34;&#34;
    This exception is generated when `refinery.lib.argformats.DelayedArgument` handlers
    are chained in an incompatible way.
    &#34;&#34;&#34;
    def __init__(self, type_expected, type_observed, modifier):
        self.type_expected = type_expected
        self.type_observed = type_observed
        self.modifier = modifier
        modifier_name = F&#39;handler {modifier}&#39; if modifier else &#39;default handler&#39;
        super().__init__(&#39;{} received {} but expected {}&#39;.format(
            modifier_name,
            type_observed.__name__,
            type_expected.__name__
        ))


class TooLazy(Exception):
    &#34;&#34;&#34;
    Exception which indicates that an argument parser requires input data before it can be
    evaluated.
    &#34;&#34;&#34;


class VariableMissing(ArgumentTypeError):
    &#34;&#34;&#34;
    Exception which indicates that a `refinery.lib.meta` variable was missing during evaluation
    of a Python expression.
    &#34;&#34;&#34;
    def __init__(self, name):
        super().__init__(F&#39;The variable {name} is not defined.&#39;)
        self.name = name


class DelayedArgumentDispatch:
    &#34;&#34;&#34;
    This class is used as a decorator for the default handler of classes that inherit from
    `refinery.lib.argformats.DelayedArgument`. After decorating the routine `handler` with
    `refinery.lib.argformats.DelayedArgumentDispatch`, `handler.register` can be used to
    register additional handlers.
    &#34;&#34;&#34;
    class Wrapper:
        def can_handle(self, *a):
            return self.ego.can_handle(*a)

        def terminates(self, *a):
            return self.ego.terminates(*a)

        def __init__(self, ego: DelayedArgumentDispatch, arg):
            self.ego = ego
            self.arg = arg

        def __call__(self, *args, **kwargs):
            return self.ego(self.arg, *args, **kwargs)

        def __getattr__(self, key):
            return getattr(self.ego, key)

    @classmethod
    def Inherit(cls, parent: DelayedArgument):
        def wrap(method):
            dispatcher = cls(method)
            parent_dispatcher = parent.handler
            dispatcher.handlers.update(parent_dispatcher.handlers)
            dispatcher.final.update(parent_dispatcher.final)
            dispatcher.units = parent_dispatcher.units
            return dispatcher
        return wrap

    def __init__(self, method):
        update_wrapper(self, method)
        self.default = method
        self.handlers = {}
        self.final = {}
        self.units = {}

    def _get_unit(self, name: str, *args) -&gt; Unit | None:
        empty, rev, name = normalize_to_identifier(name).rpartition(_REVERSE_SIGN)
        if empty:
            return None
        uhash = hash((name,) + args)
        if uhash in self.units:
            return self.units[uhash]
        from refinery import load
        unit = load(name)
        unit = unit and unit.assemble(*args).log_detach()
        if rev == _REVERSE_SIGN:
            unit = -unit
        self.units[uhash] = unit
        return unit

    def __get__(self, instance, t=None):
        return self.Wrapper(self, instance)

    def __call__(self, instance: DelayedArgument, data, modifier=None, *args):
        try:
            handler = self.default if modifier is None else self.handlers[modifier]
        except KeyError:
            unit = self._get_unit(modifier, *args)
            if not unit:
                raise ArgumentTypeError(F&#39;failed to build unit {modifier}&#39;)
            result = list(unit.act(data))
            if not result:
                return B&#39;&#39;
            return B&#39;&#39;.join(result) if len(result) &gt; 1 else result[0]
        else:
            name = next(itertools.islice(inspect.signature(handler).parameters.values(), 1, None)).name
            hint = get_type_hints(handler).get(name, None)
            if hint == Iterable[type(data)]:
                data = (data,)
            if hint == str and isbuffer(data):
                if not isinstance(data, (bytes, bytearray)):
                    data = bytes(data)
                data = data.decode(&#39;utf8&#39;)
            return handler(instance, data, *args)

    def can_handle(self, modifier, *args):
        return modifier in self.handlers or bool(self._get_unit(modifier, *args))

    def terminates(self, modifier):
        &#34;&#34;&#34;
        Indicates whether the given registered modifier is final.
        &#34;&#34;&#34;
        return self.final.get(modifier, False)

    def register(self, *modifiers, final=False):
        &#34;&#34;&#34;
        Registers a new modifier handler.
        &#34;&#34;&#34;
        def _register(method):
            for modifier in modifiers:
                self.handlers[modifier] = method
                self.final[modifier] = final
            return method
        return _register


def LazyPythonExpression(expression: str, variables: dict | None = None) -&gt; MaybeDelayedType[Any]:
    &#34;&#34;&#34;
    Wraps the given expression for use as a `refinery.lib.argformats.multibin` expression. If it
    contains no variables, the expression is evaluated immediately, otherwise the function returns
    a callable that will evaluate the given expression on an incoming `refinery.lib.frame.Chunk`.
    &#34;&#34;&#34;
    expression = expression.strip()
    if match := re.fullmatch(R&#39;([1-9][0-9]?)%&#39;, expression):
        return Percentage(int(match[1]) / 100)
    if match := re.fullmatch(RF&#39;&#39;&#39;(?ix)
        (?: (?P&lt;flt&gt;{formats.float!s})
          | (?P&lt;int&gt;{formats.integer!s})
        ) (?P&lt;unit&gt;[KMGTPE]i?B?)
    &#39;&#39;&#39;, expression):
        unit = match[&#39;unit&#39;].upper()
        step = &#39;KMGTPE&#39;.index(unit[0]) + 1
        kilo = 1024 if &#39;I&#39; in unit else 1000
        if n := match[&#39;flt&#39;]:
            base = float(n)
        if n := match[&#39;int&#39;]:
            base = int(n, 0)
        return int(base * (kilo ** step))
    if variables is not None:
        return PythonExpression.Evaluate(expression, variables)
    if (parser := PythonExpression.Lazy(expression)).variables:
        def evaluate(data: Chunk):
            try:
                result = parser(metavars(data))
            except ParserVariableMissing:
                # It is possible that a byte string can accidentally look like a valid Python
                # expression, e.g.: B0fGtH*9/HKlwT:
                definition = parser.definition
                if isinstance(definition, str):
                    definition = definition.encode(&#39;utf8&#39;)
                return definition
            else:
                return result
        return evaluate
    else:
        return parser()


class DelayedArgument(LazyEvaluation):
    &#34;&#34;&#34;
    This base class for delayed argument parsers implements parsing expressions into supported modifiers.
    When `reverse` is set to `True`, the multibin expression is expected to have suffixes for handlers
    rather than prefixes. If the `seed` value is specified, the expression is expected to only contain
    a chain of handlers, and the given seed will be used as the initial value to be passed to them.
    &#34;&#34;&#34;
    _ARG_BEGIN_TOKEN = &#39;[&#39;
    _ARG_CLOSE_TOKEN = &#39;]&#39;
    _ARG_SPLIT_TOKEN = &#39;,&#39;
    _CMD_SPLIT_TOKEN = &#39;:&#39;

    def __init__(self, expression: str, reverse: bool = False, seed=None):
        requires_seed = seed is None
        self.expression = expression
        self.modifiers = []
        self.finalized = False
        while not self.finalized:
            name, arguments, newexpr = self._split_modifier(
                expression,
                reverse,
                requires_seed,
            )
            if not name or not self.handler.can_handle(name, *arguments):
                break
            self.modifiers.append((name, arguments))
            expression = newexpr
            if self.handler.terminates(name):
                self.finalized = True
        if self.finalized:
            if not expression and seed is not None:
                expression = seed
            self.seed = expression
        elif not requires_seed:
            if expression:
                rt = &#39;reverse &#39; if reverse else &#39;&#39;
                raise ValueError(F&#39;{rt}expression {self.expression} with seed {seed} was not fully parsed.&#39;)
            self.seed = seed
        else:
            self.seed = expression
        self.modifiers.reverse()

    def _split_expression(self, expression: str, reverse: bool = False) -&gt; tuple[str, str | None]:
        argument_list_visited = False
        brackets = 0
        inc = self._ARG_BEGIN_TOKEN
        dec = self._ARG_CLOSE_TOKEN
        itx = enumerate(expression)
        if reverse:
            inc, dec = dec, inc
            itx = reversed(list(itx))
        for k, character in itx:
            if character == inc:
                if not brackets:
                    if argument_list_visited:
                        # This is the second time we encounter what appears to be an
                        # argument list, before the modifier has ended. This is not
                        # possible, and we decide to assume that no modifier was used.
                        break
                    argument_list_visited = True
                brackets += 1
                continue
            if character == dec:
                if not brackets:
                    break
                brackets -= 1
                continue
            if not brackets and character == self._CMD_SPLIT_TOKEN:
                head = expression[:k]
                tail = expression[k + 1:]
                return (head, tail) if reverse else (tail, head)
        return expression, None

    def _split_modifier(
        self,
        sequence: str,
        reverse: bool = False,
        requires_seed: bool = True,
    ) -&gt; tuple[str | None, tuple[str, ...], str]:
        brackets = 0
        name = None
        argoffset = 0
        arguments = ()

        rest, expression = self._split_expression(sequence, reverse)

        if expression is None:
            if requires_seed:
                return name, arguments, rest
            expression, rest = rest, &#39;&#39;

        name = expression

        for k, character in enumerate(expression):
            if character == self._ARG_BEGIN_TOKEN:
                if not brackets:
                    if argoffset:
                        raise ArgumentTypeError(F&#39;Unexpected error parsing &#34;{expression}&#34;: Double argument list.&#39;)
                    name = expression[:k]
                    argoffset = k + 1
                brackets += 1
                continue
            if character == self._ARG_CLOSE_TOKEN:
                if brackets == 1:
                    arguments += expression[argoffset:k],
                elif not brackets:
                    if argoffset:
                        raise ArgumentTypeError(F&#39;Unable to parse &#34;{expression}&#34;: Too many closing brackets.&#39;)
                    else:
                        break
                brackets -= 1
                continue
            if character == self._ARG_SPLIT_TOKEN:
                if brackets == 1:
                    arguments += expression[argoffset:k],
                    argoffset = k + 1
            if character == self._CMD_SPLIT_TOKEN and not brackets:
                raise ArgumentTypeError(F&#39;Unexpected error parsing &#34;{expression}&#34;.&#39;)
        return name, arguments, rest

    def __call__(self, data: buf | None = None) -&gt; bytes:
        arg = self.seed
        mod = iter(self.modifiers)
        if not self.finalized:
            mod = itertools.chain(((None, ()),), mod)
        for name, arguments in mod:
            if isbuffer(arg):
                arg = Chunk(arg)
                with suppress(AttributeError):
                    arg.meta.update(data.meta)
            try:
                arg = self.handler(arg, name, *arguments)
            except VariableMissing as v:
                if data is not None:
                    raise
                raise TooLazy from v
            except AttributeError as AE:
                raise ArgumentTypeError(F&#39;failed to apply modifier {name} to incoming data: {AE}&#39;) from AE
            if callable(arg):
                if data is None:
                    raise TooLazy
                arg = arg(data)
        return arg

    def __eq__(self, other):
        if isinstance(other, DelayedArgument):
            return other.expression == self.expression
        try:
            # Try to realize on a completely empty chunk of data. If the result equals the
            # other object, we are likely identical and we were too cautious when delaying.
            value = self(B&#39;&#39;)
        except Exception:
            return False
        else:
            return value == other

    def default_handler(self, expression: str) -&gt; bytes:
        try:
            return open(expression, &#39;rb&#39;).read()
        except Exception:
            pass
        try:
            return utf8(expression)
        except Exception:
            return expression

    @DelayedArgumentDispatch
    def handler(self, expression) -&gt; bytes:
        return self.default_handler(expression)

    @handler.register(&#39;s&#39;, &#39;S&#39;, final=True)
    def s(self, string: str) -&gt; bytes:
        &#34;&#34;&#34;
        The final modifier `s:string` returns the UTF-8 encoded representation of `string`.
        &#34;&#34;&#34;
        return string.encode(&#39;UTF8&#39;)

    @handler.register(&#39;u&#39;, &#39;U&#39;, final=True)
    def u(self, string: str) -&gt; bytes:
        &#34;&#34;&#34;
        The final modifier `u:string` returns the UTF16 (little endian without BOM) encoded
        representation of `string`.
        &#34;&#34;&#34;
        return string.encode(&#39;UTF-16LE&#39;)

    @handler.register(&#39;a&#39;, &#39;A&#39;, final=True)
    def a(self, string: str) -&gt; bytes:
        &#34;&#34;&#34;
        The final modifier `a:string` returns the latin-1 encoded representation of `string`.
        &#34;&#34;&#34;
        return string.encode(&#39;LATIN-1&#39;)

    @handler.register(F&#39;{_REVERSE_SIGN}h&#39;, F&#39;{_REVERSE_SIGN}H&#39;)
    def bang_h(self, string: bytes) -&gt; bytes:
        F&#34;&#34;&#34;
        The modifier `{_REVERSE_SIGN}h` (or `{_REVERSE_SIGN}H`) encodes the input as hexadecimal.
        &#34;&#34;&#34;
        import base64
        return base64.b16encode(string)

    @handler.register(&#39;h&#39;, &#39;H&#39;, final=True)
    def h(self, string: str) -&gt; bytes:
        &#34;&#34;&#34;
        The final modifier `h:string` (or `H:string`) returns the hex decoding of `string`.
        &#34;&#34;&#34;
        import base64
        return base64.b16decode(string, casefold=True)

    @handler.register(&#39;n&#39;)
    def n(self, string: bytes) -&gt; bytes:
        &#34;&#34;&#34;
        The final modifier `n:string` returns the un-escaped version of a string containing
        backslash escape sequences.
        &#34;&#34;&#34;
        from refinery.units.encoding.esc import esc
        return esc().process(string)

    @handler.register(F&#39;{_REVERSE_SIGN}n&#39;)
    def bang_n(self, string: bytes) -&gt; bytes:
        F&#34;&#34;&#34;
        The modifier `{_REVERSE_SIGN}n:string` returns an escaped and quoted version of the
        input string.
        &#34;&#34;&#34;
        from refinery.units.encoding.esc import esc
        return esc(quoted=True).reverse(string)

    @handler.register(&#39;q&#39;, &#39;Q&#39;, final=True)
    def q(self, string: str) -&gt; bytes:
        &#34;&#34;&#34;
        The final modifier `q:string` (or `Q:string`) returns the url-quote decoding of `string`.
        &#34;&#34;&#34;
        import urllib.parse
        return urllib.parse.unquote_to_bytes(string)

    @handler.register(&#39;read&#39;, final=True)
    def read(self, path: str, region: str = &#39;&#39;) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the contents of the file located at the given path. This path may contain
        wildcard characters, but this pattern has to match a single file. It is also possible
        to use the handler as `read[count]` or as `read[offset:count]` to read `count` many
        bytes from the file at the given offset.
        &#34;&#34;&#34;
        return self._file(path, region)

    @handler.register(&#39;readfrom&#39;)
    def readfrom(self, path: bytes, region: str = &#39;&#39;) -&gt; bytes:
        &#34;&#34;&#34;
        A non-final variant of the `refinery.lib.argformats.DelayedArgument.read` handler. This
        handler should only be used to read from path names that were the result of a previous
        handler. Using `readfrom:sample.bin` will cause an error: Since `readfrom` is not final,
        the default handler will be applied to `sample.bin`, feeding the binary contents of the
        file into `readfrom`, but the handler is expecting a path name.
        &#34;&#34;&#34;
        try:
            path = path.decode(&#39;utf8&#39;)
        except UnicodeDecodeError:
            raise ArgumentTypeError(
                &#39;The input for the readfrom handler was not a path. Consider using the read &#39;
                &#39;handler instead, which is final.&#39;)
        else:
            return self._file(path, region)

    def _file(self, pattern: str, region: str) -&gt; bytes | None:
        def read(data: Chunk | None = None):
            if not region:
                k = slice(0, None)
            else:
                k = sliceobj(region, data, intok=True)
            if isinstance(k, SliceAgain):
                raise TooLazy
            if isinstance(k, int):
                offset = 0
                length = k
            else:
                if k.step and k.step != 1:
                    raise ValueError(&#39;Step size is not supported for file slices.&#39;)
                offset = k.start or 0
                length = k.stop
            if length and length &lt; 0:
                raise ValueError(&#39;The count for a read operation must be non-negative.&#39;)
            with open(path, &#39;rb&#39;) as stream:
                stream.seek(offset)
                return stream.read(length)
        try:
            path: Path = one(Path.cwd().glob(pattern))
        except (NotImplementedError, LookupError):
            path: Path = Path(pattern)
        try:
            return read()
        except FileNotFoundError:
            raise ArgumentTypeError(F&#39;File not found: {pattern}&#39;)
        except Exception:
            return read

    @handler.register(&#39;range&#39;, final=True)
    def range(self, region: str) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        Implements the final modifier `range:bounds` to generate a sequence of bytes, where
        `bounds` is parsed as a `refinery.lib.argformats.sliceobj` with one exception: If
        `bounds` is just a single integer, it is interpreted as the upper bound for a sequence
        of bytes starting at zero.
        &#34;&#34;&#34;
        def compute_range(data: Chunk | None = None):
            try:
                s = sliceobj(region, data, intok=True)
            except ParserVariableMissing:
                raise TooLazy
            if isinstance(s, SliceAgain):
                raise TooLazy
            if isinstance(s, int):
                s = slice(None, s, None)
            result = bounds[s]
            result.max -= 1
            if 0 &lt;= result.min and result.max &lt;= 0x100:
                result = bytearray(result)
            return result
        try:
            return compute_range()
        except TooLazy:
            return compute_range

    @handler.register(&#39;env&#39;, final=True)
    def env(self, name: str) -&gt; bytes:
        &#34;&#34;&#34;
        The final modifier `env:name` returns the UTF8-encoded value of the environment variable
        with the given name.
        &#34;&#34;&#34;
        import os
        return os.environ[name]

    @handler.register(&#39;pos&#39;)
    def pos(self, regex: buf, occurrence: int = 0) -&gt; int:
        &#34;&#34;&#34;
        The handler pos[k=0]:[regex] returns the position of the k-th occurrence of the regular
        expression [regex]. The value `k` can be set to `-1` to return the position of the last
        match. If `k` is a negative value, then the handler returns the offset at the end of the
        match rather than the one at the beginning. If no match is found, the handler returns
        the value `-1`.
        &#34;&#34;&#34;
        if isinstance(occurrence, str):
            occurrence = int(occurrence, 0)

        def _pos(data: bytearray) -&gt; int:
            it: Iterable[re.Match] = re.finditer(bytes(regex), data, flags=re.DOTALL)

            if occurrence &lt; 0:
                from collections import deque
                matches: Deque[re.Match] = deque()
                while len(matches) &lt; -occurrence:
                    try:
                        matches.append(next(it))
                    except StopIteration:
                        return -1
                for match in it:
                    matches.append(match)
                    matches.popleft()
                return matches[0].end()
            else:
                for k, match in enumerate(it):
                    if k == occurrence:
                        return match.start()
                else:
                    return -1

        return _pos

    @handler.register(&#39;rx&#39;)
    def rx(self, string: bytes) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `rx:str` returns a regular expression which matches the exact string
        sequence given by `str`, with special regular expression control characters escaped.
        &#34;&#34;&#34;
        return re.escape(string)

    @handler.register(&#39;c&#39;, &#39;copy&#39;, final=True)
    def copy(self, region: str) -&gt; bytes:
        &#34;&#34;&#34;
        Implements the final modifier `copy:start[:length[:step]]`. It copies `length` bytes
        from the input using step size `step` at offset `start`. If length is not given, it
        defaults to the input length. If step is not given, it defaults to 1.
        &#34;&#34;&#34;
        def _copy(data: bytearray):
            bounds = relslice(region, data)
            return data[bounds]
        return _copy

    @handler.register(&#39;x&#39;, &#39;cut&#39;, final=True)
    def cut(self, region: str) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `cut:region` work like `refinery.lib.argformats.DelayedBinaryArgument.copy`,
        but the bytes are removed from the input data after copying them.
        &#34;&#34;&#34;
        def _cut(data: bytearray | Chunk):
            bounds = relslice(region, data)
            result = bytearray(data[bounds])
            del data[bounds]
            return result
        return _cut

    @handler.register(&#39;pd&#39;)
    def pd(self, input: bytes, region: slice | str = slice(1, None, 1), separator: bytes = B&#39;/&#39;) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `pd[region=1:,sep=/]:input` splits the input at the given string `sep`
        and reverses the sequence. Parts are then selected according to the `region` parameter,
        which can be any expression in Python slice syntax. Afterwards, the resulting sequence
        is reversed again and joined at the `sep` parameter. For example, the expression

            pd[2:]:/path/to/some/item/and/more

        will return the string `/path/to/some/item`.
        &#34;&#34;&#34;
        def _pd(data: Chunk | None = None):
            b: slice = sliceobj(region, data=data, final=True)
            pd = input.split(separator)
            pd.reverse()
            pd = pd[b]
            pd.reverse()
            return separator.join(pd)
        try:
            return _pd()
        except TooLazy:
            return _pd

    @handler.register(&#39;pb&#39;)
    def pb(self, input: bytes, separator: bytes = B&#39;/&#39;) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `pb:input` is equivalent to `pd[:1]:input` and corresponds to &#34;basename&#34;.
        &#34;&#34;&#34;
        return self.pd(input, slice(0, 1, 1), separator=separator)

    @handler.register(&#39;pn&#39;)
    def pn(self, path: str | bytes) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `pn:/path/to/file.ext` returns `/path/to/file`, i.e. the path without its
        extension. The handler name is short for &#34;path name&#34;. If the last part does not have
        any extension, the input path is returned unchanged.
        &#34;&#34;&#34;
        if not isinstance(path, str):
            path = path.decode(&#39;utf8&#39;)
        return Path(path).with_suffix(&#39;&#39;).as_posix().encode()

    @handler.register(&#39;px&#39;)
    def px(self, path: str | bytes) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `px:/path/to/file.ext` returns `ext`, i.e. the extension extension. The
        handler name is short for &#34;path eXtension&#34;.
        &#34;&#34;&#34;
        if not isinstance(path, str):
            path = path.decode(&#39;utf8&#39;)
        return Path(path).suffix[1:].encode()

    def _interpret_variable(self, name: str, obj: Any):
        if isbuffer(obj) or isinstance(obj, int) or obj is None:
            return obj
        if isinstance(obj, str):
            return utf8(obj)
        if isinstance(obj, (tuple, set, frozenset)):
            obj = list(obj)
        if isinstance(obj, list):
            return obj
        raise ArgumentTypeError(F&#39;The meta variable {name} is of type {type(obj).__name__} and no conversion is known.&#39;)

    def _var(self, name: str, eat: bool) -&gt; bytes:
        if not is_valid_variable_name(name, allow_wildcards=True):
            name = multibin(name)

        def extract(data: Chunk):
            var = name(data) if callable(name) else name
            if not isinstance(var, str):
                if not isinstance(var, bytes):
                    var = bytes(var)
                var = var.decode()
            meta = metavars(data)
            if var not in meta:
                from fnmatch import fnmatch as matches
                options = [name for name in meta.keys() if matches(name, var)]
                if len(options) == 1:
                    var = options[0]
            try:
                if eat:
                    result = meta.pop(var)
                else:
                    result = meta[var]
            except KeyError as KE:
                raise VariableMissing(var) from KE
            return self._interpret_variable(name, result)

        return extract

    @handler.register(&#39;v&#39;, &#39;var&#39;, final=True)
    def var(self, name: str) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `var:name` contains the value of the meta variable `name`. This handler is semi-final;
        if the provided argument is an identifier pattern, it is read directly as a variable name. Otherwise,
        it will be interpreted as a multibin expression to compute the name. An identifier pattern here is
        a unix file name pattern including the wildcards `?`, `*`, and letter options in `[` brackets `]`.
        &#34;&#34;&#34;
        return self._var(name, eat=False)

    @handler.register(&#39;eat&#39;, final=True)
    def eat(self, name: str) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `eat:name` works exactly like `var:name` with the exception that the variable is removed
        from the chunk after evaluation.
        &#34;&#34;&#34;
        return self._var(name, eat=True)

    @handler.register(&#39;e&#39;, &#39;E&#39;, &#39;eval&#39;)
    def eval(self, expression) -&gt; Any:
        &#34;&#34;&#34;
        Final modifier `e:expression` or `eval:expression`; uses a `refinery.lib.argformats.PythonExpression`
        parser to process expressions. The expression can contain any meta variable that is attached to the
        chunk. The `refinery.cm` unit can be used to attach information such as chunk size and the chunk
        index within the current frame (see `refinery.lib.frame`).
        &#34;&#34;&#34;
        if isbuffer(expression):
            expression = expression.decode(&#39;utf8&#39;)
        if not isinstance(expression, str):
            return expression
        return LazyPythonExpression(expression)

    @handler.register(&#39;btoi&#39;)
    def btoi(self, binary: buf, size=None, step=None) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        The modifier `btoi[size=0,step=0]:data` uses `refinery.lib.chunks.unpack` to convert a
        sequence of bytes into a sequence of integers.

        The optional parameter `size` has to be an integer expression whose absolute value gives
        the size of each encoded number in bytes. Its default value is `0`, which corresponds to
        choosing the size automatically in the following manner: If the length of the buffer is
        uneven, the value 1 is chosen. If the length modulo 4 is nonzero, the value 2 is chosen. If
        the length is divisible by 4, then 4 is chosen. To unpack as big endian as opposed to the
        default little endian, a negative value for `size` has to be specified. The absolute value
        of `size` will be used.

        By default, integers are parsed from the input buffer at offsets that are integer multiples
        of the block size. The optional parameter `step` can be used to override this behavior. For
        example, `btoi[2,1]` can be used to read 16-bit values at each byte offset.
        &#34;&#34;&#34;
        from refinery.lib import chunks
        size = int(size, 0) if size else 0
        step = int(step, 0) if step else 0
        bigE = size &lt; 0
        size = abs(size)
        if not size:
            n = len(binary)
            if n % 2:
                size = 1
            elif n % 4:
                size = 2
            else:
                size = 4
        return list(chunks.unpack(binary, size, bigE, step))

    @handler.register(&#39;itob&#39;)
    def itob(self, integers: Iterable[int], size=None) -&gt; buf:
        &#34;&#34;&#34;
        The modifier `itob[size=0]:integers` is the inverse of `btoi` and works in the same way,
        except that the case `size=0` is handled in the following way: The handler inspects all
        integers in the input and determines the minimum block size required to pack all of them.
        &#34;&#34;&#34;
        from refinery.lib import chunks
        size = int(size, 0) if size else 0
        bigE = size &lt; 0
        size = abs(size)
        if not size:
            def byte_length(n: int):
                width, overflow = divmod(n.bit_length(), 8)
                width += bool(overflow)
                return width
            if not isinstance(integers, list):
                integers = list(integers)
            size = max((byte_length(n) for n in integers), default=1)
            size = max(size, 1)
        else:
            mask = (1 &lt;&lt; (size * 8)) - 1
            integers = (integer &amp; mask for integer in integers)
        return chunks.pack(integers, size, bigE)

    @handler.register(&#39;inc&#39;)
    def inc(self, it: Iterable[int], precision=None) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        The modifier `inc:it` or `inc[N=64]:it` expects a sequence `it` of integers (a binary
        string is interpreted as the sequence of its byte values), iterates it cyclically and
        perpetually adds an increasing counter to the result. If the number `N` is nonzero, then
        the counter is limited to `N` bits.
        &#34;&#34;&#34;
        precision = precision and int(precision, 0) or _DEFAULT_BITS
        it = infinitize(it)
        if precision:
            def delay(_):
                mask = (1 &lt;&lt; precision) - 1
                for a, b in zip(it, itertools.cycle(range(mask + 1))):
                    yield a + b &amp; mask
        else:
            def delay(_):
                for a, b in zip(it, itertools.count()):
                    yield a + b
        return delay

    @handler.register(&#39;dec&#39;)
    def dec(self, it: Iterable[int], precision=None) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        Identical to `refinery.lib.argformats.DelayedNumSeqArgument.inc`, but decreasing the counter
        rather than increasing it.
        &#34;&#34;&#34;
        precision = precision and int(precision, 0) or _DEFAULT_BITS
        it = infinitize(it)
        if precision:
            def delay(_):
                mask = (1 &lt;&lt; precision) - 1
                for a, b in zip(it, itertools.cycle(range(mask + 1))):
                    yield a - b &amp; mask
        else:
            def delay(_):
                for a, b in zip(it, itertools.count()):
                    yield a - b
        return delay

    @handler.register(&#39;take&#39;)
    def take(self, it: Iterable[int], bounds: str | None = None):
        &#34;&#34;&#34;
        The handler `take[start:stop:step]` expects an integer sequence as input and applies a slice
        to it. Slices are given in Python syntax, so `take[::2]` will extract every second item from
        the incoming data. The default sequence is `1:`, i.e. skipping the first element.
        &#34;&#34;&#34;
        def sliced(bounds):
            try:
                return it[bounds]
            except TypeError:
                subsequence = itertools.islice(it, bounds.start, bounds.stop, bounds.step)
                if bounds.stop is not None:
                    subsequence = list(subsequence)
                    if all(t in range(0x100) for t in subsequence):
                        subsequence = bytearray(subsequence)
                return subsequence
        bounds = bounds and sliceobj(bounds) or slice(1, None)
        if isinstance(bounds, slice):
            return sliced(bounds)
        return lambda d: sliced(bounds(d))

    @handler.register(&#39;cycle&#39;)
    def cycle(self, it: Iterable[int]) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        The `cycle` handler turns a finite integer sequence into an infinitely repeating integer sequence.
        &#34;&#34;&#34;
        if isinstance(it, itertools.cycle):
            return it
        return itertools.cycle(it)

    @handler.register(&#39;rng&#39;, final=True)
    def rng(
        self,
        size: str,
    ) -&gt; bytes:
        &#34;&#34;&#34;
        The `rng:count` handler generates `count` secure random bytes using the Python standard
        library module function `secrets.token_bytes`.
        &#34;&#34;&#34;
        import secrets
        size = PythonExpression.Lazy(size)
        try:
            _size = size()
        except ParserVariableMissing:
            def finalize(data):
                meta = dict(metavars(data))
                return secrets.token_bytes(size(meta))
            return finalize
        else:
            return secrets.token_bytes(_size)

    @handler.register(&#39;prng&#39;, final=True)
    def prng(
        self,
        size: str,
        seed: str | None = None
    ) -&gt; bytes:
        &#34;&#34;&#34;
        The `prng[seed]:count` handler generates `count` random bytes using Python&#39;s built-in random
        number generator. The `seed` argument can be omitted, in which case the PRNG will be seeded
        with the current timestamp in nanoseconds.
        &#34;&#34;&#34;
        import random
        import time

        try:
            randbytes = random.randbytes
        except AttributeError:
            def randbytes(n):
                return bytearray(random.randint(0, 0xFF) for _ in range(n))

        seed = time.time_ns if seed is None else PythonExpression.Lazy(seed)
        size = PythonExpression.Lazy(size)
        try:
            _size = size()
            _seed = seed()
        except ParserVariableMissing:
            def finalize(data):
                meta = dict(metavars(data))
                random.seed(seed(meta))
                return randbytes(size(meta))
            return finalize
        else:
            random.seed(_seed)
            return randbytes(_size)

    @handler.register(&#39;accu&#39;, final=True)
    def accu(
        self,
        spec: str,
        seed: str | None = None,
        skip: str | None = None,
        precision: str | None = None
    ) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        The final handler

            accu[seed=0,skip=1,precision=64]:update[#feed]

        expects `seed`, `skip`, `update`, and `feed` to be Python expressions. It generates an infinite integer
        sequence maintaining an internal state `A`: The initial value for `A` is `seed`. Each subsequent state is
        the result of evaluating the `update` expression, which can use the variable `A` to access the current
        state. The next integer value to be generated is the result of evaluating the expression `feed`, which
        may again use the variable `A` to access the internal state. If the `feed` expression is omitted, the
        complete state `A` is emitted in each step. The value of `skip` specifies the number of elements from the
        beginning of the sequence that should be skipped. The value of `precision` specifies the number of bits
        that are used by the internal state variable `A`. You can specify `precision` to be zero if you want the
        result to be an unbounded big integer.

        Instead of a Python expression, the  variable `update` can also be one of the following values, which
        are pre-defined update routines based on popular generators:

        - `@libc`: `A * 0x041C64E6D + 0x003039`
        - `@ansi`: `A * 0x041C64E6D + 0x003039 # (A &gt;&gt; 0x10)`
        - `@msvc`: `A * 0x0000343FD + 0x269EC3 # (A &gt;&gt; 0x10)`
        - `@msvb`: `A * 0x043FD43FD + 0xC39EC3`
        - `@java`: `A * 0x5DEECE66D + 0x00000B`
        - `@mmix`: `A * 6364136223846793005 + 1442695040888963407`
        &#34;&#34;&#34;
        if spec.startswith(&#39;@&#39;):
            try:
                spec = {
                    &#39;@libc&#39;: &#39;A * 0x041C64E6D + 0x003039&#39;,
                    &#39;@ansi&#39;: &#39;A * 0x041C64E6D + 0x003039 # (A &gt;&gt; 0x10)&#39;,
                    &#39;@msvc&#39;: &#39;A * 0x0000343FD + 0x269EC3 # (A &gt;&gt; 0x10)&#39;,
                    &#39;@msvb&#39;: &#39;A * 0x043FD43FD + 0xC39EC3&#39;,
                    &#39;@java&#39;: &#39;A * 0x5DEECE66D + 0x00000B&#39;,
                    &#39;@mmix&#39;: &#39;A * 6364136223846793005 + 1442695040888963407&#39;
                }[spec]
            except KeyError:
                raise ArgumentTypeError(F&#39;The generator type {spec} is unknown.&#39;)
        update, _, feed = spec.partition(&#39;#&#39;)
        update = PythonExpression.Lazy(update)
        seed = seed or &#39;0&#39;
        seed = PythonExpression.Lazy(seed)
        feed = feed and PythonExpression.Lazy(feed)
        skip = 1 if skip is None else int(skip, 0)
        precision = precision and int(precision, 0) or _DEFAULT_BITS
        mask = precision and (1 &lt;&lt; precision) - 1

        def finalize(data: Chunk | None = None):
            @lru_cache(maxsize=512, typed=False)
            def accumulate(A):
                return update(meta, A=A)
            meta = dict(metavars(data))
            A = seed and seed(meta) or 0
            F = feed(meta, A=A) if feed else A
            S = skip
            while True:
                if not S:
                    yield F
                else:
                    S = S - 1
                A = accumulate(A)
                if mask:
                    A &amp;= mask
                F = feed(meta, A=A) if feed else A
        try:
            update(A=seed())
        except ParserVariableMissing:
            return finalize
        else:
            return finalize()

    @handler.register(&#39;be&#39;)
    def be(self, arg: int | buf, size: str | None = None) -&gt; int:
        &#34;&#34;&#34;
        The handler `be[size=0]:data` converts a binary input into the integer that it encodes in
        big endian format, and vice versa. The optional parameter `size` can be used to specify
        the number of bytes used for encoding integers. For byte string inputs, this parameter is
        used to truncate the input before conversion.
        &#34;&#34;&#34;
        if size is not None:
            size = int(size, 0)
        if isinstance(arg, int):
            if size is None:
                size, r = divmod(arg.bit_length(), 8)
                size += int(bool(r))
            return arg.to_bytes(max(size, 1), &#39;big&#39;)
        else:
            return int.from_bytes(arg[:size], &#39;big&#39;)

    @handler.register(&#39;le&#39;)
    def le(self, arg: int | buf, size: str | None = None) -&gt; int:
        &#34;&#34;&#34;
        The handler `be[size=0]:data` converts a binary input into the integer that it encodes in
        little endian format, and vice versa. The optional parameter `size` can be used to specify
        the number of bytes used for encoding integers. For byte string inputs, this parameter is
        used to truncate the input before conversion.
        &#34;&#34;&#34;
        if size is not None:
            size = int(size, 0)
        if isinstance(arg, int):
            if size is None:
                size, r = divmod(arg.bit_length(), 8)
                size += int(bool(r))
            return arg.to_bytes(max(size, 1), &#39;little&#39;)
        else:
            return int.from_bytes(arg[:size], &#39;little&#39;)

    @handler.register(&#39;reduce&#39;)
    def reduce(self, it: Iterable[int], reduction: str, seed: str | None = None) -&gt; int:
        &#34;&#34;&#34;
        The handler `reduce[reduction, seed=0]` has two parameters. The string `reduction` is a
        Python expression that involves the two special variables `S` (the state) and `B`
        (the current block value). This expression is evaluated for every `B` in the incoming
        integer sequence and assigned back to `S`. The starting value of `S` is given by `seed`,
        which has a default value of `0` and must also be given as a Python expression.
        &#34;&#34;&#34;
        seed = seed and PythonExpression.Lazy(seed)
        reduction = PythonExpression.Lazy(reduction)

        def finalize(data: Chunk | None = None):
            def _reduction(S, B):
                v = reduction(args, S=S, B=B)
                return v
            args = dict(metavars(data))
            return reduce(_reduction, it, seed and seed(args) or 0)

        try:
            return finalize()
        except ParserVariableMissing:
            return finalize


class DelayedBinaryArgument(DelayedArgument):
    &#34;&#34;&#34;
    A parser for binary arguments. It does not implement any handlers beyond the default handlers that
    are implemented in `refinery.lib.argformats.DelayedArgument`.
    &#34;&#34;&#34;

    def __call__(self, data: buf | None = None) -&gt; bytes:
        value = super().__call__(data=data)
        if not isbuffer(value):
            if isinstance(value, str):
                return value.encode(&#39;utf8&#39;)
            if not value:
                return B&#39;&#39;
            raise ArgumentTypeError(
                F&#39;The expression {self.expression} returned a value of type {type(value).__name__}, &#39;
                R&#39;which could not be converted to a byte string.&#39;
            )
        return value


class DelayedPathArgument(DelayedBinaryArgument):
    &#34;&#34;&#34;
    A parser for binary arguments like `refinery.lib.argformats.DelayedBinaryArgument` which does not
    read files from disk as the default. This makes it more suitable for parsing path patterns that
    are passed to path extractor units: It avoids the problem that a provided file name is confused
    with the contents of an equally named file on disk.
    &#34;&#34;&#34;
    def default_handler(self, expression: str) -&gt; bytes:
        return utf8(expression)

    def __call__(self, data: buf | None = None) -&gt; str:
        return super().__call__(data).decode(&#39;utf8&#39;)


class DelayedNumSeqArgument(DelayedArgument):
    &#34;&#34;&#34;
    A parser for sequences of numeric arguments. It does not implement any handlers beyond the default
    handlers that are implemented in `refinery.lib.argformats.DelayedArgument`, but the default handler
    attempts to evalue the input as a Python expression.
    &#34;&#34;&#34;

    def __init__(self, expression: str, reverse=False, seed=None, typecheck=True, additional_types=None):
        super().__init__(expression, reverse, seed)
        self.typecheck = typecheck
        self.additional_types = additional_types or []

    def default_handler(self, expression: str) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        Attempts to parse the input expression as a sequence of integers. If this fails, the handler defaults
        to the parent `refinery.lib.argformats.DelayedArgument.default_handler`.
        &#34;&#34;&#34;
        try:
            with open(expression, &#39;rb&#39;) as stream:
                return stream.read()
        except Exception:
            pass
        try:
            return LazyPythonExpression(expression)
        except Exception:
            if isinstance(expression, str):
                return super().default_handler(expression)
            return expression

    def __call__(self, data: buf | Chunk | None = None) -&gt; Iterable[int]:
        value = super().__call__(data)
        if isbuffer(value):
            return value
        if isinstance(value, str):
            return value.encode()
        if hasattr(value, &#39;__iter__&#39;):
            try:
                if len(value) == 1:
                    return RepeatedInteger(next(iter(value)))
            except TypeError:
                def rewind():
                    yield top
                    yield from it
                it = iter(value)
                top = next(it)
                if not isinstance(top, int):
                    raise ArgumentTypeError(
                        F&#39;The first item {top!r} of the iterable computed from {self.expression} was not an integer.&#39;)
                return rewind()
            else:
                return value
        if isinstance(value, float):
            tmp = int(value)
            if float(tmp) == value:
                value = tmp
        if isinstance(value, int):
            return RepeatedInteger(value)
        if not self.typecheck:
            return value
        if self.additional_types:
            typecheck = self.additional_types
            try:
                typecheck = tuple(typecheck)
            except Exception:
                pass
            try:
                if isinstance(value, typecheck):
                    return value
            except Exception:
                pass
        raise ArgumentTypeError(
            F&#39;The value computed from {self.expression} is of type {type(value).__name__} but the unit requested an &#39;
            R&#39;integer or a sequence of integers.&#39;
        )


class DelayedRegexpArgument(DelayedArgument):
    &#34;&#34;&#34;
    A parser for regular expressions arguments. It implements two additional handlers beyond the ones
    inherited from `refinery.lib.argformats.DelayedArgument`.
    &#34;&#34;&#34;

    @DelayedArgumentDispatch.Inherit(DelayedArgument)
    def handler(self, expression: str) -&gt; bytes:
        &#34;&#34;&#34;
        The default handler encodes the input expression as latin-1 to return a binary string regular
        expression. Two additional syntax features have been added:

        - The use of named patterns from `refinery.lib.patterns.formats` and `refinery.lib.patterns.indicators`
          is possible by means of the extension format `(??name)`. For example, the pattern `((??url)\\x00){4}`
          will match a sequence of four URL strings which are all terminated with a null character.
        - The syntax `(?/var=PATTERN)` is equivalent to `(?P&lt;var&gt;PATTERN)`.
        &#34;&#34;&#34;
        if &#39;(?&#39; in expression:
            from refinery.lib.patterns import formats, indicators
            tick = 0

            def replace_known_pattern(match: re.Match[str]):
                nonlocal tick
                name = match[1]
                if (pattern := formats.get(name)) is None:
                    if (pattern := indicators.get(name)) is None:
                        return match[0]
                tick += 1
                pattern = re.sub(
                    R&#39;(?&lt;=\(\?P[&lt;=])__(\w+)__&#39;, F&#39;__\\1_{tick}__&#39;, str(pattern))
                return F&#39;(?:{pattern})&#39;

            def replace_variable_assignment(match):
                return F&#39;(?P&lt;{match[1]}&gt;&#39;

            expression = re.sub(R&#39;\(\?/(\w+)=&#39;,
                replace_variable_assignment, expression)
            expression = re.sub(
                R&#39;\(\?\?([-\w]+)\)&#39;,
                replace_known_pattern,
                expression
            )

        return expression.encode(&#39;latin-1&#39;)

    @handler.register(&#39;f&#39;, final=True)
    def format(self, name: str) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `f:[name]` returns a regular expression for to one of the format types
        supported by `refinery.carve` unit.
        &#34;&#34;&#34;
        from refinery.lib.patterns import formats
        try:
            return formats[name].value.bin_pattern
        except LookupError:
            raise ArgumentTypeError(
                F&#39;Based on the prefix &#34;f:&#34;, the parser looked for a carve format named &#34;{name}&#34;.&#39;
                &#39; No such format is known; prefix the entire expression with &#34;s:&#34; if this was &#39;
                &#39;unintended, otherwise correct the format name spelling.&#39;)

    @handler.register(&#39;yara&#39;, &#39;y&#39;, &#39;Y&#39;)
    def yara(self, pattern: bytes) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `yara:pattern` or `Y:pattern` converts YARA syntax wildcard hexadecimal
        expressions into standard regular expressions. For example, the string `D?` is
        translated to `[\\xD0-\\xDF]`, the expression `[2-6]` becomes `.{2,6}`, and `?D`
        becomes the following substring:
        ```
        [\\x0D\\x1D\\x2D\\x3D\\x4D\\x5D\\x6D\\x7D\\x8D\\x9D\\xAD\\xBD\\xCD\\xDD\\xED\\xFD]
        ```
        Only two-letter hexadecimal sequences with optional `?` wildcards and wildcard
        ranges such as `[2-6]` are substituted, all other characters in the pattern are
        left unchanged.
        &#34;&#34;&#34;
        def y2r(match: re.Match[bytes]):
            mask = match[2]
            _not = bool(match[1])
            if mask == B&#39;??&#39;:
                if _not:
                    raise ArgumentTypeError(&#39;Found ~?? in YARA pattern; cannot negate arbitrary wildcard.&#39;)
                return B&#39;.&#39;
            if B&#39;?&#39; not in mask:
                pattern = BR&#39;\x%s&#39; % mask
                if not _not:
                    return pattern
            elif mask.endswith(B&#39;?&#39;):
                pattern = BR&#39;\x%c0-\x%cF&#39; % (mask[0], mask[0])
            else:
                pattern = BR&#39;%s&#39; % BR&#39;&#39;.join(BR&#39;\x%x%c&#39; % (k, mask[1]) for k in range(0x10))
            return B&#39;[%s%s]&#39; % (_not * B&#39;^&#39;, pattern)

        def yara_range(rng: bytes, last: bool):
            bounds = [t.strip() for t in rng[1:-1].split(B&#39;-&#39;)]
            if len(bounds) &gt; 2:
                raise ArgumentTypeError(F&#39;Invalid YARA range: {rng}&#39;)
            if not any(bounds):
                return B&#39;.*&#39; if last else B&#39;.*?&#39;
            if not bounds[0]:
                bounds[0] = B&#39;0&#39;
            return B&#39;.{%s}&#39; % B&#39;,&#39;.join(bounds)

        pattern = re.split(BR&#39;(\[\s*\d*(?:\s*-\s*\d*)?\s*\])&#39;, pattern)
        length = (len(pattern) // 2) - int(not pattern[~0])
        pattern[0::2] = [re.sub(BR&#39;(~?)([A-Fa-f0-9?]{2})&#39;, y2r, c) for c in pattern[::2]]
        pattern[1::2] = [yara_range(b, k == length) for k, b in enumerate(pattern[1::2])]
        pattern = B&#39;&#39;.join(pattern)
        return pattern


class DelayedNumberArgument(DelayedArgument):
    &#34;&#34;&#34;
    A parser for numeric arguments. Implements no handlers beyond the ones inherited from its parent
    `refinery.lib.argformats.DelayedArgument`. The final handler output is expected to be an integer.
    The class can be initialized with numerical bounds and checks the validity of the input after
    having evaluated all handlers.
    &#34;&#34;&#34;
    def __init__(self, expression: str, min: int | None, max: int | None):
        self.min = min
        self.max = max
        super().__init__(expression)

    def __call__(self, data: buf | Chunk | None = None) -&gt; int:
        value = super().__call__(data)
        if not isinstance(value, int):
            tv = type(value).__name__
            raise ArgumentTypeError(F&#39;The value computed from {self.expression} is of type {tv}, it should be an integer.&#39;)
        if self.min is not None and value &lt; self.min or self.max is not None and value &gt; self.max:
            a = &#39;-&#39; if self.min is None else self.min
            b = &#39;&#39; if self.max is None else self.max
            raise ArgumentTypeError(F&#39;value {value} is out of bounds [{a},{b}]&#39;)
        return value

    def default_handler(self, expression: str) -&gt; int:
        &#34;&#34;&#34;
        The default handler: Attempts to parse the input expression as an integer.
        &#34;&#34;&#34;
        return LazyPythonExpression(expression)


class ___number:
    __name__ = &#39;number&#39;

    def __init__(self, min: int | None = None, max: int | None = None):
        self.min = min
        self.max = max

    def __getitem__(self, k: slice):
        return self.__class__(k.start, k.stop)

    def __call__(self, value):
        if isinstance(value, int):
            return value
        try:
            delay = DelayedNumberArgument(value, self.min, self.max)
            try:
                return delay()
            except TooLazy:
                return delay
        except ParserError:
            import re
            match = re.fullmatch(&#39;(?:0x)?([A-F0-9]+)H?&#39;, value, flags=re.IGNORECASE)
            if not match:
                raise
            return number(F&#39;0x{match[1]}&#39;)


number = ___number()
&#34;&#34;&#34;
The singleton instance of a class that uses `refinery.lib.argformats.PythonExpression`
to parse expressions with integer value. This singleton can be slice accessed to
create new number parsers, e.g. `number[0:]` will refuse to parse negative integer
expressions.
&#34;&#34;&#34;


def numseq(expression: int | str, reverse=False, seed=None, typecheck=True) -&gt; Iterable[int] | DelayedNumSeqArgument:
    &#34;&#34;&#34;
    This is the argument parser type that uses `refinery.lib.argformats.DelayedNumSeqArgument`.
    &#34;&#34;&#34;
    if isinstance(expression, int):
        return RepeatedInteger(expression)
    arg = DelayedNumSeqArgument(expression, reverse=reverse, seed=seed, typecheck=typecheck)
    with suppress(TooLazy):
        return arg()
    return arg


def pathvar(expression: str) -&gt; str | DelayedArgument:
    &#34;&#34;&#34;
    This is the argument parser type that uses `refinery.lib.argformats.DelayedPathArgument`.
    &#34;&#34;&#34;
    arg = DelayedPathArgument(expression)
    with suppress(TooLazy):
        return arg()
    return arg


def multibin(expression: str | bytes | bytearray, reverse=False, seed=None) -&gt; bytes | DelayedArgument:
    &#34;&#34;&#34;
    This is the argument parser type that uses `refinery.lib.argformats.DelayedBinaryArgument`.
    &#34;&#34;&#34;
    if not isinstance(expression, str):
        return bytes(expression)
    arg = DelayedBinaryArgument(expression, reverse, seed)
    with suppress(TooLazy):
        return arg()
    return arg


def regexp(expression: str) -&gt; int | bytes | DelayedRegexpArgument:
    &#34;&#34;&#34;
    This is the argument parser type that uses `refinery.lib.argformats.DelayedRegexpArgument`.
    &#34;&#34;&#34;
    arg = DelayedRegexpArgument(expression)
    with suppress(TooLazy):
        return arg()
    return arg


class Option(ABC):
    name: str
    mode: Any

    @abstractmethod
    def __init__(self, name: str):
        raise NotImplementedError

    def __eq__(self, other):
        return str(other) == self.name

    def __hash__(self):
        return hash(self.name)

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.name

    @property
    def value(self):
        return self.mode


def OptionFactory(options: Mapping[str, Any], ignorecase: bool = False):
    &#34;&#34;&#34;
    The factory produces an argument parser type that accepts the keys of `options`
    as possible values and causes the parsed argument to contain the corresponding
    value from the `options` dictionary.
    &#34;&#34;&#34;
    try:
        cache = OptionFactory.Cache
    except AttributeError:
        cache = OptionFactory.Cache = {}

    option_description = &#39;,&#39;.join(sorted(options))
    option_identifier = hash(option_description)

    try:
        return cache[option_identifier]
    except KeyError:
        pass

    class TheOption(Option):
        def __init__(self, name: str):
            if ignorecase and name not in options:
                needle = name.upper()
                for key in options:
                    if needle == key.upper():
                        name = key
                        break
            if name not in options:
                raise ValueError(&#39;The option {} is not one of these: {}&#39;.format(name, list(options)))
            self.mode = options[name]
            self.name = name

    TheOption.__qualname__ = F&#39;OptionFactory.Option[{option_description}]&#39;
    cache[option_identifier] = TheOption
    return TheOption


def extract_options(symbols, prefix: str, *exceptions: str):
    &#34;&#34;&#34;
    A helper function to extract all numeric constants from modules that have a certain
    prefix. `refinery.units.crypto.cipher.StandardCipherUnit` uses this to extract the
    block cipher modes of operation from block cipher modules of the `pycryptodome` library.
    &#34;&#34;&#34;
    candidates = {
        k[len(prefix):]: getattr(symbols, k, None)
        for k in dir(symbols) if k.startswith(prefix) and all(
            e not in k for e in exceptions
        )
    }
    return {k: v for k, v in candidates.items() if isinstance(v, int)}


def pending(argument: Any | Iterable[Any]) -&gt; bool:
    &#34;&#34;&#34;
    This function returns a boolean value which indicates whether the given
    argument is a `refinery.lib.argformats.LazyEvaluation`.
    &#34;&#34;&#34;
    if isinstance(argument, (list, tuple)):
        return any(pending(x) for x in argument)
    return isinstance(argument, LazyEvaluation)


def manifest(argument: Any | list[Any], data: bytearray) -&gt; Any | list[Any]:
    &#34;&#34;&#34;
    Returns the manifestation of a `refinery.lib.argformats.LazyEvaluation`
    on the given data. This function can change the data.
    &#34;&#34;&#34;
    if isinstance(argument, (list, tuple)):
        return [manifest(x, data) for x in argument]
    return argument(data) if isinstance(argument, LazyEvaluation) else argument</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="refinery.lib.argformats.number"><code class="name">var <span class="ident">number</span></code></dt>
<dd>
<section class="desc"><p>The singleton instance of a class that uses <code><a title="refinery.lib.argformats.PythonExpression" href="#refinery.lib.argformats.PythonExpression">PythonExpression</a></code>
to parse expressions with integer value. This singleton can be slice accessed to
create new number parsers, e.g. <code>number[0:]</code> will refuse to parse negative integer
expressions.</p></section>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.argformats.percent"><code class="name flex">
<span>def <span class="ident">percent</span></span>(<span>expression)</span>
</code></dt>
<dd>
<section class="desc"><p>Allows specification of percentages.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L291-L297" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def percent(expression: str):
    &#34;&#34;&#34;
    Allows specification of percentages.
    &#34;&#34;&#34;
    if expression.endswith(&#39;%&#39;):
        return float(expression[:-1].strip()) / 100
    return float(expression)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.relslice"><code class="name flex">
<span>def <span class="ident">relslice</span></span>(<span>expression, data=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Uses <code><a title="refinery.lib.argformats.sliceobj" href="#refinery.lib.argformats.sliceobj">sliceobj()</a></code> to parse a slice from the input, but
interprets the second part of the slice as a relative length (which can also
be negative).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L310-L323" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def relslice(expression: int | str | slice, data: Chunk | None = None) -&gt; slice | SliceAgain:
    &#34;&#34;&#34;
    Uses `refinery.lib.argformats.sliceobj` to parse a slice from the input, but
    interprets the second part of the slice as a relative length (which can also
    be negative).
    &#34;&#34;&#34;
    s = sliceobj(expression, data)
    if isinstance(s, slice) and (stop := s.stop) is not None:
        start = s.start or 0
        stop += start
        if (step := s.step) is None and stop &lt; start:
            step = -1
        s = slice(start, stop, step)
    return s</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.sliceobj"><code class="name flex">
<span>def <span class="ident">sliceobj</span></span>(<span>expression, data=None, intok=False, final=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Uses <code><a title="refinery.lib.argformats.PythonExpression" href="#refinery.lib.argformats.PythonExpression">PythonExpression</a></code> to parse slice expressions
where the bounds can be given as arithmetic expressions. For example, this
argument format type will process the string <code>0x11:0x11+4*0x34</code> as the slice
object <code>slice(17, 225, None)</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L346-L405" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sliceobj(
    expression: int | str | slice,
    data: Chunk | None = None,
    intok: bool = False,
    final: bool = False,
) -&gt; slice | int | SliceAgain:
    &#34;&#34;&#34;
    Uses `refinery.lib.argformats.PythonExpression` to parse slice expressions
    where the bounds can be given as arithmetic expressions. For example, this
    argument format type will process the string `0x11:0x11+4*0x34` as the slice
    object `slice(17, 225, None)`.
    &#34;&#34;&#34;
    if isinstance(expression, (slice, SliceAgain)):
        return expression
    if isinstance(expression, int):
        if intok:
            return expression
        return slice(expression, expression + 1, 1)
    if isinstance(expression, (bytes, bytearray)):
        expression = expression.decode(&#39;utf8&#39;)

    if data is None:
        variables = {}
    else:
        variables = metavars(data)
        if is_valid_variable_name(expression):
            try:
                return sliceobj(variables[expression], data, intok=intok, final=True)
            except Exception:
                pass

    sliced = expression and expression.split(&#39;:&#39;) or [&#39;&#39;, &#39;&#39;]

    if not sliced or len(sliced) &gt; 3:
        raise ArgumentTypeError(F&#39;The expression &#34;{expression}&#34; is not a valid slice.&#39;)
    try:
        sliced = [None if not t else LazyPythonExpression(t, variables) for t in sliced]
    except ParserVariableMissing:
        if final:
            raise
        elif data is not None:
            parser = DelayedNumSeqArgument(expression)
            return sliceobj(parser(data), data, intok=intok, final=True)
        else:
            return SliceAgain(expression, intok)
    if len(sliced) == 1:
        k = sliced[0]
        if intok:
            return k
        return slice(k, k + 1) if k + 1 else slice(k, None, None)
    for k, item in enumerate(sliced):
        if item is None:
            continue
        if isinstance(item, int):
            continue
        if isbuffer(item) and len(item) in (1, 2, 4, 8, 16):
            sliced[k] = int.from_bytes(item, &#39;little&#39;)
            continue
        raise TypeError(F&#39;The value {item!r} of type {type(item).__name__} cannot be used as a slice index.&#39;)
    return slice(*sliced)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.utf8"><code class="name flex">
<span>def <span class="ident">utf8</span></span>(<span>x)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the UTF8 encoding of the given string.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L408-L412" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def utf8(x: str):
    &#34;&#34;&#34;
    Returns the UTF8 encoding of the given string.
    &#34;&#34;&#34;
    return x.encode(&#39;UTF8&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.LazyPythonExpression"><code class="name flex">
<span>def <span class="ident">LazyPythonExpression</span></span>(<span>expression, variables=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Wraps the given expression for use as a <code><a title="refinery.lib.argformats.multibin" href="#refinery.lib.argformats.multibin">multibin()</a></code> expression. If it
contains no variables, the expression is evaluated immediately, otherwise the function returns
a callable that will evaluate the given expression on an incoming <code><a title="refinery.lib.frame.Chunk" href="frame.html#refinery.lib.frame.Chunk">Chunk</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L552-L591" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def LazyPythonExpression(expression: str, variables: dict | None = None) -&gt; MaybeDelayedType[Any]:
    &#34;&#34;&#34;
    Wraps the given expression for use as a `refinery.lib.argformats.multibin` expression. If it
    contains no variables, the expression is evaluated immediately, otherwise the function returns
    a callable that will evaluate the given expression on an incoming `refinery.lib.frame.Chunk`.
    &#34;&#34;&#34;
    expression = expression.strip()
    if match := re.fullmatch(R&#39;([1-9][0-9]?)%&#39;, expression):
        return Percentage(int(match[1]) / 100)
    if match := re.fullmatch(RF&#39;&#39;&#39;(?ix)
        (?: (?P&lt;flt&gt;{formats.float!s})
          | (?P&lt;int&gt;{formats.integer!s})
        ) (?P&lt;unit&gt;[KMGTPE]i?B?)
    &#39;&#39;&#39;, expression):
        unit = match[&#39;unit&#39;].upper()
        step = &#39;KMGTPE&#39;.index(unit[0]) + 1
        kilo = 1024 if &#39;I&#39; in unit else 1000
        if n := match[&#39;flt&#39;]:
            base = float(n)
        if n := match[&#39;int&#39;]:
            base = int(n, 0)
        return int(base * (kilo ** step))
    if variables is not None:
        return PythonExpression.Evaluate(expression, variables)
    if (parser := PythonExpression.Lazy(expression)).variables:
        def evaluate(data: Chunk):
            try:
                result = parser(metavars(data))
            except ParserVariableMissing:
                # It is possible that a byte string can accidentally look like a valid Python
                # expression, e.g.: B0fGtH*9/HKlwT:
                definition = parser.definition
                if isinstance(definition, str):
                    definition = definition.encode(&#39;utf8&#39;)
                return definition
            else:
                return result
        return evaluate
    else:
        return parser()</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.numseq"><code class="name flex">
<span>def <span class="ident">numseq</span></span>(<span>expression, reverse=False, seed=None, typecheck=True)</span>
</code></dt>
<dd>
<section class="desc"><p>This is the argument parser type that uses <code><a title="refinery.lib.argformats.DelayedNumSeqArgument" href="#refinery.lib.argformats.DelayedNumSeqArgument">DelayedNumSeqArgument</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1724-L1733" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def numseq(expression: int | str, reverse=False, seed=None, typecheck=True) -&gt; Iterable[int] | DelayedNumSeqArgument:
    &#34;&#34;&#34;
    This is the argument parser type that uses `refinery.lib.argformats.DelayedNumSeqArgument`.
    &#34;&#34;&#34;
    if isinstance(expression, int):
        return RepeatedInteger(expression)
    arg = DelayedNumSeqArgument(expression, reverse=reverse, seed=seed, typecheck=typecheck)
    with suppress(TooLazy):
        return arg()
    return arg</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.pathvar"><code class="name flex">
<span>def <span class="ident">pathvar</span></span>(<span>expression)</span>
</code></dt>
<dd>
<section class="desc"><p>This is the argument parser type that uses <code><a title="refinery.lib.argformats.DelayedPathArgument" href="#refinery.lib.argformats.DelayedPathArgument">DelayedPathArgument</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1736-L1743" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pathvar(expression: str) -&gt; str | DelayedArgument:
    &#34;&#34;&#34;
    This is the argument parser type that uses `refinery.lib.argformats.DelayedPathArgument`.
    &#34;&#34;&#34;
    arg = DelayedPathArgument(expression)
    with suppress(TooLazy):
        return arg()
    return arg</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.multibin"><code class="name flex">
<span>def <span class="ident">multibin</span></span>(<span>expression, reverse=False, seed=None)</span>
</code></dt>
<dd>
<section class="desc"><p>This is the argument parser type that uses <code><a title="refinery.lib.argformats.DelayedBinaryArgument" href="#refinery.lib.argformats.DelayedBinaryArgument">DelayedBinaryArgument</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1746-L1755" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def multibin(expression: str | bytes | bytearray, reverse=False, seed=None) -&gt; bytes | DelayedArgument:
    &#34;&#34;&#34;
    This is the argument parser type that uses `refinery.lib.argformats.DelayedBinaryArgument`.
    &#34;&#34;&#34;
    if not isinstance(expression, str):
        return bytes(expression)
    arg = DelayedBinaryArgument(expression, reverse, seed)
    with suppress(TooLazy):
        return arg()
    return arg</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.regexp"><code class="name flex">
<span>def <span class="ident">regexp</span></span>(<span>expression)</span>
</code></dt>
<dd>
<section class="desc"><p>This is the argument parser type that uses <code><a title="refinery.lib.argformats.DelayedRegexpArgument" href="#refinery.lib.argformats.DelayedRegexpArgument">DelayedRegexpArgument</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1758-L1765" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def regexp(expression: str) -&gt; int | bytes | DelayedRegexpArgument:
    &#34;&#34;&#34;
    This is the argument parser type that uses `refinery.lib.argformats.DelayedRegexpArgument`.
    &#34;&#34;&#34;
    arg = DelayedRegexpArgument(expression)
    with suppress(TooLazy):
        return arg()
    return arg</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.OptionFactory"><code class="name flex">
<span>def <span class="ident">OptionFactory</span></span>(<span>options, ignorecase=False)</span>
</code></dt>
<dd>
<section class="desc"><p>The factory produces an argument parser type that accepts the keys of <code>options</code>
as possible values and causes the parsed argument to contain the corresponding
value from the <code>options</code> dictionary.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1793-L1827" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def OptionFactory(options: Mapping[str, Any], ignorecase: bool = False):
    &#34;&#34;&#34;
    The factory produces an argument parser type that accepts the keys of `options`
    as possible values and causes the parsed argument to contain the corresponding
    value from the `options` dictionary.
    &#34;&#34;&#34;
    try:
        cache = OptionFactory.Cache
    except AttributeError:
        cache = OptionFactory.Cache = {}

    option_description = &#39;,&#39;.join(sorted(options))
    option_identifier = hash(option_description)

    try:
        return cache[option_identifier]
    except KeyError:
        pass

    class TheOption(Option):
        def __init__(self, name: str):
            if ignorecase and name not in options:
                needle = name.upper()
                for key in options:
                    if needle == key.upper():
                        name = key
                        break
            if name not in options:
                raise ValueError(&#39;The option {} is not one of these: {}&#39;.format(name, list(options)))
            self.mode = options[name]
            self.name = name

    TheOption.__qualname__ = F&#39;OptionFactory.Option[{option_description}]&#39;
    cache[option_identifier] = TheOption
    return TheOption</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.extract_options"><code class="name flex">
<span>def <span class="ident">extract_options</span></span>(<span>symbols, prefix, *exceptions)</span>
</code></dt>
<dd>
<section class="desc"><p>A helper function to extract all numeric constants from modules that have a certain
prefix. <code><a title="refinery.units.crypto.cipher.StandardCipherUnit" href="../units/crypto/cipher/index.html#refinery.units.crypto.cipher.StandardCipherUnit">StandardCipherUnit</a></code> uses this to extract the
block cipher modes of operation from block cipher modules of the <code>pycryptodome</code> library.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1830-L1842" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def extract_options(symbols, prefix: str, *exceptions: str):
    &#34;&#34;&#34;
    A helper function to extract all numeric constants from modules that have a certain
    prefix. `refinery.units.crypto.cipher.StandardCipherUnit` uses this to extract the
    block cipher modes of operation from block cipher modules of the `pycryptodome` library.
    &#34;&#34;&#34;
    candidates = {
        k[len(prefix):]: getattr(symbols, k, None)
        for k in dir(symbols) if k.startswith(prefix) and all(
            e not in k for e in exceptions
        )
    }
    return {k: v for k, v in candidates.items() if isinstance(v, int)}</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.pending"><code class="name flex">
<span>def <span class="ident">pending</span></span>(<span>argument)</span>
</code></dt>
<dd>
<section class="desc"><p>This function returns a boolean value which indicates whether the given
argument is a <code><a title="refinery.lib.argformats.LazyEvaluation" href="#refinery.lib.argformats.LazyEvaluation">LazyEvaluation</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1845-L1852" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pending(argument: Any | Iterable[Any]) -&gt; bool:
    &#34;&#34;&#34;
    This function returns a boolean value which indicates whether the given
    argument is a `refinery.lib.argformats.LazyEvaluation`.
    &#34;&#34;&#34;
    if isinstance(argument, (list, tuple)):
        return any(pending(x) for x in argument)
    return isinstance(argument, LazyEvaluation)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.manifest"><code class="name flex">
<span>def <span class="ident">manifest</span></span>(<span>argument, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the manifestation of a <code><a title="refinery.lib.argformats.LazyEvaluation" href="#refinery.lib.argformats.LazyEvaluation">LazyEvaluation</a></code>
on the given data. This function can change the data.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1855-L1862" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def manifest(argument: Any | list[Any], data: bytearray) -&gt; Any | list[Any]:
    &#34;&#34;&#34;
    Returns the manifestation of a `refinery.lib.argformats.LazyEvaluation`
    on the given data. This function can change the data.
    &#34;&#34;&#34;
    if isinstance(argument, (list, tuple)):
        return [manifest(x, data) for x in argument]
    return argument(data) if isinstance(argument, LazyEvaluation) else argument</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.argformats.ParserError"><code class="flex name class">
<span>class <span class="ident">ParserError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>An exception raised by the <code><a title="refinery.lib.argformats.PythonExpression" href="#refinery.lib.argformats.PythonExpression">PythonExpression</a></code> parser.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L148-L151" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ParserError(ArgumentTypeError):
    &#34;&#34;&#34;
    An exception raised by the `refinery.lib.argformats.PythonExpression` parser.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>argparse.ArgumentTypeError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.argformats.ParserVariableMissing" href="#refinery.lib.argformats.ParserVariableMissing">ParserVariableMissing</a></li>
</ul>
</dd>
<dt id="refinery.lib.argformats.ParserVariableMissing"><code class="flex name class">
<span>class <span class="ident">ParserVariableMissing</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Raised when the <code><a title="refinery.lib.argformats.PythonExpression" href="#refinery.lib.argformats.PythonExpression">PythonExpression</a></code> parser fails to evaluate an
expression because of a missing variable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L154-L158" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ParserVariableMissing(ParserError):
    &#34;&#34;&#34;
    Raised when the `refinery.lib.argformats.PythonExpression` parser fails to evaluate an
    expression because of a missing variable.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.argformats.ParserError" href="#refinery.lib.argformats.ParserError">ParserError</a></li>
<li>argparse.ArgumentTypeError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.argformats.LazyEvaluation"><code class="flex name class">
<span>class <span class="ident">LazyEvaluation</span></span>
</code></dt>
<dd>
<section class="desc"><p>Empty parent class for any parse result that throws <code><a title="refinery.lib.argformats.TooLazy" href="#refinery.lib.argformats.TooLazy">TooLazy</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L161-L164" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LazyEvaluation:
    &#34;&#34;&#34;
    Empty parent class for any parse result that throws `refinery.lib.argformats.TooLazy`.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></li>
<li><a title="refinery.lib.argformats.SliceAgain" href="#refinery.lib.argformats.SliceAgain">SliceAgain</a></li>
</ul>
</dd>
<dt id="refinery.lib.argformats.PythonExpression"><code class="flex name class">
<span>class <span class="ident">PythonExpression</span></span>
<span>(</span><span>definition, *variables, constants=None, all_variables_allowed=False, modulus=None, mask=-1)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements a parser for any Python expression with a prescribed set of variable names permitted
to occur in the expression. The resulting object is a callable which can be given the string
representation of such an expression. In turn, the result of this operation is either the value
of the expression if no variables were present, or a callable which expects keyword arguments
corresponding to the permitted variable names.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L167-L272" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PythonExpression:
    &#34;&#34;&#34;
    Implements a parser for any Python expression with a prescribed set of variable names permitted
    to occur in the expression. The resulting object is a callable which can be given the string
    representation of such an expression. In turn, the result of this operation is either the value
    of the expression if no variables were present, or a callable which expects keyword arguments
    corresponding to the permitted variable names.
    &#34;&#34;&#34;
    def __init__(self, definition: str | buf, *variables, constants=None, all_variables_allowed=False, modulus=None, mask=-1):
        if not isinstance(definition, str):
            definition = codecs.decode(definition, &#39;utf8&#39;)
        self.definition = definition = definition.strip()
        constants = constants or {}
        variables = set(variables) | set(constants)
        try:
            expression = ast.parse(definition, mode=&#39;eval&#39;)
        except Exception as error:
            raise ParserError(F&#39;The provided expression could not be parsed: {definition!s}; {exception_to_string(error)}&#39;)

        if mask &gt; 0 and modulus is not None:
            raise ValueError(&#39;Cannot specify both modulus and mask.&#39;)

        class Postprocessor(ast.NodeTransformer):
            def visit_Constant(self, node: ast.Constant):
                if not isinstance(node.value, str):
                    return node
                return ast.Constant(value=node.value.encode(&#39;utf8&#39;))

            def visit_MatMult(self, node: ast.MatMult) -&gt; Any:
                return ast.BitXor()

            def visit_BinOp(self, node: ast.BinOp) -&gt; Any:
                self.generic_visit(node)
                if not isinstance(node.op, (ast.Add, ast.Mult, ast.Sub, ast.LShift, ast.Pow)):
                    return node
                if modulus is not None:
                    return ast.BinOp(node, ast.Mod(), ast.Constant(modulus))
                elif mask &gt; 0:
                    return ast.BinOp(node, ast.BitAnd(), ast.Constant(mask))
                else:
                    return node

            def visit_UnaryOp(self, node: ast.UnaryOp) -&gt; Any:
                self.generic_visit(node)
                if not isinstance(node.op, (ast.UAdd, ast.USub, ast.Invert)):
                    return node
                if modulus is not None:
                    return ast.BinOp(node, ast.Mod(), ast.Constant(modulus))
                elif mask &gt; 0:
                    return ast.BinOp(node, ast.BitAnd(), ast.Constant(mask))
                else:
                    return node

        expression = ast.fix_missing_locations(Postprocessor().visit(expression))
        nodes = ast.walk(expression)

        try:
            if type(next(nodes)) != ast.Expression:
                raise ParserError(F&#39;Unknown error parsing the expression: {definition!s}&#39;)
        except StopIteration:
            raise ParserError(&#39;The input string is not a Python expression.&#39;)

        names = {node for node in nodes if isinstance(node, ast.Name)}
        names = {node.id for node in names} - {node.id for node in names if isinstance(node.ctx, ast.Store)}
        names.difference_update(dir(builtins))
        names.difference_update(globals())
        if not all_variables_allowed and not names &lt;= variables:
            raise ParserVariableMissing(
                &#39;the following variable names are unknown: {}&#39;.format(&#39;, &#39;.join(names - variables)))

        self.variables = names
        self.constants = constants
        self.expression = compile(expression, &#39;&lt;string&gt;&#39;, &#39;eval&#39;)

    def __str__(self):
        return self.definition

    def __call__(self, mapping: dict | None = None, **values):
        if mapping is not None:
            values, tmp = mapping, values
            values.update(tmp)
        variables = dict(values)
        for v in self.variables.difference(variables):
            try:
                variables[v] = values[v]
            except KeyError:
                raise ParserVariableMissing(v)
        variables.update(self.constants)
        return eval(self.expression, None, variables)

    @classmethod
    def Lazy(cls, definition: str):
        return cls(definition, all_variables_allowed=True)

    @classmethod
    def Evaluate(cls, definition: str, values: dict):
        &#34;&#34;&#34;
        Creates a new `refinery.lib.argformats.PythonExpression` object based on `definition` and
        evaluates it based on the variable mapping `values`. If a variable used in the expression
        is missing, a `refinery.lib.argformats.ParserVariableMissing` exception is raised.
        &#34;&#34;&#34;
        expression = cls(definition, all_variables_allowed=True)
        for name in expression.variables:
            if name not in values:
                raise ParserVariableMissing(name)
        return expression(values)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.argformats.PythonExpression.Lazy"><code class="name flex">
<span>def <span class="ident">Lazy</span></span>(<span>definition)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="refinery.lib.argformats.PythonExpression.Evaluate"><code class="name flex">
<span>def <span class="ident">Evaluate</span></span>(<span>definition, values)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new <code><a title="refinery.lib.argformats.PythonExpression" href="#refinery.lib.argformats.PythonExpression">PythonExpression</a></code> object based on <code>definition</code> and
evaluates it based on the variable mapping <code>values</code>. If a variable used in the expression
is missing, a <code><a title="refinery.lib.argformats.ParserVariableMissing" href="#refinery.lib.argformats.ParserVariableMissing">ParserVariableMissing</a></code> exception is raised.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.argformats.SliceAgain"><code class="flex name class">
<span>class <span class="ident">SliceAgain</span></span>
<span>(</span><span>expr, intok=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Raised by <code><a title="refinery.lib.argformats.sliceobj" href="#refinery.lib.argformats.sliceobj">sliceobj()</a></code> to indicate that meta variables are required to
compute this slice.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L275-L288" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SliceAgain(LazyEvaluation):
    &#34;&#34;&#34;
    Raised by `refinery.lib.argformats.sliceobj` to indicate that meta variables are required to
    compute this slice.
    &#34;&#34;&#34;
    def __init__(self, expr: DelayedBinaryArgument | str, intok: bool = False):
        self.expr = expr
        self.intok = intok

    def __call__(self, data):
        expression = self.expr
        if pending(expression):
            expression = expression(data).decode(&#39;utf8&#39;)
        return sliceobj(expression, data, intok=self.intok)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.argformats.LazyEvaluation" href="#refinery.lib.argformats.LazyEvaluation">LazyEvaluation</a></li>
</ul>
</dd>
<dt id="refinery.lib.argformats.IncompatibleHandler"><code class="flex name class">
<span>class <span class="ident">IncompatibleHandler</span></span>
<span>(</span><span>type_expected, type_observed, modifier)</span>
</code></dt>
<dd>
<section class="desc"><p>This exception is generated when <code><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></code> handlers
are chained in an incompatible way.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L415-L429" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IncompatibleHandler(ArgumentTypeError):
    &#34;&#34;&#34;
    This exception is generated when `refinery.lib.argformats.DelayedArgument` handlers
    are chained in an incompatible way.
    &#34;&#34;&#34;
    def __init__(self, type_expected, type_observed, modifier):
        self.type_expected = type_expected
        self.type_observed = type_observed
        self.modifier = modifier
        modifier_name = F&#39;handler {modifier}&#39; if modifier else &#39;default handler&#39;
        super().__init__(&#39;{} received {} but expected {}&#39;.format(
            modifier_name,
            type_observed.__name__,
            type_expected.__name__
        ))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>argparse.ArgumentTypeError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.argformats.TooLazy"><code class="flex name class">
<span>class <span class="ident">TooLazy</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Exception which indicates that an argument parser requires input data before it can be
evaluated.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L432-L436" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TooLazy(Exception):
    &#34;&#34;&#34;
    Exception which indicates that an argument parser requires input data before it can be
    evaluated.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.argformats.VariableMissing"><code class="flex name class">
<span>class <span class="ident">VariableMissing</span></span>
<span>(</span><span>name)</span>
</code></dt>
<dd>
<section class="desc"><p>Exception which indicates that a <code><a title="refinery.lib.meta" href="meta.html">refinery.lib.meta</a></code> variable was missing during evaluation
of a Python expression.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L439-L446" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class VariableMissing(ArgumentTypeError):
    &#34;&#34;&#34;
    Exception which indicates that a `refinery.lib.meta` variable was missing during evaluation
    of a Python expression.
    &#34;&#34;&#34;
    def __init__(self, name):
        super().__init__(F&#39;The variable {name} is not defined.&#39;)
        self.name = name</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>argparse.ArgumentTypeError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.argformats.DelayedArgumentDispatch"><code class="flex name class">
<span>class <span class="ident">DelayedArgumentDispatch</span></span>
<span>(</span><span>method)</span>
</code></dt>
<dd>
<section class="desc"><p>This class is used as a decorator for the default handler of classes that inherit from
<code><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></code>. After decorating the routine <code>handler</code> with
<code><a title="refinery.lib.argformats.DelayedArgumentDispatch" href="#refinery.lib.argformats.DelayedArgumentDispatch">DelayedArgumentDispatch</a></code>, <code>handler.register</code> can be used to
register additional handlers.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L506-L507" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def __get__(self, instance, t=None):
    return self.Wrapper(self, instance)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.argformats.DelayedArgumentDispatch.Wrapper"><code class="name">var <span class="ident">Wrapper</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="refinery.lib.argformats.DelayedArgumentDispatch.Inherit"><code class="name flex">
<span>def <span class="ident">Inherit</span></span>(<span>parent)</span>
</code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.argformats.DelayedArgumentDispatch.can_handle"><code class="name flex">
<span>def <span class="ident">can_handle</span></span>(<span>self, modifier, *args)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L531-L532" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def can_handle(self, modifier, *args):
    return modifier in self.handlers or bool(self._get_unit(modifier, *args))</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgumentDispatch.terminates"><code class="name flex">
<span>def <span class="ident">terminates</span></span>(<span>self, modifier)</span>
</code></dt>
<dd>
<section class="desc"><p>Indicates whether the given registered modifier is final.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L534-L538" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def terminates(self, modifier):
    &#34;&#34;&#34;
    Indicates whether the given registered modifier is final.
    &#34;&#34;&#34;
    return self.final.get(modifier, False)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgumentDispatch.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, *modifiers, final=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Registers a new modifier handler.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L540-L549" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def register(self, *modifiers, final=False):
    &#34;&#34;&#34;
    Registers a new modifier handler.
    &#34;&#34;&#34;
    def _register(method):
        for modifier in modifiers:
            self.handlers[modifier] = method
            self.final[modifier] = final
        return method
    return _register</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument"><code class="flex name class">
<span>class <span class="ident">DelayedArgument</span></span>
<span>(</span><span>expression, reverse=False, seed=None)</span>
</code></dt>
<dd>
<section class="desc"><p>This base class for delayed argument parsers implements parsing expressions into supported modifiers.
When <code>reverse</code> is set to <code>True</code>, the multibin expression is expected to have suffixes for handlers
rather than prefixes. If the <code>seed</code> value is specified, the expression is expected to only contain
a chain of handlers, and the given seed will be used as the initial value to be passed to them.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L594-L1436" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DelayedArgument(LazyEvaluation):
    &#34;&#34;&#34;
    This base class for delayed argument parsers implements parsing expressions into supported modifiers.
    When `reverse` is set to `True`, the multibin expression is expected to have suffixes for handlers
    rather than prefixes. If the `seed` value is specified, the expression is expected to only contain
    a chain of handlers, and the given seed will be used as the initial value to be passed to them.
    &#34;&#34;&#34;
    _ARG_BEGIN_TOKEN = &#39;[&#39;
    _ARG_CLOSE_TOKEN = &#39;]&#39;
    _ARG_SPLIT_TOKEN = &#39;,&#39;
    _CMD_SPLIT_TOKEN = &#39;:&#39;

    def __init__(self, expression: str, reverse: bool = False, seed=None):
        requires_seed = seed is None
        self.expression = expression
        self.modifiers = []
        self.finalized = False
        while not self.finalized:
            name, arguments, newexpr = self._split_modifier(
                expression,
                reverse,
                requires_seed,
            )
            if not name or not self.handler.can_handle(name, *arguments):
                break
            self.modifiers.append((name, arguments))
            expression = newexpr
            if self.handler.terminates(name):
                self.finalized = True
        if self.finalized:
            if not expression and seed is not None:
                expression = seed
            self.seed = expression
        elif not requires_seed:
            if expression:
                rt = &#39;reverse &#39; if reverse else &#39;&#39;
                raise ValueError(F&#39;{rt}expression {self.expression} with seed {seed} was not fully parsed.&#39;)
            self.seed = seed
        else:
            self.seed = expression
        self.modifiers.reverse()

    def _split_expression(self, expression: str, reverse: bool = False) -&gt; tuple[str, str | None]:
        argument_list_visited = False
        brackets = 0
        inc = self._ARG_BEGIN_TOKEN
        dec = self._ARG_CLOSE_TOKEN
        itx = enumerate(expression)
        if reverse:
            inc, dec = dec, inc
            itx = reversed(list(itx))
        for k, character in itx:
            if character == inc:
                if not brackets:
                    if argument_list_visited:
                        # This is the second time we encounter what appears to be an
                        # argument list, before the modifier has ended. This is not
                        # possible, and we decide to assume that no modifier was used.
                        break
                    argument_list_visited = True
                brackets += 1
                continue
            if character == dec:
                if not brackets:
                    break
                brackets -= 1
                continue
            if not brackets and character == self._CMD_SPLIT_TOKEN:
                head = expression[:k]
                tail = expression[k + 1:]
                return (head, tail) if reverse else (tail, head)
        return expression, None

    def _split_modifier(
        self,
        sequence: str,
        reverse: bool = False,
        requires_seed: bool = True,
    ) -&gt; tuple[str | None, tuple[str, ...], str]:
        brackets = 0
        name = None
        argoffset = 0
        arguments = ()

        rest, expression = self._split_expression(sequence, reverse)

        if expression is None:
            if requires_seed:
                return name, arguments, rest
            expression, rest = rest, &#39;&#39;

        name = expression

        for k, character in enumerate(expression):
            if character == self._ARG_BEGIN_TOKEN:
                if not brackets:
                    if argoffset:
                        raise ArgumentTypeError(F&#39;Unexpected error parsing &#34;{expression}&#34;: Double argument list.&#39;)
                    name = expression[:k]
                    argoffset = k + 1
                brackets += 1
                continue
            if character == self._ARG_CLOSE_TOKEN:
                if brackets == 1:
                    arguments += expression[argoffset:k],
                elif not brackets:
                    if argoffset:
                        raise ArgumentTypeError(F&#39;Unable to parse &#34;{expression}&#34;: Too many closing brackets.&#39;)
                    else:
                        break
                brackets -= 1
                continue
            if character == self._ARG_SPLIT_TOKEN:
                if brackets == 1:
                    arguments += expression[argoffset:k],
                    argoffset = k + 1
            if character == self._CMD_SPLIT_TOKEN and not brackets:
                raise ArgumentTypeError(F&#39;Unexpected error parsing &#34;{expression}&#34;.&#39;)
        return name, arguments, rest

    def __call__(self, data: buf | None = None) -&gt; bytes:
        arg = self.seed
        mod = iter(self.modifiers)
        if not self.finalized:
            mod = itertools.chain(((None, ()),), mod)
        for name, arguments in mod:
            if isbuffer(arg):
                arg = Chunk(arg)
                with suppress(AttributeError):
                    arg.meta.update(data.meta)
            try:
                arg = self.handler(arg, name, *arguments)
            except VariableMissing as v:
                if data is not None:
                    raise
                raise TooLazy from v
            except AttributeError as AE:
                raise ArgumentTypeError(F&#39;failed to apply modifier {name} to incoming data: {AE}&#39;) from AE
            if callable(arg):
                if data is None:
                    raise TooLazy
                arg = arg(data)
        return arg

    def __eq__(self, other):
        if isinstance(other, DelayedArgument):
            return other.expression == self.expression
        try:
            # Try to realize on a completely empty chunk of data. If the result equals the
            # other object, we are likely identical and we were too cautious when delaying.
            value = self(B&#39;&#39;)
        except Exception:
            return False
        else:
            return value == other

    def default_handler(self, expression: str) -&gt; bytes:
        try:
            return open(expression, &#39;rb&#39;).read()
        except Exception:
            pass
        try:
            return utf8(expression)
        except Exception:
            return expression

    @DelayedArgumentDispatch
    def handler(self, expression) -&gt; bytes:
        return self.default_handler(expression)

    @handler.register(&#39;s&#39;, &#39;S&#39;, final=True)
    def s(self, string: str) -&gt; bytes:
        &#34;&#34;&#34;
        The final modifier `s:string` returns the UTF-8 encoded representation of `string`.
        &#34;&#34;&#34;
        return string.encode(&#39;UTF8&#39;)

    @handler.register(&#39;u&#39;, &#39;U&#39;, final=True)
    def u(self, string: str) -&gt; bytes:
        &#34;&#34;&#34;
        The final modifier `u:string` returns the UTF16 (little endian without BOM) encoded
        representation of `string`.
        &#34;&#34;&#34;
        return string.encode(&#39;UTF-16LE&#39;)

    @handler.register(&#39;a&#39;, &#39;A&#39;, final=True)
    def a(self, string: str) -&gt; bytes:
        &#34;&#34;&#34;
        The final modifier `a:string` returns the latin-1 encoded representation of `string`.
        &#34;&#34;&#34;
        return string.encode(&#39;LATIN-1&#39;)

    @handler.register(F&#39;{_REVERSE_SIGN}h&#39;, F&#39;{_REVERSE_SIGN}H&#39;)
    def bang_h(self, string: bytes) -&gt; bytes:
        F&#34;&#34;&#34;
        The modifier `{_REVERSE_SIGN}h` (or `{_REVERSE_SIGN}H`) encodes the input as hexadecimal.
        &#34;&#34;&#34;
        import base64
        return base64.b16encode(string)

    @handler.register(&#39;h&#39;, &#39;H&#39;, final=True)
    def h(self, string: str) -&gt; bytes:
        &#34;&#34;&#34;
        The final modifier `h:string` (or `H:string`) returns the hex decoding of `string`.
        &#34;&#34;&#34;
        import base64
        return base64.b16decode(string, casefold=True)

    @handler.register(&#39;n&#39;)
    def n(self, string: bytes) -&gt; bytes:
        &#34;&#34;&#34;
        The final modifier `n:string` returns the un-escaped version of a string containing
        backslash escape sequences.
        &#34;&#34;&#34;
        from refinery.units.encoding.esc import esc
        return esc().process(string)

    @handler.register(F&#39;{_REVERSE_SIGN}n&#39;)
    def bang_n(self, string: bytes) -&gt; bytes:
        F&#34;&#34;&#34;
        The modifier `{_REVERSE_SIGN}n:string` returns an escaped and quoted version of the
        input string.
        &#34;&#34;&#34;
        from refinery.units.encoding.esc import esc
        return esc(quoted=True).reverse(string)

    @handler.register(&#39;q&#39;, &#39;Q&#39;, final=True)
    def q(self, string: str) -&gt; bytes:
        &#34;&#34;&#34;
        The final modifier `q:string` (or `Q:string`) returns the url-quote decoding of `string`.
        &#34;&#34;&#34;
        import urllib.parse
        return urllib.parse.unquote_to_bytes(string)

    @handler.register(&#39;read&#39;, final=True)
    def read(self, path: str, region: str = &#39;&#39;) -&gt; bytes:
        &#34;&#34;&#34;
        Returns the contents of the file located at the given path. This path may contain
        wildcard characters, but this pattern has to match a single file. It is also possible
        to use the handler as `read[count]` or as `read[offset:count]` to read `count` many
        bytes from the file at the given offset.
        &#34;&#34;&#34;
        return self._file(path, region)

    @handler.register(&#39;readfrom&#39;)
    def readfrom(self, path: bytes, region: str = &#39;&#39;) -&gt; bytes:
        &#34;&#34;&#34;
        A non-final variant of the `refinery.lib.argformats.DelayedArgument.read` handler. This
        handler should only be used to read from path names that were the result of a previous
        handler. Using `readfrom:sample.bin` will cause an error: Since `readfrom` is not final,
        the default handler will be applied to `sample.bin`, feeding the binary contents of the
        file into `readfrom`, but the handler is expecting a path name.
        &#34;&#34;&#34;
        try:
            path = path.decode(&#39;utf8&#39;)
        except UnicodeDecodeError:
            raise ArgumentTypeError(
                &#39;The input for the readfrom handler was not a path. Consider using the read &#39;
                &#39;handler instead, which is final.&#39;)
        else:
            return self._file(path, region)

    def _file(self, pattern: str, region: str) -&gt; bytes | None:
        def read(data: Chunk | None = None):
            if not region:
                k = slice(0, None)
            else:
                k = sliceobj(region, data, intok=True)
            if isinstance(k, SliceAgain):
                raise TooLazy
            if isinstance(k, int):
                offset = 0
                length = k
            else:
                if k.step and k.step != 1:
                    raise ValueError(&#39;Step size is not supported for file slices.&#39;)
                offset = k.start or 0
                length = k.stop
            if length and length &lt; 0:
                raise ValueError(&#39;The count for a read operation must be non-negative.&#39;)
            with open(path, &#39;rb&#39;) as stream:
                stream.seek(offset)
                return stream.read(length)
        try:
            path: Path = one(Path.cwd().glob(pattern))
        except (NotImplementedError, LookupError):
            path: Path = Path(pattern)
        try:
            return read()
        except FileNotFoundError:
            raise ArgumentTypeError(F&#39;File not found: {pattern}&#39;)
        except Exception:
            return read

    @handler.register(&#39;range&#39;, final=True)
    def range(self, region: str) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        Implements the final modifier `range:bounds` to generate a sequence of bytes, where
        `bounds` is parsed as a `refinery.lib.argformats.sliceobj` with one exception: If
        `bounds` is just a single integer, it is interpreted as the upper bound for a sequence
        of bytes starting at zero.
        &#34;&#34;&#34;
        def compute_range(data: Chunk | None = None):
            try:
                s = sliceobj(region, data, intok=True)
            except ParserVariableMissing:
                raise TooLazy
            if isinstance(s, SliceAgain):
                raise TooLazy
            if isinstance(s, int):
                s = slice(None, s, None)
            result = bounds[s]
            result.max -= 1
            if 0 &lt;= result.min and result.max &lt;= 0x100:
                result = bytearray(result)
            return result
        try:
            return compute_range()
        except TooLazy:
            return compute_range

    @handler.register(&#39;env&#39;, final=True)
    def env(self, name: str) -&gt; bytes:
        &#34;&#34;&#34;
        The final modifier `env:name` returns the UTF8-encoded value of the environment variable
        with the given name.
        &#34;&#34;&#34;
        import os
        return os.environ[name]

    @handler.register(&#39;pos&#39;)
    def pos(self, regex: buf, occurrence: int = 0) -&gt; int:
        &#34;&#34;&#34;
        The handler pos[k=0]:[regex] returns the position of the k-th occurrence of the regular
        expression [regex]. The value `k` can be set to `-1` to return the position of the last
        match. If `k` is a negative value, then the handler returns the offset at the end of the
        match rather than the one at the beginning. If no match is found, the handler returns
        the value `-1`.
        &#34;&#34;&#34;
        if isinstance(occurrence, str):
            occurrence = int(occurrence, 0)

        def _pos(data: bytearray) -&gt; int:
            it: Iterable[re.Match] = re.finditer(bytes(regex), data, flags=re.DOTALL)

            if occurrence &lt; 0:
                from collections import deque
                matches: Deque[re.Match] = deque()
                while len(matches) &lt; -occurrence:
                    try:
                        matches.append(next(it))
                    except StopIteration:
                        return -1
                for match in it:
                    matches.append(match)
                    matches.popleft()
                return matches[0].end()
            else:
                for k, match in enumerate(it):
                    if k == occurrence:
                        return match.start()
                else:
                    return -1

        return _pos

    @handler.register(&#39;rx&#39;)
    def rx(self, string: bytes) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `rx:str` returns a regular expression which matches the exact string
        sequence given by `str`, with special regular expression control characters escaped.
        &#34;&#34;&#34;
        return re.escape(string)

    @handler.register(&#39;c&#39;, &#39;copy&#39;, final=True)
    def copy(self, region: str) -&gt; bytes:
        &#34;&#34;&#34;
        Implements the final modifier `copy:start[:length[:step]]`. It copies `length` bytes
        from the input using step size `step` at offset `start`. If length is not given, it
        defaults to the input length. If step is not given, it defaults to 1.
        &#34;&#34;&#34;
        def _copy(data: bytearray):
            bounds = relslice(region, data)
            return data[bounds]
        return _copy

    @handler.register(&#39;x&#39;, &#39;cut&#39;, final=True)
    def cut(self, region: str) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `cut:region` work like `refinery.lib.argformats.DelayedBinaryArgument.copy`,
        but the bytes are removed from the input data after copying them.
        &#34;&#34;&#34;
        def _cut(data: bytearray | Chunk):
            bounds = relslice(region, data)
            result = bytearray(data[bounds])
            del data[bounds]
            return result
        return _cut

    @handler.register(&#39;pd&#39;)
    def pd(self, input: bytes, region: slice | str = slice(1, None, 1), separator: bytes = B&#39;/&#39;) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `pd[region=1:,sep=/]:input` splits the input at the given string `sep`
        and reverses the sequence. Parts are then selected according to the `region` parameter,
        which can be any expression in Python slice syntax. Afterwards, the resulting sequence
        is reversed again and joined at the `sep` parameter. For example, the expression

            pd[2:]:/path/to/some/item/and/more

        will return the string `/path/to/some/item`.
        &#34;&#34;&#34;
        def _pd(data: Chunk | None = None):
            b: slice = sliceobj(region, data=data, final=True)
            pd = input.split(separator)
            pd.reverse()
            pd = pd[b]
            pd.reverse()
            return separator.join(pd)
        try:
            return _pd()
        except TooLazy:
            return _pd

    @handler.register(&#39;pb&#39;)
    def pb(self, input: bytes, separator: bytes = B&#39;/&#39;) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `pb:input` is equivalent to `pd[:1]:input` and corresponds to &#34;basename&#34;.
        &#34;&#34;&#34;
        return self.pd(input, slice(0, 1, 1), separator=separator)

    @handler.register(&#39;pn&#39;)
    def pn(self, path: str | bytes) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `pn:/path/to/file.ext` returns `/path/to/file`, i.e. the path without its
        extension. The handler name is short for &#34;path name&#34;. If the last part does not have
        any extension, the input path is returned unchanged.
        &#34;&#34;&#34;
        if not isinstance(path, str):
            path = path.decode(&#39;utf8&#39;)
        return Path(path).with_suffix(&#39;&#39;).as_posix().encode()

    @handler.register(&#39;px&#39;)
    def px(self, path: str | bytes) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `px:/path/to/file.ext` returns `ext`, i.e. the extension extension. The
        handler name is short for &#34;path eXtension&#34;.
        &#34;&#34;&#34;
        if not isinstance(path, str):
            path = path.decode(&#39;utf8&#39;)
        return Path(path).suffix[1:].encode()

    def _interpret_variable(self, name: str, obj: Any):
        if isbuffer(obj) or isinstance(obj, int) or obj is None:
            return obj
        if isinstance(obj, str):
            return utf8(obj)
        if isinstance(obj, (tuple, set, frozenset)):
            obj = list(obj)
        if isinstance(obj, list):
            return obj
        raise ArgumentTypeError(F&#39;The meta variable {name} is of type {type(obj).__name__} and no conversion is known.&#39;)

    def _var(self, name: str, eat: bool) -&gt; bytes:
        if not is_valid_variable_name(name, allow_wildcards=True):
            name = multibin(name)

        def extract(data: Chunk):
            var = name(data) if callable(name) else name
            if not isinstance(var, str):
                if not isinstance(var, bytes):
                    var = bytes(var)
                var = var.decode()
            meta = metavars(data)
            if var not in meta:
                from fnmatch import fnmatch as matches
                options = [name for name in meta.keys() if matches(name, var)]
                if len(options) == 1:
                    var = options[0]
            try:
                if eat:
                    result = meta.pop(var)
                else:
                    result = meta[var]
            except KeyError as KE:
                raise VariableMissing(var) from KE
            return self._interpret_variable(name, result)

        return extract

    @handler.register(&#39;v&#39;, &#39;var&#39;, final=True)
    def var(self, name: str) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `var:name` contains the value of the meta variable `name`. This handler is semi-final;
        if the provided argument is an identifier pattern, it is read directly as a variable name. Otherwise,
        it will be interpreted as a multibin expression to compute the name. An identifier pattern here is
        a unix file name pattern including the wildcards `?`, `*`, and letter options in `[` brackets `]`.
        &#34;&#34;&#34;
        return self._var(name, eat=False)

    @handler.register(&#39;eat&#39;, final=True)
    def eat(self, name: str) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `eat:name` works exactly like `var:name` with the exception that the variable is removed
        from the chunk after evaluation.
        &#34;&#34;&#34;
        return self._var(name, eat=True)

    @handler.register(&#39;e&#39;, &#39;E&#39;, &#39;eval&#39;)
    def eval(self, expression) -&gt; Any:
        &#34;&#34;&#34;
        Final modifier `e:expression` or `eval:expression`; uses a `refinery.lib.argformats.PythonExpression`
        parser to process expressions. The expression can contain any meta variable that is attached to the
        chunk. The `refinery.cm` unit can be used to attach information such as chunk size and the chunk
        index within the current frame (see `refinery.lib.frame`).
        &#34;&#34;&#34;
        if isbuffer(expression):
            expression = expression.decode(&#39;utf8&#39;)
        if not isinstance(expression, str):
            return expression
        return LazyPythonExpression(expression)

    @handler.register(&#39;btoi&#39;)
    def btoi(self, binary: buf, size=None, step=None) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        The modifier `btoi[size=0,step=0]:data` uses `refinery.lib.chunks.unpack` to convert a
        sequence of bytes into a sequence of integers.

        The optional parameter `size` has to be an integer expression whose absolute value gives
        the size of each encoded number in bytes. Its default value is `0`, which corresponds to
        choosing the size automatically in the following manner: If the length of the buffer is
        uneven, the value 1 is chosen. If the length modulo 4 is nonzero, the value 2 is chosen. If
        the length is divisible by 4, then 4 is chosen. To unpack as big endian as opposed to the
        default little endian, a negative value for `size` has to be specified. The absolute value
        of `size` will be used.

        By default, integers are parsed from the input buffer at offsets that are integer multiples
        of the block size. The optional parameter `step` can be used to override this behavior. For
        example, `btoi[2,1]` can be used to read 16-bit values at each byte offset.
        &#34;&#34;&#34;
        from refinery.lib import chunks
        size = int(size, 0) if size else 0
        step = int(step, 0) if step else 0
        bigE = size &lt; 0
        size = abs(size)
        if not size:
            n = len(binary)
            if n % 2:
                size = 1
            elif n % 4:
                size = 2
            else:
                size = 4
        return list(chunks.unpack(binary, size, bigE, step))

    @handler.register(&#39;itob&#39;)
    def itob(self, integers: Iterable[int], size=None) -&gt; buf:
        &#34;&#34;&#34;
        The modifier `itob[size=0]:integers` is the inverse of `btoi` and works in the same way,
        except that the case `size=0` is handled in the following way: The handler inspects all
        integers in the input and determines the minimum block size required to pack all of them.
        &#34;&#34;&#34;
        from refinery.lib import chunks
        size = int(size, 0) if size else 0
        bigE = size &lt; 0
        size = abs(size)
        if not size:
            def byte_length(n: int):
                width, overflow = divmod(n.bit_length(), 8)
                width += bool(overflow)
                return width
            if not isinstance(integers, list):
                integers = list(integers)
            size = max((byte_length(n) for n in integers), default=1)
            size = max(size, 1)
        else:
            mask = (1 &lt;&lt; (size * 8)) - 1
            integers = (integer &amp; mask for integer in integers)
        return chunks.pack(integers, size, bigE)

    @handler.register(&#39;inc&#39;)
    def inc(self, it: Iterable[int], precision=None) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        The modifier `inc:it` or `inc[N=64]:it` expects a sequence `it` of integers (a binary
        string is interpreted as the sequence of its byte values), iterates it cyclically and
        perpetually adds an increasing counter to the result. If the number `N` is nonzero, then
        the counter is limited to `N` bits.
        &#34;&#34;&#34;
        precision = precision and int(precision, 0) or _DEFAULT_BITS
        it = infinitize(it)
        if precision:
            def delay(_):
                mask = (1 &lt;&lt; precision) - 1
                for a, b in zip(it, itertools.cycle(range(mask + 1))):
                    yield a + b &amp; mask
        else:
            def delay(_):
                for a, b in zip(it, itertools.count()):
                    yield a + b
        return delay

    @handler.register(&#39;dec&#39;)
    def dec(self, it: Iterable[int], precision=None) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        Identical to `refinery.lib.argformats.DelayedNumSeqArgument.inc`, but decreasing the counter
        rather than increasing it.
        &#34;&#34;&#34;
        precision = precision and int(precision, 0) or _DEFAULT_BITS
        it = infinitize(it)
        if precision:
            def delay(_):
                mask = (1 &lt;&lt; precision) - 1
                for a, b in zip(it, itertools.cycle(range(mask + 1))):
                    yield a - b &amp; mask
        else:
            def delay(_):
                for a, b in zip(it, itertools.count()):
                    yield a - b
        return delay

    @handler.register(&#39;take&#39;)
    def take(self, it: Iterable[int], bounds: str | None = None):
        &#34;&#34;&#34;
        The handler `take[start:stop:step]` expects an integer sequence as input and applies a slice
        to it. Slices are given in Python syntax, so `take[::2]` will extract every second item from
        the incoming data. The default sequence is `1:`, i.e. skipping the first element.
        &#34;&#34;&#34;
        def sliced(bounds):
            try:
                return it[bounds]
            except TypeError:
                subsequence = itertools.islice(it, bounds.start, bounds.stop, bounds.step)
                if bounds.stop is not None:
                    subsequence = list(subsequence)
                    if all(t in range(0x100) for t in subsequence):
                        subsequence = bytearray(subsequence)
                return subsequence
        bounds = bounds and sliceobj(bounds) or slice(1, None)
        if isinstance(bounds, slice):
            return sliced(bounds)
        return lambda d: sliced(bounds(d))

    @handler.register(&#39;cycle&#39;)
    def cycle(self, it: Iterable[int]) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        The `cycle` handler turns a finite integer sequence into an infinitely repeating integer sequence.
        &#34;&#34;&#34;
        if isinstance(it, itertools.cycle):
            return it
        return itertools.cycle(it)

    @handler.register(&#39;rng&#39;, final=True)
    def rng(
        self,
        size: str,
    ) -&gt; bytes:
        &#34;&#34;&#34;
        The `rng:count` handler generates `count` secure random bytes using the Python standard
        library module function `secrets.token_bytes`.
        &#34;&#34;&#34;
        import secrets
        size = PythonExpression.Lazy(size)
        try:
            _size = size()
        except ParserVariableMissing:
            def finalize(data):
                meta = dict(metavars(data))
                return secrets.token_bytes(size(meta))
            return finalize
        else:
            return secrets.token_bytes(_size)

    @handler.register(&#39;prng&#39;, final=True)
    def prng(
        self,
        size: str,
        seed: str | None = None
    ) -&gt; bytes:
        &#34;&#34;&#34;
        The `prng[seed]:count` handler generates `count` random bytes using Python&#39;s built-in random
        number generator. The `seed` argument can be omitted, in which case the PRNG will be seeded
        with the current timestamp in nanoseconds.
        &#34;&#34;&#34;
        import random
        import time

        try:
            randbytes = random.randbytes
        except AttributeError:
            def randbytes(n):
                return bytearray(random.randint(0, 0xFF) for _ in range(n))

        seed = time.time_ns if seed is None else PythonExpression.Lazy(seed)
        size = PythonExpression.Lazy(size)
        try:
            _size = size()
            _seed = seed()
        except ParserVariableMissing:
            def finalize(data):
                meta = dict(metavars(data))
                random.seed(seed(meta))
                return randbytes(size(meta))
            return finalize
        else:
            random.seed(_seed)
            return randbytes(_size)

    @handler.register(&#39;accu&#39;, final=True)
    def accu(
        self,
        spec: str,
        seed: str | None = None,
        skip: str | None = None,
        precision: str | None = None
    ) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        The final handler

            accu[seed=0,skip=1,precision=64]:update[#feed]

        expects `seed`, `skip`, `update`, and `feed` to be Python expressions. It generates an infinite integer
        sequence maintaining an internal state `A`: The initial value for `A` is `seed`. Each subsequent state is
        the result of evaluating the `update` expression, which can use the variable `A` to access the current
        state. The next integer value to be generated is the result of evaluating the expression `feed`, which
        may again use the variable `A` to access the internal state. If the `feed` expression is omitted, the
        complete state `A` is emitted in each step. The value of `skip` specifies the number of elements from the
        beginning of the sequence that should be skipped. The value of `precision` specifies the number of bits
        that are used by the internal state variable `A`. You can specify `precision` to be zero if you want the
        result to be an unbounded big integer.

        Instead of a Python expression, the  variable `update` can also be one of the following values, which
        are pre-defined update routines based on popular generators:

        - `@libc`: `A * 0x041C64E6D + 0x003039`
        - `@ansi`: `A * 0x041C64E6D + 0x003039 # (A &gt;&gt; 0x10)`
        - `@msvc`: `A * 0x0000343FD + 0x269EC3 # (A &gt;&gt; 0x10)`
        - `@msvb`: `A * 0x043FD43FD + 0xC39EC3`
        - `@java`: `A * 0x5DEECE66D + 0x00000B`
        - `@mmix`: `A * 6364136223846793005 + 1442695040888963407`
        &#34;&#34;&#34;
        if spec.startswith(&#39;@&#39;):
            try:
                spec = {
                    &#39;@libc&#39;: &#39;A * 0x041C64E6D + 0x003039&#39;,
                    &#39;@ansi&#39;: &#39;A * 0x041C64E6D + 0x003039 # (A &gt;&gt; 0x10)&#39;,
                    &#39;@msvc&#39;: &#39;A * 0x0000343FD + 0x269EC3 # (A &gt;&gt; 0x10)&#39;,
                    &#39;@msvb&#39;: &#39;A * 0x043FD43FD + 0xC39EC3&#39;,
                    &#39;@java&#39;: &#39;A * 0x5DEECE66D + 0x00000B&#39;,
                    &#39;@mmix&#39;: &#39;A * 6364136223846793005 + 1442695040888963407&#39;
                }[spec]
            except KeyError:
                raise ArgumentTypeError(F&#39;The generator type {spec} is unknown.&#39;)
        update, _, feed = spec.partition(&#39;#&#39;)
        update = PythonExpression.Lazy(update)
        seed = seed or &#39;0&#39;
        seed = PythonExpression.Lazy(seed)
        feed = feed and PythonExpression.Lazy(feed)
        skip = 1 if skip is None else int(skip, 0)
        precision = precision and int(precision, 0) or _DEFAULT_BITS
        mask = precision and (1 &lt;&lt; precision) - 1

        def finalize(data: Chunk | None = None):
            @lru_cache(maxsize=512, typed=False)
            def accumulate(A):
                return update(meta, A=A)
            meta = dict(metavars(data))
            A = seed and seed(meta) or 0
            F = feed(meta, A=A) if feed else A
            S = skip
            while True:
                if not S:
                    yield F
                else:
                    S = S - 1
                A = accumulate(A)
                if mask:
                    A &amp;= mask
                F = feed(meta, A=A) if feed else A
        try:
            update(A=seed())
        except ParserVariableMissing:
            return finalize
        else:
            return finalize()

    @handler.register(&#39;be&#39;)
    def be(self, arg: int | buf, size: str | None = None) -&gt; int:
        &#34;&#34;&#34;
        The handler `be[size=0]:data` converts a binary input into the integer that it encodes in
        big endian format, and vice versa. The optional parameter `size` can be used to specify
        the number of bytes used for encoding integers. For byte string inputs, this parameter is
        used to truncate the input before conversion.
        &#34;&#34;&#34;
        if size is not None:
            size = int(size, 0)
        if isinstance(arg, int):
            if size is None:
                size, r = divmod(arg.bit_length(), 8)
                size += int(bool(r))
            return arg.to_bytes(max(size, 1), &#39;big&#39;)
        else:
            return int.from_bytes(arg[:size], &#39;big&#39;)

    @handler.register(&#39;le&#39;)
    def le(self, arg: int | buf, size: str | None = None) -&gt; int:
        &#34;&#34;&#34;
        The handler `be[size=0]:data` converts a binary input into the integer that it encodes in
        little endian format, and vice versa. The optional parameter `size` can be used to specify
        the number of bytes used for encoding integers. For byte string inputs, this parameter is
        used to truncate the input before conversion.
        &#34;&#34;&#34;
        if size is not None:
            size = int(size, 0)
        if isinstance(arg, int):
            if size is None:
                size, r = divmod(arg.bit_length(), 8)
                size += int(bool(r))
            return arg.to_bytes(max(size, 1), &#39;little&#39;)
        else:
            return int.from_bytes(arg[:size], &#39;little&#39;)

    @handler.register(&#39;reduce&#39;)
    def reduce(self, it: Iterable[int], reduction: str, seed: str | None = None) -&gt; int:
        &#34;&#34;&#34;
        The handler `reduce[reduction, seed=0]` has two parameters. The string `reduction` is a
        Python expression that involves the two special variables `S` (the state) and `B`
        (the current block value). This expression is evaluated for every `B` in the incoming
        integer sequence and assigned back to `S`. The starting value of `S` is given by `seed`,
        which has a default value of `0` and must also be given as a Python expression.
        &#34;&#34;&#34;
        seed = seed and PythonExpression.Lazy(seed)
        reduction = PythonExpression.Lazy(reduction)

        def finalize(data: Chunk | None = None):
            def _reduction(S, B):
                v = reduction(args, S=S, B=B)
                return v
            args = dict(metavars(data))
            return reduce(_reduction, it, seed and seed(args) or 0)

        try:
            return finalize()
        except ParserVariableMissing:
            return finalize</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.argformats.LazyEvaluation" href="#refinery.lib.argformats.LazyEvaluation">LazyEvaluation</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.argformats.DelayedBinaryArgument" href="#refinery.lib.argformats.DelayedBinaryArgument">DelayedBinaryArgument</a></li>
<li><a title="refinery.lib.argformats.DelayedNumSeqArgument" href="#refinery.lib.argformats.DelayedNumSeqArgument">DelayedNumSeqArgument</a></li>
<li><a title="refinery.lib.argformats.DelayedNumberArgument" href="#refinery.lib.argformats.DelayedNumberArgument">DelayedNumberArgument</a></li>
<li><a title="refinery.lib.argformats.DelayedRegexpArgument" href="#refinery.lib.argformats.DelayedRegexpArgument">DelayedRegexpArgument</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.argformats.DelayedArgument.default_handler"><code class="name flex">
<span>def <span class="ident">default_handler</span></span>(<span>self, expression)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L750-L758" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def default_handler(self, expression: str) -&gt; bytes:
    try:
        return open(expression, &#39;rb&#39;).read()
    except Exception:
        pass
    try:
        return utf8(expression)
    except Exception:
        return expression</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.handler"><code class="name flex">
<span>def <span class="ident">handler</span></span>(<span>self, expression)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L760-L762" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@DelayedArgumentDispatch
def handler(self, expression) -&gt; bytes:
    return self.default_handler(expression)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.s"><code class="name flex">
<span>def <span class="ident">s</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"><p>The final modifier <code>s:string</code> returns the UTF-8 encoded representation of <code>string</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L764-L769" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;s&#39;, &#39;S&#39;, final=True)
def s(self, string: str) -&gt; bytes:
    &#34;&#34;&#34;
    The final modifier `s:string` returns the UTF-8 encoded representation of `string`.
    &#34;&#34;&#34;
    return string.encode(&#39;UTF8&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.u"><code class="name flex">
<span>def <span class="ident">u</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"><p>The final modifier <code>u:string</code> returns the UTF16 (little endian without BOM) encoded
representation of <code>string</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L771-L777" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;u&#39;, &#39;U&#39;, final=True)
def u(self, string: str) -&gt; bytes:
    &#34;&#34;&#34;
    The final modifier `u:string` returns the UTF16 (little endian without BOM) encoded
    representation of `string`.
    &#34;&#34;&#34;
    return string.encode(&#39;UTF-16LE&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.a"><code class="name flex">
<span>def <span class="ident">a</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"><p>The final modifier <code>a:string</code> returns the latin-1 encoded representation of <code>string</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L779-L784" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;a&#39;, &#39;A&#39;, final=True)
def a(self, string: str) -&gt; bytes:
    &#34;&#34;&#34;
    The final modifier `a:string` returns the latin-1 encoded representation of `string`.
    &#34;&#34;&#34;
    return string.encode(&#39;LATIN-1&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.bang_h"><code class="name flex">
<span>def <span class="ident">bang_h</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L786-L792" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(F&#39;{_REVERSE_SIGN}h&#39;, F&#39;{_REVERSE_SIGN}H&#39;)
def bang_h(self, string: bytes) -&gt; bytes:
    F&#34;&#34;&#34;
    The modifier `{_REVERSE_SIGN}h` (or `{_REVERSE_SIGN}H`) encodes the input as hexadecimal.
    &#34;&#34;&#34;
    import base64
    return base64.b16encode(string)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.h"><code class="name flex">
<span>def <span class="ident">h</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"><p>The final modifier <code>h:string</code> (or <code>H:string</code>) returns the hex decoding of <code>string</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L794-L800" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;h&#39;, &#39;H&#39;, final=True)
def h(self, string: str) -&gt; bytes:
    &#34;&#34;&#34;
    The final modifier `h:string` (or `H:string`) returns the hex decoding of `string`.
    &#34;&#34;&#34;
    import base64
    return base64.b16decode(string, casefold=True)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.n"><code class="name flex">
<span>def <span class="ident">n</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"><p>The final modifier <code>n:string</code> returns the un-escaped version of a string containing
backslash escape sequences.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L802-L809" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;n&#39;)
def n(self, string: bytes) -&gt; bytes:
    &#34;&#34;&#34;
    The final modifier `n:string` returns the un-escaped version of a string containing
    backslash escape sequences.
    &#34;&#34;&#34;
    from refinery.units.encoding.esc import esc
    return esc().process(string)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.bang_n"><code class="name flex">
<span>def <span class="ident">bang_n</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L811-L818" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(F&#39;{_REVERSE_SIGN}n&#39;)
def bang_n(self, string: bytes) -&gt; bytes:
    F&#34;&#34;&#34;
    The modifier `{_REVERSE_SIGN}n:string` returns an escaped and quoted version of the
    input string.
    &#34;&#34;&#34;
    from refinery.units.encoding.esc import esc
    return esc(quoted=True).reverse(string)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.q"><code class="name flex">
<span>def <span class="ident">q</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"><p>The final modifier <code>q:string</code> (or <code>Q:string</code>) returns the url-quote decoding of <code>string</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L820-L826" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;q&#39;, &#39;Q&#39;, final=True)
def q(self, string: str) -&gt; bytes:
    &#34;&#34;&#34;
    The final modifier `q:string` (or `Q:string`) returns the url-quote decoding of `string`.
    &#34;&#34;&#34;
    import urllib.parse
    return urllib.parse.unquote_to_bytes(string)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, path, region='')</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the contents of the file located at the given path. This path may contain
wildcard characters, but this pattern has to match a single file. It is also possible
to use the handler as <code>read[count]</code> or as <code>read[offset:count]</code> to read <code>count</code> many
bytes from the file at the given offset.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L828-L836" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;read&#39;, final=True)
def read(self, path: str, region: str = &#39;&#39;) -&gt; bytes:
    &#34;&#34;&#34;
    Returns the contents of the file located at the given path. This path may contain
    wildcard characters, but this pattern has to match a single file. It is also possible
    to use the handler as `read[count]` or as `read[offset:count]` to read `count` many
    bytes from the file at the given offset.
    &#34;&#34;&#34;
    return self._file(path, region)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.readfrom"><code class="name flex">
<span>def <span class="ident">readfrom</span></span>(<span>self, path, region='')</span>
</code></dt>
<dd>
<section class="desc"><p>A non-final variant of the <code><a title="refinery.lib.argformats.DelayedArgument.read" href="#refinery.lib.argformats.DelayedArgument.read">DelayedArgument.read()</a></code> handler. This
handler should only be used to read from path names that were the result of a previous
handler. Using <code>readfrom:sample.bin</code> will cause an error: Since <code>readfrom</code> is not final,
the default handler will be applied to <code>sample.bin</code>, feeding the binary contents of the
file into <code>readfrom</code>, but the handler is expecting a path name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L838-L854" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;readfrom&#39;)
def readfrom(self, path: bytes, region: str = &#39;&#39;) -&gt; bytes:
    &#34;&#34;&#34;
    A non-final variant of the `refinery.lib.argformats.DelayedArgument.read` handler. This
    handler should only be used to read from path names that were the result of a previous
    handler. Using `readfrom:sample.bin` will cause an error: Since `readfrom` is not final,
    the default handler will be applied to `sample.bin`, feeding the binary contents of the
    file into `readfrom`, but the handler is expecting a path name.
    &#34;&#34;&#34;
    try:
        path = path.decode(&#39;utf8&#39;)
    except UnicodeDecodeError:
        raise ArgumentTypeError(
            &#39;The input for the readfrom handler was not a path. Consider using the read &#39;
            &#39;handler instead, which is final.&#39;)
    else:
        return self._file(path, region)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.range"><code class="name flex">
<span>def <span class="ident">range</span></span>(<span>self, region)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements the final modifier <code>range:bounds</code> to generate a sequence of bytes, where
<code>bounds</code> is parsed as a <code><a title="refinery.lib.argformats.sliceobj" href="#refinery.lib.argformats.sliceobj">sliceobj()</a></code> with one exception: If
<code>bounds</code> is just a single integer, it is interpreted as the upper bound for a sequence
of bytes starting at zero.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L888-L913" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;range&#39;, final=True)
def range(self, region: str) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    Implements the final modifier `range:bounds` to generate a sequence of bytes, where
    `bounds` is parsed as a `refinery.lib.argformats.sliceobj` with one exception: If
    `bounds` is just a single integer, it is interpreted as the upper bound for a sequence
    of bytes starting at zero.
    &#34;&#34;&#34;
    def compute_range(data: Chunk | None = None):
        try:
            s = sliceobj(region, data, intok=True)
        except ParserVariableMissing:
            raise TooLazy
        if isinstance(s, SliceAgain):
            raise TooLazy
        if isinstance(s, int):
            s = slice(None, s, None)
        result = bounds[s]
        result.max -= 1
        if 0 &lt;= result.min and result.max &lt;= 0x100:
            result = bytearray(result)
        return result
    try:
        return compute_range()
    except TooLazy:
        return compute_range</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.env"><code class="name flex">
<span>def <span class="ident">env</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>The final modifier <code>env:name</code> returns the UTF8-encoded value of the environment variable
with the given name.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L915-L922" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;env&#39;, final=True)
def env(self, name: str) -&gt; bytes:
    &#34;&#34;&#34;
    The final modifier `env:name` returns the UTF8-encoded value of the environment variable
    with the given name.
    &#34;&#34;&#34;
    import os
    return os.environ[name]</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.pos"><code class="name flex">
<span>def <span class="ident">pos</span></span>(<span>self, regex, occurrence=0)</span>
</code></dt>
<dd>
<section class="desc"><p>The handler pos[k=0]:[regex] returns the position of the k-th occurrence of the regular
expression [regex]. The value <code>k</code> can be set to <code>-1</code> to return the position of the last
match. If <code>k</code> is a negative value, then the handler returns the offset at the end of the
match rather than the one at the beginning. If no match is found, the handler returns
the value <code>-1</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L924-L958" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;pos&#39;)
def pos(self, regex: buf, occurrence: int = 0) -&gt; int:
    &#34;&#34;&#34;
    The handler pos[k=0]:[regex] returns the position of the k-th occurrence of the regular
    expression [regex]. The value `k` can be set to `-1` to return the position of the last
    match. If `k` is a negative value, then the handler returns the offset at the end of the
    match rather than the one at the beginning. If no match is found, the handler returns
    the value `-1`.
    &#34;&#34;&#34;
    if isinstance(occurrence, str):
        occurrence = int(occurrence, 0)

    def _pos(data: bytearray) -&gt; int:
        it: Iterable[re.Match] = re.finditer(bytes(regex), data, flags=re.DOTALL)

        if occurrence &lt; 0:
            from collections import deque
            matches: Deque[re.Match] = deque()
            while len(matches) &lt; -occurrence:
                try:
                    matches.append(next(it))
                except StopIteration:
                    return -1
            for match in it:
                matches.append(match)
                matches.popleft()
            return matches[0].end()
        else:
            for k, match in enumerate(it):
                if k == occurrence:
                    return match.start()
            else:
                return -1

    return _pos</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.rx"><code class="name flex">
<span>def <span class="ident">rx</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<section class="desc"><p>The handler <code>rx:str</code> returns a regular expression which matches the exact string
sequence given by <code>str</code>, with special regular expression control characters escaped.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L960-L966" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;rx&#39;)
def rx(self, string: bytes) -&gt; bytes:
    &#34;&#34;&#34;
    The handler `rx:str` returns a regular expression which matches the exact string
    sequence given by `str`, with special regular expression control characters escaped.
    &#34;&#34;&#34;
    return re.escape(string)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, region)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements the final modifier <code>copy:start[:length[:step]]</code>. It copies <code>length</code> bytes
from the input using step size <code>step</code> at offset <code>start</code>. If length is not given, it
defaults to the input length. If step is not given, it defaults to 1.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L968-L978" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;c&#39;, &#39;copy&#39;, final=True)
def copy(self, region: str) -&gt; bytes:
    &#34;&#34;&#34;
    Implements the final modifier `copy:start[:length[:step]]`. It copies `length` bytes
    from the input using step size `step` at offset `start`. If length is not given, it
    defaults to the input length. If step is not given, it defaults to 1.
    &#34;&#34;&#34;
    def _copy(data: bytearray):
        bounds = relslice(region, data)
        return data[bounds]
    return _copy</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.cut"><code class="name flex">
<span>def <span class="ident">cut</span></span>(<span>self, region)</span>
</code></dt>
<dd>
<section class="desc"><p>The handler <code>cut:region</code> work like <code><a title="refinery.lib.argformats.DelayedBinaryArgument.copy" href="#refinery.lib.argformats.DelayedArgument.copy">DelayedArgument.copy()</a></code>,
but the bytes are removed from the input data after copying them.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L980-L991" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;x&#39;, &#39;cut&#39;, final=True)
def cut(self, region: str) -&gt; bytes:
    &#34;&#34;&#34;
    The handler `cut:region` work like `refinery.lib.argformats.DelayedBinaryArgument.copy`,
    but the bytes are removed from the input data after copying them.
    &#34;&#34;&#34;
    def _cut(data: bytearray | Chunk):
        bounds = relslice(region, data)
        result = bytearray(data[bounds])
        del data[bounds]
        return result
    return _cut</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.pd"><code class="name flex">
<span>def <span class="ident">pd</span></span>(<span>self, input, region=slice(1, None, 1), separator=b'/')</span>
</code></dt>
<dd>
<section class="desc"><p>The handler <code>pd[region=1:,sep=/]:input</code> splits the input at the given string <code>sep</code>
and reverses the sequence. Parts are then selected according to the <code>region</code> parameter,
which can be any expression in Python slice syntax. Afterwards, the resulting sequence
is reversed again and joined at the <code>sep</code> parameter. For example, the expression</p>
<pre><code>pd[2:]:/path/to/some/item/and/more
</code></pre>
<p>will return the string <code>/path/to/some/item</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L993-L1015" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;pd&#39;)
def pd(self, input: bytes, region: slice | str = slice(1, None, 1), separator: bytes = B&#39;/&#39;) -&gt; bytes:
    &#34;&#34;&#34;
    The handler `pd[region=1:,sep=/]:input` splits the input at the given string `sep`
    and reverses the sequence. Parts are then selected according to the `region` parameter,
    which can be any expression in Python slice syntax. Afterwards, the resulting sequence
    is reversed again and joined at the `sep` parameter. For example, the expression

        pd[2:]:/path/to/some/item/and/more

    will return the string `/path/to/some/item`.
    &#34;&#34;&#34;
    def _pd(data: Chunk | None = None):
        b: slice = sliceobj(region, data=data, final=True)
        pd = input.split(separator)
        pd.reverse()
        pd = pd[b]
        pd.reverse()
        return separator.join(pd)
    try:
        return _pd()
    except TooLazy:
        return _pd</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.pb"><code class="name flex">
<span>def <span class="ident">pb</span></span>(<span>self, input, separator=b'/')</span>
</code></dt>
<dd>
<section class="desc"><p>The handler <code>pb:input</code> is equivalent to <code>pd[:1]:input</code> and corresponds to "basename".</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1017-L1022" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;pb&#39;)
def pb(self, input: bytes, separator: bytes = B&#39;/&#39;) -&gt; bytes:
    &#34;&#34;&#34;
    The handler `pb:input` is equivalent to `pd[:1]:input` and corresponds to &#34;basename&#34;.
    &#34;&#34;&#34;
    return self.pd(input, slice(0, 1, 1), separator=separator)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.pn"><code class="name flex">
<span>def <span class="ident">pn</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<section class="desc"><p>The handler <code>pn:/path/to/file.ext</code> returns <code>/path/to/file</code>, i.e. the path without its
extension. The handler name is short for "path name". If the last part does not have
any extension, the input path is returned unchanged.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1024-L1033" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;pn&#39;)
def pn(self, path: str | bytes) -&gt; bytes:
    &#34;&#34;&#34;
    The handler `pn:/path/to/file.ext` returns `/path/to/file`, i.e. the path without its
    extension. The handler name is short for &#34;path name&#34;. If the last part does not have
    any extension, the input path is returned unchanged.
    &#34;&#34;&#34;
    if not isinstance(path, str):
        path = path.decode(&#39;utf8&#39;)
    return Path(path).with_suffix(&#39;&#39;).as_posix().encode()</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.px"><code class="name flex">
<span>def <span class="ident">px</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<section class="desc"><p>The handler <code>px:/path/to/file.ext</code> returns <code>ext</code>, i.e. the extension extension. The
handler name is short for "path eXtension".</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1035-L1043" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;px&#39;)
def px(self, path: str | bytes) -&gt; bytes:
    &#34;&#34;&#34;
    The handler `px:/path/to/file.ext` returns `ext`, i.e. the extension extension. The
    handler name is short for &#34;path eXtension&#34;.
    &#34;&#34;&#34;
    if not isinstance(path, str):
        path = path.decode(&#39;utf8&#39;)
    return Path(path).suffix[1:].encode()</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.var"><code class="name flex">
<span>def <span class="ident">var</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>The handler <code>var:name</code> contains the value of the meta variable <code>name</code>. This handler is semi-final;
if the provided argument is an identifier pattern, it is read directly as a variable name. Otherwise,
it will be interpreted as a multibin expression to compute the name. An identifier pattern here is
a unix file name pattern including the wildcards <code>?</code>, <code>*</code>, and letter options in <code>[</code> brackets <code>]</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1083-L1091" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;v&#39;, &#39;var&#39;, final=True)
def var(self, name: str) -&gt; bytes:
    &#34;&#34;&#34;
    The handler `var:name` contains the value of the meta variable `name`. This handler is semi-final;
    if the provided argument is an identifier pattern, it is read directly as a variable name. Otherwise,
    it will be interpreted as a multibin expression to compute the name. An identifier pattern here is
    a unix file name pattern including the wildcards `?`, `*`, and letter options in `[` brackets `]`.
    &#34;&#34;&#34;
    return self._var(name, eat=False)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.eat"><code class="name flex">
<span>def <span class="ident">eat</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>The handler <code>eat:name</code> works exactly like <code>var:name</code> with the exception that the variable is removed
from the chunk after evaluation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1093-L1099" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;eat&#39;, final=True)
def eat(self, name: str) -&gt; bytes:
    &#34;&#34;&#34;
    The handler `eat:name` works exactly like `var:name` with the exception that the variable is removed
    from the chunk after evaluation.
    &#34;&#34;&#34;
    return self._var(name, eat=True)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>self, expression)</span>
</code></dt>
<dd>
<section class="desc"><p>Final modifier <code>e:expression</code> or <code>eval:expression</code>; uses a <code><a title="refinery.lib.argformats.PythonExpression" href="#refinery.lib.argformats.PythonExpression">PythonExpression</a></code>
parser to process expressions. The expression can contain any meta variable that is attached to the
chunk. The <code><a title="refinery.cm" href="../index.html#refinery.cm">cm</a></code> unit can be used to attach information such as chunk size and the chunk
index within the current frame (see <code><a title="refinery.lib.frame" href="frame.html">refinery.lib.frame</a></code>).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1101-L1113" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;e&#39;, &#39;E&#39;, &#39;eval&#39;)
def eval(self, expression) -&gt; Any:
    &#34;&#34;&#34;
    Final modifier `e:expression` or `eval:expression`; uses a `refinery.lib.argformats.PythonExpression`
    parser to process expressions. The expression can contain any meta variable that is attached to the
    chunk. The `refinery.cm` unit can be used to attach information such as chunk size and the chunk
    index within the current frame (see `refinery.lib.frame`).
    &#34;&#34;&#34;
    if isbuffer(expression):
        expression = expression.decode(&#39;utf8&#39;)
    if not isinstance(expression, str):
        return expression
    return LazyPythonExpression(expression)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.btoi"><code class="name flex">
<span>def <span class="ident">btoi</span></span>(<span>self, binary, size=None, step=None)</span>
</code></dt>
<dd>
<section class="desc"><p>The modifier <code>btoi[size=0,step=0]:data</code> uses <code><a title="refinery.lib.chunks.unpack" href="chunks.html#refinery.lib.chunks.unpack">unpack()</a></code> to convert a
sequence of bytes into a sequence of integers.</p>
<p>The optional parameter <code>size</code> has to be an integer expression whose absolute value gives
the size of each encoded number in bytes. Its default value is <code>0</code>, which corresponds to
choosing the size automatically in the following manner: If the length of the buffer is
uneven, the value 1 is chosen. If the length modulo 4 is nonzero, the value 2 is chosen. If
the length is divisible by 4, then 4 is chosen. To unpack as big endian as opposed to the
default little endian, a negative value for <code>size</code> has to be specified. The absolute value
of <code>size</code> will be used.</p>
<p>By default, integers are parsed from the input buffer at offsets that are integer multiples
of the block size. The optional parameter <code>step</code> can be used to override this behavior. For
example, <code>btoi[2,1]</code> can be used to read 16-bit values at each byte offset.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1115-L1146" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;btoi&#39;)
def btoi(self, binary: buf, size=None, step=None) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    The modifier `btoi[size=0,step=0]:data` uses `refinery.lib.chunks.unpack` to convert a
    sequence of bytes into a sequence of integers.

    The optional parameter `size` has to be an integer expression whose absolute value gives
    the size of each encoded number in bytes. Its default value is `0`, which corresponds to
    choosing the size automatically in the following manner: If the length of the buffer is
    uneven, the value 1 is chosen. If the length modulo 4 is nonzero, the value 2 is chosen. If
    the length is divisible by 4, then 4 is chosen. To unpack as big endian as opposed to the
    default little endian, a negative value for `size` has to be specified. The absolute value
    of `size` will be used.

    By default, integers are parsed from the input buffer at offsets that are integer multiples
    of the block size. The optional parameter `step` can be used to override this behavior. For
    example, `btoi[2,1]` can be used to read 16-bit values at each byte offset.
    &#34;&#34;&#34;
    from refinery.lib import chunks
    size = int(size, 0) if size else 0
    step = int(step, 0) if step else 0
    bigE = size &lt; 0
    size = abs(size)
    if not size:
        n = len(binary)
        if n % 2:
            size = 1
        elif n % 4:
            size = 2
        else:
            size = 4
    return list(chunks.unpack(binary, size, bigE, step))</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.itob"><code class="name flex">
<span>def <span class="ident">itob</span></span>(<span>self, integers, size=None)</span>
</code></dt>
<dd>
<section class="desc"><p>The modifier <code>itob[size=0]:integers</code> is the inverse of <code>btoi</code> and works in the same way,
except that the case <code>size=0</code> is handled in the following way: The handler inspects all
integers in the input and determines the minimum block size required to pack all of them.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1148-L1171" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;itob&#39;)
def itob(self, integers: Iterable[int], size=None) -&gt; buf:
    &#34;&#34;&#34;
    The modifier `itob[size=0]:integers` is the inverse of `btoi` and works in the same way,
    except that the case `size=0` is handled in the following way: The handler inspects all
    integers in the input and determines the minimum block size required to pack all of them.
    &#34;&#34;&#34;
    from refinery.lib import chunks
    size = int(size, 0) if size else 0
    bigE = size &lt; 0
    size = abs(size)
    if not size:
        def byte_length(n: int):
            width, overflow = divmod(n.bit_length(), 8)
            width += bool(overflow)
            return width
        if not isinstance(integers, list):
            integers = list(integers)
        size = max((byte_length(n) for n in integers), default=1)
        size = max(size, 1)
    else:
        mask = (1 &lt;&lt; (size * 8)) - 1
        integers = (integer &amp; mask for integer in integers)
    return chunks.pack(integers, size, bigE)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.inc"><code class="name flex">
<span>def <span class="ident">inc</span></span>(<span>self, it, precision=None)</span>
</code></dt>
<dd>
<section class="desc"><p>The modifier <code>inc:it</code> or <code>inc[N=64]:it</code> expects a sequence <code>it</code> of integers (a binary
string is interpreted as the sequence of its byte values), iterates it cyclically and
perpetually adds an increasing counter to the result. If the number <code>N</code> is nonzero, then
the counter is limited to <code>N</code> bits.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1173-L1192" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;inc&#39;)
def inc(self, it: Iterable[int], precision=None) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    The modifier `inc:it` or `inc[N=64]:it` expects a sequence `it` of integers (a binary
    string is interpreted as the sequence of its byte values), iterates it cyclically and
    perpetually adds an increasing counter to the result. If the number `N` is nonzero, then
    the counter is limited to `N` bits.
    &#34;&#34;&#34;
    precision = precision and int(precision, 0) or _DEFAULT_BITS
    it = infinitize(it)
    if precision:
        def delay(_):
            mask = (1 &lt;&lt; precision) - 1
            for a, b in zip(it, itertools.cycle(range(mask + 1))):
                yield a + b &amp; mask
    else:
        def delay(_):
            for a, b in zip(it, itertools.count()):
                yield a + b
    return delay</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.dec"><code class="name flex">
<span>def <span class="ident">dec</span></span>(<span>self, it, precision=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Identical to <code><a title="refinery.lib.argformats.DelayedNumSeqArgument.inc" href="#refinery.lib.argformats.DelayedArgument.inc">DelayedArgument.inc()</a></code>, but decreasing the counter
rather than increasing it.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1194-L1211" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;dec&#39;)
def dec(self, it: Iterable[int], precision=None) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    Identical to `refinery.lib.argformats.DelayedNumSeqArgument.inc`, but decreasing the counter
    rather than increasing it.
    &#34;&#34;&#34;
    precision = precision and int(precision, 0) or _DEFAULT_BITS
    it = infinitize(it)
    if precision:
        def delay(_):
            mask = (1 &lt;&lt; precision) - 1
            for a, b in zip(it, itertools.cycle(range(mask + 1))):
                yield a - b &amp; mask
    else:
        def delay(_):
            for a, b in zip(it, itertools.count()):
                yield a - b
    return delay</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.take"><code class="name flex">
<span>def <span class="ident">take</span></span>(<span>self, it, bounds=None)</span>
</code></dt>
<dd>
<section class="desc"><p>The handler <code>take[start:stop:step]</code> expects an integer sequence as input and applies a slice
to it. Slices are given in Python syntax, so <code>take[::2]</code> will extract every second item from
the incoming data. The default sequence is <code>1:</code>, i.e. skipping the first element.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1213-L1233" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;take&#39;)
def take(self, it: Iterable[int], bounds: str | None = None):
    &#34;&#34;&#34;
    The handler `take[start:stop:step]` expects an integer sequence as input and applies a slice
    to it. Slices are given in Python syntax, so `take[::2]` will extract every second item from
    the incoming data. The default sequence is `1:`, i.e. skipping the first element.
    &#34;&#34;&#34;
    def sliced(bounds):
        try:
            return it[bounds]
        except TypeError:
            subsequence = itertools.islice(it, bounds.start, bounds.stop, bounds.step)
            if bounds.stop is not None:
                subsequence = list(subsequence)
                if all(t in range(0x100) for t in subsequence):
                    subsequence = bytearray(subsequence)
            return subsequence
    bounds = bounds and sliceobj(bounds) or slice(1, None)
    if isinstance(bounds, slice):
        return sliced(bounds)
    return lambda d: sliced(bounds(d))</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.cycle"><code class="name flex">
<span>def <span class="ident">cycle</span></span>(<span>self, it)</span>
</code></dt>
<dd>
<section class="desc"><p>The <code>cycle</code> handler turns a finite integer sequence into an infinitely repeating integer sequence.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1235-L1242" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;cycle&#39;)
def cycle(self, it: Iterable[int]) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    The `cycle` handler turns a finite integer sequence into an infinitely repeating integer sequence.
    &#34;&#34;&#34;
    if isinstance(it, itertools.cycle):
        return it
    return itertools.cycle(it)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.rng"><code class="name flex">
<span>def <span class="ident">rng</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<section class="desc"><p>The <code>rng:count</code> handler generates <code>count</code> secure random bytes using the Python standard
library module function <code>secrets.token_bytes</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1244-L1263" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;rng&#39;, final=True)
def rng(
    self,
    size: str,
) -&gt; bytes:
    &#34;&#34;&#34;
    The `rng:count` handler generates `count` secure random bytes using the Python standard
    library module function `secrets.token_bytes`.
    &#34;&#34;&#34;
    import secrets
    size = PythonExpression.Lazy(size)
    try:
        _size = size()
    except ParserVariableMissing:
        def finalize(data):
            meta = dict(metavars(data))
            return secrets.token_bytes(size(meta))
        return finalize
    else:
        return secrets.token_bytes(_size)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.prng"><code class="name flex">
<span>def <span class="ident">prng</span></span>(<span>self, size, seed=None)</span>
</code></dt>
<dd>
<section class="desc"><p>The <code>prng[seed]:count</code> handler generates <code>count</code> random bytes using Python's built-in random
number generator. The <code>seed</code> argument can be omitted, in which case the PRNG will be seeded
with the current timestamp in nanoseconds.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1265-L1298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;prng&#39;, final=True)
def prng(
    self,
    size: str,
    seed: str | None = None
) -&gt; bytes:
    &#34;&#34;&#34;
    The `prng[seed]:count` handler generates `count` random bytes using Python&#39;s built-in random
    number generator. The `seed` argument can be omitted, in which case the PRNG will be seeded
    with the current timestamp in nanoseconds.
    &#34;&#34;&#34;
    import random
    import time

    try:
        randbytes = random.randbytes
    except AttributeError:
        def randbytes(n):
            return bytearray(random.randint(0, 0xFF) for _ in range(n))

    seed = time.time_ns if seed is None else PythonExpression.Lazy(seed)
    size = PythonExpression.Lazy(size)
    try:
        _size = size()
        _seed = seed()
    except ParserVariableMissing:
        def finalize(data):
            meta = dict(metavars(data))
            random.seed(seed(meta))
            return randbytes(size(meta))
        return finalize
    else:
        random.seed(_seed)
        return randbytes(_size)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.accu"><code class="name flex">
<span>def <span class="ident">accu</span></span>(<span>self, spec, seed=None, skip=None, precision=None)</span>
</code></dt>
<dd>
<section class="desc"><p>The final handler</p>
<pre><code>accu[seed=0,skip=1,precision=64]:update[#feed]
</code></pre>
<p>expects <code>seed</code>, <code>skip</code>, <code>update</code>, and <code>feed</code> to be Python expressions. It generates an infinite integer
sequence maintaining an internal state <code>A</code>: The initial value for <code>A</code> is <code>seed</code>. Each subsequent state is
the result of evaluating the <code>update</code> expression, which can use the variable <code>A</code> to access the current
state. The next integer value to be generated is the result of evaluating the expression <code>feed</code>, which
may again use the variable <code>A</code> to access the internal state. If the <code>feed</code> expression is omitted, the
complete state <code>A</code> is emitted in each step. The value of <code>skip</code> specifies the number of elements from the
beginning of the sequence that should be skipped. The value of <code>precision</code> specifies the number of bits
that are used by the internal state variable <code>A</code>. You can specify <code>precision</code> to be zero if you want the
result to be an unbounded big integer.</p>
<p>Instead of a Python expression, the
variable <code>update</code> can also be one of the following values, which
are pre-defined update routines based on popular generators:</p>
<ul>
<li><code>@libc</code>: <code>A * 0x041C64E6D + 0x003039</code></li>
<li><code>@ansi</code>: <code>A * 0x041C64E6D + 0x003039 # (A &gt;&gt; 0x10)</code></li>
<li><code>@msvc</code>: <code>A * 0x0000343FD + 0x269EC3 # (A &gt;&gt; 0x10)</code></li>
<li><code>@msvb</code>: <code>A * 0x043FD43FD + 0xC39EC3</code></li>
<li><code>@java</code>: <code>A * 0x5DEECE66D + 0x00000B</code></li>
<li><code>@mmix</code>: <code>A * 6364136223846793005 + 1442695040888963407</code></li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1300-L1376" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;accu&#39;, final=True)
def accu(
    self,
    spec: str,
    seed: str | None = None,
    skip: str | None = None,
    precision: str | None = None
) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    The final handler

        accu[seed=0,skip=1,precision=64]:update[#feed]

    expects `seed`, `skip`, `update`, and `feed` to be Python expressions. It generates an infinite integer
    sequence maintaining an internal state `A`: The initial value for `A` is `seed`. Each subsequent state is
    the result of evaluating the `update` expression, which can use the variable `A` to access the current
    state. The next integer value to be generated is the result of evaluating the expression `feed`, which
    may again use the variable `A` to access the internal state. If the `feed` expression is omitted, the
    complete state `A` is emitted in each step. The value of `skip` specifies the number of elements from the
    beginning of the sequence that should be skipped. The value of `precision` specifies the number of bits
    that are used by the internal state variable `A`. You can specify `precision` to be zero if you want the
    result to be an unbounded big integer.

    Instead of a Python expression, the  variable `update` can also be one of the following values, which
    are pre-defined update routines based on popular generators:

    - `@libc`: `A * 0x041C64E6D + 0x003039`
    - `@ansi`: `A * 0x041C64E6D + 0x003039 # (A &gt;&gt; 0x10)`
    - `@msvc`: `A * 0x0000343FD + 0x269EC3 # (A &gt;&gt; 0x10)`
    - `@msvb`: `A * 0x043FD43FD + 0xC39EC3`
    - `@java`: `A * 0x5DEECE66D + 0x00000B`
    - `@mmix`: `A * 6364136223846793005 + 1442695040888963407`
    &#34;&#34;&#34;
    if spec.startswith(&#39;@&#39;):
        try:
            spec = {
                &#39;@libc&#39;: &#39;A * 0x041C64E6D + 0x003039&#39;,
                &#39;@ansi&#39;: &#39;A * 0x041C64E6D + 0x003039 # (A &gt;&gt; 0x10)&#39;,
                &#39;@msvc&#39;: &#39;A * 0x0000343FD + 0x269EC3 # (A &gt;&gt; 0x10)&#39;,
                &#39;@msvb&#39;: &#39;A * 0x043FD43FD + 0xC39EC3&#39;,
                &#39;@java&#39;: &#39;A * 0x5DEECE66D + 0x00000B&#39;,
                &#39;@mmix&#39;: &#39;A * 6364136223846793005 + 1442695040888963407&#39;
            }[spec]
        except KeyError:
            raise ArgumentTypeError(F&#39;The generator type {spec} is unknown.&#39;)
    update, _, feed = spec.partition(&#39;#&#39;)
    update = PythonExpression.Lazy(update)
    seed = seed or &#39;0&#39;
    seed = PythonExpression.Lazy(seed)
    feed = feed and PythonExpression.Lazy(feed)
    skip = 1 if skip is None else int(skip, 0)
    precision = precision and int(precision, 0) or _DEFAULT_BITS
    mask = precision and (1 &lt;&lt; precision) - 1

    def finalize(data: Chunk | None = None):
        @lru_cache(maxsize=512, typed=False)
        def accumulate(A):
            return update(meta, A=A)
        meta = dict(metavars(data))
        A = seed and seed(meta) or 0
        F = feed(meta, A=A) if feed else A
        S = skip
        while True:
            if not S:
                yield F
            else:
                S = S - 1
            A = accumulate(A)
            if mask:
                A &amp;= mask
            F = feed(meta, A=A) if feed else A
    try:
        update(A=seed())
    except ParserVariableMissing:
        return finalize
    else:
        return finalize()</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.be"><code class="name flex">
<span>def <span class="ident">be</span></span>(<span>self, arg, size=None)</span>
</code></dt>
<dd>
<section class="desc"><p>The handler <code>be[size=0]:data</code> converts a binary input into the integer that it encodes in
big endian format, and vice versa. The optional parameter <code>size</code> can be used to specify
the number of bytes used for encoding integers. For byte string inputs, this parameter is
used to truncate the input before conversion.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1378-L1394" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;be&#39;)
def be(self, arg: int | buf, size: str | None = None) -&gt; int:
    &#34;&#34;&#34;
    The handler `be[size=0]:data` converts a binary input into the integer that it encodes in
    big endian format, and vice versa. The optional parameter `size` can be used to specify
    the number of bytes used for encoding integers. For byte string inputs, this parameter is
    used to truncate the input before conversion.
    &#34;&#34;&#34;
    if size is not None:
        size = int(size, 0)
    if isinstance(arg, int):
        if size is None:
            size, r = divmod(arg.bit_length(), 8)
            size += int(bool(r))
        return arg.to_bytes(max(size, 1), &#39;big&#39;)
    else:
        return int.from_bytes(arg[:size], &#39;big&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.le"><code class="name flex">
<span>def <span class="ident">le</span></span>(<span>self, arg, size=None)</span>
</code></dt>
<dd>
<section class="desc"><p>The handler <code>be[size=0]:data</code> converts a binary input into the integer that it encodes in
little endian format, and vice versa. The optional parameter <code>size</code> can be used to specify
the number of bytes used for encoding integers. For byte string inputs, this parameter is
used to truncate the input before conversion.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1396-L1412" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;le&#39;)
def le(self, arg: int | buf, size: str | None = None) -&gt; int:
    &#34;&#34;&#34;
    The handler `be[size=0]:data` converts a binary input into the integer that it encodes in
    little endian format, and vice versa. The optional parameter `size` can be used to specify
    the number of bytes used for encoding integers. For byte string inputs, this parameter is
    used to truncate the input before conversion.
    &#34;&#34;&#34;
    if size is not None:
        size = int(size, 0)
    if isinstance(arg, int):
        if size is None:
            size, r = divmod(arg.bit_length(), 8)
            size += int(bool(r))
        return arg.to_bytes(max(size, 1), &#39;little&#39;)
    else:
        return int.from_bytes(arg[:size], &#39;little&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedArgument.reduce"><code class="name flex">
<span>def <span class="ident">reduce</span></span>(<span>self, it, reduction, seed=None)</span>
</code></dt>
<dd>
<section class="desc"><p>The handler <code>reduce[reduction, seed=0]</code> has two parameters. The string <code>reduction</code> is a
Python expression that involves the two special variables <code>S</code> (the state) and <code>B</code>
(the current block value). This expression is evaluated for every <code>B</code> in the incoming
integer sequence and assigned back to <code>S</code>. The starting value of <code>S</code> is given by <code>seed</code>,
which has a default value of <code>0</code> and must also be given as a Python expression.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1414-L1436" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;reduce&#39;)
def reduce(self, it: Iterable[int], reduction: str, seed: str | None = None) -&gt; int:
    &#34;&#34;&#34;
    The handler `reduce[reduction, seed=0]` has two parameters. The string `reduction` is a
    Python expression that involves the two special variables `S` (the state) and `B`
    (the current block value). This expression is evaluated for every `B` in the incoming
    integer sequence and assigned back to `S`. The starting value of `S` is given by `seed`,
    which has a default value of `0` and must also be given as a Python expression.
    &#34;&#34;&#34;
    seed = seed and PythonExpression.Lazy(seed)
    reduction = PythonExpression.Lazy(reduction)

    def finalize(data: Chunk | None = None):
        def _reduction(S, B):
            v = reduction(args, S=S, B=B)
            return v
        args = dict(metavars(data))
        return reduce(_reduction, it, seed and seed(args) or 0)

    try:
        return finalize()
    except ParserVariableMissing:
        return finalize</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.argformats.DelayedBinaryArgument"><code class="flex name class">
<span>class <span class="ident">DelayedBinaryArgument</span></span>
<span>(</span><span>expression, reverse=False, seed=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A parser for binary arguments. It does not implement any handlers beyond the default handlers that
are implemented in <code><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1439-L1456" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DelayedBinaryArgument(DelayedArgument):
    &#34;&#34;&#34;
    A parser for binary arguments. It does not implement any handlers beyond the default handlers that
    are implemented in `refinery.lib.argformats.DelayedArgument`.
    &#34;&#34;&#34;

    def __call__(self, data: buf | None = None) -&gt; bytes:
        value = super().__call__(data=data)
        if not isbuffer(value):
            if isinstance(value, str):
                return value.encode(&#39;utf8&#39;)
            if not value:
                return B&#39;&#39;
            raise ArgumentTypeError(
                F&#39;The expression {self.expression} returned a value of type {type(value).__name__}, &#39;
                R&#39;which could not be converted to a byte string.&#39;
            )
        return value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></li>
<li><a title="refinery.lib.argformats.LazyEvaluation" href="#refinery.lib.argformats.LazyEvaluation">LazyEvaluation</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.argformats.DelayedPathArgument" href="#refinery.lib.argformats.DelayedPathArgument">DelayedPathArgument</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.argformats.DelayedArgument.a" href="#refinery.lib.argformats.DelayedArgument.a">a</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.accu" href="#refinery.lib.argformats.DelayedArgument.accu">accu</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.be" href="#refinery.lib.argformats.DelayedArgument.be">be</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.btoi" href="#refinery.lib.argformats.DelayedArgument.btoi">btoi</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.copy" href="#refinery.lib.argformats.DelayedArgument.copy">copy</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.cut" href="#refinery.lib.argformats.DelayedArgument.cut">cut</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.cycle" href="#refinery.lib.argformats.DelayedArgument.cycle">cycle</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.dec" href="#refinery.lib.argformats.DelayedArgument.dec">dec</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.eat" href="#refinery.lib.argformats.DelayedArgument.eat">eat</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.env" href="#refinery.lib.argformats.DelayedArgument.env">env</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.eval" href="#refinery.lib.argformats.DelayedArgument.eval">eval</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.h" href="#refinery.lib.argformats.DelayedArgument.h">h</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.inc" href="#refinery.lib.argformats.DelayedArgument.inc">inc</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.itob" href="#refinery.lib.argformats.DelayedArgument.itob">itob</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.le" href="#refinery.lib.argformats.DelayedArgument.le">le</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.n" href="#refinery.lib.argformats.DelayedArgument.n">n</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pb" href="#refinery.lib.argformats.DelayedArgument.pb">pb</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pd" href="#refinery.lib.argformats.DelayedArgument.pd">pd</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pn" href="#refinery.lib.argformats.DelayedArgument.pn">pn</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pos" href="#refinery.lib.argformats.DelayedArgument.pos">pos</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.prng" href="#refinery.lib.argformats.DelayedArgument.prng">prng</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.px" href="#refinery.lib.argformats.DelayedArgument.px">px</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.q" href="#refinery.lib.argformats.DelayedArgument.q">q</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.range" href="#refinery.lib.argformats.DelayedArgument.range">range</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.read" href="#refinery.lib.argformats.DelayedArgument.read">read</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.readfrom" href="#refinery.lib.argformats.DelayedArgument.readfrom">readfrom</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.reduce" href="#refinery.lib.argformats.DelayedArgument.reduce">reduce</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.rng" href="#refinery.lib.argformats.DelayedArgument.rng">rng</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.rx" href="#refinery.lib.argformats.DelayedArgument.rx">rx</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.s" href="#refinery.lib.argformats.DelayedArgument.s">s</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.take" href="#refinery.lib.argformats.DelayedArgument.take">take</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.u" href="#refinery.lib.argformats.DelayedArgument.u">u</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.var" href="#refinery.lib.argformats.DelayedArgument.var">var</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.argformats.DelayedPathArgument"><code class="flex name class">
<span>class <span class="ident">DelayedPathArgument</span></span>
<span>(</span><span>expression, reverse=False, seed=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A parser for binary arguments like <code><a title="refinery.lib.argformats.DelayedBinaryArgument" href="#refinery.lib.argformats.DelayedBinaryArgument">DelayedBinaryArgument</a></code> which does not
read files from disk as the default. This makes it more suitable for parsing path patterns that
are passed to path extractor units: It avoids the problem that a provided file name is confused
with the contents of an equally named file on disk.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1459-L1470" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DelayedPathArgument(DelayedBinaryArgument):
    &#34;&#34;&#34;
    A parser for binary arguments like `refinery.lib.argformats.DelayedBinaryArgument` which does not
    read files from disk as the default. This makes it more suitable for parsing path patterns that
    are passed to path extractor units: It avoids the problem that a provided file name is confused
    with the contents of an equally named file on disk.
    &#34;&#34;&#34;
    def default_handler(self, expression: str) -&gt; bytes:
        return utf8(expression)

    def __call__(self, data: buf | None = None) -&gt; str:
        return super().__call__(data).decode(&#39;utf8&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.argformats.DelayedBinaryArgument" href="#refinery.lib.argformats.DelayedBinaryArgument">DelayedBinaryArgument</a></li>
<li><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></li>
<li><a title="refinery.lib.argformats.LazyEvaluation" href="#refinery.lib.argformats.LazyEvaluation">LazyEvaluation</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.argformats.DelayedPathArgument.default_handler"><code class="name flex">
<span>def <span class="ident">default_handler</span></span>(<span>self, expression)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1466-L1467" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def default_handler(self, expression: str) -&gt; bytes:
    return utf8(expression)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.argformats.DelayedBinaryArgument" href="#refinery.lib.argformats.DelayedBinaryArgument">DelayedBinaryArgument</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.a" href="#refinery.lib.argformats.DelayedArgument.a">a</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.accu" href="#refinery.lib.argformats.DelayedArgument.accu">accu</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.be" href="#refinery.lib.argformats.DelayedArgument.be">be</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.btoi" href="#refinery.lib.argformats.DelayedArgument.btoi">btoi</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.copy" href="#refinery.lib.argformats.DelayedArgument.copy">copy</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.cut" href="#refinery.lib.argformats.DelayedArgument.cut">cut</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.cycle" href="#refinery.lib.argformats.DelayedArgument.cycle">cycle</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.dec" href="#refinery.lib.argformats.DelayedArgument.dec">dec</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.eat" href="#refinery.lib.argformats.DelayedArgument.eat">eat</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.env" href="#refinery.lib.argformats.DelayedArgument.env">env</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.eval" href="#refinery.lib.argformats.DelayedArgument.eval">eval</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.h" href="#refinery.lib.argformats.DelayedArgument.h">h</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.inc" href="#refinery.lib.argformats.DelayedArgument.inc">inc</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.itob" href="#refinery.lib.argformats.DelayedArgument.itob">itob</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.le" href="#refinery.lib.argformats.DelayedArgument.le">le</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.n" href="#refinery.lib.argformats.DelayedArgument.n">n</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.pb" href="#refinery.lib.argformats.DelayedArgument.pb">pb</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.pd" href="#refinery.lib.argformats.DelayedArgument.pd">pd</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.pn" href="#refinery.lib.argformats.DelayedArgument.pn">pn</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.pos" href="#refinery.lib.argformats.DelayedArgument.pos">pos</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.prng" href="#refinery.lib.argformats.DelayedArgument.prng">prng</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.px" href="#refinery.lib.argformats.DelayedArgument.px">px</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.q" href="#refinery.lib.argformats.DelayedArgument.q">q</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.range" href="#refinery.lib.argformats.DelayedArgument.range">range</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.read" href="#refinery.lib.argformats.DelayedArgument.read">read</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.readfrom" href="#refinery.lib.argformats.DelayedArgument.readfrom">readfrom</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.reduce" href="#refinery.lib.argformats.DelayedArgument.reduce">reduce</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.rng" href="#refinery.lib.argformats.DelayedArgument.rng">rng</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.rx" href="#refinery.lib.argformats.DelayedArgument.rx">rx</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.s" href="#refinery.lib.argformats.DelayedArgument.s">s</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.take" href="#refinery.lib.argformats.DelayedArgument.take">take</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.u" href="#refinery.lib.argformats.DelayedArgument.u">u</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedBinaryArgument.var" href="#refinery.lib.argformats.DelayedArgument.var">var</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.argformats.DelayedNumSeqArgument"><code class="flex name class">
<span>class <span class="ident">DelayedNumSeqArgument</span></span>
<span>(</span><span>expression, reverse=False, seed=None, typecheck=True, additional_types=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A parser for sequences of numeric arguments. It does not implement any handlers beyond the default
handlers that are implemented in <code><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></code>, but the default handler
attempts to evalue the input as a Python expression.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1473-L1546" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DelayedNumSeqArgument(DelayedArgument):
    &#34;&#34;&#34;
    A parser for sequences of numeric arguments. It does not implement any handlers beyond the default
    handlers that are implemented in `refinery.lib.argformats.DelayedArgument`, but the default handler
    attempts to evalue the input as a Python expression.
    &#34;&#34;&#34;

    def __init__(self, expression: str, reverse=False, seed=None, typecheck=True, additional_types=None):
        super().__init__(expression, reverse, seed)
        self.typecheck = typecheck
        self.additional_types = additional_types or []

    def default_handler(self, expression: str) -&gt; Iterable[int]:
        &#34;&#34;&#34;
        Attempts to parse the input expression as a sequence of integers. If this fails, the handler defaults
        to the parent `refinery.lib.argformats.DelayedArgument.default_handler`.
        &#34;&#34;&#34;
        try:
            with open(expression, &#39;rb&#39;) as stream:
                return stream.read()
        except Exception:
            pass
        try:
            return LazyPythonExpression(expression)
        except Exception:
            if isinstance(expression, str):
                return super().default_handler(expression)
            return expression

    def __call__(self, data: buf | Chunk | None = None) -&gt; Iterable[int]:
        value = super().__call__(data)
        if isbuffer(value):
            return value
        if isinstance(value, str):
            return value.encode()
        if hasattr(value, &#39;__iter__&#39;):
            try:
                if len(value) == 1:
                    return RepeatedInteger(next(iter(value)))
            except TypeError:
                def rewind():
                    yield top
                    yield from it
                it = iter(value)
                top = next(it)
                if not isinstance(top, int):
                    raise ArgumentTypeError(
                        F&#39;The first item {top!r} of the iterable computed from {self.expression} was not an integer.&#39;)
                return rewind()
            else:
                return value
        if isinstance(value, float):
            tmp = int(value)
            if float(tmp) == value:
                value = tmp
        if isinstance(value, int):
            return RepeatedInteger(value)
        if not self.typecheck:
            return value
        if self.additional_types:
            typecheck = self.additional_types
            try:
                typecheck = tuple(typecheck)
            except Exception:
                pass
            try:
                if isinstance(value, typecheck):
                    return value
            except Exception:
                pass
        raise ArgumentTypeError(
            F&#39;The value computed from {self.expression} is of type {type(value).__name__} but the unit requested an &#39;
            R&#39;integer or a sequence of integers.&#39;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></li>
<li><a title="refinery.lib.argformats.LazyEvaluation" href="#refinery.lib.argformats.LazyEvaluation">LazyEvaluation</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.argformats.DelayedNumSeqArgument.default_handler"><code class="name flex">
<span>def <span class="ident">default_handler</span></span>(<span>self, expression)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempts to parse the input expression as a sequence of integers. If this fails, the handler defaults
to the parent <code><a title="refinery.lib.argformats.DelayedArgument.default_handler" href="#refinery.lib.argformats.DelayedArgument.default_handler">DelayedArgument.default_handler()</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1485-L1500" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def default_handler(self, expression: str) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    Attempts to parse the input expression as a sequence of integers. If this fails, the handler defaults
    to the parent `refinery.lib.argformats.DelayedArgument.default_handler`.
    &#34;&#34;&#34;
    try:
        with open(expression, &#39;rb&#39;) as stream:
            return stream.read()
    except Exception:
        pass
    try:
        return LazyPythonExpression(expression)
    except Exception:
        if isinstance(expression, str):
            return super().default_handler(expression)
        return expression</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.argformats.DelayedArgument.a" href="#refinery.lib.argformats.DelayedArgument.a">a</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.accu" href="#refinery.lib.argformats.DelayedArgument.accu">accu</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.be" href="#refinery.lib.argformats.DelayedArgument.be">be</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.btoi" href="#refinery.lib.argformats.DelayedArgument.btoi">btoi</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.copy" href="#refinery.lib.argformats.DelayedArgument.copy">copy</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.cut" href="#refinery.lib.argformats.DelayedArgument.cut">cut</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.cycle" href="#refinery.lib.argformats.DelayedArgument.cycle">cycle</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.dec" href="#refinery.lib.argformats.DelayedArgument.dec">dec</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.eat" href="#refinery.lib.argformats.DelayedArgument.eat">eat</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.env" href="#refinery.lib.argformats.DelayedArgument.env">env</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.eval" href="#refinery.lib.argformats.DelayedArgument.eval">eval</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.h" href="#refinery.lib.argformats.DelayedArgument.h">h</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.inc" href="#refinery.lib.argformats.DelayedArgument.inc">inc</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.itob" href="#refinery.lib.argformats.DelayedArgument.itob">itob</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.le" href="#refinery.lib.argformats.DelayedArgument.le">le</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.n" href="#refinery.lib.argformats.DelayedArgument.n">n</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pb" href="#refinery.lib.argformats.DelayedArgument.pb">pb</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pd" href="#refinery.lib.argformats.DelayedArgument.pd">pd</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pn" href="#refinery.lib.argformats.DelayedArgument.pn">pn</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pos" href="#refinery.lib.argformats.DelayedArgument.pos">pos</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.prng" href="#refinery.lib.argformats.DelayedArgument.prng">prng</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.px" href="#refinery.lib.argformats.DelayedArgument.px">px</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.q" href="#refinery.lib.argformats.DelayedArgument.q">q</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.range" href="#refinery.lib.argformats.DelayedArgument.range">range</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.read" href="#refinery.lib.argformats.DelayedArgument.read">read</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.readfrom" href="#refinery.lib.argformats.DelayedArgument.readfrom">readfrom</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.reduce" href="#refinery.lib.argformats.DelayedArgument.reduce">reduce</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.rng" href="#refinery.lib.argformats.DelayedArgument.rng">rng</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.rx" href="#refinery.lib.argformats.DelayedArgument.rx">rx</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.s" href="#refinery.lib.argformats.DelayedArgument.s">s</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.take" href="#refinery.lib.argformats.DelayedArgument.take">take</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.u" href="#refinery.lib.argformats.DelayedArgument.u">u</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.var" href="#refinery.lib.argformats.DelayedArgument.var">var</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.argformats.DelayedRegexpArgument"><code class="flex name class">
<span>class <span class="ident">DelayedRegexpArgument</span></span>
<span>(</span><span>expression, reverse=False, seed=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A parser for regular expressions arguments. It implements two additional handlers beyond the ones
inherited from <code><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1549-L1655" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DelayedRegexpArgument(DelayedArgument):
    &#34;&#34;&#34;
    A parser for regular expressions arguments. It implements two additional handlers beyond the ones
    inherited from `refinery.lib.argformats.DelayedArgument`.
    &#34;&#34;&#34;

    @DelayedArgumentDispatch.Inherit(DelayedArgument)
    def handler(self, expression: str) -&gt; bytes:
        &#34;&#34;&#34;
        The default handler encodes the input expression as latin-1 to return a binary string regular
        expression. Two additional syntax features have been added:

        - The use of named patterns from `refinery.lib.patterns.formats` and `refinery.lib.patterns.indicators`
          is possible by means of the extension format `(??name)`. For example, the pattern `((??url)\\x00){4}`
          will match a sequence of four URL strings which are all terminated with a null character.
        - The syntax `(?/var=PATTERN)` is equivalent to `(?P&lt;var&gt;PATTERN)`.
        &#34;&#34;&#34;
        if &#39;(?&#39; in expression:
            from refinery.lib.patterns import formats, indicators
            tick = 0

            def replace_known_pattern(match: re.Match[str]):
                nonlocal tick
                name = match[1]
                if (pattern := formats.get(name)) is None:
                    if (pattern := indicators.get(name)) is None:
                        return match[0]
                tick += 1
                pattern = re.sub(
                    R&#39;(?&lt;=\(\?P[&lt;=])__(\w+)__&#39;, F&#39;__\\1_{tick}__&#39;, str(pattern))
                return F&#39;(?:{pattern})&#39;

            def replace_variable_assignment(match):
                return F&#39;(?P&lt;{match[1]}&gt;&#39;

            expression = re.sub(R&#39;\(\?/(\w+)=&#39;,
                replace_variable_assignment, expression)
            expression = re.sub(
                R&#39;\(\?\?([-\w]+)\)&#39;,
                replace_known_pattern,
                expression
            )

        return expression.encode(&#39;latin-1&#39;)

    @handler.register(&#39;f&#39;, final=True)
    def format(self, name: str) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `f:[name]` returns a regular expression for to one of the format types
        supported by `refinery.carve` unit.
        &#34;&#34;&#34;
        from refinery.lib.patterns import formats
        try:
            return formats[name].value.bin_pattern
        except LookupError:
            raise ArgumentTypeError(
                F&#39;Based on the prefix &#34;f:&#34;, the parser looked for a carve format named &#34;{name}&#34;.&#39;
                &#39; No such format is known; prefix the entire expression with &#34;s:&#34; if this was &#39;
                &#39;unintended, otherwise correct the format name spelling.&#39;)

    @handler.register(&#39;yara&#39;, &#39;y&#39;, &#39;Y&#39;)
    def yara(self, pattern: bytes) -&gt; bytes:
        &#34;&#34;&#34;
        The handler `yara:pattern` or `Y:pattern` converts YARA syntax wildcard hexadecimal
        expressions into standard regular expressions. For example, the string `D?` is
        translated to `[\\xD0-\\xDF]`, the expression `[2-6]` becomes `.{2,6}`, and `?D`
        becomes the following substring:
        ```
        [\\x0D\\x1D\\x2D\\x3D\\x4D\\x5D\\x6D\\x7D\\x8D\\x9D\\xAD\\xBD\\xCD\\xDD\\xED\\xFD]
        ```
        Only two-letter hexadecimal sequences with optional `?` wildcards and wildcard
        ranges such as `[2-6]` are substituted, all other characters in the pattern are
        left unchanged.
        &#34;&#34;&#34;
        def y2r(match: re.Match[bytes]):
            mask = match[2]
            _not = bool(match[1])
            if mask == B&#39;??&#39;:
                if _not:
                    raise ArgumentTypeError(&#39;Found ~?? in YARA pattern; cannot negate arbitrary wildcard.&#39;)
                return B&#39;.&#39;
            if B&#39;?&#39; not in mask:
                pattern = BR&#39;\x%s&#39; % mask
                if not _not:
                    return pattern
            elif mask.endswith(B&#39;?&#39;):
                pattern = BR&#39;\x%c0-\x%cF&#39; % (mask[0], mask[0])
            else:
                pattern = BR&#39;%s&#39; % BR&#39;&#39;.join(BR&#39;\x%x%c&#39; % (k, mask[1]) for k in range(0x10))
            return B&#39;[%s%s]&#39; % (_not * B&#39;^&#39;, pattern)

        def yara_range(rng: bytes, last: bool):
            bounds = [t.strip() for t in rng[1:-1].split(B&#39;-&#39;)]
            if len(bounds) &gt; 2:
                raise ArgumentTypeError(F&#39;Invalid YARA range: {rng}&#39;)
            if not any(bounds):
                return B&#39;.*&#39; if last else B&#39;.*?&#39;
            if not bounds[0]:
                bounds[0] = B&#39;0&#39;
            return B&#39;.{%s}&#39; % B&#39;,&#39;.join(bounds)

        pattern = re.split(BR&#39;(\[\s*\d*(?:\s*-\s*\d*)?\s*\])&#39;, pattern)
        length = (len(pattern) // 2) - int(not pattern[~0])
        pattern[0::2] = [re.sub(BR&#39;(~?)([A-Fa-f0-9?]{2})&#39;, y2r, c) for c in pattern[::2]]
        pattern[1::2] = [yara_range(b, k == length) for k, b in enumerate(pattern[1::2])]
        pattern = B&#39;&#39;.join(pattern)
        return pattern</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></li>
<li><a title="refinery.lib.argformats.LazyEvaluation" href="#refinery.lib.argformats.LazyEvaluation">LazyEvaluation</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.argformats.DelayedRegexpArgument.handler"><code class="name flex">
<span>def <span class="ident">handler</span></span>(<span>self, expression)</span>
</code></dt>
<dd>
<section class="desc"><p>The default handler encodes the input expression as latin-1 to return a binary string regular
expression. Two additional syntax features have been added:</p>
<ul>
<li>The use of named patterns from <code><a title="refinery.lib.patterns.formats" href="patterns/index.html#refinery.lib.patterns.formats">formats</a></code> and <code><a title="refinery.lib.patterns.indicators" href="patterns/index.html#refinery.lib.patterns.indicators">indicators</a></code>
is possible by means of the extension format <code>(??name)</code>. For example, the pattern <code>((??url)\x00){4}</code>
will match a sequence of four URL strings which are all terminated with a null character.</li>
<li>The syntax <code>(?/var=PATTERN)</code> is equivalent to <code>(?P&lt;var&gt;PATTERN)</code>.</li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1555-L1592" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@DelayedArgumentDispatch.Inherit(DelayedArgument)
def handler(self, expression: str) -&gt; bytes:
    &#34;&#34;&#34;
    The default handler encodes the input expression as latin-1 to return a binary string regular
    expression. Two additional syntax features have been added:

    - The use of named patterns from `refinery.lib.patterns.formats` and `refinery.lib.patterns.indicators`
      is possible by means of the extension format `(??name)`. For example, the pattern `((??url)\\x00){4}`
      will match a sequence of four URL strings which are all terminated with a null character.
    - The syntax `(?/var=PATTERN)` is equivalent to `(?P&lt;var&gt;PATTERN)`.
    &#34;&#34;&#34;
    if &#39;(?&#39; in expression:
        from refinery.lib.patterns import formats, indicators
        tick = 0

        def replace_known_pattern(match: re.Match[str]):
            nonlocal tick
            name = match[1]
            if (pattern := formats.get(name)) is None:
                if (pattern := indicators.get(name)) is None:
                    return match[0]
            tick += 1
            pattern = re.sub(
                R&#39;(?&lt;=\(\?P[&lt;=])__(\w+)__&#39;, F&#39;__\\1_{tick}__&#39;, str(pattern))
            return F&#39;(?:{pattern})&#39;

        def replace_variable_assignment(match):
            return F&#39;(?P&lt;{match[1]}&gt;&#39;

        expression = re.sub(R&#39;\(\?/(\w+)=&#39;,
            replace_variable_assignment, expression)
        expression = re.sub(
            R&#39;\(\?\?([-\w]+)\)&#39;,
            replace_known_pattern,
            expression
        )

    return expression.encode(&#39;latin-1&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedRegexpArgument.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>The handler <code>f:[name]</code> returns a regular expression for to one of the format types
supported by <code><a title="refinery.carve" href="../index.html#refinery.carve">carve</a></code> unit.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1594-L1607" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;f&#39;, final=True)
def format(self, name: str) -&gt; bytes:
    &#34;&#34;&#34;
    The handler `f:[name]` returns a regular expression for to one of the format types
    supported by `refinery.carve` unit.
    &#34;&#34;&#34;
    from refinery.lib.patterns import formats
    try:
        return formats[name].value.bin_pattern
    except LookupError:
        raise ArgumentTypeError(
            F&#39;Based on the prefix &#34;f:&#34;, the parser looked for a carve format named &#34;{name}&#34;.&#39;
            &#39; No such format is known; prefix the entire expression with &#34;s:&#34; if this was &#39;
            &#39;unintended, otherwise correct the format name spelling.&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.argformats.DelayedRegexpArgument.yara"><code class="name flex">
<span>def <span class="ident">yara</span></span>(<span>self, pattern)</span>
</code></dt>
<dd>
<section class="desc"><p>The handler <code>yara:pattern</code> or <code>Y:pattern</code> converts YARA syntax wildcard hexadecimal
expressions into standard regular expressions. For example, the string <code>D?</code> is
translated to <code>[\xD0-\xDF]</code>, the expression <code>[2-6]</code> becomes <code>.{2,6}</code>, and <code>?D</code>
becomes the following substring:</p>
<pre><code>[\x0D\x1D\x2D\x3D\x4D\x5D\x6D\x7D\x8D\x9D\xAD\xBD\xCD\xDD\xED\xFD]
</code></pre>
<p>Only two-letter hexadecimal sequences with optional <code>?</code> wildcards and wildcard
ranges such as <code>[2-6]</code> are substituted, all other characters in the pattern are
left unchanged.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1609-L1655" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@handler.register(&#39;yara&#39;, &#39;y&#39;, &#39;Y&#39;)
def yara(self, pattern: bytes) -&gt; bytes:
    &#34;&#34;&#34;
    The handler `yara:pattern` or `Y:pattern` converts YARA syntax wildcard hexadecimal
    expressions into standard regular expressions. For example, the string `D?` is
    translated to `[\\xD0-\\xDF]`, the expression `[2-6]` becomes `.{2,6}`, and `?D`
    becomes the following substring:
    ```
    [\\x0D\\x1D\\x2D\\x3D\\x4D\\x5D\\x6D\\x7D\\x8D\\x9D\\xAD\\xBD\\xCD\\xDD\\xED\\xFD]
    ```
    Only two-letter hexadecimal sequences with optional `?` wildcards and wildcard
    ranges such as `[2-6]` are substituted, all other characters in the pattern are
    left unchanged.
    &#34;&#34;&#34;
    def y2r(match: re.Match[bytes]):
        mask = match[2]
        _not = bool(match[1])
        if mask == B&#39;??&#39;:
            if _not:
                raise ArgumentTypeError(&#39;Found ~?? in YARA pattern; cannot negate arbitrary wildcard.&#39;)
            return B&#39;.&#39;
        if B&#39;?&#39; not in mask:
            pattern = BR&#39;\x%s&#39; % mask
            if not _not:
                return pattern
        elif mask.endswith(B&#39;?&#39;):
            pattern = BR&#39;\x%c0-\x%cF&#39; % (mask[0], mask[0])
        else:
            pattern = BR&#39;%s&#39; % BR&#39;&#39;.join(BR&#39;\x%x%c&#39; % (k, mask[1]) for k in range(0x10))
        return B&#39;[%s%s]&#39; % (_not * B&#39;^&#39;, pattern)

    def yara_range(rng: bytes, last: bool):
        bounds = [t.strip() for t in rng[1:-1].split(B&#39;-&#39;)]
        if len(bounds) &gt; 2:
            raise ArgumentTypeError(F&#39;Invalid YARA range: {rng}&#39;)
        if not any(bounds):
            return B&#39;.*&#39; if last else B&#39;.*?&#39;
        if not bounds[0]:
            bounds[0] = B&#39;0&#39;
        return B&#39;.{%s}&#39; % B&#39;,&#39;.join(bounds)

    pattern = re.split(BR&#39;(\[\s*\d*(?:\s*-\s*\d*)?\s*\])&#39;, pattern)
    length = (len(pattern) // 2) - int(not pattern[~0])
    pattern[0::2] = [re.sub(BR&#39;(~?)([A-Fa-f0-9?]{2})&#39;, y2r, c) for c in pattern[::2]]
    pattern[1::2] = [yara_range(b, k == length) for k, b in enumerate(pattern[1::2])]
    pattern = B&#39;&#39;.join(pattern)
    return pattern</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.argformats.DelayedArgument.a" href="#refinery.lib.argformats.DelayedArgument.a">a</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.accu" href="#refinery.lib.argformats.DelayedArgument.accu">accu</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.be" href="#refinery.lib.argformats.DelayedArgument.be">be</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.btoi" href="#refinery.lib.argformats.DelayedArgument.btoi">btoi</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.copy" href="#refinery.lib.argformats.DelayedArgument.copy">copy</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.cut" href="#refinery.lib.argformats.DelayedArgument.cut">cut</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.cycle" href="#refinery.lib.argformats.DelayedArgument.cycle">cycle</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.dec" href="#refinery.lib.argformats.DelayedArgument.dec">dec</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.eat" href="#refinery.lib.argformats.DelayedArgument.eat">eat</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.env" href="#refinery.lib.argformats.DelayedArgument.env">env</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.eval" href="#refinery.lib.argformats.DelayedArgument.eval">eval</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.h" href="#refinery.lib.argformats.DelayedArgument.h">h</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.inc" href="#refinery.lib.argformats.DelayedArgument.inc">inc</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.itob" href="#refinery.lib.argformats.DelayedArgument.itob">itob</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.le" href="#refinery.lib.argformats.DelayedArgument.le">le</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.n" href="#refinery.lib.argformats.DelayedArgument.n">n</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pb" href="#refinery.lib.argformats.DelayedArgument.pb">pb</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pd" href="#refinery.lib.argformats.DelayedArgument.pd">pd</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pn" href="#refinery.lib.argformats.DelayedArgument.pn">pn</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pos" href="#refinery.lib.argformats.DelayedArgument.pos">pos</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.prng" href="#refinery.lib.argformats.DelayedArgument.prng">prng</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.px" href="#refinery.lib.argformats.DelayedArgument.px">px</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.q" href="#refinery.lib.argformats.DelayedArgument.q">q</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.range" href="#refinery.lib.argformats.DelayedArgument.range">range</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.read" href="#refinery.lib.argformats.DelayedArgument.read">read</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.readfrom" href="#refinery.lib.argformats.DelayedArgument.readfrom">readfrom</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.reduce" href="#refinery.lib.argformats.DelayedArgument.reduce">reduce</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.rng" href="#refinery.lib.argformats.DelayedArgument.rng">rng</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.rx" href="#refinery.lib.argformats.DelayedArgument.rx">rx</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.s" href="#refinery.lib.argformats.DelayedArgument.s">s</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.take" href="#refinery.lib.argformats.DelayedArgument.take">take</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.u" href="#refinery.lib.argformats.DelayedArgument.u">u</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.var" href="#refinery.lib.argformats.DelayedArgument.var">var</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.argformats.DelayedNumberArgument"><code class="flex name class">
<span>class <span class="ident">DelayedNumberArgument</span></span>
<span>(</span><span>expression, min, max)</span>
</code></dt>
<dd>
<section class="desc"><p>A parser for numeric arguments. Implements no handlers beyond the ones inherited from its parent
<code><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></code>. The final handler output is expected to be an integer.
The class can be initialized with numerical bounds and checks the validity of the input after
having evaluated all handlers.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1658-L1685" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DelayedNumberArgument(DelayedArgument):
    &#34;&#34;&#34;
    A parser for numeric arguments. Implements no handlers beyond the ones inherited from its parent
    `refinery.lib.argformats.DelayedArgument`. The final handler output is expected to be an integer.
    The class can be initialized with numerical bounds and checks the validity of the input after
    having evaluated all handlers.
    &#34;&#34;&#34;
    def __init__(self, expression: str, min: int | None, max: int | None):
        self.min = min
        self.max = max
        super().__init__(expression)

    def __call__(self, data: buf | Chunk | None = None) -&gt; int:
        value = super().__call__(data)
        if not isinstance(value, int):
            tv = type(value).__name__
            raise ArgumentTypeError(F&#39;The value computed from {self.expression} is of type {tv}, it should be an integer.&#39;)
        if self.min is not None and value &lt; self.min or self.max is not None and value &gt; self.max:
            a = &#39;-&#39; if self.min is None else self.min
            b = &#39;&#39; if self.max is None else self.max
            raise ArgumentTypeError(F&#39;value {value} is out of bounds [{a},{b}]&#39;)
        return value

    def default_handler(self, expression: str) -&gt; int:
        &#34;&#34;&#34;
        The default handler: Attempts to parse the input expression as an integer.
        &#34;&#34;&#34;
        return LazyPythonExpression(expression)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></li>
<li><a title="refinery.lib.argformats.LazyEvaluation" href="#refinery.lib.argformats.LazyEvaluation">LazyEvaluation</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.argformats.DelayedNumberArgument.default_handler"><code class="name flex">
<span>def <span class="ident">default_handler</span></span>(<span>self, expression)</span>
</code></dt>
<dd>
<section class="desc"><p>The default handler: Attempts to parse the input expression as an integer.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1681-L1685" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def default_handler(self, expression: str) -&gt; int:
    &#34;&#34;&#34;
    The default handler: Attempts to parse the input expression as an integer.
    &#34;&#34;&#34;
    return LazyPythonExpression(expression)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.argformats.DelayedArgument.a" href="#refinery.lib.argformats.DelayedArgument.a">a</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.accu" href="#refinery.lib.argformats.DelayedArgument.accu">accu</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.be" href="#refinery.lib.argformats.DelayedArgument.be">be</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.btoi" href="#refinery.lib.argformats.DelayedArgument.btoi">btoi</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.copy" href="#refinery.lib.argformats.DelayedArgument.copy">copy</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.cut" href="#refinery.lib.argformats.DelayedArgument.cut">cut</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.cycle" href="#refinery.lib.argformats.DelayedArgument.cycle">cycle</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.dec" href="#refinery.lib.argformats.DelayedArgument.dec">dec</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.eat" href="#refinery.lib.argformats.DelayedArgument.eat">eat</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.env" href="#refinery.lib.argformats.DelayedArgument.env">env</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.eval" href="#refinery.lib.argformats.DelayedArgument.eval">eval</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.h" href="#refinery.lib.argformats.DelayedArgument.h">h</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.inc" href="#refinery.lib.argformats.DelayedArgument.inc">inc</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.itob" href="#refinery.lib.argformats.DelayedArgument.itob">itob</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.le" href="#refinery.lib.argformats.DelayedArgument.le">le</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.n" href="#refinery.lib.argformats.DelayedArgument.n">n</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pb" href="#refinery.lib.argformats.DelayedArgument.pb">pb</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pd" href="#refinery.lib.argformats.DelayedArgument.pd">pd</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pn" href="#refinery.lib.argformats.DelayedArgument.pn">pn</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pos" href="#refinery.lib.argformats.DelayedArgument.pos">pos</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.prng" href="#refinery.lib.argformats.DelayedArgument.prng">prng</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.px" href="#refinery.lib.argformats.DelayedArgument.px">px</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.q" href="#refinery.lib.argformats.DelayedArgument.q">q</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.range" href="#refinery.lib.argformats.DelayedArgument.range">range</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.read" href="#refinery.lib.argformats.DelayedArgument.read">read</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.readfrom" href="#refinery.lib.argformats.DelayedArgument.readfrom">readfrom</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.reduce" href="#refinery.lib.argformats.DelayedArgument.reduce">reduce</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.rng" href="#refinery.lib.argformats.DelayedArgument.rng">rng</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.rx" href="#refinery.lib.argformats.DelayedArgument.rx">rx</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.s" href="#refinery.lib.argformats.DelayedArgument.s">s</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.take" href="#refinery.lib.argformats.DelayedArgument.take">take</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.u" href="#refinery.lib.argformats.DelayedArgument.u">u</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.var" href="#refinery.lib.argformats.DelayedArgument.var">var</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.argformats.Option"><code class="flex name class">
<span>class <span class="ident">Option</span></span>
<span>(</span><span>name)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1768-L1790" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Option(ABC):
    name: str
    mode: Any

    @abstractmethod
    def __init__(self, name: str):
        raise NotImplementedError

    def __eq__(self, other):
        return str(other) == self.name

    def __hash__(self):
        return hash(self.name)

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.name

    @property
    def value(self):
        return self.mode</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>refinery.lib.argformats.OptionFactory.Option[CBC,CCM,CFB,CTR,EAX,ECB,GCM,KW,KWP,OCB,OFB]</li>
<li>refinery.lib.argformats.OptionFactory.Option[CBC,CFB,CTR,EAX,ECB,OFB]</li>
<li>refinery.lib.argformats.OptionFactory.Option[CBC,CFB,CTR,ECB,OFB,PCBC]</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.argformats.Option.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.argformats.Option.mode"><code class="name">var <span class="ident">mode</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.argformats.Option.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/argformats.py#L1788-L1790" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def value(self):
    return self.mode</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#multibin-syntax">Multibin Syntax</a></li>
<li><a href="#arguments-for-handlers">Arguments For Handlers</a></li>
<li><a href="#technical-details">Technical Details</a></li>
<li><a href="#examples">Examples</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="refinery.lib.argformats.number" href="#refinery.lib.argformats.number">number</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.argformats.percent" href="#refinery.lib.argformats.percent">percent</a></code></li>
<li><code><a title="refinery.lib.argformats.relslice" href="#refinery.lib.argformats.relslice">relslice</a></code></li>
<li><code><a title="refinery.lib.argformats.sliceobj" href="#refinery.lib.argformats.sliceobj">sliceobj</a></code></li>
<li><code><a title="refinery.lib.argformats.utf8" href="#refinery.lib.argformats.utf8">utf8</a></code></li>
<li><code><a title="refinery.lib.argformats.LazyPythonExpression" href="#refinery.lib.argformats.LazyPythonExpression">LazyPythonExpression</a></code></li>
<li><code><a title="refinery.lib.argformats.numseq" href="#refinery.lib.argformats.numseq">numseq</a></code></li>
<li><code><a title="refinery.lib.argformats.pathvar" href="#refinery.lib.argformats.pathvar">pathvar</a></code></li>
<li><code><a title="refinery.lib.argformats.multibin" href="#refinery.lib.argformats.multibin">multibin</a></code></li>
<li><code><a title="refinery.lib.argformats.regexp" href="#refinery.lib.argformats.regexp">regexp</a></code></li>
<li><code><a title="refinery.lib.argformats.OptionFactory" href="#refinery.lib.argformats.OptionFactory">OptionFactory</a></code></li>
<li><code><a title="refinery.lib.argformats.extract_options" href="#refinery.lib.argformats.extract_options">extract_options</a></code></li>
<li><code><a title="refinery.lib.argformats.pending" href="#refinery.lib.argformats.pending">pending</a></code></li>
<li><code><a title="refinery.lib.argformats.manifest" href="#refinery.lib.argformats.manifest">manifest</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.argformats.ParserError" href="#refinery.lib.argformats.ParserError">ParserError</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.ParserVariableMissing" href="#refinery.lib.argformats.ParserVariableMissing">ParserVariableMissing</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.LazyEvaluation" href="#refinery.lib.argformats.LazyEvaluation">LazyEvaluation</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.PythonExpression" href="#refinery.lib.argformats.PythonExpression">PythonExpression</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.argformats.PythonExpression.Lazy" href="#refinery.lib.argformats.PythonExpression.Lazy">Lazy</a></code></li>
<li><code><a title="refinery.lib.argformats.PythonExpression.Evaluate" href="#refinery.lib.argformats.PythonExpression.Evaluate">Evaluate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.SliceAgain" href="#refinery.lib.argformats.SliceAgain">SliceAgain</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.IncompatibleHandler" href="#refinery.lib.argformats.IncompatibleHandler">IncompatibleHandler</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.TooLazy" href="#refinery.lib.argformats.TooLazy">TooLazy</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.VariableMissing" href="#refinery.lib.argformats.VariableMissing">VariableMissing</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.DelayedArgumentDispatch" href="#refinery.lib.argformats.DelayedArgumentDispatch">DelayedArgumentDispatch</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.argformats.DelayedArgumentDispatch.Inherit" href="#refinery.lib.argformats.DelayedArgumentDispatch.Inherit">Inherit</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgumentDispatch.can_handle" href="#refinery.lib.argformats.DelayedArgumentDispatch.can_handle">can_handle</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgumentDispatch.terminates" href="#refinery.lib.argformats.DelayedArgumentDispatch.terminates">terminates</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgumentDispatch.register" href="#refinery.lib.argformats.DelayedArgumentDispatch.register">register</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.DelayedArgument" href="#refinery.lib.argformats.DelayedArgument">DelayedArgument</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.lib.argformats.DelayedArgument.default_handler" href="#refinery.lib.argformats.DelayedArgument.default_handler">default_handler</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.handler" href="#refinery.lib.argformats.DelayedArgument.handler">handler</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.s" href="#refinery.lib.argformats.DelayedArgument.s">s</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.u" href="#refinery.lib.argformats.DelayedArgument.u">u</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.a" href="#refinery.lib.argformats.DelayedArgument.a">a</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.bang_h" href="#refinery.lib.argformats.DelayedArgument.bang_h">bang_h</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.h" href="#refinery.lib.argformats.DelayedArgument.h">h</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.n" href="#refinery.lib.argformats.DelayedArgument.n">n</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.bang_n" href="#refinery.lib.argformats.DelayedArgument.bang_n">bang_n</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.q" href="#refinery.lib.argformats.DelayedArgument.q">q</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.read" href="#refinery.lib.argformats.DelayedArgument.read">read</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.readfrom" href="#refinery.lib.argformats.DelayedArgument.readfrom">readfrom</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.range" href="#refinery.lib.argformats.DelayedArgument.range">range</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.env" href="#refinery.lib.argformats.DelayedArgument.env">env</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pos" href="#refinery.lib.argformats.DelayedArgument.pos">pos</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.rx" href="#refinery.lib.argformats.DelayedArgument.rx">rx</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.copy" href="#refinery.lib.argformats.DelayedArgument.copy">copy</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.cut" href="#refinery.lib.argformats.DelayedArgument.cut">cut</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pd" href="#refinery.lib.argformats.DelayedArgument.pd">pd</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pb" href="#refinery.lib.argformats.DelayedArgument.pb">pb</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.pn" href="#refinery.lib.argformats.DelayedArgument.pn">pn</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.px" href="#refinery.lib.argformats.DelayedArgument.px">px</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.var" href="#refinery.lib.argformats.DelayedArgument.var">var</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.eat" href="#refinery.lib.argformats.DelayedArgument.eat">eat</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.eval" href="#refinery.lib.argformats.DelayedArgument.eval">eval</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.btoi" href="#refinery.lib.argformats.DelayedArgument.btoi">btoi</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.itob" href="#refinery.lib.argformats.DelayedArgument.itob">itob</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.inc" href="#refinery.lib.argformats.DelayedArgument.inc">inc</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.dec" href="#refinery.lib.argformats.DelayedArgument.dec">dec</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.take" href="#refinery.lib.argformats.DelayedArgument.take">take</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.cycle" href="#refinery.lib.argformats.DelayedArgument.cycle">cycle</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.rng" href="#refinery.lib.argformats.DelayedArgument.rng">rng</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.prng" href="#refinery.lib.argformats.DelayedArgument.prng">prng</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.accu" href="#refinery.lib.argformats.DelayedArgument.accu">accu</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.be" href="#refinery.lib.argformats.DelayedArgument.be">be</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.le" href="#refinery.lib.argformats.DelayedArgument.le">le</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedArgument.reduce" href="#refinery.lib.argformats.DelayedArgument.reduce">reduce</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.DelayedBinaryArgument" href="#refinery.lib.argformats.DelayedBinaryArgument">DelayedBinaryArgument</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.DelayedPathArgument" href="#refinery.lib.argformats.DelayedPathArgument">DelayedPathArgument</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.argformats.DelayedPathArgument.default_handler" href="#refinery.lib.argformats.DelayedPathArgument.default_handler">default_handler</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.DelayedNumSeqArgument" href="#refinery.lib.argformats.DelayedNumSeqArgument">DelayedNumSeqArgument</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.argformats.DelayedNumSeqArgument.default_handler" href="#refinery.lib.argformats.DelayedNumSeqArgument.default_handler">default_handler</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.DelayedRegexpArgument" href="#refinery.lib.argformats.DelayedRegexpArgument">DelayedRegexpArgument</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.argformats.DelayedRegexpArgument.handler" href="#refinery.lib.argformats.DelayedRegexpArgument.handler">handler</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedRegexpArgument.format" href="#refinery.lib.argformats.DelayedRegexpArgument.format">format</a></code></li>
<li><code><a title="refinery.lib.argformats.DelayedRegexpArgument.yara" href="#refinery.lib.argformats.DelayedRegexpArgument.yara">yara</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.DelayedNumberArgument" href="#refinery.lib.argformats.DelayedNumberArgument">DelayedNumberArgument</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.argformats.DelayedNumberArgument.default_handler" href="#refinery.lib.argformats.DelayedNumberArgument.default_handler">default_handler</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.argformats.Option" href="#refinery.lib.argformats.Option">Option</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
