<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.intervals documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.intervals</code></h1>
</header>
<section id="section-intro">
<p>Classes that implement different kinds of interval unions. These are primarily used by code
related to <code><a title="refinery.lib.emulator" href="emulator/index.html">refinery.lib.emulator</a></code> for representing memory regions that have been mapped or
written to.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/intervals.py#L1-L232" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Classes that implement different kinds of interval unions. These are primarily used by code
related to `refinery.lib.emulator` for representing memory regions that have been mapped or
written to.
&#34;&#34;&#34;
from __future__ import annotations

from abc import ABC, abstractmethod
from bisect import bisect_right
from typing import ClassVar, Generic, Iterator, TypeVar

Value = TypeVar(&#39;Value&#39;)
&#34;&#34;&#34;
A generic type variable representing the value type for `refinery.lib.intervals.IntervalUnion`.
Intervals `[A,B]` are stored by mapping `A` to a `refinery.lib.intervals.Value` object which
contains all additional information about the interval. In particular, `B` can be computed from
this object. The `refinery.lib.intervals.MemoryIntervalUnion` implementation, for example, uses
a `bytearray` type for the `refinery.lib.intervals.Value`.
&#34;&#34;&#34;


class IntervalUnion(ABC, Generic[Value]):
    &#34;&#34;&#34;
    An abstract class representing a generic union of intervals. Intervals inserted into the union
    are automatically fused if they overlap or touch.
    &#34;&#34;&#34;

    value_type: ClassVar[type]
    &#34;&#34;&#34;
    This class variable contains the type of `refinery.lib.intervals.Value`.
    &#34;&#34;&#34;

    def __init__(self):
        self._starts: list[int] = []
        self._values: dict[int, Value] = {}

    @abstractmethod
    def sizeof(self, d: Value) -&gt; int:
        &#34;&#34;&#34;
        Compute the length of the interval from the stored `refinery.lib.intervals.Value` value.
        &#34;&#34;&#34;

    @abstractmethod
    def insert(
        self,
        start: int,
        value: Value,
        new_start: int,
        new_value: Value,
    ) -&gt; Value:
        &#34;&#34;&#34;
        Insert new interval data into an interval that already exists and covers the start of the
        newly inserted interval.
        &#34;&#34;&#34;

    @abstractmethod
    def extend(
        self,
        start: int,
        value: Value,
        new_delta: int,
        new_value: Value
    ) -&gt; Value:
        &#34;&#34;&#34;
        This function extends the interval given by `(start;value)` with the data from the interval
        `(new_start;new_value)`. Instead of `new_start`, however, the function expects the parameter
        `new_delta` which is computed as subtracting `new_start` from the result of calling the
        method `refinery.lib.intervals.IntervalUnion.endof` for the interval `(start;value)`.
        &#34;&#34;&#34;

    def endof(self, start: int, value: Value | None = None):
        &#34;&#34;&#34;
        Compute the end of an interval. A `refinery.lib.intervals.Value` can be provided; if none
        is given, the interval is assumed to exist in the union and its value is recovered from the
        internal storage.
        &#34;&#34;&#34;
        if value is None:
            value = self._starts[start]
        return start + self.sizeof(value)

    def clear(self):
        &#34;&#34;&#34;
        Remove all intervals from the union.
        &#34;&#34;&#34;
        self._starts.clear()
        self._values.clear()

    def __len__(self):
        return len(self._starts)

    def __iter__(self):
        for start in self._starts:
            yield (start, self._values[start])

    def _insertion_point(self, point: int, append: bool = False):
        &#34;&#34;&#34;
        Find the insertion point for any given integer value. The result is a tuple containing:
        - An index into the sorted array of interval starts. If an interval already covers the point,
          then this index points to the start of that interval. If no interval covers the point, this
          value is the index where a new interval start would have to be inserted.
        - The start of an existing interval that covers the point, or `None` if this does not exist.
        - The value of an existing interval that covers the point, or `None` if this does not exist.
        An interval `[A,B]` covers a point `P` if `A &lt;= P &lt;= B+X` where `X` is `1` if the `append`
        parameter is `True`, and `0` otherwise.
        &#34;&#34;&#34;
        index = bisect_right(self._starts, point)
        start = None
        value = None
        if index &gt; 0:
            _start = self._starts[index - 1]
            _value = self._values[_start]
            if point in range(_start, _start + self.sizeof(_value) + append):
                index = index - 1
                start = _start
                value = _value
        return index, start, value

    def addi(self, start: int, value: Value):
        &#34;&#34;&#34;
        Insert a new interval into the union.
        &#34;&#34;&#34;
        starts = self._starts
        values = self._values

        index_of_start, cursor_start, cursor_value = self._insertion_point(
            start, value is not None)
        index_of_next = index_of_start + int(cursor_start is not None)

        if cursor_value is None:
            cursor_start = start
            cursor_value = values[cursor_start] = self.value_type()
            index_of_start = index_of_next
            index_of_next = index_of_next + 1
            starts.append(cursor_start)
            starts.sort()
            if starts[index_of_start] != cursor_start:
                raise RuntimeError(
                    F&#39;Adding 0x{cursor_start:X} into sorted lookup table failed; &#39;
                    &#39;value did not end up at the expected position.&#39;)

        cursor_value = self.insert(cursor_start, cursor_value, start, value)
        end = cursor_start + self.sizeof(cursor_value)

        insert_value = None
        insert_start = 0

        for index_after_merge in range(index_of_next, len(starts)):
            temp = starts[index_after_merge]
            if temp &gt; end:
                break
            insert_start = temp
            insert_value = values.pop(insert_start)
        else:
            if insert_value is not None:
                index_after_merge += 1

        if insert_value is not None:
            del starts[index_of_next:index_after_merge]
            if (insert_delta := end - insert_start) &gt;= 0:
                self.extend(
                    cursor_start,
                    cursor_value,
                    insert_delta,
                    insert_value,
                )

        return cursor_start

    def overlap(self, start: int, value: Value) -&gt; Iterator[tuple[int, Value]]:
        &#34;&#34;&#34;
        Generate all intervals in the union that overlap with the given interval.
        &#34;&#34;&#34;
        starts = self._starts
        values = self._values
        lower, _, _ = self._insertion_point(start)
        upper, b, _ = self._insertion_point(self.endof(start, value))
        for k in range(lower, upper + bool(b)):
            start = starts[k]
            value = values[start]
            yield (start, value)

    def overlaps(self, start: int, value: Value | None = None) -&gt; bool:
        &#34;&#34;&#34;
        Return whether the given interval or point overlaps with any interval in the union.
        &#34;&#34;&#34;
        if value is None:
            _, base, _ = self._insertion_point(start)
            return base is not None
        return any(self.overlap(start, value))


class IntIntervalUnion(IntervalUnion[int]):
    &#34;&#34;&#34;
    An `refinery.lib.intervals.IntervalUnion` of `(start, length)` pairs. Notably, the length of an
    inclusive interval `[A,B]` is computed as `(B-A+1)`.
    &#34;&#34;&#34;
    value_type = int

    def sizeof(self, d: int) -&gt; int:
        return d

    def insert(self, start: int, value: int, new_start: int, new_value: int) -&gt; int:
        self._values[start] = value = max(value, new_start - start + new_value)
        return value

    def extend(self, start: int, value: int, new_delta: int, new_value: int) -&gt; int:
        self._values[start] = value = value + new_value - new_delta
        return value


class MemoryIntervalUnion(IntervalUnion[bytearray]):
    &#34;&#34;&#34;
    An `refinery.lib.intervals.IntervalUnion` of memory patches, implemented as `(start, data)`
    paris. Each `data` value is a `bytearray` which contains the region of memory that starts at
    the base address `start`.
    &#34;&#34;&#34;

    value_type = bytearray

    def sizeof(self, d: bytearray) -&gt; int:
        return len(d)

    def insert(self, start: int, value: bytearray, new_start: int, new_value: bytearray) -&gt; bytearray:
        rva = new_start - start
        end = rva + len(new_value)
        value[rva:end] = new_value
        return value

    def extend(self, start: int, value: bytearray, new_delta: int, new_value: bytearray) -&gt; bytearray:
        view = memoryview(new_value)
        value.extend(view[new_delta:])
        return value</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="refinery.lib.intervals.Value"><code class="name">var <span class="ident">Value</span></code></dt>
<dd>
<section class="desc"><p>A generic type variable representing the value type for <code><a title="refinery.lib.intervals.IntervalUnion" href="#refinery.lib.intervals.IntervalUnion">IntervalUnion</a></code>.
Intervals <code>[A,B]</code> are stored by mapping <code>A</code> to a <code><a title="refinery.lib.intervals.Value" href="#refinery.lib.intervals.Value">Value</a></code> object which
contains all additional information about the interval. In particular, <code>B</code> can be computed from
this object. The <code><a title="refinery.lib.intervals.MemoryIntervalUnion" href="#refinery.lib.intervals.MemoryIntervalUnion">MemoryIntervalUnion</a></code> implementation, for example, uses
a <code>bytearray</code> type for the <code><a title="refinery.lib.intervals.Value" href="#refinery.lib.intervals.Value">Value</a></code>.</p></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.intervals.IntervalUnion"><code class="flex name class">
<span>class <span class="ident">IntervalUnion</span></span>
</code></dt>
<dd>
<section class="desc"><p>An abstract class representing a generic union of intervals. Intervals inserted into the union
are automatically fused if they overlap or touch.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/intervals.py#L22-L189" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IntervalUnion(ABC, Generic[Value]):
    &#34;&#34;&#34;
    An abstract class representing a generic union of intervals. Intervals inserted into the union
    are automatically fused if they overlap or touch.
    &#34;&#34;&#34;

    value_type: ClassVar[type]
    &#34;&#34;&#34;
    This class variable contains the type of `refinery.lib.intervals.Value`.
    &#34;&#34;&#34;

    def __init__(self):
        self._starts: list[int] = []
        self._values: dict[int, Value] = {}

    @abstractmethod
    def sizeof(self, d: Value) -&gt; int:
        &#34;&#34;&#34;
        Compute the length of the interval from the stored `refinery.lib.intervals.Value` value.
        &#34;&#34;&#34;

    @abstractmethod
    def insert(
        self,
        start: int,
        value: Value,
        new_start: int,
        new_value: Value,
    ) -&gt; Value:
        &#34;&#34;&#34;
        Insert new interval data into an interval that already exists and covers the start of the
        newly inserted interval.
        &#34;&#34;&#34;

    @abstractmethod
    def extend(
        self,
        start: int,
        value: Value,
        new_delta: int,
        new_value: Value
    ) -&gt; Value:
        &#34;&#34;&#34;
        This function extends the interval given by `(start;value)` with the data from the interval
        `(new_start;new_value)`. Instead of `new_start`, however, the function expects the parameter
        `new_delta` which is computed as subtracting `new_start` from the result of calling the
        method `refinery.lib.intervals.IntervalUnion.endof` for the interval `(start;value)`.
        &#34;&#34;&#34;

    def endof(self, start: int, value: Value | None = None):
        &#34;&#34;&#34;
        Compute the end of an interval. A `refinery.lib.intervals.Value` can be provided; if none
        is given, the interval is assumed to exist in the union and its value is recovered from the
        internal storage.
        &#34;&#34;&#34;
        if value is None:
            value = self._starts[start]
        return start + self.sizeof(value)

    def clear(self):
        &#34;&#34;&#34;
        Remove all intervals from the union.
        &#34;&#34;&#34;
        self._starts.clear()
        self._values.clear()

    def __len__(self):
        return len(self._starts)

    def __iter__(self):
        for start in self._starts:
            yield (start, self._values[start])

    def _insertion_point(self, point: int, append: bool = False):
        &#34;&#34;&#34;
        Find the insertion point for any given integer value. The result is a tuple containing:
        - An index into the sorted array of interval starts. If an interval already covers the point,
          then this index points to the start of that interval. If no interval covers the point, this
          value is the index where a new interval start would have to be inserted.
        - The start of an existing interval that covers the point, or `None` if this does not exist.
        - The value of an existing interval that covers the point, or `None` if this does not exist.
        An interval `[A,B]` covers a point `P` if `A &lt;= P &lt;= B+X` where `X` is `1` if the `append`
        parameter is `True`, and `0` otherwise.
        &#34;&#34;&#34;
        index = bisect_right(self._starts, point)
        start = None
        value = None
        if index &gt; 0:
            _start = self._starts[index - 1]
            _value = self._values[_start]
            if point in range(_start, _start + self.sizeof(_value) + append):
                index = index - 1
                start = _start
                value = _value
        return index, start, value

    def addi(self, start: int, value: Value):
        &#34;&#34;&#34;
        Insert a new interval into the union.
        &#34;&#34;&#34;
        starts = self._starts
        values = self._values

        index_of_start, cursor_start, cursor_value = self._insertion_point(
            start, value is not None)
        index_of_next = index_of_start + int(cursor_start is not None)

        if cursor_value is None:
            cursor_start = start
            cursor_value = values[cursor_start] = self.value_type()
            index_of_start = index_of_next
            index_of_next = index_of_next + 1
            starts.append(cursor_start)
            starts.sort()
            if starts[index_of_start] != cursor_start:
                raise RuntimeError(
                    F&#39;Adding 0x{cursor_start:X} into sorted lookup table failed; &#39;
                    &#39;value did not end up at the expected position.&#39;)

        cursor_value = self.insert(cursor_start, cursor_value, start, value)
        end = cursor_start + self.sizeof(cursor_value)

        insert_value = None
        insert_start = 0

        for index_after_merge in range(index_of_next, len(starts)):
            temp = starts[index_after_merge]
            if temp &gt; end:
                break
            insert_start = temp
            insert_value = values.pop(insert_start)
        else:
            if insert_value is not None:
                index_after_merge += 1

        if insert_value is not None:
            del starts[index_of_next:index_after_merge]
            if (insert_delta := end - insert_start) &gt;= 0:
                self.extend(
                    cursor_start,
                    cursor_value,
                    insert_delta,
                    insert_value,
                )

        return cursor_start

    def overlap(self, start: int, value: Value) -&gt; Iterator[tuple[int, Value]]:
        &#34;&#34;&#34;
        Generate all intervals in the union that overlap with the given interval.
        &#34;&#34;&#34;
        starts = self._starts
        values = self._values
        lower, _, _ = self._insertion_point(start)
        upper, b, _ = self._insertion_point(self.endof(start, value))
        for k in range(lower, upper + bool(b)):
            start = starts[k]
            value = values[start]
            yield (start, value)

    def overlaps(self, start: int, value: Value | None = None) -&gt; bool:
        &#34;&#34;&#34;
        Return whether the given interval or point overlaps with any interval in the union.
        &#34;&#34;&#34;
        if value is None:
            _, base, _ = self._insertion_point(start)
            return base is not None
        return any(self.overlap(start, value))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.intervals.IntIntervalUnion" href="#refinery.lib.intervals.IntIntervalUnion">IntIntervalUnion</a></li>
<li><a title="refinery.lib.intervals.MemoryIntervalUnion" href="#refinery.lib.intervals.MemoryIntervalUnion">MemoryIntervalUnion</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.intervals.IntervalUnion.value_type"><code class="name">var <span class="ident">value_type</span></code></dt>
<dd>
<section class="desc"><p>This class variable contains the type of <code><a title="refinery.lib.intervals.Value" href="#refinery.lib.intervals.Value">Value</a></code>.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.intervals.IntervalUnion.sizeof"><code class="name flex">
<span>def <span class="ident">sizeof</span></span>(<span>self, d)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the length of the interval from the stored <code><a title="refinery.lib.intervals.Value" href="#refinery.lib.intervals.Value">Value</a></code> value.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/intervals.py#L37-L41" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def sizeof(self, d: Value) -&gt; int:
    &#34;&#34;&#34;
    Compute the length of the interval from the stored `refinery.lib.intervals.Value` value.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="refinery.lib.intervals.IntervalUnion.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, start, value, new_start, new_value)</span>
</code></dt>
<dd>
<section class="desc"><p>Insert new interval data into an interval that already exists and covers the start of the
newly inserted interval.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/intervals.py#L43-L54" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def insert(
    self,
    start: int,
    value: Value,
    new_start: int,
    new_value: Value,
) -&gt; Value:
    &#34;&#34;&#34;
    Insert new interval data into an interval that already exists and covers the start of the
    newly inserted interval.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="refinery.lib.intervals.IntervalUnion.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, start, value, new_delta, new_value)</span>
</code></dt>
<dd>
<section class="desc"><p>This function extends the interval given by <code>(start;value)</code> with the data from the interval
<code>(new_start;new_value)</code>. Instead of <code>new_start</code>, however, the function expects the parameter
<code>new_delta</code> which is computed as subtracting <code>new_start</code> from the result of calling the
method <code><a title="refinery.lib.intervals.IntervalUnion.endof" href="#refinery.lib.intervals.IntervalUnion.endof">IntervalUnion.endof()</a></code> for the interval <code>(start;value)</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/intervals.py#L56-L69" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abstractmethod
def extend(
    self,
    start: int,
    value: Value,
    new_delta: int,
    new_value: Value
) -&gt; Value:
    &#34;&#34;&#34;
    This function extends the interval given by `(start;value)` with the data from the interval
    `(new_start;new_value)`. Instead of `new_start`, however, the function expects the parameter
    `new_delta` which is computed as subtracting `new_start` from the result of calling the
    method `refinery.lib.intervals.IntervalUnion.endof` for the interval `(start;value)`.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="refinery.lib.intervals.IntervalUnion.endof"><code class="name flex">
<span>def <span class="ident">endof</span></span>(<span>self, start, value=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the end of an interval. A <code><a title="refinery.lib.intervals.Value" href="#refinery.lib.intervals.Value">Value</a></code> can be provided; if none
is given, the interval is assumed to exist in the union and its value is recovered from the
internal storage.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/intervals.py#L71-L79" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def endof(self, start: int, value: Value | None = None):
    &#34;&#34;&#34;
    Compute the end of an interval. A `refinery.lib.intervals.Value` can be provided; if none
    is given, the interval is assumed to exist in the union and its value is recovered from the
    internal storage.
    &#34;&#34;&#34;
    if value is None:
        value = self._starts[start]
    return start + self.sizeof(value)</code></pre>
</details>
</dd>
<dt id="refinery.lib.intervals.IntervalUnion.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove all intervals from the union.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/intervals.py#L81-L86" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;
    Remove all intervals from the union.
    &#34;&#34;&#34;
    self._starts.clear()
    self._values.clear()</code></pre>
</details>
</dd>
<dt id="refinery.lib.intervals.IntervalUnion.addi"><code class="name flex">
<span>def <span class="ident">addi</span></span>(<span>self, start, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Insert a new interval into the union.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/intervals.py#L118-L167" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addi(self, start: int, value: Value):
    &#34;&#34;&#34;
    Insert a new interval into the union.
    &#34;&#34;&#34;
    starts = self._starts
    values = self._values

    index_of_start, cursor_start, cursor_value = self._insertion_point(
        start, value is not None)
    index_of_next = index_of_start + int(cursor_start is not None)

    if cursor_value is None:
        cursor_start = start
        cursor_value = values[cursor_start] = self.value_type()
        index_of_start = index_of_next
        index_of_next = index_of_next + 1
        starts.append(cursor_start)
        starts.sort()
        if starts[index_of_start] != cursor_start:
            raise RuntimeError(
                F&#39;Adding 0x{cursor_start:X} into sorted lookup table failed; &#39;
                &#39;value did not end up at the expected position.&#39;)

    cursor_value = self.insert(cursor_start, cursor_value, start, value)
    end = cursor_start + self.sizeof(cursor_value)

    insert_value = None
    insert_start = 0

    for index_after_merge in range(index_of_next, len(starts)):
        temp = starts[index_after_merge]
        if temp &gt; end:
            break
        insert_start = temp
        insert_value = values.pop(insert_start)
    else:
        if insert_value is not None:
            index_after_merge += 1

    if insert_value is not None:
        del starts[index_of_next:index_after_merge]
        if (insert_delta := end - insert_start) &gt;= 0:
            self.extend(
                cursor_start,
                cursor_value,
                insert_delta,
                insert_value,
            )

    return cursor_start</code></pre>
</details>
</dd>
<dt id="refinery.lib.intervals.IntervalUnion.overlap"><code class="name flex">
<span>def <span class="ident">overlap</span></span>(<span>self, start, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate all intervals in the union that overlap with the given interval.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/intervals.py#L169-L180" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def overlap(self, start: int, value: Value) -&gt; Iterator[tuple[int, Value]]:
    &#34;&#34;&#34;
    Generate all intervals in the union that overlap with the given interval.
    &#34;&#34;&#34;
    starts = self._starts
    values = self._values
    lower, _, _ = self._insertion_point(start)
    upper, b, _ = self._insertion_point(self.endof(start, value))
    for k in range(lower, upper + bool(b)):
        start = starts[k]
        value = values[start]
        yield (start, value)</code></pre>
</details>
</dd>
<dt id="refinery.lib.intervals.IntervalUnion.overlaps"><code class="name flex">
<span>def <span class="ident">overlaps</span></span>(<span>self, start, value=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Return whether the given interval or point overlaps with any interval in the union.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/intervals.py#L182-L189" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def overlaps(self, start: int, value: Value | None = None) -&gt; bool:
    &#34;&#34;&#34;
    Return whether the given interval or point overlaps with any interval in the union.
    &#34;&#34;&#34;
    if value is None:
        _, base, _ = self._insertion_point(start)
        return base is not None
    return any(self.overlap(start, value))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.intervals.IntIntervalUnion"><code class="flex name class">
<span>class <span class="ident">IntIntervalUnion</span></span>
</code></dt>
<dd>
<section class="desc"><p>An <code><a title="refinery.lib.intervals.IntervalUnion" href="#refinery.lib.intervals.IntervalUnion">IntervalUnion</a></code> of <code>(start, length)</code> pairs. Notably, the length of an
inclusive interval <code>[A,B]</code> is computed as <code>(B-A+1)</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/intervals.py#L192-L208" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class IntIntervalUnion(IntervalUnion[int]):
    &#34;&#34;&#34;
    An `refinery.lib.intervals.IntervalUnion` of `(start, length)` pairs. Notably, the length of an
    inclusive interval `[A,B]` is computed as `(B-A+1)`.
    &#34;&#34;&#34;
    value_type = int

    def sizeof(self, d: int) -&gt; int:
        return d

    def insert(self, start: int, value: int, new_start: int, new_value: int) -&gt; int:
        self._values[start] = value = max(value, new_start - start + new_value)
        return value

    def extend(self, start: int, value: int, new_delta: int, new_value: int) -&gt; int:
        self._values[start] = value = value + new_value - new_delta
        return value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.intervals.IntervalUnion" href="#refinery.lib.intervals.IntervalUnion">IntervalUnion</a></li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.intervals.IntervalUnion" href="#refinery.lib.intervals.IntervalUnion">IntervalUnion</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.intervals.IntervalUnion.addi" href="#refinery.lib.intervals.IntervalUnion.addi">addi</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.clear" href="#refinery.lib.intervals.IntervalUnion.clear">clear</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.endof" href="#refinery.lib.intervals.IntervalUnion.endof">endof</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.extend" href="#refinery.lib.intervals.IntervalUnion.extend">extend</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.insert" href="#refinery.lib.intervals.IntervalUnion.insert">insert</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.overlap" href="#refinery.lib.intervals.IntervalUnion.overlap">overlap</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.overlaps" href="#refinery.lib.intervals.IntervalUnion.overlaps">overlaps</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.sizeof" href="#refinery.lib.intervals.IntervalUnion.sizeof">sizeof</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.value_type" href="#refinery.lib.intervals.IntervalUnion.value_type">value_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.intervals.MemoryIntervalUnion"><code class="flex name class">
<span>class <span class="ident">MemoryIntervalUnion</span></span>
</code></dt>
<dd>
<section class="desc"><p>An <code><a title="refinery.lib.intervals.IntervalUnion" href="#refinery.lib.intervals.IntervalUnion">IntervalUnion</a></code> of memory patches, implemented as <code>(start, data)</code>
paris. Each <code>data</code> value is a <code>bytearray</code> which contains the region of memory that starts at
the base address <code>start</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/intervals.py#L211-L232" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class MemoryIntervalUnion(IntervalUnion[bytearray]):
    &#34;&#34;&#34;
    An `refinery.lib.intervals.IntervalUnion` of memory patches, implemented as `(start, data)`
    paris. Each `data` value is a `bytearray` which contains the region of memory that starts at
    the base address `start`.
    &#34;&#34;&#34;

    value_type = bytearray

    def sizeof(self, d: bytearray) -&gt; int:
        return len(d)

    def insert(self, start: int, value: bytearray, new_start: int, new_value: bytearray) -&gt; bytearray:
        rva = new_start - start
        end = rva + len(new_value)
        value[rva:end] = new_value
        return value

    def extend(self, start: int, value: bytearray, new_delta: int, new_value: bytearray) -&gt; bytearray:
        view = memoryview(new_value)
        value.extend(view[new_delta:])
        return value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.intervals.IntervalUnion" href="#refinery.lib.intervals.IntervalUnion">IntervalUnion</a></li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.intervals.IntervalUnion" href="#refinery.lib.intervals.IntervalUnion">IntervalUnion</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.intervals.IntervalUnion.addi" href="#refinery.lib.intervals.IntervalUnion.addi">addi</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.clear" href="#refinery.lib.intervals.IntervalUnion.clear">clear</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.endof" href="#refinery.lib.intervals.IntervalUnion.endof">endof</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.extend" href="#refinery.lib.intervals.IntervalUnion.extend">extend</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.insert" href="#refinery.lib.intervals.IntervalUnion.insert">insert</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.overlap" href="#refinery.lib.intervals.IntervalUnion.overlap">overlap</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.overlaps" href="#refinery.lib.intervals.IntervalUnion.overlaps">overlaps</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.sizeof" href="#refinery.lib.intervals.IntervalUnion.sizeof">sizeof</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.value_type" href="#refinery.lib.intervals.IntervalUnion.value_type">value_type</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="refinery.lib.intervals.Value" href="#refinery.lib.intervals.Value">Value</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.intervals.IntervalUnion" href="#refinery.lib.intervals.IntervalUnion">IntervalUnion</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.lib.intervals.IntervalUnion.sizeof" href="#refinery.lib.intervals.IntervalUnion.sizeof">sizeof</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.insert" href="#refinery.lib.intervals.IntervalUnion.insert">insert</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.extend" href="#refinery.lib.intervals.IntervalUnion.extend">extend</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.endof" href="#refinery.lib.intervals.IntervalUnion.endof">endof</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.clear" href="#refinery.lib.intervals.IntervalUnion.clear">clear</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.addi" href="#refinery.lib.intervals.IntervalUnion.addi">addi</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.overlap" href="#refinery.lib.intervals.IntervalUnion.overlap">overlap</a></code></li>
<li><code><a title="refinery.lib.intervals.IntervalUnion.overlaps" href="#refinery.lib.intervals.IntervalUnion.overlaps">overlaps</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.intervals.IntIntervalUnion" href="#refinery.lib.intervals.IntIntervalUnion">IntIntervalUnion</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.intervals.MemoryIntervalUnion" href="#refinery.lib.intervals.MemoryIntervalUnion">MemoryIntervalUnion</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
