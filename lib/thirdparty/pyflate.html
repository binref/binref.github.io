<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.thirdparty.pyflate documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.thirdparty.pyflate</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L1-L695" class="git-link">Browse git</a>
</summary>
<pre><code class="python"># ============================ MOTIFICATION NOTE ============================
# The content of this file has been modified for use in binary refinery; it
# has been ported from Python2 to Python3 and the BZip2 implementation was
# rewritten to support NSIS-specific BZip stream and block headers, which are
# different from the official standard values. The original code was taken
# from the following location:
#  https://github.com/pfalcon/pyflate/blob/master/pyflate.py

# ============================ ORIGINAL LICENSING ============================
# Copyright 2006--2007-01-21 Paul Sladen
#  http://www.paul.sladen.org/projects/compression/
#
# You may use and distribute this code under any DFSG-compatible license (eg.
# BSD, GNU GPLv2).
#
# Stand-alone pure-Python DEFLATE (gzip) and bzip2 decoder/decompressor. This
# is probably most useful for research purposes/index building; there is
# certainly some room for improvement in the Huffman bit-matcher.
#
# With the as-written implementation, there was a known bug in BWT decoding
# to do with repeated strings. This has been worked around; see bwt_reverse().
# Correct output is produced in all test cases but ideally the problem would
# be found...
# ============================================================================
from __future__ import annotations

import abc
import itertools

from typing import BinaryIO, Iterable


class BitfieldBase(abc.ABC):

    def __init__(self, x):
        if isinstance(x, BitfieldBase):
            self.f = x.f
            self.bits = x.bits
            self.bitfield = x.bitfield
            self.count = x.bitfield
        else:
            self.f = x
            self.bits = 0
            self.bitfield = 0x0
            self.count = 0

    def _read(self, n):
        s = self.f.read(n)
        if not s:
            raise RuntimeError(&#39;length error&#39;)
        self.count += len(s)
        return s

    def needbits(self, n):
        while self.bits &lt; n:
            self._more()

    def _mask(self, n):
        return (1 &lt;&lt; n) - 1

    def toskip(self):
        return self.bits &amp; 0x7

    def align(self):
        self.readbits(self.toskip())

    def dropbits(self, n=8):
        while n &gt;= self.bits and n &gt; 7:
            n -= self.bits
            self.bits = 0
            n -= len(self.f._read(n &gt;&gt; 3)) &lt;&lt; 3
        if n:
            self.readbits(n)

    def dropbytes(self, n=1):
        self.dropbits(n &lt;&lt; 3)

    def tell(self):
        return self.count - ((self.bits + 7) &gt;&gt; 3), 7 - ((self.bits - 1) &amp; 0x7)

    def tellbits(self):
        bytes, bits = self.tell()
        return (bytes &lt;&lt; 3) + bits

    @abc.abstractmethod
    def _more(self):
        pass

    @abc.abstractmethod
    def snoopbits(self, n=8):
        pass

    @abc.abstractmethod
    def readbits(self, n=8):
        pass


class LBitfield(BitfieldBase):

    def _more(self):
        c = self._read(1)
        self.bitfield += c[0] &lt;&lt; self.bits
        self.bits += 8

    def snoopbits(self, n=8):
        if n &gt; self.bits:
            self.needbits(n)
        return self.bitfield &amp; self._mask(n)

    def readbits(self, n=8):
        if n &gt; self.bits:
            self.needbits(n)
        r = self.bitfield &amp; self._mask(n)
        self.bits -= n
        self.bitfield &gt;&gt;= n
        return r


class RBitfield(BitfieldBase):

    def _more(self):
        c = self._read(1)
        self.bitfield &lt;&lt;= 8
        self.bitfield += c[0]
        self.bits += 8

    def snoopbits(self, n=8):
        if n &gt; self.bits:
            self.needbits(n)
        return (self.bitfield &gt;&gt; (self.bits - n)) &amp; self._mask(n)

    def readbits(self, n=8):
        if n &gt; self.bits:
            self.needbits(n)
        r = (self.bitfield &gt;&gt; (self.bits - n)) &amp; self._mask(n)
        self.bits -= n
        self.bitfield &amp;= ~(self._mask(n) &lt;&lt; self.bits)
        return r


class HuffmanLength:
    code: int
    bits: int
    symbol: int | None
    reverse_symbol: int | None

    def __init__(self, code, bits=0):
        self.code = code
        self.bits = bits
        self.symbol = None
        self.reverse_symbol = None

    def __lt__(self, other):
        return self.__cmp(other) &lt; 0

    def __gt__(self, other):
        return self.__cmp(other) &gt; 0

    def __eq__(self, other):
        return self.__cmp(other) == 0

    def __le__(self, other):
        return self.__cmp(other) &lt;= 0

    def __ge__(self, other):
        return self.__cmp(other) &gt;= 0

    def __ne__(self, other):
        return self.__cmp(other) != 0

    def __cmp(self, other):
        a, b = self.bits, other.bits
        if a == b:
            a, b = self.code, other.code
        return (a &gt; b) - (a &lt; b)


def reverse_bits(v: int, n: int):
    a = 1 &lt;&lt; 0
    b = 1 &lt;&lt; (n - 1)
    z = 0
    for i in range(n - 1, -1, -2):
        z |= (v &gt;&gt; i) &amp; a
        z |= (v &lt;&lt; i) &amp; b
        a &lt;&lt;= 1
        b &gt;&gt;= 1
    return z


def reverse_bytes(v, n):
    a = 0xff &lt;&lt; 0
    b = 0xff &lt;&lt; (n - 8)
    z = 0
    for i in range(n - 8, -8, -16):
        z |= (v &gt;&gt; i) &amp; a
        z |= (v &lt;&lt; i) &amp; b
        a &lt;&lt;= 8
        b &gt;&gt;= 8
    return z


class HuffmanTable:
    table: list[HuffmanLength]

    def __init__(self, bootstrap):
        table = []
        start, bits = bootstrap[0]
        for finish, endbits in bootstrap[1:]:
            if bits:
                for code in range(start, finish):
                    table.append(HuffmanLength(code, bits))
            start, bits = finish, endbits
            if endbits == -1:
                break
        table.sort()
        self.table = table

    def populate_huffman_symbols(self):
        bits, symbol = -1, -1
        for x in self.table:
            symbol += 1
            if x.bits != bits:
                symbol &lt;&lt;= (x.bits - bits)
                bits = x.bits
            x.symbol = symbol
            x.reverse_symbol = reverse_bits(symbol, bits)

    def min_max_bits(self):
        self.min_bits, self.max_bits = 16, -1
        for x in self.table:
            if x.bits &lt; self.min_bits: self.min_bits = x.bits
            if x.bits &gt; self.max_bits: self.max_bits = x.bits

    def _find_symbol(self, bits: int, symbol: int, table: Iterable[HuffmanLength]) -&gt; int:
        for h in table:
            if h.bits == bits and h.reverse_symbol == symbol:
                return h.code
        return -1

    def find_next_symbol(self, field: LBitfield, reversed=True):
        cached_length = -1
        cached = None
        for x in self.table:
            if cached_length != x.bits:
                cached = field.snoopbits(x.bits)
                cached_length = x.bits
            if (reversed and x.reverse_symbol == cached) or (not reversed and x.symbol == cached):
                field.readbits(x.bits)
                return x.code
        raise RuntimeError(F&#39;symbol not found even after end of table at {field.tell()}&#39;)


class OrderedHuffmanTable(HuffmanTable):
    def __init__(self, lengths):
        _ordered_lengths = list(enumerate(lengths))
        _ordered_lengths.append((len(lengths), -1))
        super().__init__(_ordered_lengths)


CODE_LENGTH_ORDERS = (
    0x10, 0x11, 0x12, 0x00, 0x08, 0x07, 0x09, 0x06, 0x0A, 0x05,
    0x0B, 0x04, 0x0C, 0x03, 0x0D, 0x02, 0x0E, 0x01, 0x0F)

DISTANCE_BASE = (
    0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000D, 0x0011, 0x0019,
    0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00C1, 0x0101, 0x0181, 0x0201, 0x0301,
    0x0401, 0x0601, 0x0801, 0x0C01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001)

LENGTH_BASE = (
    0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000A, 0x000B, 0x000D,
    0x000F, 0x0011, 0x0013, 0x0017, 0x001B, 0x001F, 0x0023, 0x002B, 0x0033, 0x003B,
    0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00A3, 0x00C3, 0x00E3, 0x0102)


def extra_distance_bits(n):
    if 0 &lt;= n &lt;= 1:
        return 0
    elif 2 &lt;= n &lt;= 29:
        return (n &gt;&gt; 1) - 1
    else:
        raise RuntimeError(&#39;illegal distance code&#39;)


def extra_length_bits(n):
    if 257 &lt;= n &lt;= 260 or n == 285:
        return 0
    elif 261 &lt;= n &lt;= 284:
        return ((n - 257) &gt;&gt; 2) - 1
    else:
        raise RuntimeError(&#39;illegal length code&#39;)


def move_to_front(array: list, index):
    array[:] = itertools.chain(
        itertools.islice(array, index, index + 1),
        itertools.islice(array, 0, index),
        itertools.islice(array, index + 1, None)
    )


def bwt_transform(data):
    tmp = bytearray(sorted(data))
    base = list(map(tmp.find, range(256)))
    pointers = [-1] * len(data)
    for i, symbol in enumerate(data):
        pointers[base[symbol]] = i
        base[symbol] += 1
    return pointers


def bwt_reverse(data, end):
    out = bytearray(len(data))
    transform = bwt_transform(data)

    # STRAGENESS WARNING: There was a bug somewhere here in that
    # if the output of the BWT resolves to a perfect copy of N
    # identical strings (think exact multiples of 255 &#39;X&#39; here),
    # then a loop is formed.  When decoded, the output string would
    # be cut off after the first loop, typically &#39;\0\0\0\0\xfb&#39;.
    # The previous loop construct was:
    #
    #  next = T[end]
    #  while next != end:
    #      out += L[next]
    #      next = T[next]
    #  out += L[next]
    #
    # For the moment, I&#39;ve instead replaced it with a check to see
    # if there has been enough output generated.  I didn&#39;t figured
    # out where the off-by-one-ism is yet---that actually produced
    # the cyclic loop.

    for i in range(len(data)):
        end = transform[end]
        out[i] = data[end]

    return out


class _DecompressionFile(abc.ABC):

    def readable(self) -&gt; bool:
        return True

    def seekable(self) -&gt; bool:
        return False

    def writable(self) -&gt; bool:
        return False

    def write(self, __b):
        raise NotImplementedError

    data: BinaryIO
    bits: BitfieldBase
    nsis: bool
    done: bool
    current_block: bytearray

    def __init__(self, data: BinaryIO, nsis: bool = True):
        self.data = data
        self.nsis = nsis
        self.done = False
        self.current_block = bytearray()

    def readall(self) -&gt; bytes:
        return self.read()

    def readinto(self, __buffer):
        data = self.read(len(__buffer))
        size = len(data)
        __buffer[:size] = data
        return size

    def read(self, size=-1):
        while size not in range(len(self.current_block)):
            if not self._readblock():
                break
        block = self.current_block
        if size &lt; 0 or size &gt;= len(block):
            self.current_block = bytearray()
            return block
        else:
            out = block[:size]
            del block[:size]
            return out

    @abc.abstractmethod
    def _readblock(self) -&gt; bool:
        pass


class BZip2File(_DecompressionFile):

    blocksize: int
    block_header_size: int
    block_header_type: tuple[int, int]
    current_block: bytearray

    def __init__(self, data: BinaryIO, nsis: bool = True):
        super().__init__(data, nsis)
        self.bits = RBitfield(data)

        if nsis:
            self.blocksize = 9
            self.block_header_size = 8
            self.block_header_type = (0x31, 0x17)
        else:
            if data.read(2) != b&#39;BZ&#39;:
                raise RuntimeError(&#39;BZip2 header magic is missing&#39;)
            if self.bits.readbits(8) != ord(&#39;h&#39;):
                raise RuntimeError(&#39;BZip2 header contains unknown compression method&#39;)
            blocksize = self.bits.readbits(8)
            if 0x31 &lt;= blocksize &lt;= 0x39:
                blocksize = blocksize - 0x30
            else:
                raise RuntimeError(&#39;BZip2 header specifies invalid block size&#39;)
            self.blocksize = blocksize
            self.block_header_size = 48
            self.block_header_type = (0x314159265359, 0x177245385090)

        self.blocksize *= 100_000

    def _readblock(self):
        out = self.current_block
        if self.done:
            return False
        br = self.bits
        blocktype = br.readbits(self.block_header_size)
        if not self.nsis:
            _ = br.readbits(32) # crc
        if blocktype == self.block_header_type[0]:
            if not self.nsis and br.readbits(1):
                raise RuntimeError(&#39;BZip2 randomised support not implemented&#39;)
            pointer = br.readbits(24)
            huffman_used_map = br.readbits(16)
            map_mask = 1 &lt;&lt; 15
            used = []
            while map_mask &gt; 0:
                if huffman_used_map &amp; map_mask:
                    huffman_used_bitmap = br.readbits(16)
                    bit_mask = 1 &lt;&lt; 15
                    while bit_mask &gt; 0:
                        if huffman_used_bitmap &amp; bit_mask:
                            pass
                        used += [bool(huffman_used_bitmap &amp; bit_mask)]
                        bit_mask &gt;&gt;= 1
                else:
                    used += [False] * 16
                map_mask &gt;&gt;= 1
            huffman_groups = br.readbits(3)
            if not 2 &lt;= huffman_groups &lt;= 6:
                raise RuntimeError(&#39;BZip2 number of Huffman groups not in range 2..6&#39;)
            selectors_used = br.readbits(15)
            mtf = list(range(huffman_groups))
            selectors_list = []
            for i in range(selectors_used):
                c = 0
                while br.readbits(1):
                    c += 1
                    if c &gt;= huffman_groups:
                        raise RuntimeError(&#39;BZip2 chosen selector greater than number of groups (max 6)&#39;)
                if c &gt;= 0:
                    move_to_front(mtf, c)
                selectors_list += mtf[0:1]
            groups_lengths = []
            symbols_in_use = sum(used) + 2  # remember RUN[AB] RLE symbols
            for _ in range(huffman_groups):
                length = br.readbits(5)
                lengths = []
                for i in range(symbols_in_use):
                    if not 0 &lt;= length &lt;= 20:
                        raise RuntimeError(&#39;BZip2 Huffman length code outside range 0..20&#39;)
                    while br.readbits(1):
                        length -= (br.readbits(1) * 2) - 1
                    lengths += [length]
                groups_lengths += [lengths]

            tables = []
            for g in groups_lengths:
                codes = OrderedHuffmanTable(g)
                codes.populate_huffman_symbols()
                codes.min_max_bits()
                tables.append(codes)

            favourites = [y for y, x in enumerate(used) if x]
            selector_pointer = 0
            decoded = 0
            repeat = repeat_power = 0
            buffer = bytearray()
            t = None
            while True:
                decoded -= 1
                if decoded &lt;= 0:
                    decoded = 50
                    if selector_pointer &lt;= len(selectors_list):
                        t = tables[selectors_list[selector_pointer]]
                        selector_pointer += 1
                r = t.find_next_symbol(br, False)
                if 0 &lt;= r &lt;= 1:
                    if repeat == 0:
                        repeat_power = 1
                    repeat += repeat_power &lt;&lt; r
                    repeat_power &lt;&lt;= 1
                    continue
                elif repeat &gt; 0:
                    buffer.extend(itertools.repeat(favourites[0], repeat))
                    repeat = 0
                if r == symbols_in_use - 1:
                    break
                else:
                    o = favourites[r - 1]
                    move_to_front(favourites, r - 1)
                    buffer.append(o)
            # RLE step
            nt = bwt_reverse(buffer, pointer)
            done = bytearray()
            n = len(nt)
            i = 0
            while i &lt; n:
                if i &lt; n - 4 and nt[i] == nt[i + 1] == nt[i + 2] == nt[i + 3]:
                    done.extend(itertools.repeat(nt[i], nt[i + 4] + 4))
                    i += 5
                else:
                    done.append(nt[i])
                    i += 1
            out.extend(done)
            return True
        elif blocktype == self.block_header_type[1]:
            br.align()
            self.done = True
            return False
        else:
            raise RuntimeError(
                F&#39;unknown BZip2 block value 0x{blocktype:0{self.block_header_size // 4}X}&#39;)


class GZipFile(_DecompressionFile):

    def __init__(self, data: BinaryIO, nsis: bool = True):
        super().__init__(data, nsis)
        br = self.bits = LBitfield(data)
        if not nsis and self.data.read(2) != b&#39;\x1F\x8B&#39;:
            raise RuntimeError(&#39;Unknown (not 1F8B) header&#39;)
        if not nsis and br.readbits(8) != 8:
            raise RuntimeError(&#39;Unknown (not type 8 DEFLATE) compression method&#39;)
        if not nsis:
            self.flags = br.readbits(8)
            self.mtime = br.readbits(32)
            self.extra_flags = br.readbits(8)
            self.os_type = br.readbits(8)
            self.file_name = &#39;&#39;
            self.comment = &#39;&#39;

            if self.flags &amp; 0x04:
                # structured GZ_FEXTRA miscellaneous data
                xlen = br.readbits(16)
                br.dropbytes(xlen)
            while self.flags &amp; 0x08:
                # original GZ_FNAME filename
                cc = br.readbits(8)
                if not cc:
                    break
                self.file_name += chr(cc)
            while self.flags &amp; 0x10:
                # human readable GZ_FCOMMENT
                cc = br.readbits(8)
                if not cc:
                    break
                self.comment += chr(cc)
            if self.flags &amp; 0x02:
                # header-only GZ_FHCRC checksum
                br.readbits(16)

    def _readblock(self) -&gt; bool:
        if self.done:
            return False
        br = self.bits
        out = self.current_block
        lastbit = br.readbits(1)
        blocktype = br.readbits(2)

        def _error_unused(msg):
            return RuntimeError(F&#39;illegal unused {msg} in use at {br.tell()}&#39;)

        if blocktype == 0:
            br.align()
            length = br.readbits(16)
            if not self.nsis and 0 != length &amp; br.readbits(16):
                raise RuntimeError(&#39;stored block lengths do not match each other&#39;)
            if not br.bits:
                it = self.data.read(length)
            else:
                it = (br.readbits(8) for _ in range(length))
            out.extend(it)

        elif blocktype == 1 or blocktype == 2:
            main_literals, main_distances = None, None

            if blocktype == 1: # Static Huffman
                static_huffman_bootstrap = [(0, 8), (144, 9), (256, 7), (280, 8), (288, -1)]
                static_huffman_lengths_bootstrap = [(0, 5), (32, -1)]
                main_literals = HuffmanTable(static_huffman_bootstrap)
                main_distances = HuffmanTable(static_huffman_lengths_bootstrap)

            elif blocktype == 2: # Dynamic Huffman
                len_codes = br.readbits(5)
                literals = len_codes + 257
                distances = br.readbits(5) + 1
                code_lengths_length = br.readbits(4) + 4
                table = [0] * 19
                for i in range(code_lengths_length):
                    table[CODE_LENGTH_ORDERS[i]] = br.readbits(3)
                dynamic_codes = OrderedHuffmanTable(table)
                dynamic_codes.populate_huffman_symbols()
                dynamic_codes.min_max_bits()

                # Decode the code_lengths for both tables at once,
                # then split the list later

                code_lengths = []
                n = 0
                while n &lt; (literals + distances):
                    r = dynamic_codes.find_next_symbol(br)
                    if 0 &lt;= r &lt;= 15: # literal bitlength for this code
                        count = 1
                        what = r
                    elif r == 16: # repeat last code
                        count = 3 + br.readbits(2)
                        # Is this supposed to default to &#39;0&#39; if in the zeroth position?
                        what = code_lengths[-1]
                    elif r == 17: # repeat zero
                        count = 3 + br.readbits(3)
                        what = 0
                    elif r == 18: # repeat zero lots
                        count = 11 + br.readbits(7)
                        what = 0
                    else:
                        raise RuntimeError(&#39;next code length is outside of the range 0 &lt;= r &lt;= 18&#39;)
                    code_lengths += [what] * count
                    n += count

                main_literals = OrderedHuffmanTable(code_lengths[:literals])
                main_distances = OrderedHuffmanTable(code_lengths[literals:])

            main_literals.populate_huffman_symbols()
            main_distances.populate_huffman_symbols()
            main_literals.min_max_bits()
            main_distances.min_max_bits()
            literal_count = 0

            while True:
                r = main_literals.find_next_symbol(br)
                if 0 &lt;= r &lt;= 255:
                    literal_count += 1
                    out.append(r)
                elif r == 256:
                    if literal_count &gt; 0:
                        literal_count = 0
                    break
                elif 257 &lt;= r &lt;= 285: # dictionary lookup
                    if literal_count &gt; 0:
                        literal_count = 0
                    length_extra = br.readbits(extra_length_bits(r))
                    length = LENGTH_BASE[r - 257] + length_extra

                    r1 = main_distances.find_next_symbol(br)
                    if 0 &lt;= r1 &lt;= 29:
                        distance = DISTANCE_BASE[r1] + br.readbits(extra_distance_bits(r1))
                        while length &gt; distance:
                            out += out[-distance:]
                            length -= distance
                        if length == distance:
                            out += out[-distance:]
                        else:
                            out += out[-distance:length - distance]
                    elif 30 &lt;= r1 &lt;= 31:
                        raise _error_unused(&#39;distance symbol&#39;)
                elif 286 &lt;= r &lt;= 287:
                    raise _error_unused(&#39;literal/length symbol&#39;)
        elif blocktype == 3:
            raise _error_unused(&#39;blocktype&#39;)

        if lastbit:
            self.done = True
            br.align()
            try:
                _ = br.readbits(32) # crc
                _ = br.readbits(32) # length
            except Exception:
                if not self.nsis:
                    raise
            return False
        else:
            return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.thirdparty.pyflate.reverse_bits"><code class="name flex">
<span>def <span class="ident">reverse_bits</span></span>(<span>v, n)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L178-L187" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reverse_bits(v: int, n: int):
    a = 1 &lt;&lt; 0
    b = 1 &lt;&lt; (n - 1)
    z = 0
    for i in range(n - 1, -1, -2):
        z |= (v &gt;&gt; i) &amp; a
        z |= (v &lt;&lt; i) &amp; b
        a &lt;&lt;= 1
        b &gt;&gt;= 1
    return z</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.reverse_bytes"><code class="name flex">
<span>def <span class="ident">reverse_bytes</span></span>(<span>v, n)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L190-L199" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reverse_bytes(v, n):
    a = 0xff &lt;&lt; 0
    b = 0xff &lt;&lt; (n - 8)
    z = 0
    for i in range(n - 8, -8, -16):
        z |= (v &gt;&gt; i) &amp; a
        z |= (v &lt;&lt; i) &amp; b
        a &lt;&lt;= 8
        b &gt;&gt;= 8
    return z</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.extra_distance_bits"><code class="name flex">
<span>def <span class="ident">extra_distance_bits</span></span>(<span>n)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L275-L281" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def extra_distance_bits(n):
    if 0 &lt;= n &lt;= 1:
        return 0
    elif 2 &lt;= n &lt;= 29:
        return (n &gt;&gt; 1) - 1
    else:
        raise RuntimeError(&#39;illegal distance code&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.extra_length_bits"><code class="name flex">
<span>def <span class="ident">extra_length_bits</span></span>(<span>n)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L284-L290" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def extra_length_bits(n):
    if 257 &lt;= n &lt;= 260 or n == 285:
        return 0
    elif 261 &lt;= n &lt;= 284:
        return ((n - 257) &gt;&gt; 2) - 1
    else:
        raise RuntimeError(&#39;illegal length code&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.move_to_front"><code class="name flex">
<span>def <span class="ident">move_to_front</span></span>(<span>array, index)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L293-L298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def move_to_front(array: list, index):
    array[:] = itertools.chain(
        itertools.islice(array, index, index + 1),
        itertools.islice(array, 0, index),
        itertools.islice(array, index + 1, None)
    )</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.bwt_transform"><code class="name flex">
<span>def <span class="ident">bwt_transform</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L301-L308" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bwt_transform(data):
    tmp = bytearray(sorted(data))
    base = list(map(tmp.find, range(256)))
    pointers = [-1] * len(data)
    for i, symbol in enumerate(data):
        pointers[base[symbol]] = i
        base[symbol] += 1
    return pointers</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.bwt_reverse"><code class="name flex">
<span>def <span class="ident">bwt_reverse</span></span>(<span>data, end)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L311-L337" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bwt_reverse(data, end):
    out = bytearray(len(data))
    transform = bwt_transform(data)

    # STRAGENESS WARNING: There was a bug somewhere here in that
    # if the output of the BWT resolves to a perfect copy of N
    # identical strings (think exact multiples of 255 &#39;X&#39; here),
    # then a loop is formed.  When decoded, the output string would
    # be cut off after the first loop, typically &#39;\0\0\0\0\xfb&#39;.
    # The previous loop construct was:
    #
    #  next = T[end]
    #  while next != end:
    #      out += L[next]
    #      next = T[next]
    #  out += L[next]
    #
    # For the moment, I&#39;ve instead replaced it with a check to see
    # if there has been enough output generated.  I didn&#39;t figured
    # out where the off-by-one-ism is yet---that actually produced
    # the cyclic loop.

    for i in range(len(data)):
        end = transform[end]
        out[i] = data[end]

    return out</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.thirdparty.pyflate.BitfieldBase"><code class="flex name class">
<span>class <span class="ident">BitfieldBase</span></span>
<span>(</span><span>x)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L33-L95" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BitfieldBase(abc.ABC):

    def __init__(self, x):
        if isinstance(x, BitfieldBase):
            self.f = x.f
            self.bits = x.bits
            self.bitfield = x.bitfield
            self.count = x.bitfield
        else:
            self.f = x
            self.bits = 0
            self.bitfield = 0x0
            self.count = 0

    def _read(self, n):
        s = self.f.read(n)
        if not s:
            raise RuntimeError(&#39;length error&#39;)
        self.count += len(s)
        return s

    def needbits(self, n):
        while self.bits &lt; n:
            self._more()

    def _mask(self, n):
        return (1 &lt;&lt; n) - 1

    def toskip(self):
        return self.bits &amp; 0x7

    def align(self):
        self.readbits(self.toskip())

    def dropbits(self, n=8):
        while n &gt;= self.bits and n &gt; 7:
            n -= self.bits
            self.bits = 0
            n -= len(self.f._read(n &gt;&gt; 3)) &lt;&lt; 3
        if n:
            self.readbits(n)

    def dropbytes(self, n=1):
        self.dropbits(n &lt;&lt; 3)

    def tell(self):
        return self.count - ((self.bits + 7) &gt;&gt; 3), 7 - ((self.bits - 1) &amp; 0x7)

    def tellbits(self):
        bytes, bits = self.tell()
        return (bytes &lt;&lt; 3) + bits

    @abc.abstractmethod
    def _more(self):
        pass

    @abc.abstractmethod
    def snoopbits(self, n=8):
        pass

    @abc.abstractmethod
    def readbits(self, n=8):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.thirdparty.pyflate.LBitfield" href="#refinery.lib.thirdparty.pyflate.LBitfield">LBitfield</a></li>
<li><a title="refinery.lib.thirdparty.pyflate.RBitfield" href="#refinery.lib.thirdparty.pyflate.RBitfield">RBitfield</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.thirdparty.pyflate.BitfieldBase.needbits"><code class="name flex">
<span>def <span class="ident">needbits</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L54-L56" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def needbits(self, n):
    while self.bits &lt; n:
        self._more()</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.BitfieldBase.toskip"><code class="name flex">
<span>def <span class="ident">toskip</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L61-L62" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def toskip(self):
    return self.bits &amp; 0x7</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.BitfieldBase.align"><code class="name flex">
<span>def <span class="ident">align</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L64-L65" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def align(self):
    self.readbits(self.toskip())</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.BitfieldBase.dropbits"><code class="name flex">
<span>def <span class="ident">dropbits</span></span>(<span>self, n=8)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L67-L73" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dropbits(self, n=8):
    while n &gt;= self.bits and n &gt; 7:
        n -= self.bits
        self.bits = 0
        n -= len(self.f._read(n &gt;&gt; 3)) &lt;&lt; 3
    if n:
        self.readbits(n)</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.BitfieldBase.dropbytes"><code class="name flex">
<span>def <span class="ident">dropbytes</span></span>(<span>self, n=1)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L75-L76" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dropbytes(self, n=1):
    self.dropbits(n &lt;&lt; 3)</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.BitfieldBase.tell"><code class="name flex">
<span>def <span class="ident">tell</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L78-L79" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tell(self):
    return self.count - ((self.bits + 7) &gt;&gt; 3), 7 - ((self.bits - 1) &amp; 0x7)</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.BitfieldBase.tellbits"><code class="name flex">
<span>def <span class="ident">tellbits</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L81-L83" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tellbits(self):
    bytes, bits = self.tell()
    return (bytes &lt;&lt; 3) + bits</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.BitfieldBase.snoopbits"><code class="name flex">
<span>def <span class="ident">snoopbits</span></span>(<span>self, n=8)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L89-L91" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def snoopbits(self, n=8):
    pass</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.BitfieldBase.readbits"><code class="name flex">
<span>def <span class="ident">readbits</span></span>(<span>self, n=8)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L93-L95" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def readbits(self, n=8):
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.LBitfield"><code class="flex name class">
<span>class <span class="ident">LBitfield</span></span>
<span>(</span><span>x)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L98-L116" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LBitfield(BitfieldBase):

    def _more(self):
        c = self._read(1)
        self.bitfield += c[0] &lt;&lt; self.bits
        self.bits += 8

    def snoopbits(self, n=8):
        if n &gt; self.bits:
            self.needbits(n)
        return self.bitfield &amp; self._mask(n)

    def readbits(self, n=8):
        if n &gt; self.bits:
            self.needbits(n)
        r = self.bitfield &amp; self._mask(n)
        self.bits -= n
        self.bitfield &gt;&gt;= n
        return r</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.thirdparty.pyflate.BitfieldBase" href="#refinery.lib.thirdparty.pyflate.BitfieldBase">BitfieldBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.thirdparty.pyflate.LBitfield.snoopbits"><code class="name flex">
<span>def <span class="ident">snoopbits</span></span>(<span>self, n=8)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L105-L108" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def snoopbits(self, n=8):
    if n &gt; self.bits:
        self.needbits(n)
    return self.bitfield &amp; self._mask(n)</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.LBitfield.readbits"><code class="name flex">
<span>def <span class="ident">readbits</span></span>(<span>self, n=8)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L110-L116" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readbits(self, n=8):
    if n &gt; self.bits:
        self.needbits(n)
    r = self.bitfield &amp; self._mask(n)
    self.bits -= n
    self.bitfield &gt;&gt;= n
    return r</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.RBitfield"><code class="flex name class">
<span>class <span class="ident">RBitfield</span></span>
<span>(</span><span>x)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L119-L138" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RBitfield(BitfieldBase):

    def _more(self):
        c = self._read(1)
        self.bitfield &lt;&lt;= 8
        self.bitfield += c[0]
        self.bits += 8

    def snoopbits(self, n=8):
        if n &gt; self.bits:
            self.needbits(n)
        return (self.bitfield &gt;&gt; (self.bits - n)) &amp; self._mask(n)

    def readbits(self, n=8):
        if n &gt; self.bits:
            self.needbits(n)
        r = (self.bitfield &gt;&gt; (self.bits - n)) &amp; self._mask(n)
        self.bits -= n
        self.bitfield &amp;= ~(self._mask(n) &lt;&lt; self.bits)
        return r</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.thirdparty.pyflate.BitfieldBase" href="#refinery.lib.thirdparty.pyflate.BitfieldBase">BitfieldBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.thirdparty.pyflate.RBitfield.snoopbits"><code class="name flex">
<span>def <span class="ident">snoopbits</span></span>(<span>self, n=8)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L127-L130" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def snoopbits(self, n=8):
    if n &gt; self.bits:
        self.needbits(n)
    return (self.bitfield &gt;&gt; (self.bits - n)) &amp; self._mask(n)</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.RBitfield.readbits"><code class="name flex">
<span>def <span class="ident">readbits</span></span>(<span>self, n=8)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L132-L138" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readbits(self, n=8):
    if n &gt; self.bits:
        self.needbits(n)
    r = (self.bitfield &gt;&gt; (self.bits - n)) &amp; self._mask(n)
    self.bits -= n
    self.bitfield &amp;= ~(self._mask(n) &lt;&lt; self.bits)
    return r</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.HuffmanLength"><code class="flex name class">
<span>class <span class="ident">HuffmanLength</span></span>
<span>(</span><span>code, bits=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L141-L175" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class HuffmanLength:
    code: int
    bits: int
    symbol: int | None
    reverse_symbol: int | None

    def __init__(self, code, bits=0):
        self.code = code
        self.bits = bits
        self.symbol = None
        self.reverse_symbol = None

    def __lt__(self, other):
        return self.__cmp(other) &lt; 0

    def __gt__(self, other):
        return self.__cmp(other) &gt; 0

    def __eq__(self, other):
        return self.__cmp(other) == 0

    def __le__(self, other):
        return self.__cmp(other) &lt;= 0

    def __ge__(self, other):
        return self.__cmp(other) &gt;= 0

    def __ne__(self, other):
        return self.__cmp(other) != 0

    def __cmp(self, other):
        a, b = self.bits, other.bits
        if a == b:
            a, b = self.code, other.code
        return (a &gt; b) - (a &lt; b)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.thirdparty.pyflate.HuffmanLength.code"><code class="name">var <span class="ident">code</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.HuffmanLength.bits"><code class="name">var <span class="ident">bits</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.HuffmanLength.symbol"><code class="name">var <span class="ident">symbol</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.HuffmanLength.reverse_symbol"><code class="name">var <span class="ident">reverse_symbol</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.HuffmanTable"><code class="flex name class">
<span>class <span class="ident">HuffmanTable</span></span>
<span>(</span><span>bootstrap)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L202-L250" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class HuffmanTable:
    table: list[HuffmanLength]

    def __init__(self, bootstrap):
        table = []
        start, bits = bootstrap[0]
        for finish, endbits in bootstrap[1:]:
            if bits:
                for code in range(start, finish):
                    table.append(HuffmanLength(code, bits))
            start, bits = finish, endbits
            if endbits == -1:
                break
        table.sort()
        self.table = table

    def populate_huffman_symbols(self):
        bits, symbol = -1, -1
        for x in self.table:
            symbol += 1
            if x.bits != bits:
                symbol &lt;&lt;= (x.bits - bits)
                bits = x.bits
            x.symbol = symbol
            x.reverse_symbol = reverse_bits(symbol, bits)

    def min_max_bits(self):
        self.min_bits, self.max_bits = 16, -1
        for x in self.table:
            if x.bits &lt; self.min_bits: self.min_bits = x.bits
            if x.bits &gt; self.max_bits: self.max_bits = x.bits

    def _find_symbol(self, bits: int, symbol: int, table: Iterable[HuffmanLength]) -&gt; int:
        for h in table:
            if h.bits == bits and h.reverse_symbol == symbol:
                return h.code
        return -1

    def find_next_symbol(self, field: LBitfield, reversed=True):
        cached_length = -1
        cached = None
        for x in self.table:
            if cached_length != x.bits:
                cached = field.snoopbits(x.bits)
                cached_length = x.bits
            if (reversed and x.reverse_symbol == cached) or (not reversed and x.symbol == cached):
                field.readbits(x.bits)
                return x.code
        raise RuntimeError(F&#39;symbol not found even after end of table at {field.tell()}&#39;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.thirdparty.pyflate.OrderedHuffmanTable" href="#refinery.lib.thirdparty.pyflate.OrderedHuffmanTable">OrderedHuffmanTable</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.thirdparty.pyflate.HuffmanTable.table"><code class="name">var <span class="ident">table</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.thirdparty.pyflate.HuffmanTable.populate_huffman_symbols"><code class="name flex">
<span>def <span class="ident">populate_huffman_symbols</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L218-L226" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def populate_huffman_symbols(self):
    bits, symbol = -1, -1
    for x in self.table:
        symbol += 1
        if x.bits != bits:
            symbol &lt;&lt;= (x.bits - bits)
            bits = x.bits
        x.symbol = symbol
        x.reverse_symbol = reverse_bits(symbol, bits)</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.HuffmanTable.min_max_bits"><code class="name flex">
<span>def <span class="ident">min_max_bits</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L228-L232" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def min_max_bits(self):
    self.min_bits, self.max_bits = 16, -1
    for x in self.table:
        if x.bits &lt; self.min_bits: self.min_bits = x.bits
        if x.bits &gt; self.max_bits: self.max_bits = x.bits</code></pre>
</details>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.HuffmanTable.find_next_symbol"><code class="name flex">
<span>def <span class="ident">find_next_symbol</span></span>(<span>self, field, reversed=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L240-L250" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def find_next_symbol(self, field: LBitfield, reversed=True):
    cached_length = -1
    cached = None
    for x in self.table:
        if cached_length != x.bits:
            cached = field.snoopbits(x.bits)
            cached_length = x.bits
        if (reversed and x.reverse_symbol == cached) or (not reversed and x.symbol == cached):
            field.readbits(x.bits)
            return x.code
    raise RuntimeError(F&#39;symbol not found even after end of table at {field.tell()}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.OrderedHuffmanTable"><code class="flex name class">
<span>class <span class="ident">OrderedHuffmanTable</span></span>
<span>(</span><span>lengths)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L253-L257" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class OrderedHuffmanTable(HuffmanTable):
    def __init__(self, lengths):
        _ordered_lengths = list(enumerate(lengths))
        _ordered_lengths.append((len(lengths), -1))
        super().__init__(_ordered_lengths)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.thirdparty.pyflate.HuffmanTable" href="#refinery.lib.thirdparty.pyflate.HuffmanTable">HuffmanTable</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="refinery.lib.thirdparty.pyflate.HuffmanTable" href="#refinery.lib.thirdparty.pyflate.HuffmanTable">HuffmanTable</a></b></code>:
<ul class="hlist">
<li><code><a title="refinery.lib.thirdparty.pyflate.HuffmanTable.table" href="#refinery.lib.thirdparty.pyflate.HuffmanTable.table">table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.BZip2File"><code class="flex name class">
<span>class <span class="ident">BZip2File</span></span>
<span>(</span><span>data, nsis=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L393-L535" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BZip2File(_DecompressionFile):

    blocksize: int
    block_header_size: int
    block_header_type: tuple[int, int]
    current_block: bytearray

    def __init__(self, data: BinaryIO, nsis: bool = True):
        super().__init__(data, nsis)
        self.bits = RBitfield(data)

        if nsis:
            self.blocksize = 9
            self.block_header_size = 8
            self.block_header_type = (0x31, 0x17)
        else:
            if data.read(2) != b&#39;BZ&#39;:
                raise RuntimeError(&#39;BZip2 header magic is missing&#39;)
            if self.bits.readbits(8) != ord(&#39;h&#39;):
                raise RuntimeError(&#39;BZip2 header contains unknown compression method&#39;)
            blocksize = self.bits.readbits(8)
            if 0x31 &lt;= blocksize &lt;= 0x39:
                blocksize = blocksize - 0x30
            else:
                raise RuntimeError(&#39;BZip2 header specifies invalid block size&#39;)
            self.blocksize = blocksize
            self.block_header_size = 48
            self.block_header_type = (0x314159265359, 0x177245385090)

        self.blocksize *= 100_000

    def _readblock(self):
        out = self.current_block
        if self.done:
            return False
        br = self.bits
        blocktype = br.readbits(self.block_header_size)
        if not self.nsis:
            _ = br.readbits(32) # crc
        if blocktype == self.block_header_type[0]:
            if not self.nsis and br.readbits(1):
                raise RuntimeError(&#39;BZip2 randomised support not implemented&#39;)
            pointer = br.readbits(24)
            huffman_used_map = br.readbits(16)
            map_mask = 1 &lt;&lt; 15
            used = []
            while map_mask &gt; 0:
                if huffman_used_map &amp; map_mask:
                    huffman_used_bitmap = br.readbits(16)
                    bit_mask = 1 &lt;&lt; 15
                    while bit_mask &gt; 0:
                        if huffman_used_bitmap &amp; bit_mask:
                            pass
                        used += [bool(huffman_used_bitmap &amp; bit_mask)]
                        bit_mask &gt;&gt;= 1
                else:
                    used += [False] * 16
                map_mask &gt;&gt;= 1
            huffman_groups = br.readbits(3)
            if not 2 &lt;= huffman_groups &lt;= 6:
                raise RuntimeError(&#39;BZip2 number of Huffman groups not in range 2..6&#39;)
            selectors_used = br.readbits(15)
            mtf = list(range(huffman_groups))
            selectors_list = []
            for i in range(selectors_used):
                c = 0
                while br.readbits(1):
                    c += 1
                    if c &gt;= huffman_groups:
                        raise RuntimeError(&#39;BZip2 chosen selector greater than number of groups (max 6)&#39;)
                if c &gt;= 0:
                    move_to_front(mtf, c)
                selectors_list += mtf[0:1]
            groups_lengths = []
            symbols_in_use = sum(used) + 2  # remember RUN[AB] RLE symbols
            for _ in range(huffman_groups):
                length = br.readbits(5)
                lengths = []
                for i in range(symbols_in_use):
                    if not 0 &lt;= length &lt;= 20:
                        raise RuntimeError(&#39;BZip2 Huffman length code outside range 0..20&#39;)
                    while br.readbits(1):
                        length -= (br.readbits(1) * 2) - 1
                    lengths += [length]
                groups_lengths += [lengths]

            tables = []
            for g in groups_lengths:
                codes = OrderedHuffmanTable(g)
                codes.populate_huffman_symbols()
                codes.min_max_bits()
                tables.append(codes)

            favourites = [y for y, x in enumerate(used) if x]
            selector_pointer = 0
            decoded = 0
            repeat = repeat_power = 0
            buffer = bytearray()
            t = None
            while True:
                decoded -= 1
                if decoded &lt;= 0:
                    decoded = 50
                    if selector_pointer &lt;= len(selectors_list):
                        t = tables[selectors_list[selector_pointer]]
                        selector_pointer += 1
                r = t.find_next_symbol(br, False)
                if 0 &lt;= r &lt;= 1:
                    if repeat == 0:
                        repeat_power = 1
                    repeat += repeat_power &lt;&lt; r
                    repeat_power &lt;&lt;= 1
                    continue
                elif repeat &gt; 0:
                    buffer.extend(itertools.repeat(favourites[0], repeat))
                    repeat = 0
                if r == symbols_in_use - 1:
                    break
                else:
                    o = favourites[r - 1]
                    move_to_front(favourites, r - 1)
                    buffer.append(o)
            # RLE step
            nt = bwt_reverse(buffer, pointer)
            done = bytearray()
            n = len(nt)
            i = 0
            while i &lt; n:
                if i &lt; n - 4 and nt[i] == nt[i + 1] == nt[i + 2] == nt[i + 3]:
                    done.extend(itertools.repeat(nt[i], nt[i + 4] + 4))
                    i += 5
                else:
                    done.append(nt[i])
                    i += 1
            out.extend(done)
            return True
        elif blocktype == self.block_header_type[1]:
            br.align()
            self.done = True
            return False
        else:
            raise RuntimeError(
                F&#39;unknown BZip2 block value 0x{blocktype:0{self.block_header_size // 4}X}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>refinery.lib.thirdparty.pyflate._DecompressionFile</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.thirdparty.pyflate.BZip2File.blocksize"><code class="name">var <span class="ident">blocksize</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.BZip2File.block_header_size"><code class="name">var <span class="ident">block_header_size</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.BZip2File.block_header_type"><code class="name">var <span class="ident">block_header_type</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.BZip2File.current_block"><code class="name">var <span class="ident">current_block</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.thirdparty.pyflate.GZipFile"><code class="flex name class">
<span>class <span class="ident">GZipFile</span></span>
<span>(</span><span>data, nsis=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/thirdparty/pyflate.py#L538-L695" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GZipFile(_DecompressionFile):

    def __init__(self, data: BinaryIO, nsis: bool = True):
        super().__init__(data, nsis)
        br = self.bits = LBitfield(data)
        if not nsis and self.data.read(2) != b&#39;\x1F\x8B&#39;:
            raise RuntimeError(&#39;Unknown (not 1F8B) header&#39;)
        if not nsis and br.readbits(8) != 8:
            raise RuntimeError(&#39;Unknown (not type 8 DEFLATE) compression method&#39;)
        if not nsis:
            self.flags = br.readbits(8)
            self.mtime = br.readbits(32)
            self.extra_flags = br.readbits(8)
            self.os_type = br.readbits(8)
            self.file_name = &#39;&#39;
            self.comment = &#39;&#39;

            if self.flags &amp; 0x04:
                # structured GZ_FEXTRA miscellaneous data
                xlen = br.readbits(16)
                br.dropbytes(xlen)
            while self.flags &amp; 0x08:
                # original GZ_FNAME filename
                cc = br.readbits(8)
                if not cc:
                    break
                self.file_name += chr(cc)
            while self.flags &amp; 0x10:
                # human readable GZ_FCOMMENT
                cc = br.readbits(8)
                if not cc:
                    break
                self.comment += chr(cc)
            if self.flags &amp; 0x02:
                # header-only GZ_FHCRC checksum
                br.readbits(16)

    def _readblock(self) -&gt; bool:
        if self.done:
            return False
        br = self.bits
        out = self.current_block
        lastbit = br.readbits(1)
        blocktype = br.readbits(2)

        def _error_unused(msg):
            return RuntimeError(F&#39;illegal unused {msg} in use at {br.tell()}&#39;)

        if blocktype == 0:
            br.align()
            length = br.readbits(16)
            if not self.nsis and 0 != length &amp; br.readbits(16):
                raise RuntimeError(&#39;stored block lengths do not match each other&#39;)
            if not br.bits:
                it = self.data.read(length)
            else:
                it = (br.readbits(8) for _ in range(length))
            out.extend(it)

        elif blocktype == 1 or blocktype == 2:
            main_literals, main_distances = None, None

            if blocktype == 1: # Static Huffman
                static_huffman_bootstrap = [(0, 8), (144, 9), (256, 7), (280, 8), (288, -1)]
                static_huffman_lengths_bootstrap = [(0, 5), (32, -1)]
                main_literals = HuffmanTable(static_huffman_bootstrap)
                main_distances = HuffmanTable(static_huffman_lengths_bootstrap)

            elif blocktype == 2: # Dynamic Huffman
                len_codes = br.readbits(5)
                literals = len_codes + 257
                distances = br.readbits(5) + 1
                code_lengths_length = br.readbits(4) + 4
                table = [0] * 19
                for i in range(code_lengths_length):
                    table[CODE_LENGTH_ORDERS[i]] = br.readbits(3)
                dynamic_codes = OrderedHuffmanTable(table)
                dynamic_codes.populate_huffman_symbols()
                dynamic_codes.min_max_bits()

                # Decode the code_lengths for both tables at once,
                # then split the list later

                code_lengths = []
                n = 0
                while n &lt; (literals + distances):
                    r = dynamic_codes.find_next_symbol(br)
                    if 0 &lt;= r &lt;= 15: # literal bitlength for this code
                        count = 1
                        what = r
                    elif r == 16: # repeat last code
                        count = 3 + br.readbits(2)
                        # Is this supposed to default to &#39;0&#39; if in the zeroth position?
                        what = code_lengths[-1]
                    elif r == 17: # repeat zero
                        count = 3 + br.readbits(3)
                        what = 0
                    elif r == 18: # repeat zero lots
                        count = 11 + br.readbits(7)
                        what = 0
                    else:
                        raise RuntimeError(&#39;next code length is outside of the range 0 &lt;= r &lt;= 18&#39;)
                    code_lengths += [what] * count
                    n += count

                main_literals = OrderedHuffmanTable(code_lengths[:literals])
                main_distances = OrderedHuffmanTable(code_lengths[literals:])

            main_literals.populate_huffman_symbols()
            main_distances.populate_huffman_symbols()
            main_literals.min_max_bits()
            main_distances.min_max_bits()
            literal_count = 0

            while True:
                r = main_literals.find_next_symbol(br)
                if 0 &lt;= r &lt;= 255:
                    literal_count += 1
                    out.append(r)
                elif r == 256:
                    if literal_count &gt; 0:
                        literal_count = 0
                    break
                elif 257 &lt;= r &lt;= 285: # dictionary lookup
                    if literal_count &gt; 0:
                        literal_count = 0
                    length_extra = br.readbits(extra_length_bits(r))
                    length = LENGTH_BASE[r - 257] + length_extra

                    r1 = main_distances.find_next_symbol(br)
                    if 0 &lt;= r1 &lt;= 29:
                        distance = DISTANCE_BASE[r1] + br.readbits(extra_distance_bits(r1))
                        while length &gt; distance:
                            out += out[-distance:]
                            length -= distance
                        if length == distance:
                            out += out[-distance:]
                        else:
                            out += out[-distance:length - distance]
                    elif 30 &lt;= r1 &lt;= 31:
                        raise _error_unused(&#39;distance symbol&#39;)
                elif 286 &lt;= r &lt;= 287:
                    raise _error_unused(&#39;literal/length symbol&#39;)
        elif blocktype == 3:
            raise _error_unused(&#39;blocktype&#39;)

        if lastbit:
            self.done = True
            br.align()
            try:
                _ = br.readbits(32) # crc
                _ = br.readbits(32) # length
            except Exception:
                if not self.nsis:
                    raise
            return False
        else:
            return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>refinery.lib.thirdparty.pyflate._DecompressionFile</li>
<li>abc.ABC</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib.thirdparty" href="index.html">refinery.lib.thirdparty</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="refinery.lib.thirdparty.pyflate.reverse_bits" href="#refinery.lib.thirdparty.pyflate.reverse_bits">reverse_bits</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.reverse_bytes" href="#refinery.lib.thirdparty.pyflate.reverse_bytes">reverse_bytes</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.extra_distance_bits" href="#refinery.lib.thirdparty.pyflate.extra_distance_bits">extra_distance_bits</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.extra_length_bits" href="#refinery.lib.thirdparty.pyflate.extra_length_bits">extra_length_bits</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.move_to_front" href="#refinery.lib.thirdparty.pyflate.move_to_front">move_to_front</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.bwt_transform" href="#refinery.lib.thirdparty.pyflate.bwt_transform">bwt_transform</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.bwt_reverse" href="#refinery.lib.thirdparty.pyflate.bwt_reverse">bwt_reverse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.thirdparty.pyflate.BitfieldBase" href="#refinery.lib.thirdparty.pyflate.BitfieldBase">BitfieldBase</a></code></h4>
<ul class="two-column">
<li><code><a title="refinery.lib.thirdparty.pyflate.BitfieldBase.needbits" href="#refinery.lib.thirdparty.pyflate.BitfieldBase.needbits">needbits</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.BitfieldBase.toskip" href="#refinery.lib.thirdparty.pyflate.BitfieldBase.toskip">toskip</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.BitfieldBase.align" href="#refinery.lib.thirdparty.pyflate.BitfieldBase.align">align</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.BitfieldBase.dropbits" href="#refinery.lib.thirdparty.pyflate.BitfieldBase.dropbits">dropbits</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.BitfieldBase.dropbytes" href="#refinery.lib.thirdparty.pyflate.BitfieldBase.dropbytes">dropbytes</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.BitfieldBase.tell" href="#refinery.lib.thirdparty.pyflate.BitfieldBase.tell">tell</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.BitfieldBase.tellbits" href="#refinery.lib.thirdparty.pyflate.BitfieldBase.tellbits">tellbits</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.BitfieldBase.snoopbits" href="#refinery.lib.thirdparty.pyflate.BitfieldBase.snoopbits">snoopbits</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.BitfieldBase.readbits" href="#refinery.lib.thirdparty.pyflate.BitfieldBase.readbits">readbits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.thirdparty.pyflate.LBitfield" href="#refinery.lib.thirdparty.pyflate.LBitfield">LBitfield</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.thirdparty.pyflate.LBitfield.snoopbits" href="#refinery.lib.thirdparty.pyflate.LBitfield.snoopbits">snoopbits</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.LBitfield.readbits" href="#refinery.lib.thirdparty.pyflate.LBitfield.readbits">readbits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.thirdparty.pyflate.RBitfield" href="#refinery.lib.thirdparty.pyflate.RBitfield">RBitfield</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.thirdparty.pyflate.RBitfield.snoopbits" href="#refinery.lib.thirdparty.pyflate.RBitfield.snoopbits">snoopbits</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.RBitfield.readbits" href="#refinery.lib.thirdparty.pyflate.RBitfield.readbits">readbits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.thirdparty.pyflate.HuffmanLength" href="#refinery.lib.thirdparty.pyflate.HuffmanLength">HuffmanLength</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.thirdparty.pyflate.HuffmanTable" href="#refinery.lib.thirdparty.pyflate.HuffmanTable">HuffmanTable</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.thirdparty.pyflate.HuffmanTable.populate_huffman_symbols" href="#refinery.lib.thirdparty.pyflate.HuffmanTable.populate_huffman_symbols">populate_huffman_symbols</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.HuffmanTable.min_max_bits" href="#refinery.lib.thirdparty.pyflate.HuffmanTable.min_max_bits">min_max_bits</a></code></li>
<li><code><a title="refinery.lib.thirdparty.pyflate.HuffmanTable.find_next_symbol" href="#refinery.lib.thirdparty.pyflate.HuffmanTable.find_next_symbol">find_next_symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.thirdparty.pyflate.OrderedHuffmanTable" href="#refinery.lib.thirdparty.pyflate.OrderedHuffmanTable">OrderedHuffmanTable</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.thirdparty.pyflate.BZip2File" href="#refinery.lib.thirdparty.pyflate.BZip2File">BZip2File</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.thirdparty.pyflate.GZipFile" href="#refinery.lib.thirdparty.pyflate.GZipFile">GZipFile</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
