<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.tools documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.tools</code></h1>
</header>
<section id="section-intro">
<p>Miscellaneous helper functions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L1-L499" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Miscellaneous helper functions.
&#34;&#34;&#34;
from __future__ import annotations

import inspect
import io
import itertools
import logging
import os
import re
import sys
import warnings

from enum import Enum, IntFlag
from math import log
from typing import Generator, Iterable, TypeVar, cast

from refinery.lib.types import buf

_T = TypeVar(&#39;_T&#39;)


def lookahead(iterator: Iterable[_T]) -&gt; Generator[tuple[bool, _T]]:
    &#34;&#34;&#34;
    Implements a new iterator from a given one which returns elements `(last, item)` where each
    `item` is taken from the original iterator and `last` is a boolean indicating whether this is
    the last item.
    &#34;&#34;&#34;
    last = False
    it = iter(iterator)
    try:
        peek = next(it)
    except StopIteration:
        return
    while not last:
        item = peek
        try:
            peek = next(it)
        except StopIteration:
            last = True
        yield last, item


def get_terminal_size(default=0):
    &#34;&#34;&#34;
    Returns the size of the currently attached terminal. If the environment variable
    `REFINERY_TERM_SIZE` is set to an integer value, it takes prescedence. If the width of the
    terminal cannot be determined or if the width is less than 8 characters, the function
    returns zero.
    &#34;&#34;&#34;
    from refinery.lib.environment import environment
    ev_terminal_size = environment.term_size.value
    if ev_terminal_size and ev_terminal_size &gt; 0:
        return ev_terminal_size
    width = default
    for stream in (sys.stderr, sys.stdout):
        if stream.isatty():
            try:
                width = os.get_terminal_size(stream.fileno()).columns
            except Exception:
                width = default
            else:
                break
    return default if width &lt; 2 else width - 1


def terminalfit(text: str, delta: int = 0, width: int = 0, parsep: str = &#39;\n\n&#39;, **kw) -&gt; str:
    &#34;&#34;&#34;
    Reformats text to fit the given width while not mangling bullet point lists.
    &#34;&#34;&#34;
    import re
    import textwrap

    width = width or get_terminal_size()
    width = width - delta

    def isol(t):
        return re.match(R&#39;^\(\d+\)|\d+[.:;]&#39;, t)

    def isul(t):
        return t.startswith(&#39;-&#39;) or t.startswith(&#39;*&#39;)

    def issp(t):
        return t.startswith(&#39;  &#39;)

    text = text.replace(&#39;\r&#39;, &#39;&#39;)

    def bulletpoint(line):
        wrapped = textwrap.wrap(line, width - 2, **kw)
        indent = &#39;  &#39; if isul(line) else &#39;   &#39;
        wrapped[1:] = [f&#39;{indent}{line}&#39; for line in wrapped[1:]]
        return &#39;\n&#39;.join(wrapped)

    def fitted(paragraphs):
        for k, p in enumerate(paragraphs):
            if p.startswith(&#39; &#39;):
                yield p
                continue
            ol, ul = isol(p), isul(p)
            if ol or ul:
                input_lines = p.splitlines(keepends=False)
                unwrapped_line = input_lines[0].rstrip()
                lines = []
                if (ol and all(isol(t) or issp(t) for t in input_lines) or ul and all(isul(t) or issp(t) for t in input_lines)):
                    for line in input_lines[1:]:
                        if not (ol and isol(line) or ul and isul(line)):
                            unwrapped_line += &#39; &#39; + line.strip()
                            continue
                        lines.append(bulletpoint(unwrapped_line))
                        unwrapped_line = line.rstrip()
                    lines.append(bulletpoint(unwrapped_line))
                    yield &#39;\n&#39;.join(lines)
                    continue
            yield &#39;\n&#39;.join(textwrap.wrap(p, width, **kw))

    return parsep.join(fitted(text.split(&#39;\n\n&#39;)))


def documentation(unit):
    &#34;&#34;&#34;
    Return the documentation string of a given unit as it should be displayed on the command line.
    Certain pdoc3-specific reference strings are removed.
    &#34;&#34;&#34;
    import re
    docs = inspect.getdoc(unit) or &#39;&#39;
    docs = re.sub(R&#39;`refinery\.(?:\w+\.)*(\w+)`&#39;, R&#39;\1&#39;, docs)
    return docs.replace(&#39;`&#39;, &#39;&#39;)


def begin(iterable: Iterable[_T]) -&gt; tuple[_T, Iterable[_T]] | None:
    &#34;&#34;&#34;
    Iterates the first element of an iterator and returns None if this fails. Otherwise, it returns
    both the first element and a new iterable which will return the same elements as the input.
    &#34;&#34;&#34;
    try:
        body = iter(iterable)
        head = next(body)
    except StopIteration:
        return None
    else:
        def _fused():
            yield head
            yield from body
        return head, _fused()


def skipfirst(iterable: Iterable[_T]) -&gt; Generator[_T]:
    &#34;&#34;&#34;
    Returns an interable where the first element of the input iterable was skipped.
    &#34;&#34;&#34;
    it = iter(iterable)
    next(it)
    yield from it


def entropy_fallback(data: buf) -&gt; float:
    &#34;&#34;&#34;
    This method is called by `refinery.lib.tools.entropy` when the `numpy` module is not available.
    It computes the shannon entropy of the input byte string and is written in pure Python.
    &#34;&#34;&#34;
    if isinstance(data, memoryview):
        # this copy is better than re-implementing count in Python for memory views
        data = bytes(data)
    histogram = {b: data.count(b) for b in range(0x100)}
    S = [histogram[b] / len(data) for b in histogram]
    return 0.0 + -sum(p * log(p, 2) for p in S if p) / 8.0


def entropy(data: buf) -&gt; float:
    &#34;&#34;&#34;
    Computes the entropy of `data` over the alphabet of all bytes.
    &#34;&#34;&#34;
    if not data:
        return 0.0
    try:
        import numpy
    except ImportError:
        return entropy_fallback(data)
    hist = numpy.unique(memoryview(data), return_counts=True)[1]
    prob = hist / len(data)
    # 8 bits are the maximum number of bits of information in a byte
    return 0.0 - (numpy.log2(prob) * prob).sum() / 8.0


def index_of_coincidence(data: buf) -&gt; float:
    &#34;&#34;&#34;
    Computes the index of coincidence of `data` over the alphabet of all bytes.
    &#34;&#34;&#34;
    if not data:
        return 0.0
    N = len(data)
    if N &lt; 2:
        return 0.0
    try:
        import numpy
    except ImportError:
        C = [0] * 0x100
        for b in data:
            C[b] += 1
    else:
        C = numpy.histogram(
            numpy.frombuffer(data, dtype=numpy.uint8),
            numpy.arange(0x100))[0]
    d = 1 / N / (N - 1)
    return float(sum(x * (x - 1) * d for x in C))


def splitchunks(
    data: buf,
    size: int,
    step: int | None = None,
    truncate: bool = False
) -&gt; Iterable[buf]:
    &#34;&#34;&#34;
    Split `data` into chunks of size `size`. The cursor advances by `step` bytes after extracting a
    block, the default value for `step` is equal to `size`. The boolean parameter `truncate`
    specifies whether any chunks of size smaller than `size` are generated or whether to abort as
    soon as the last complete chunk of the given size is extracted.
    &#34;&#34;&#34;
    if step is None:
        step = size
    if len(data) &lt;= size:
        if not truncate or len(data) == size:
            yield data
        return
    for k in range(0, len(data), step):
        chunk = data[k:k + size]
        if not chunk:
            break
        if len(chunk) &lt; size and truncate:
            break
        yield chunk


def infinitize(it: _T | Iterable[_T]) -&gt; Iterable[_T]:
    &#34;&#34;&#34;
    Creates an infinite iterable from the input.
    &#34;&#34;&#34;
    if isinstance(it, (
        itertools.cycle,
        itertools.repeat,
        itertools.count,
    )):
        return it
    elif isinstance(it, Iterable):
        return itertools.cycle(it)
    else:
        return itertools.repeat(it)


class NoLogging:
    &#34;&#34;&#34;
    A context manager to prevent various unwanted kinds of logging messages to appear.
    The class is initialized with a given mode that encodes the logging channels to be
    suppressed. After the context is exited, the original logging behavior is restored.
    &#34;&#34;&#34;

    class Mode(IntFlag):
        &#34;&#34;&#34;
        A set of flags for different logging mechanisms to be suppressed.
        &#34;&#34;&#34;
        STD_OUT = 0b0001
        &#34;&#34;&#34;Silence the standard output channel.&#34;&#34;&#34;
        STD_ERR = 0b0010
        &#34;&#34;&#34;Silence the standard error channel.&#34;&#34;&#34;
        WARNING = 0b0100
        &#34;&#34;&#34;Silence the Python warning module.&#34;&#34;&#34;
        LOGGING = 0b1000
        &#34;&#34;&#34;Silence the Python logging module.&#34;&#34;&#34;
        ALL     = 0b1111 # noqa
        &#34;&#34;&#34;Silence all known logging mechanisms.&#34;&#34;&#34;

    def __init__(self, mode: Mode = Mode.WARNING | Mode.LOGGING):
        self.mode = mode

    def __enter__(self):
        if self.mode &amp; NoLogging.Mode.LOGGING:
            logging.disable(logging.CRITICAL)
        if self.mode &amp; NoLogging.Mode.WARNING:
            self._warning_filters = list(warnings.filters)
            warnings.filterwarnings(&#39;ignore&#39;)
        if self.mode &amp; NoLogging.Mode.STD_ERR:
            self._stderr = sys.stderr
            sys.stderr = io.TextIOWrapper(open(os.devnull, &#39;wb&#39;), encoding=&#39;latin1&#39;)
        if self.mode &amp; NoLogging.Mode.STD_OUT:
            self._stdout = sys.stdout
            sys.stdout = io.TextIOWrapper(open(os.devnull, &#39;wb&#39;), encoding=&#39;latin1&#39;)
        return self

    def __exit__(self, *_):
        if self.mode &amp; NoLogging.Mode.LOGGING:
            logging.disable(logging.NOTSET)
        if self.mode &amp; NoLogging.Mode.WARNING:
            warnings.resetwarnings()
            assert isinstance(warnings.filters, list)
            warnings.filters[:] = self._warning_filters
        if self.mode &amp; NoLogging.Mode.STD_ERR:
            sys.stderr.close()
            sys.stderr = self._stderr
        if self.mode &amp; NoLogging.Mode.STD_OUT:
            sys.stdout.close()
            sys.stdout = self._stdout


class NoLoggingProxy:
    &#34;&#34;&#34;
    This class can be used to wrap any object. It acts as a proxy for this object, passing though
    and attribute access, operator use, and method calls to its base. However, any such action
    is wrapped in a `refinery.lib.tools.NoLogging` context to ensure that it procudes no logging
    output. Notably, any returned values that are not considered primitive are wrapped as a proxy
    as well. The main downside of this is that instance checks no longer work as expected.
    &#34;&#34;&#34;

    __slots__ = (
        &#39;__wrapped__&#39;,
        &#39;__nl_mode__&#39;,
    )

    __proxy_cache__ = {}

    def __new__(cls, wrap, mode: NoLogging.Mode = NoLogging.Mode.ALL):
        wrap_type = type(wrap)
        if isinstance(wrap, (int, float, str, bytes, bytearray, memoryview, Enum)):
            return wrap
        if (proxy_class := cls.__proxy_cache__.get(wrap_type)) is None:
            dunder_names = [
                name for name in dir(wrap_type) if name.startswith(&#39;__&#39;) and name.endswith(&#39;__&#39;)]
            proxied_dunder_methods = {}
            for name in dunder_names:
                if name == &#39;__new__&#39;:
                    continue
                class_method = getattr(wrap_type, name)
                if class_method and class_method is getattr(wrap, name):
                    def proxied_method(
                        _, *args,
                        _proxy___call=class_method,
                        _proxy___wrap=wrap,
                        _proxy___mode=mode,
                        **kwargs
                    ):
                        with NoLogging(_proxy___mode):
                            result = _proxy___call(_proxy___wrap, *args, **kwargs)
                        return NoLoggingProxy(result, _proxy___mode)
                    if not callable(class_method):
                        continue
                    proxied_dunder_methods[name] = proxied_method
            if proxied_dunder_methods:
                proxy_class = type(
                    F&#39;_proxy_{wrap_type.__name__}&#39;, (NoLoggingProxy,), proxied_dunder_methods)
            else:
                proxy_class = cls
            cls.__proxy_cache__[wrap_type] = proxy_class
        return super().__new__(proxy_class) # type:ignore

    def __init__(self, wrap, mode: NoLogging.Mode = NoLogging.Mode.ALL):
        self.__wrapped__ = wrap
        self.__nl_mode__ = mode

    def __setattr__(self, name, value):
        if name in NoLoggingProxy.__slots__:
            return super().__setattr__(name, value)
        mode = self.__nl_mode__
        wrap = self.__wrapped__
        with NoLogging(mode):
            setattr(wrap, name, value)

    def __repr__(self):
        with NoLogging(self.__nl_mode__):
            return repr(self.__wrapped__)

    def __getattribute__(self, name):
        wrap = super().__getattribute__(&#39;__wrapped__&#39;)
        mode = super().__getattribute__(&#39;__nl_mode__&#39;)
        if name == &#39;__wrapped__&#39;:
            return wrap
        if name == &#39;__nl_mode__&#39;:
            return mode
        with NoLogging(mode):
            attr = getattr(wrap, name)
        return NoLoggingProxy(attr, mode)

    def __getitem__(self, k):
        mode = self.__nl_mode__
        with NoLogging(mode):
            item = self.__wrapped__[k]
        return NoLoggingProxy(item, mode)

    def __iter__(self):
        mode = self.__nl_mode__
        with NoLogging(mode):
            it = iter(self.__wrapped__)
        while True:
            try:
                with NoLogging(mode):
                    item = next(it)
            except StopIteration:
                return
            else:
                yield NoLoggingProxy(item, mode)

    def __call__(self, *args, **kwargs):
        mode = self.__nl_mode__
        with NoLogging(mode):
            rv = self.__wrapped__(*args, **kwargs)
        return NoLoggingProxy(rv, mode)


def proxy(t: _T) -&gt; _T:
    &#34;&#34;&#34;
    Proxy an object using `refinery.lib.tools.NoLoggingProxy` but cheat the type checker into
    thinking that it has retained its type.
    &#34;&#34;&#34;
    return cast(_T, NoLoggingProxy(t))


def unwrap(t: _T) -&gt; _T:
    &#34;&#34;&#34;
    Unwrap an object that is potentially wrapped, say, as a `refinery.lib.tools.NoLoggingProxy`.
    &#34;&#34;&#34;
    return getattr(t, &#39;__wrapped__&#39;, t)


class NotOne(LookupError):
    &#34;&#34;&#34;
    A custom exception raised by `refinery.lib.tools.one` if the input iterator does not yield
    exactly one element. The property `empty` indicates whether the iterator was empty; if it is
    false, then the exception was raised because the iterator contained more than one element.
    &#34;&#34;&#34;
    def __init__(self, empty: bool):
        how = &#39;none&#39; if empty else &#39;more&#39;
        super().__init__(F&#39;Expected a single item, but the iterator was {how}&#39;)
        self.empty = empty


def one(iterable: Iterable[_T]) -&gt; _T:
    &#34;&#34;&#34;
    The function expects the input `iterable` to be an iterable that yields exactly one element
    and returns that element. Raises `refinery.lib.tools.NotOne` for invalid inputs.
    &#34;&#34;&#34;
    it = iter(iterable)
    try:
        top = next(it)
    except StopIteration:
        raise NotOne(True)
    try:
        next(it)
    except StopIteration:
        return top
    else:
        raise NotOne(False)


def integers_of_slice(s: slice) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    Returns an iterable that iterates the integers in the range given by the input slice.
    &#34;&#34;&#34;
    if s.stop is None:
        return itertools.count(s.start or 0, s.step or 1)
    else:
        return range(s.start or 0, s.stop, s.step or 1)


def normalize_word_separators(words: str, unified_separator: str, strip: bool = True):
    &#34;&#34;&#34;
    For a sequence of words separated by whitespace, punctuation, slashes, dashes or underscores,
    normalize all occurrences of one or more of these separators to one given symbol. Leading and
    trailing occurrences of separators are removed.
    &#34;&#34;&#34;
    normalized = re.sub(&#39;[-\\s_.,;:/\\\\]+&#39;, unified_separator, words)
    if strip:
        normalized = normalized.strip(unified_separator)
    return normalized


def normalize_to_display(words: str, strip: bool = True):
    &#34;&#34;&#34;
    Normalizes all separators to dashes.
    &#34;&#34;&#34;
    return normalize_word_separators(words, &#39;-&#39;, strip)


def normalize_to_identifier(words: str, strip: bool = True):
    &#34;&#34;&#34;
    Normalizes all separators to underscores.
    &#34;&#34;&#34;
    return normalize_word_separators(words, &#39;_&#39;, strip)


def exception_to_string(exception: BaseException, default=None) -&gt; str:
    &#34;&#34;&#34;
    Attempts to convert a given exception to a good description that can be exposed to the user.
    &#34;&#34;&#34;
    if not exception.args:
        return exception.__class__.__name__
    it = (a for a in exception.args if isinstance(a, str))
    if default is None:
        default = str(exception)
    return max(it, key=len, default=default).strip()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.tools.lookahead"><code class="name flex">
<span>def <span class="ident">lookahead</span></span>(<span>iterator)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements a new iterator from a given one which returns elements <code>(last, item)</code> where each
<code>item</code> is taken from the original iterator and <code>last</code> is a boolean indicating whether this is
the last item.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L24-L42" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def lookahead(iterator: Iterable[_T]) -&gt; Generator[tuple[bool, _T]]:
    &#34;&#34;&#34;
    Implements a new iterator from a given one which returns elements `(last, item)` where each
    `item` is taken from the original iterator and `last` is a boolean indicating whether this is
    the last item.
    &#34;&#34;&#34;
    last = False
    it = iter(iterator)
    try:
        peek = next(it)
    except StopIteration:
        return
    while not last:
        item = peek
        try:
            peek = next(it)
        except StopIteration:
            last = True
        yield last, item</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.get_terminal_size"><code class="name flex">
<span>def <span class="ident">get_terminal_size</span></span>(<span>default=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the size of the currently attached terminal. If the environment variable
<code>REFINERY_TERM_SIZE</code> is set to an integer value, it takes prescedence. If the width of the
terminal cannot be determined or if the width is less than 8 characters, the function
returns zero.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L45-L65" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_terminal_size(default=0):
    &#34;&#34;&#34;
    Returns the size of the currently attached terminal. If the environment variable
    `REFINERY_TERM_SIZE` is set to an integer value, it takes prescedence. If the width of the
    terminal cannot be determined or if the width is less than 8 characters, the function
    returns zero.
    &#34;&#34;&#34;
    from refinery.lib.environment import environment
    ev_terminal_size = environment.term_size.value
    if ev_terminal_size and ev_terminal_size &gt; 0:
        return ev_terminal_size
    width = default
    for stream in (sys.stderr, sys.stdout):
        if stream.isatty():
            try:
                width = os.get_terminal_size(stream.fileno()).columns
            except Exception:
                width = default
            else:
                break
    return default if width &lt; 2 else width - 1</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.terminalfit"><code class="name flex">
<span>def <span class="ident">terminalfit</span></span>(<span>text, delta=0, width=0, parsep='\n\n', **kw)</span>
</code></dt>
<dd>
<section class="desc"><p>Reformats text to fit the given width while not mangling bullet point lists.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L68-L117" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def terminalfit(text: str, delta: int = 0, width: int = 0, parsep: str = &#39;\n\n&#39;, **kw) -&gt; str:
    &#34;&#34;&#34;
    Reformats text to fit the given width while not mangling bullet point lists.
    &#34;&#34;&#34;
    import re
    import textwrap

    width = width or get_terminal_size()
    width = width - delta

    def isol(t):
        return re.match(R&#39;^\(\d+\)|\d+[.:;]&#39;, t)

    def isul(t):
        return t.startswith(&#39;-&#39;) or t.startswith(&#39;*&#39;)

    def issp(t):
        return t.startswith(&#39;  &#39;)

    text = text.replace(&#39;\r&#39;, &#39;&#39;)

    def bulletpoint(line):
        wrapped = textwrap.wrap(line, width - 2, **kw)
        indent = &#39;  &#39; if isul(line) else &#39;   &#39;
        wrapped[1:] = [f&#39;{indent}{line}&#39; for line in wrapped[1:]]
        return &#39;\n&#39;.join(wrapped)

    def fitted(paragraphs):
        for k, p in enumerate(paragraphs):
            if p.startswith(&#39; &#39;):
                yield p
                continue
            ol, ul = isol(p), isul(p)
            if ol or ul:
                input_lines = p.splitlines(keepends=False)
                unwrapped_line = input_lines[0].rstrip()
                lines = []
                if (ol and all(isol(t) or issp(t) for t in input_lines) or ul and all(isul(t) or issp(t) for t in input_lines)):
                    for line in input_lines[1:]:
                        if not (ol and isol(line) or ul and isul(line)):
                            unwrapped_line += &#39; &#39; + line.strip()
                            continue
                        lines.append(bulletpoint(unwrapped_line))
                        unwrapped_line = line.rstrip()
                    lines.append(bulletpoint(unwrapped_line))
                    yield &#39;\n&#39;.join(lines)
                    continue
            yield &#39;\n&#39;.join(textwrap.wrap(p, width, **kw))

    return parsep.join(fitted(text.split(&#39;\n\n&#39;)))</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.documentation"><code class="name flex">
<span>def <span class="ident">documentation</span></span>(<span>unit)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the documentation string of a given unit as it should be displayed on the command line.
Certain pdoc3-specific reference strings are removed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L120-L128" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def documentation(unit):
    &#34;&#34;&#34;
    Return the documentation string of a given unit as it should be displayed on the command line.
    Certain pdoc3-specific reference strings are removed.
    &#34;&#34;&#34;
    import re
    docs = inspect.getdoc(unit) or &#39;&#39;
    docs = re.sub(R&#39;`refinery\.(?:\w+\.)*(\w+)`&#39;, R&#39;\1&#39;, docs)
    return docs.replace(&#39;`&#39;, &#39;&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>iterable)</span>
</code></dt>
<dd>
<section class="desc"><p>Iterates the first element of an iterator and returns None if this fails. Otherwise, it returns
both the first element and a new iterable which will return the same elements as the input.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L131-L145" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def begin(iterable: Iterable[_T]) -&gt; tuple[_T, Iterable[_T]] | None:
    &#34;&#34;&#34;
    Iterates the first element of an iterator and returns None if this fails. Otherwise, it returns
    both the first element and a new iterable which will return the same elements as the input.
    &#34;&#34;&#34;
    try:
        body = iter(iterable)
        head = next(body)
    except StopIteration:
        return None
    else:
        def _fused():
            yield head
            yield from body
        return head, _fused()</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.skipfirst"><code class="name flex">
<span>def <span class="ident">skipfirst</span></span>(<span>iterable)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an interable where the first element of the input iterable was skipped.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L148-L154" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def skipfirst(iterable: Iterable[_T]) -&gt; Generator[_T]:
    &#34;&#34;&#34;
    Returns an interable where the first element of the input iterable was skipped.
    &#34;&#34;&#34;
    it = iter(iterable)
    next(it)
    yield from it</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.entropy_fallback"><code class="name flex">
<span>def <span class="ident">entropy_fallback</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>This method is called by <code><a title="refinery.lib.tools.entropy" href="#refinery.lib.tools.entropy">entropy()</a></code> when the <code>numpy</code> module is not available.
It computes the shannon entropy of the input byte string and is written in pure Python.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L157-L167" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def entropy_fallback(data: buf) -&gt; float:
    &#34;&#34;&#34;
    This method is called by `refinery.lib.tools.entropy` when the `numpy` module is not available.
    It computes the shannon entropy of the input byte string and is written in pure Python.
    &#34;&#34;&#34;
    if isinstance(data, memoryview):
        # this copy is better than re-implementing count in Python for memory views
        data = bytes(data)
    histogram = {b: data.count(b) for b in range(0x100)}
    S = [histogram[b] / len(data) for b in histogram]
    return 0.0 + -sum(p * log(p, 2) for p in S if p) / 8.0</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.entropy"><code class="name flex">
<span>def <span class="ident">entropy</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes the entropy of <code>data</code> over the alphabet of all bytes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L170-L183" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def entropy(data: buf) -&gt; float:
    &#34;&#34;&#34;
    Computes the entropy of `data` over the alphabet of all bytes.
    &#34;&#34;&#34;
    if not data:
        return 0.0
    try:
        import numpy
    except ImportError:
        return entropy_fallback(data)
    hist = numpy.unique(memoryview(data), return_counts=True)[1]
    prob = hist / len(data)
    # 8 bits are the maximum number of bits of information in a byte
    return 0.0 - (numpy.log2(prob) * prob).sum() / 8.0</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.index_of_coincidence"><code class="name flex">
<span>def <span class="ident">index_of_coincidence</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes the index of coincidence of <code>data</code> over the alphabet of all bytes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L186-L206" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def index_of_coincidence(data: buf) -&gt; float:
    &#34;&#34;&#34;
    Computes the index of coincidence of `data` over the alphabet of all bytes.
    &#34;&#34;&#34;
    if not data:
        return 0.0
    N = len(data)
    if N &lt; 2:
        return 0.0
    try:
        import numpy
    except ImportError:
        C = [0] * 0x100
        for b in data:
            C[b] += 1
    else:
        C = numpy.histogram(
            numpy.frombuffer(data, dtype=numpy.uint8),
            numpy.arange(0x100))[0]
    d = 1 / N / (N - 1)
    return float(sum(x * (x - 1) * d for x in C))</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.splitchunks"><code class="name flex">
<span>def <span class="ident">splitchunks</span></span>(<span>data, size, step=None, truncate=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Split <code>data</code> into chunks of size <code>size</code>. The cursor advances by <code>step</code> bytes after extracting a
block, the default value for <code>step</code> is equal to <code>size</code>. The boolean parameter <code>truncate</code>
specifies whether any chunks of size smaller than <code>size</code> are generated or whether to abort as
soon as the last complete chunk of the given size is extracted.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L209-L233" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def splitchunks(
    data: buf,
    size: int,
    step: int | None = None,
    truncate: bool = False
) -&gt; Iterable[buf]:
    &#34;&#34;&#34;
    Split `data` into chunks of size `size`. The cursor advances by `step` bytes after extracting a
    block, the default value for `step` is equal to `size`. The boolean parameter `truncate`
    specifies whether any chunks of size smaller than `size` are generated or whether to abort as
    soon as the last complete chunk of the given size is extracted.
    &#34;&#34;&#34;
    if step is None:
        step = size
    if len(data) &lt;= size:
        if not truncate or len(data) == size:
            yield data
        return
    for k in range(0, len(data), step):
        chunk = data[k:k + size]
        if not chunk:
            break
        if len(chunk) &lt; size and truncate:
            break
        yield chunk</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.infinitize"><code class="name flex">
<span>def <span class="ident">infinitize</span></span>(<span>it)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates an infinite iterable from the input.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L236-L249" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def infinitize(it: _T | Iterable[_T]) -&gt; Iterable[_T]:
    &#34;&#34;&#34;
    Creates an infinite iterable from the input.
    &#34;&#34;&#34;
    if isinstance(it, (
        itertools.cycle,
        itertools.repeat,
        itertools.count,
    )):
        return it
    elif isinstance(it, Iterable):
        return itertools.cycle(it)
    else:
        return itertools.repeat(it)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.proxy"><code class="name flex">
<span>def <span class="ident">proxy</span></span>(<span>t)</span>
</code></dt>
<dd>
<section class="desc"><p>Proxy an object using <code><a title="refinery.lib.tools.NoLoggingProxy" href="#refinery.lib.tools.NoLoggingProxy">NoLoggingProxy</a></code> but cheat the type checker into
thinking that it has retained its type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L409-L414" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def proxy(t: _T) -&gt; _T:
    &#34;&#34;&#34;
    Proxy an object using `refinery.lib.tools.NoLoggingProxy` but cheat the type checker into
    thinking that it has retained its type.
    &#34;&#34;&#34;
    return cast(_T, NoLoggingProxy(t))</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.unwrap"><code class="name flex">
<span>def <span class="ident">unwrap</span></span>(<span>t)</span>
</code></dt>
<dd>
<section class="desc"><p>Unwrap an object that is potentially wrapped, say, as a <code><a title="refinery.lib.tools.NoLoggingProxy" href="#refinery.lib.tools.NoLoggingProxy">NoLoggingProxy</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L417-L421" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unwrap(t: _T) -&gt; _T:
    &#34;&#34;&#34;
    Unwrap an object that is potentially wrapped, say, as a `refinery.lib.tools.NoLoggingProxy`.
    &#34;&#34;&#34;
    return getattr(t, &#39;__wrapped__&#39;, t)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.one"><code class="name flex">
<span>def <span class="ident">one</span></span>(<span>iterable)</span>
</code></dt>
<dd>
<section class="desc"><p>The function expects the input <code>iterable</code> to be an iterable that yields exactly one element
and returns that element. Raises <code><a title="refinery.lib.tools.NotOne" href="#refinery.lib.tools.NotOne">NotOne</a></code> for invalid inputs.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L436-L451" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def one(iterable: Iterable[_T]) -&gt; _T:
    &#34;&#34;&#34;
    The function expects the input `iterable` to be an iterable that yields exactly one element
    and returns that element. Raises `refinery.lib.tools.NotOne` for invalid inputs.
    &#34;&#34;&#34;
    it = iter(iterable)
    try:
        top = next(it)
    except StopIteration:
        raise NotOne(True)
    try:
        next(it)
    except StopIteration:
        return top
    else:
        raise NotOne(False)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.integers_of_slice"><code class="name flex">
<span>def <span class="ident">integers_of_slice</span></span>(<span>s)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an iterable that iterates the integers in the range given by the input slice.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L454-L461" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def integers_of_slice(s: slice) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    Returns an iterable that iterates the integers in the range given by the input slice.
    &#34;&#34;&#34;
    if s.stop is None:
        return itertools.count(s.start or 0, s.step or 1)
    else:
        return range(s.start or 0, s.stop, s.step or 1)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.normalize_word_separators"><code class="name flex">
<span>def <span class="ident">normalize_word_separators</span></span>(<span>words, unified_separator, strip=True)</span>
</code></dt>
<dd>
<section class="desc"><p>For a sequence of words separated by whitespace, punctuation, slashes, dashes or underscores,
normalize all occurrences of one or more of these separators to one given symbol. Leading and
trailing occurrences of separators are removed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L464-L473" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize_word_separators(words: str, unified_separator: str, strip: bool = True):
    &#34;&#34;&#34;
    For a sequence of words separated by whitespace, punctuation, slashes, dashes or underscores,
    normalize all occurrences of one or more of these separators to one given symbol. Leading and
    trailing occurrences of separators are removed.
    &#34;&#34;&#34;
    normalized = re.sub(&#39;[-\\s_.,;:/\\\\]+&#39;, unified_separator, words)
    if strip:
        normalized = normalized.strip(unified_separator)
    return normalized</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.normalize_to_display"><code class="name flex">
<span>def <span class="ident">normalize_to_display</span></span>(<span>words, strip=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Normalizes all separators to dashes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L476-L480" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize_to_display(words: str, strip: bool = True):
    &#34;&#34;&#34;
    Normalizes all separators to dashes.
    &#34;&#34;&#34;
    return normalize_word_separators(words, &#39;-&#39;, strip)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.normalize_to_identifier"><code class="name flex">
<span>def <span class="ident">normalize_to_identifier</span></span>(<span>words, strip=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Normalizes all separators to underscores.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L483-L487" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize_to_identifier(words: str, strip: bool = True):
    &#34;&#34;&#34;
    Normalizes all separators to underscores.
    &#34;&#34;&#34;
    return normalize_word_separators(words, &#39;_&#39;, strip)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.exception_to_string"><code class="name flex">
<span>def <span class="ident">exception_to_string</span></span>(<span>exception, default=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempts to convert a given exception to a good description that can be exposed to the user.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L490-L499" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def exception_to_string(exception: BaseException, default=None) -&gt; str:
    &#34;&#34;&#34;
    Attempts to convert a given exception to a good description that can be exposed to the user.
    &#34;&#34;&#34;
    if not exception.args:
        return exception.__class__.__name__
    it = (a for a in exception.args if isinstance(a, str))
    if default is None:
        default = str(exception)
    return max(it, key=len, default=default).strip()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.tools.NoLogging"><code class="flex name class">
<span>class <span class="ident">NoLogging</span></span>
<span>(</span><span>mode=12)</span>
</code></dt>
<dd>
<section class="desc"><p>A context manager to prevent various unwanted kinds of logging messages to appear.
The class is initialized with a given mode that encodes the logging channels to be
suppressed. After the context is exited, the original logging behavior is restored.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L252-L303" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class NoLogging:
    &#34;&#34;&#34;
    A context manager to prevent various unwanted kinds of logging messages to appear.
    The class is initialized with a given mode that encodes the logging channels to be
    suppressed. After the context is exited, the original logging behavior is restored.
    &#34;&#34;&#34;

    class Mode(IntFlag):
        &#34;&#34;&#34;
        A set of flags for different logging mechanisms to be suppressed.
        &#34;&#34;&#34;
        STD_OUT = 0b0001
        &#34;&#34;&#34;Silence the standard output channel.&#34;&#34;&#34;
        STD_ERR = 0b0010
        &#34;&#34;&#34;Silence the standard error channel.&#34;&#34;&#34;
        WARNING = 0b0100
        &#34;&#34;&#34;Silence the Python warning module.&#34;&#34;&#34;
        LOGGING = 0b1000
        &#34;&#34;&#34;Silence the Python logging module.&#34;&#34;&#34;
        ALL     = 0b1111 # noqa
        &#34;&#34;&#34;Silence all known logging mechanisms.&#34;&#34;&#34;

    def __init__(self, mode: Mode = Mode.WARNING | Mode.LOGGING):
        self.mode = mode

    def __enter__(self):
        if self.mode &amp; NoLogging.Mode.LOGGING:
            logging.disable(logging.CRITICAL)
        if self.mode &amp; NoLogging.Mode.WARNING:
            self._warning_filters = list(warnings.filters)
            warnings.filterwarnings(&#39;ignore&#39;)
        if self.mode &amp; NoLogging.Mode.STD_ERR:
            self._stderr = sys.stderr
            sys.stderr = io.TextIOWrapper(open(os.devnull, &#39;wb&#39;), encoding=&#39;latin1&#39;)
        if self.mode &amp; NoLogging.Mode.STD_OUT:
            self._stdout = sys.stdout
            sys.stdout = io.TextIOWrapper(open(os.devnull, &#39;wb&#39;), encoding=&#39;latin1&#39;)
        return self

    def __exit__(self, *_):
        if self.mode &amp; NoLogging.Mode.LOGGING:
            logging.disable(logging.NOTSET)
        if self.mode &amp; NoLogging.Mode.WARNING:
            warnings.resetwarnings()
            assert isinstance(warnings.filters, list)
            warnings.filters[:] = self._warning_filters
        if self.mode &amp; NoLogging.Mode.STD_ERR:
            sys.stderr.close()
            sys.stderr = self._stderr
        if self.mode &amp; NoLogging.Mode.STD_OUT:
            sys.stdout.close()
            sys.stdout = self._stdout</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.tools.NoLogging.Mode"><code class="name">var <span class="ident">Mode</span></code></dt>
<dd>
<section class="desc"><p>A set of flags for different logging mechanisms to be suppressed.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.tools.NoLoggingProxy"><code class="flex name class">
<span>class <span class="ident">NoLoggingProxy</span></span>
<span>(</span><span>wrap, mode=15)</span>
</code></dt>
<dd>
<section class="desc"><p>This class can be used to wrap any object. It acts as a proxy for this object, passing though
and attribute access, operator use, and method calls to its base. However, any such action
is wrapped in a <code><a title="refinery.lib.tools.NoLogging" href="#refinery.lib.tools.NoLogging">NoLogging</a></code> context to ensure that it procudes no logging
output. Notably, any returned values that are not considered primitive are wrapped as a proxy
as well. The main downside of this is that instance checks no longer work as expected.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L306-L406" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class NoLoggingProxy:
    &#34;&#34;&#34;
    This class can be used to wrap any object. It acts as a proxy for this object, passing though
    and attribute access, operator use, and method calls to its base. However, any such action
    is wrapped in a `refinery.lib.tools.NoLogging` context to ensure that it procudes no logging
    output. Notably, any returned values that are not considered primitive are wrapped as a proxy
    as well. The main downside of this is that instance checks no longer work as expected.
    &#34;&#34;&#34;

    __slots__ = (
        &#39;__wrapped__&#39;,
        &#39;__nl_mode__&#39;,
    )

    __proxy_cache__ = {}

    def __new__(cls, wrap, mode: NoLogging.Mode = NoLogging.Mode.ALL):
        wrap_type = type(wrap)
        if isinstance(wrap, (int, float, str, bytes, bytearray, memoryview, Enum)):
            return wrap
        if (proxy_class := cls.__proxy_cache__.get(wrap_type)) is None:
            dunder_names = [
                name for name in dir(wrap_type) if name.startswith(&#39;__&#39;) and name.endswith(&#39;__&#39;)]
            proxied_dunder_methods = {}
            for name in dunder_names:
                if name == &#39;__new__&#39;:
                    continue
                class_method = getattr(wrap_type, name)
                if class_method and class_method is getattr(wrap, name):
                    def proxied_method(
                        _, *args,
                        _proxy___call=class_method,
                        _proxy___wrap=wrap,
                        _proxy___mode=mode,
                        **kwargs
                    ):
                        with NoLogging(_proxy___mode):
                            result = _proxy___call(_proxy___wrap, *args, **kwargs)
                        return NoLoggingProxy(result, _proxy___mode)
                    if not callable(class_method):
                        continue
                    proxied_dunder_methods[name] = proxied_method
            if proxied_dunder_methods:
                proxy_class = type(
                    F&#39;_proxy_{wrap_type.__name__}&#39;, (NoLoggingProxy,), proxied_dunder_methods)
            else:
                proxy_class = cls
            cls.__proxy_cache__[wrap_type] = proxy_class
        return super().__new__(proxy_class) # type:ignore

    def __init__(self, wrap, mode: NoLogging.Mode = NoLogging.Mode.ALL):
        self.__wrapped__ = wrap
        self.__nl_mode__ = mode

    def __setattr__(self, name, value):
        if name in NoLoggingProxy.__slots__:
            return super().__setattr__(name, value)
        mode = self.__nl_mode__
        wrap = self.__wrapped__
        with NoLogging(mode):
            setattr(wrap, name, value)

    def __repr__(self):
        with NoLogging(self.__nl_mode__):
            return repr(self.__wrapped__)

    def __getattribute__(self, name):
        wrap = super().__getattribute__(&#39;__wrapped__&#39;)
        mode = super().__getattribute__(&#39;__nl_mode__&#39;)
        if name == &#39;__wrapped__&#39;:
            return wrap
        if name == &#39;__nl_mode__&#39;:
            return mode
        with NoLogging(mode):
            attr = getattr(wrap, name)
        return NoLoggingProxy(attr, mode)

    def __getitem__(self, k):
        mode = self.__nl_mode__
        with NoLogging(mode):
            item = self.__wrapped__[k]
        return NoLoggingProxy(item, mode)

    def __iter__(self):
        mode = self.__nl_mode__
        with NoLogging(mode):
            it = iter(self.__wrapped__)
        while True:
            try:
                with NoLogging(mode):
                    item = next(it)
            except StopIteration:
                return
            else:
                yield NoLoggingProxy(item, mode)

    def __call__(self, *args, **kwargs):
        mode = self.__nl_mode__
        with NoLogging(mode):
            rv = self.__wrapped__(*args, **kwargs)
        return NoLoggingProxy(rv, mode)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.NotOne"><code class="flex name class">
<span>class <span class="ident">NotOne</span></span>
<span>(</span><span>empty)</span>
</code></dt>
<dd>
<section class="desc"><p>A custom exception raised by <code><a title="refinery.lib.tools.one" href="#refinery.lib.tools.one">one()</a></code> if the input iterator does not yield
exactly one element. The property <code>empty</code> indicates whether the iterator was empty; if it is
false, then the exception was raised because the iterator contained more than one element.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/tools.py#L424-L433" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class NotOne(LookupError):
    &#34;&#34;&#34;
    A custom exception raised by `refinery.lib.tools.one` if the input iterator does not yield
    exactly one element. The property `empty` indicates whether the iterator was empty; if it is
    false, then the exception was raised because the iterator contained more than one element.
    &#34;&#34;&#34;
    def __init__(self, empty: bool):
        how = &#39;none&#39; if empty else &#39;more&#39;
        super().__init__(F&#39;Expected a single item, but the iterator was {how}&#39;)
        self.empty = empty</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.LookupError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.tools.lookahead" href="#refinery.lib.tools.lookahead">lookahead</a></code></li>
<li><code><a title="refinery.lib.tools.get_terminal_size" href="#refinery.lib.tools.get_terminal_size">get_terminal_size</a></code></li>
<li><code><a title="refinery.lib.tools.terminalfit" href="#refinery.lib.tools.terminalfit">terminalfit</a></code></li>
<li><code><a title="refinery.lib.tools.documentation" href="#refinery.lib.tools.documentation">documentation</a></code></li>
<li><code><a title="refinery.lib.tools.begin" href="#refinery.lib.tools.begin">begin</a></code></li>
<li><code><a title="refinery.lib.tools.skipfirst" href="#refinery.lib.tools.skipfirst">skipfirst</a></code></li>
<li><code><a title="refinery.lib.tools.entropy_fallback" href="#refinery.lib.tools.entropy_fallback">entropy_fallback</a></code></li>
<li><code><a title="refinery.lib.tools.entropy" href="#refinery.lib.tools.entropy">entropy</a></code></li>
<li><code><a title="refinery.lib.tools.index_of_coincidence" href="#refinery.lib.tools.index_of_coincidence">index_of_coincidence</a></code></li>
<li><code><a title="refinery.lib.tools.splitchunks" href="#refinery.lib.tools.splitchunks">splitchunks</a></code></li>
<li><code><a title="refinery.lib.tools.infinitize" href="#refinery.lib.tools.infinitize">infinitize</a></code></li>
<li><code><a title="refinery.lib.tools.proxy" href="#refinery.lib.tools.proxy">proxy</a></code></li>
<li><code><a title="refinery.lib.tools.unwrap" href="#refinery.lib.tools.unwrap">unwrap</a></code></li>
<li><code><a title="refinery.lib.tools.one" href="#refinery.lib.tools.one">one</a></code></li>
<li><code><a title="refinery.lib.tools.integers_of_slice" href="#refinery.lib.tools.integers_of_slice">integers_of_slice</a></code></li>
<li><code><a title="refinery.lib.tools.normalize_word_separators" href="#refinery.lib.tools.normalize_word_separators">normalize_word_separators</a></code></li>
<li><code><a title="refinery.lib.tools.normalize_to_display" href="#refinery.lib.tools.normalize_to_display">normalize_to_display</a></code></li>
<li><code><a title="refinery.lib.tools.normalize_to_identifier" href="#refinery.lib.tools.normalize_to_identifier">normalize_to_identifier</a></code></li>
<li><code><a title="refinery.lib.tools.exception_to_string" href="#refinery.lib.tools.exception_to_string">exception_to_string</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.tools.NoLogging" href="#refinery.lib.tools.NoLogging">NoLogging</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.tools.NoLoggingProxy" href="#refinery.lib.tools.NoLoggingProxy">NoLoggingProxy</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.tools.NotOne" href="#refinery.lib.tools.NotOne">NotOne</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
