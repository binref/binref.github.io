<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.tools documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.tools</code></h1>
</header>
<section id="section-intro">
<p>Miscellaneous helper functions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L1-L675" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Miscellaneous helper functions.
&#34;&#34;&#34;
from __future__ import annotations

import datetime
import inspect
import io
import itertools
import logging
import os
import re
import sys
import warnings

from enum import Enum, IntFlag
from math import log
from typing import Any, Callable, Generator, Iterable, TypeVar

from refinery.lib.types import INF, buf

_T = TypeVar(&#39;_T&#39;)


def lookahead(iterator: Iterable[_T]) -&gt; Generator[tuple[bool, _T]]:
    &#34;&#34;&#34;
    Implements a new iterator from a given one which returns elements `(last, item)` where each
    `item` is taken from the original iterator and `last` is a boolean indicating whether this is
    the last item.
    &#34;&#34;&#34;
    last = False
    it = iter(iterator)
    try:
        peek = next(it)
    except StopIteration:
        return
    while not last:
        item = peek
        try:
            peek = next(it)
        except StopIteration:
            last = True
        yield last, item


def get_terminal_size(default=0):
    &#34;&#34;&#34;
    Returns the size of the currently attached terminal. If the environment variable
    `REFINERY_TERM_SIZE` is set to an integer value, it takes prescedence. If the width of the
    terminal cannot be determined or if the width is less than 8 characters, the function
    returns zero.
    &#34;&#34;&#34;
    from refinery.lib.environment import environment
    ev_terminal_size = environment.term_size.value
    if ev_terminal_size and ev_terminal_size &gt; 0:
        return ev_terminal_size
    width = default
    for stream in (sys.stderr, sys.stdout):
        if stream.isatty():
            try:
                width = os.get_terminal_size(stream.fileno()).columns
            except Exception:
                width = default
            else:
                break
    return default if width &lt; 2 else width - 1


def terminalfit(text: str, delta: int = 0, width: int = 0, parsep: str = &#39;\n\n&#39;, **kw) -&gt; str:
    &#34;&#34;&#34;
    Reformats text to fit the given width while not mangling bullet point lists.
    &#34;&#34;&#34;
    import re
    import textwrap

    width = width or get_terminal_size()
    width = width - delta

    def isol(t): return re.match(R&#39;^\(\d+\)|\d+[.:;]&#39;, t)
    def isul(t): return t.startswith(&#39;-&#39;) or t.startswith(&#39;*&#39;)
    def issp(t): return t.startswith(&#39;  &#39;)

    text = text.replace(&#39;\r&#39;, &#39;&#39;)

    def bulletpoint(line):
        wrapped = textwrap.wrap(line, width - 2, **kw)
        indent = &#39;  &#39; if isul(line) else &#39;   &#39;
        wrapped[1:] = [f&#39;{indent}{line}&#39; for line in wrapped[1:]]
        return &#39;\n&#39;.join(wrapped)

    def fitted(paragraphs):
        for k, p in enumerate(paragraphs):
            if p.startswith(&#39; &#39;):
                yield p
                continue
            ol, ul = isol(p), isul(p)
            if ol or ul:
                input_lines = p.splitlines(keepends=False)
                unwrapped_line = input_lines[0].rstrip()
                lines = []
                if (ol and all(isol(t) or issp(t) for t in input_lines) or ul and all(isul(t) or issp(t) for t in input_lines)):
                    for line in input_lines[1:]:
                        if not (ol and isol(line) or ul and isul(line)):
                            unwrapped_line += &#39; &#39; + line.strip()
                            continue
                        lines.append(bulletpoint(unwrapped_line))
                        unwrapped_line = line.rstrip()
                    lines.append(bulletpoint(unwrapped_line))
                    yield &#39;\n&#39;.join(lines)
                    continue
            yield &#39;\n&#39;.join(textwrap.wrap(p, width, **kw))

    return parsep.join(fitted(text.split(&#39;\n\n&#39;)))


def documentation(unit):
    &#34;&#34;&#34;
    Return the documentation string of a given unit as it should be displayed on the command line.
    Certain pdoc3-specific reference strings are removed.
    &#34;&#34;&#34;
    import re
    docs = inspect.getdoc(unit) or &#39;&#39;
    docs = re.sub(R&#39;`refinery\.(?:\w+\.)*(\w+)`&#39;, R&#39;\1&#39;, docs)
    return docs.replace(&#39;`&#39;, &#39;&#39;)


def begin(iterable: Iterable[_T]) -&gt; tuple[_T, Iterable[_T]] | None:
    &#34;&#34;&#34;
    Iterates the first element of an iterator and returns None if this fails. Otherwise, it returns
    both the first element and a new iterable which will return the same elements as the input.
    &#34;&#34;&#34;
    try:
        body = iter(iterable)
        head = next(body)
    except StopIteration:
        return None
    else:
        def _fused():
            yield head
            yield from body
        return head, _fused()


def skipfirst(iterable: Iterable[_T]) -&gt; Generator[_T]:
    &#34;&#34;&#34;
    Returns an interable where the first element of the input iterable was skipped.
    &#34;&#34;&#34;
    it = iter(iterable)
    next(it)
    yield from it


def autoinvoke(method: Callable[..., _T], keywords: dict) -&gt; _T:
    &#34;&#34;&#34;
    For each parameter that `method` expects, this function looks for an entry in `keywords` which
    has the same name as that parameter. `autoinvoke` then calls `method` with all matching
    parameters forwarded in the appropriate manner.
    &#34;&#34;&#34;

    kwdargs = {}
    posargs = []
    varargs = []
    kwdjoin = False

    for p in inspect.signature(method).parameters.values():
        if p.kind is p.VAR_KEYWORD:
            kwdjoin = True
        try:
            value = keywords.pop(p.name)
        except KeyError:
            if p.kind is p.VAR_KEYWORD:
                continue
            value = p.default
            if value is p.empty:
                raise ValueError(F&#39;missing required parameter {p.name}&#39;)
        if p.kind is p.POSITIONAL_OR_KEYWORD or p.kind is p.POSITIONAL_ONLY:
            if value == p.default:
                # when equality holds, we force identity
                value = p.default
            posargs.append(value)
        elif p.kind is p.VAR_POSITIONAL:
            varargs = value
        elif p.kind is p.KEYWORD_ONLY:
            kwdargs[p.name] = value

    if kwdjoin:
        kwdargs.update(keywords)

    return method(*posargs, *varargs, **kwdargs)


def entropy_fallback(data: buf) -&gt; float:
    &#34;&#34;&#34;
    This method is called by `refinery.lib.tools.entropy` when the `numpy` module is not available.
    It computes the shannon entropy of the input byte string and is written in pure Python.
    &#34;&#34;&#34;
    if isinstance(data, memoryview):
        # this copy is better than re-implementing count in Python for memory views
        data = bytes(data)
    histogram = {b: data.count(b) for b in range(0x100)}
    S = [histogram[b] / len(data) for b in histogram]
    return 0.0 + -sum(p * log(p, 2) for p in S if p) / 8.0


def entropy(data: buf) -&gt; float:
    &#34;&#34;&#34;
    Computes the entropy of `data` over the alphabet of all bytes.
    &#34;&#34;&#34;
    if not data:
        return 0.0
    try:
        import numpy
    except ImportError:
        return entropy_fallback(data)
    hist = numpy.unique(memoryview(data), return_counts=True)[1]
    prob = hist / len(data)
    # 8 bits are the maximum number of bits of information in a byte
    return 0.0 - (numpy.log2(prob) * prob).sum() / 8.0


def index_of_coincidence(data: buf) -&gt; float:
    &#34;&#34;&#34;
    Computes the index of coincidence of `data` over the alphabet of all bytes.
    &#34;&#34;&#34;
    if not data:
        return 0.0
    N = len(data)
    if N &lt; 2:
        return 0.0
    try:
        import numpy
    except ImportError:
        C = [0] * 0x100
        for b in data:
            C[b] += 1
    else:
        C = numpy.histogram(
            numpy.frombuffer(data, dtype=numpy.uint8),
            numpy.arange(0x100))[0]
    d = 1 / N / (N - 1)
    return float(sum(x * (x - 1) * d for x in C))


def isstream(obj) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether `obj` is a stream. This is currently done by simply testing whether the object
    has an attribute called `read`.
    &#34;&#34;&#34;
    return hasattr(obj, &#39;read&#39;)


def isbuffer(obj) -&gt; bool:
    &#34;&#34;&#34;
    Test whether `obj` is an object that supports the buffer API, like a bytes or bytearray object.
    &#34;&#34;&#34;
    try:
        with memoryview(obj):
            return True
    except TypeError:
        return False


def asbuffer(obj) -&gt; memoryview | None:
    &#34;&#34;&#34;
    Attempts to acquire a memoryview of the given object. This works for bytes and bytearrays, or
    memoryview objects themselves. The return value is `None` for objects that do not support the
    buffer protocol.
    &#34;&#34;&#34;
    try:
        return memoryview(obj)
    except TypeError:
        return None


def splitchunks(
    data: buf,
    size: int,
    step: int | None = None,
    truncate: bool = False
) -&gt; Iterable[buf]:
    &#34;&#34;&#34;
    Split `data` into chunks of size `size`. The cursor advances by `step` bytes after extracting a
    block, the default value for `step` is equal to `size`. The boolean parameter `truncate`
    specifies whether any chunks of size smaller than `size` are generated or whether to abort as
    soon as the last complete chunk of the given size is extracted.
    &#34;&#34;&#34;
    if step is None:
        step = size
    if len(data) &lt;= size:
        if not truncate or len(data) == size:
            yield data
        return
    for k in range(0, len(data), step):
        chunk = data[k:k + size]
        if not chunk:
            break
        if len(chunk) &lt; size and truncate:
            break
        yield chunk


def make_buffer_mutable(data: buf):
    &#34;&#34;&#34;
    Returns a mutable version of the input data. Already mutable inputs are returned
    as themselves, i.e. no copy operation occurs in these cases.
    &#34;&#34;&#34;
    if isinstance(data, bytearray):
        return data
    if isinstance(data, memoryview) and not data.readonly:
        return data
    return bytearray(data)


def infinitize(it: _T | Iterable[_T]) -&gt; Iterable[_T]:
    if isinstance(it, (
        itertools.cycle,
        itertools.repeat,
        itertools.count,
    )):
        return it
    try:
        it = iter(it)           # type:ignore
    except TypeError:
        it = (it,)              # type:ignore
    return itertools.cycle(it)  # type:ignore


class NoLogging:
    &#34;&#34;&#34;
    A context manager to prevent various unwanted kinds of logging messages to appear.
    The class is initialized with a given mode that encodes the logging channels to be
    suppressed. After the context is exited, the original logging behavior is restored.
    &#34;&#34;&#34;

    class Mode(IntFlag):
        &#34;&#34;&#34;
        A set of flags for different logging mechanisms to be suppressed.
        &#34;&#34;&#34;
        STD_OUT = 0b0001
        &#34;&#34;&#34;Silence the standard output channel.&#34;&#34;&#34;
        STD_ERR = 0b0010
        &#34;&#34;&#34;Silence the standard error channel.&#34;&#34;&#34;
        WARNING = 0b0100
        &#34;&#34;&#34;Silence the Python warning module.&#34;&#34;&#34;
        LOGGING = 0b1000
        &#34;&#34;&#34;Silence the Python logging module.&#34;&#34;&#34;
        ALL     = 0b1111 # noqa
        &#34;&#34;&#34;Silence all known logging mechanisms.&#34;&#34;&#34;

    def __init__(self, mode: Mode = Mode.WARNING | Mode.LOGGING):
        self.mode = mode

    def __enter__(self):
        if self.mode &amp; NoLogging.Mode.LOGGING:
            logging.disable(logging.CRITICAL)
        if self.mode &amp; NoLogging.Mode.WARNING:
            self._warning_filters = list(warnings.filters)
            warnings.filterwarnings(&#39;ignore&#39;)
        if self.mode &amp; NoLogging.Mode.STD_ERR:
            self._stderr = sys.stderr
            sys.stderr = io.TextIOWrapper(open(os.devnull, &#39;wb&#39;), encoding=&#39;latin1&#39;)
        if self.mode &amp; NoLogging.Mode.STD_OUT:
            self._stdout = sys.stdout
            sys.stdout = io.TextIOWrapper(open(os.devnull, &#39;wb&#39;), encoding=&#39;latin1&#39;)
        return self

    def __exit__(self, *_):
        if self.mode &amp; NoLogging.Mode.LOGGING:
            logging.disable(logging.NOTSET)
        if self.mode &amp; NoLogging.Mode.WARNING:
            warnings.resetwarnings()
            assert isinstance(warnings.filters, list)
            warnings.filters[:] = self._warning_filters
        if self.mode &amp; NoLogging.Mode.STD_ERR:
            sys.stderr.close()
            sys.stderr = self._stderr
        if self.mode &amp; NoLogging.Mode.STD_OUT:
            sys.stdout.close()
            sys.stdout = self._stdout


class NoLoggingProxy:
    &#34;&#34;&#34;
    This class can be used to wrap any object. It acts as a proxy for this object, passing though
    and attribute access, operator use, and method calls to its base. However, any such action
    is wrapped in a `refinery.lib.tools.NoLogging` context to ensure that it procudes no logging
    output. Notably, any returned values that are not considered primitive are wrapped as a proxy
    as well. The main downside of this is that instance checks no longer work as expected.
    &#34;&#34;&#34;

    __slots__ = (
        &#39;__wrapped__&#39;,
        &#39;__nl_mode__&#39;,
    )

    __proxy_cache__ = {}

    def __new__(cls, wrap, mode: NoLogging.Mode = NoLogging.Mode.ALL):
        wrap_type = type(wrap)
        if isinstance(wrap, (int, float, str, bytes, bytearray, memoryview, Enum)):
            return wrap
        if (proxy_class := cls.__proxy_cache__.get(wrap_type)) is None:
            dunder_names = [
                name for name in dir(wrap_type) if name.startswith(&#39;__&#39;) and name.endswith(&#39;__&#39;)]
            proxied_dunder_methods = {}
            for name in dunder_names:
                if name == &#39;__new__&#39;:
                    continue
                class_method = getattr(wrap_type, name)
                if class_method and class_method is getattr(wrap, name):
                    def proxied_method(
                        _, *args,
                        _proxy___call=class_method,
                        _proxy___wrap=wrap,
                        _proxy___mode=mode,
                        **kwargs
                    ):
                        with NoLogging(_proxy___mode):
                            result = _proxy___call(_proxy___wrap, *args, **kwargs)
                        return NoLoggingProxy(result, _proxy___mode)
                    if not callable(class_method):
                        continue
                    proxied_dunder_methods[name] = proxied_method
            if proxied_dunder_methods:
                proxy_class = type(
                    F&#39;_proxy_{wrap_type.__name__}&#39;, (NoLoggingProxy,), proxied_dunder_methods)
            else:
                proxy_class = cls
            cls.__proxy_cache__[wrap_type] = proxy_class
        return super().__new__(proxy_class) # type:ignore

    def __init__(self, wrap, mode: NoLogging.Mode = NoLogging.Mode.ALL):
        self.__wrapped__ = wrap
        self.__nl_mode__ = mode

    def __setattr__(self, name, value):
        if name in NoLoggingProxy.__slots__:
            return super().__setattr__(name, value)
        mode = self.__nl_mode__
        wrap = self.__wrapped__
        with NoLogging(mode):
            setattr(wrap, name, value)

    def __repr__(self):
        with NoLogging(self.__nl_mode__):
            return repr(self.__wrapped__)

    def __getattribute__(self, name):
        wrap = super().__getattribute__(&#39;__wrapped__&#39;)
        mode = super().__getattribute__(&#39;__nl_mode__&#39;)
        if name == &#39;__wrapped__&#39;:
            return wrap
        if name == &#39;__nl_mode__&#39;:
            return mode
        with NoLogging(mode):
            attr = getattr(wrap, name)
        return NoLoggingProxy(attr, mode)

    def __getitem__(self, k):
        mode = self.__nl_mode__
        with NoLogging(mode):
            item = self.__wrapped__[k]
        return NoLoggingProxy(item, mode)

    def __iter__(self):
        mode = self.__nl_mode__
        with NoLogging(mode):
            it = iter(self.__wrapped__)
        while True:
            try:
                with NoLogging(mode):
                    item = next(it)
            except StopIteration:
                return
            else:
                yield NoLoggingProxy(item, mode)

    def __call__(self, *args, **kwargs):
        mode = self.__nl_mode__
        with NoLogging(mode):
            rv = self.__wrapped__(*args, **kwargs)
        return NoLoggingProxy(rv, mode)


def unwrap(t: _T) -&gt; _T:
    &#34;&#34;&#34;
    Unwrap an object that is potentially wrapped, say, as a `refinery.lib.tools.NoLoggingProxy`.
    &#34;&#34;&#34;
    return getattr(t, &#39;__wrapped__&#39;, t)


class NotOne(LookupError):
    &#34;&#34;&#34;
    A custom exception raised by `refinery.lib.tools.one` if the input iterator does not yield
    exactly one element. The property `empty` indicates whether the iterator was empty; if it is
    false, then the exception was raised because the iterator contained more than one element.
    &#34;&#34;&#34;
    def __init__(self, empty: bool):
        how = &#39;none&#39; if empty else &#39;more&#39;
        super().__init__(F&#39;Expected a single item, but the iterator was {how}&#39;)
        self.empty = empty


def one(iterable: Iterable[_T]) -&gt; _T:
    &#34;&#34;&#34;
    The function expects the input `iterable` to be an iterable that yields exactly one element
    and returns that element. Raises `refinery.lib.tools.NotOne` for invalid inputs.
    &#34;&#34;&#34;
    it = iter(iterable)
    try:
        top = next(it)
    except StopIteration:
        raise NotOne(True)
    try:
        next(it)
    except StopIteration:
        return top
    else:
        raise NotOne(False)


def isodate(iso: str) -&gt; datetime.datetime | None:
    &#34;&#34;&#34;
    Convert an input date string in ISO format to a `datetime` object. Contains fallbacks for early
    Python versions.
    &#34;&#34;&#34;
    if len(iso) not in range(16, 25):
        return None
    iso = iso[:19].replace(&#39; &#39;, &#39;T&#39;, 1)
    try:
        try:
            return datetime.datetime.fromisoformat(iso)
        except AttributeError:
            return datetime.datetime.strptime(iso, &#34;%Y-%m-%dT%H:%M:%S&#34;)
    except ValueError:
        return None


def date_from_timestamp(ts: int):
    &#34;&#34;&#34;
    Convert a UTC timestamp to a datetime object.
    &#34;&#34;&#34;
    if sys.version_info &gt;= (3, 12):
        dt = datetime.datetime.fromtimestamp(ts, datetime.UTC)
    else:
        dt = datetime.datetime.utcfromtimestamp(ts)
    return dt.replace(tzinfo=None)


def integers_of_slice(s: slice) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    Returns an iterable that iterates the integers in the range given by the input slice.
    &#34;&#34;&#34;
    if s.stop is None:
        return itertools.count(s.start or 0, s.step or 1)
    else:
        return range(s.start or 0, s.stop, s.step or 1)


def normalize_word_separators(words: str, unified_separator: str, strip: bool = True):
    &#34;&#34;&#34;
    For a sequence of words separated by whitespace, punctuation, slashes, dashes or underscores,
    normalize all occurrences of one or more of these separators to one given symbol. Leading and
    trailing occurrences of separators are removed.
    &#34;&#34;&#34;
    normalized = re.sub(&#39;[-\\s_.,;:/\\\\]+&#39;, unified_separator, words)
    if strip:
        normalized = normalized.strip(unified_separator)
    return normalized


def normalize_to_display(words: str, strip: bool = True):
    &#34;&#34;&#34;
    Normalizes all separators to dashes.
    &#34;&#34;&#34;
    return normalize_word_separators(words, &#39;-&#39;, strip)


def normalize_to_identifier(words: str, strip: bool = True):
    &#34;&#34;&#34;
    Normalizes all separators to underscores.
    &#34;&#34;&#34;
    return normalize_word_separators(words, &#39;_&#39;, strip)


def typename(thing):
    &#34;&#34;&#34;
    Determines the name of the type of an object.
    &#34;&#34;&#34;
    if not isinstance(thing, type):
        thing = type(thing)
    mro = [c for c in thing.__mro__ if c is not object]
    if mro:
        thing = mro[~0]
    try:
        return thing.__name__
    except AttributeError:
        return repr(thing)


def exception_to_string(exception: BaseException, default=None) -&gt; str:
    &#34;&#34;&#34;
    Attempts to convert a given exception to a good description that can be exposed to the user.
    &#34;&#34;&#34;
    if not exception.args:
        return exception.__class__.__name__
    it = (a for a in exception.args if isinstance(a, str))
    if default is None:
        default = str(exception)
    return max(it, key=len, default=default).strip()


def nopdoc(obj: object):
    &#34;&#34;&#34;
    This decorator can be applied to any object to exclude it from the automatically generated
    documentation.
    &#34;&#34;&#34;
    pdoc: dict = sys.modules[obj.__module__].__dict__.setdefault(&#39;__pdoc__&#39;, {})
    pdoc[obj.__qualname__] = False
    return obj


def convert(x: _T | Any, t: type[_T]) -&gt; _T:
    &#34;&#34;&#34;
    Convert the given object `x` to the type `t`.
    &#34;&#34;&#34;
    return x if isinstance(x, t) else t(x) # type:ignore


class BoundsType:
    &#34;&#34;&#34;
    Can be used to specify certain upper and lower bounds. For example, the following is `True`:

        5 in bounds[3:5]

    This is notably different from how a `range` object functions since the upper bound is included
    in the valid range, and it is also permitted to be `None` for an unbounded range.
    &#34;&#34;&#34;
    __name__ = &#39;bounds&#39;

    def __getitem__(self, k: slice):
        return BoundsType(k)

    def __init__(self, bounds: slice[int, int | None, int | None]):
        start, stop, step = bounds.start, bounds.stop, bounds.step
        for field in (start, stop, step):
            if field is not None and not isinstance(field, int):
                raise TypeError(field)
        self.min = start or 0
        self.max = stop or INF
        self.inc = step or 1
        if stop and stop &lt; self.min:
            raise ValueError(F&#39;The maximum {self.max} is lesser than the minimum {self.min}.&#39;)
        if self.inc &lt; 0:
            raise ValueError(&#39;Negative step size not supported for range expressions.&#39;)

    def __iter__(self):
        k = self.min
        i = self.inc
        if (m := self.max) is INF:
            yield from itertools.count(k, i)
        else:
            while k &lt;= m:
                yield k
                k += i

    def __contains__(self, value: int):
        if value &lt; self.min:
            return False
        if (m := self.max) and value &gt; m:
            return False
        return (value - self.min) % self.inc == 0


bounds = BoundsType(slice(None, None))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.tools.lookahead"><code class="name flex">
<span>def <span class="ident">lookahead</span></span>(<span>iterator)</span>
</code></dt>
<dd>
<section class="desc"><p>Implements a new iterator from a given one which returns elements <code>(last, item)</code> where each
<code>item</code> is taken from the original iterator and <code>last</code> is a boolean indicating whether this is
the last item.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L25-L43" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def lookahead(iterator: Iterable[_T]) -&gt; Generator[tuple[bool, _T]]:
    &#34;&#34;&#34;
    Implements a new iterator from a given one which returns elements `(last, item)` where each
    `item` is taken from the original iterator and `last` is a boolean indicating whether this is
    the last item.
    &#34;&#34;&#34;
    last = False
    it = iter(iterator)
    try:
        peek = next(it)
    except StopIteration:
        return
    while not last:
        item = peek
        try:
            peek = next(it)
        except StopIteration:
            last = True
        yield last, item</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.get_terminal_size"><code class="name flex">
<span>def <span class="ident">get_terminal_size</span></span>(<span>default=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the size of the currently attached terminal. If the environment variable
<code>REFINERY_TERM_SIZE</code> is set to an integer value, it takes prescedence. If the width of the
terminal cannot be determined or if the width is less than 8 characters, the function
returns zero.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L46-L66" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_terminal_size(default=0):
    &#34;&#34;&#34;
    Returns the size of the currently attached terminal. If the environment variable
    `REFINERY_TERM_SIZE` is set to an integer value, it takes prescedence. If the width of the
    terminal cannot be determined or if the width is less than 8 characters, the function
    returns zero.
    &#34;&#34;&#34;
    from refinery.lib.environment import environment
    ev_terminal_size = environment.term_size.value
    if ev_terminal_size and ev_terminal_size &gt; 0:
        return ev_terminal_size
    width = default
    for stream in (sys.stderr, sys.stdout):
        if stream.isatty():
            try:
                width = os.get_terminal_size(stream.fileno()).columns
            except Exception:
                width = default
            else:
                break
    return default if width &lt; 2 else width - 1</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.terminalfit"><code class="name flex">
<span>def <span class="ident">terminalfit</span></span>(<span>text, delta=0, width=0, parsep='\n\n', **kw)</span>
</code></dt>
<dd>
<section class="desc"><p>Reformats text to fit the given width while not mangling bullet point lists.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L69-L113" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def terminalfit(text: str, delta: int = 0, width: int = 0, parsep: str = &#39;\n\n&#39;, **kw) -&gt; str:
    &#34;&#34;&#34;
    Reformats text to fit the given width while not mangling bullet point lists.
    &#34;&#34;&#34;
    import re
    import textwrap

    width = width or get_terminal_size()
    width = width - delta

    def isol(t): return re.match(R&#39;^\(\d+\)|\d+[.:;]&#39;, t)
    def isul(t): return t.startswith(&#39;-&#39;) or t.startswith(&#39;*&#39;)
    def issp(t): return t.startswith(&#39;  &#39;)

    text = text.replace(&#39;\r&#39;, &#39;&#39;)

    def bulletpoint(line):
        wrapped = textwrap.wrap(line, width - 2, **kw)
        indent = &#39;  &#39; if isul(line) else &#39;   &#39;
        wrapped[1:] = [f&#39;{indent}{line}&#39; for line in wrapped[1:]]
        return &#39;\n&#39;.join(wrapped)

    def fitted(paragraphs):
        for k, p in enumerate(paragraphs):
            if p.startswith(&#39; &#39;):
                yield p
                continue
            ol, ul = isol(p), isul(p)
            if ol or ul:
                input_lines = p.splitlines(keepends=False)
                unwrapped_line = input_lines[0].rstrip()
                lines = []
                if (ol and all(isol(t) or issp(t) for t in input_lines) or ul and all(isul(t) or issp(t) for t in input_lines)):
                    for line in input_lines[1:]:
                        if not (ol and isol(line) or ul and isul(line)):
                            unwrapped_line += &#39; &#39; + line.strip()
                            continue
                        lines.append(bulletpoint(unwrapped_line))
                        unwrapped_line = line.rstrip()
                    lines.append(bulletpoint(unwrapped_line))
                    yield &#39;\n&#39;.join(lines)
                    continue
            yield &#39;\n&#39;.join(textwrap.wrap(p, width, **kw))

    return parsep.join(fitted(text.split(&#39;\n\n&#39;)))</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.documentation"><code class="name flex">
<span>def <span class="ident">documentation</span></span>(<span>unit)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the documentation string of a given unit as it should be displayed on the command line.
Certain pdoc3-specific reference strings are removed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L116-L124" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def documentation(unit):
    &#34;&#34;&#34;
    Return the documentation string of a given unit as it should be displayed on the command line.
    Certain pdoc3-specific reference strings are removed.
    &#34;&#34;&#34;
    import re
    docs = inspect.getdoc(unit) or &#39;&#39;
    docs = re.sub(R&#39;`refinery\.(?:\w+\.)*(\w+)`&#39;, R&#39;\1&#39;, docs)
    return docs.replace(&#39;`&#39;, &#39;&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>iterable)</span>
</code></dt>
<dd>
<section class="desc"><p>Iterates the first element of an iterator and returns None if this fails. Otherwise, it returns
both the first element and a new iterable which will return the same elements as the input.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L127-L141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def begin(iterable: Iterable[_T]) -&gt; tuple[_T, Iterable[_T]] | None:
    &#34;&#34;&#34;
    Iterates the first element of an iterator and returns None if this fails. Otherwise, it returns
    both the first element and a new iterable which will return the same elements as the input.
    &#34;&#34;&#34;
    try:
        body = iter(iterable)
        head = next(body)
    except StopIteration:
        return None
    else:
        def _fused():
            yield head
            yield from body
        return head, _fused()</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.skipfirst"><code class="name flex">
<span>def <span class="ident">skipfirst</span></span>(<span>iterable)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an interable where the first element of the input iterable was skipped.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L144-L150" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def skipfirst(iterable: Iterable[_T]) -&gt; Generator[_T]:
    &#34;&#34;&#34;
    Returns an interable where the first element of the input iterable was skipped.
    &#34;&#34;&#34;
    it = iter(iterable)
    next(it)
    yield from it</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.autoinvoke"><code class="name flex">
<span>def <span class="ident">autoinvoke</span></span>(<span>method, keywords)</span>
</code></dt>
<dd>
<section class="desc"><p>For each parameter that <code>method</code> expects, this function looks for an entry in <code>keywords</code> which
has the same name as that parameter. <code><a title="refinery.lib.tools.autoinvoke" href="#refinery.lib.tools.autoinvoke">autoinvoke()</a></code> then calls <code>method</code> with all matching
parameters forwarded in the appropriate manner.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L153-L189" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def autoinvoke(method: Callable[..., _T], keywords: dict) -&gt; _T:
    &#34;&#34;&#34;
    For each parameter that `method` expects, this function looks for an entry in `keywords` which
    has the same name as that parameter. `autoinvoke` then calls `method` with all matching
    parameters forwarded in the appropriate manner.
    &#34;&#34;&#34;

    kwdargs = {}
    posargs = []
    varargs = []
    kwdjoin = False

    for p in inspect.signature(method).parameters.values():
        if p.kind is p.VAR_KEYWORD:
            kwdjoin = True
        try:
            value = keywords.pop(p.name)
        except KeyError:
            if p.kind is p.VAR_KEYWORD:
                continue
            value = p.default
            if value is p.empty:
                raise ValueError(F&#39;missing required parameter {p.name}&#39;)
        if p.kind is p.POSITIONAL_OR_KEYWORD or p.kind is p.POSITIONAL_ONLY:
            if value == p.default:
                # when equality holds, we force identity
                value = p.default
            posargs.append(value)
        elif p.kind is p.VAR_POSITIONAL:
            varargs = value
        elif p.kind is p.KEYWORD_ONLY:
            kwdargs[p.name] = value

    if kwdjoin:
        kwdargs.update(keywords)

    return method(*posargs, *varargs, **kwdargs)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.entropy_fallback"><code class="name flex">
<span>def <span class="ident">entropy_fallback</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>This method is called by <code><a title="refinery.lib.tools.entropy" href="#refinery.lib.tools.entropy">entropy()</a></code> when the <code>numpy</code> module is not available.
It computes the shannon entropy of the input byte string and is written in pure Python.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L192-L202" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def entropy_fallback(data: buf) -&gt; float:
    &#34;&#34;&#34;
    This method is called by `refinery.lib.tools.entropy` when the `numpy` module is not available.
    It computes the shannon entropy of the input byte string and is written in pure Python.
    &#34;&#34;&#34;
    if isinstance(data, memoryview):
        # this copy is better than re-implementing count in Python for memory views
        data = bytes(data)
    histogram = {b: data.count(b) for b in range(0x100)}
    S = [histogram[b] / len(data) for b in histogram]
    return 0.0 + -sum(p * log(p, 2) for p in S if p) / 8.0</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.entropy"><code class="name flex">
<span>def <span class="ident">entropy</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes the entropy of <code>data</code> over the alphabet of all bytes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L205-L218" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def entropy(data: buf) -&gt; float:
    &#34;&#34;&#34;
    Computes the entropy of `data` over the alphabet of all bytes.
    &#34;&#34;&#34;
    if not data:
        return 0.0
    try:
        import numpy
    except ImportError:
        return entropy_fallback(data)
    hist = numpy.unique(memoryview(data), return_counts=True)[1]
    prob = hist / len(data)
    # 8 bits are the maximum number of bits of information in a byte
    return 0.0 - (numpy.log2(prob) * prob).sum() / 8.0</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.index_of_coincidence"><code class="name flex">
<span>def <span class="ident">index_of_coincidence</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes the index of coincidence of <code>data</code> over the alphabet of all bytes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L221-L241" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def index_of_coincidence(data: buf) -&gt; float:
    &#34;&#34;&#34;
    Computes the index of coincidence of `data` over the alphabet of all bytes.
    &#34;&#34;&#34;
    if not data:
        return 0.0
    N = len(data)
    if N &lt; 2:
        return 0.0
    try:
        import numpy
    except ImportError:
        C = [0] * 0x100
        for b in data:
            C[b] += 1
    else:
        C = numpy.histogram(
            numpy.frombuffer(data, dtype=numpy.uint8),
            numpy.arange(0x100))[0]
    d = 1 / N / (N - 1)
    return float(sum(x * (x - 1) * d for x in C))</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.isstream"><code class="name flex">
<span>def <span class="ident">isstream</span></span>(<span>obj)</span>
</code></dt>
<dd>
<section class="desc"><p>Tests whether <code>obj</code> is a stream. This is currently done by simply testing whether the object
has an attribute called <code>read</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L244-L249" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isstream(obj) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether `obj` is a stream. This is currently done by simply testing whether the object
    has an attribute called `read`.
    &#34;&#34;&#34;
    return hasattr(obj, &#39;read&#39;)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.isbuffer"><code class="name flex">
<span>def <span class="ident">isbuffer</span></span>(<span>obj)</span>
</code></dt>
<dd>
<section class="desc"><p>Test whether <code>obj</code> is an object that supports the buffer API, like a bytes or bytearray object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L252-L260" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isbuffer(obj) -&gt; bool:
    &#34;&#34;&#34;
    Test whether `obj` is an object that supports the buffer API, like a bytes or bytearray object.
    &#34;&#34;&#34;
    try:
        with memoryview(obj):
            return True
    except TypeError:
        return False</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.asbuffer"><code class="name flex">
<span>def <span class="ident">asbuffer</span></span>(<span>obj)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempts to acquire a memoryview of the given object. This works for bytes and bytearrays, or
memoryview objects themselves. The return value is <code>None</code> for objects that do not support the
buffer protocol.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L263-L272" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def asbuffer(obj) -&gt; memoryview | None:
    &#34;&#34;&#34;
    Attempts to acquire a memoryview of the given object. This works for bytes and bytearrays, or
    memoryview objects themselves. The return value is `None` for objects that do not support the
    buffer protocol.
    &#34;&#34;&#34;
    try:
        return memoryview(obj)
    except TypeError:
        return None</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.splitchunks"><code class="name flex">
<span>def <span class="ident">splitchunks</span></span>(<span>data, size, step=None, truncate=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Split <code>data</code> into chunks of size <code>size</code>. The cursor advances by <code>step</code> bytes after extracting a
block, the default value for <code>step</code> is equal to <code>size</code>. The boolean parameter <code>truncate</code>
specifies whether any chunks of size smaller than <code>size</code> are generated or whether to abort as
soon as the last complete chunk of the given size is extracted.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L275-L299" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def splitchunks(
    data: buf,
    size: int,
    step: int | None = None,
    truncate: bool = False
) -&gt; Iterable[buf]:
    &#34;&#34;&#34;
    Split `data` into chunks of size `size`. The cursor advances by `step` bytes after extracting a
    block, the default value for `step` is equal to `size`. The boolean parameter `truncate`
    specifies whether any chunks of size smaller than `size` are generated or whether to abort as
    soon as the last complete chunk of the given size is extracted.
    &#34;&#34;&#34;
    if step is None:
        step = size
    if len(data) &lt;= size:
        if not truncate or len(data) == size:
            yield data
        return
    for k in range(0, len(data), step):
        chunk = data[k:k + size]
        if not chunk:
            break
        if len(chunk) &lt; size and truncate:
            break
        yield chunk</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.make_buffer_mutable"><code class="name flex">
<span>def <span class="ident">make_buffer_mutable</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a mutable version of the input data. Already mutable inputs are returned
as themselves, i.e. no copy operation occurs in these cases.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L302-L311" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def make_buffer_mutable(data: buf):
    &#34;&#34;&#34;
    Returns a mutable version of the input data. Already mutable inputs are returned
    as themselves, i.e. no copy operation occurs in these cases.
    &#34;&#34;&#34;
    if isinstance(data, bytearray):
        return data
    if isinstance(data, memoryview) and not data.readonly:
        return data
    return bytearray(data)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.infinitize"><code class="name flex">
<span>def <span class="ident">infinitize</span></span>(<span>it)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L314-L325" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def infinitize(it: _T | Iterable[_T]) -&gt; Iterable[_T]:
    if isinstance(it, (
        itertools.cycle,
        itertools.repeat,
        itertools.count,
    )):
        return it
    try:
        it = iter(it)           # type:ignore
    except TypeError:
        it = (it,)              # type:ignore
    return itertools.cycle(it)  # type:ignore</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.unwrap"><code class="name flex">
<span>def <span class="ident">unwrap</span></span>(<span>t)</span>
</code></dt>
<dd>
<section class="desc"><p>Unwrap an object that is potentially wrapped, say, as a <code><a title="refinery.lib.tools.NoLoggingProxy" href="#refinery.lib.tools.NoLoggingProxy">NoLoggingProxy</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L485-L489" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unwrap(t: _T) -&gt; _T:
    &#34;&#34;&#34;
    Unwrap an object that is potentially wrapped, say, as a `refinery.lib.tools.NoLoggingProxy`.
    &#34;&#34;&#34;
    return getattr(t, &#39;__wrapped__&#39;, t)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.one"><code class="name flex">
<span>def <span class="ident">one</span></span>(<span>iterable)</span>
</code></dt>
<dd>
<section class="desc"><p>The function expects the input <code>iterable</code> to be an iterable that yields exactly one element
and returns that element. Raises <code><a title="refinery.lib.tools.NotOne" href="#refinery.lib.tools.NotOne">NotOne</a></code> for invalid inputs.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L504-L519" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def one(iterable: Iterable[_T]) -&gt; _T:
    &#34;&#34;&#34;
    The function expects the input `iterable` to be an iterable that yields exactly one element
    and returns that element. Raises `refinery.lib.tools.NotOne` for invalid inputs.
    &#34;&#34;&#34;
    it = iter(iterable)
    try:
        top = next(it)
    except StopIteration:
        raise NotOne(True)
    try:
        next(it)
    except StopIteration:
        return top
    else:
        raise NotOne(False)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.isodate"><code class="name flex">
<span>def <span class="ident">isodate</span></span>(<span>iso)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert an input date string in ISO format to a <code>datetime</code> object. Contains fallbacks for early
Python versions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L522-L536" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isodate(iso: str) -&gt; datetime.datetime | None:
    &#34;&#34;&#34;
    Convert an input date string in ISO format to a `datetime` object. Contains fallbacks for early
    Python versions.
    &#34;&#34;&#34;
    if len(iso) not in range(16, 25):
        return None
    iso = iso[:19].replace(&#39; &#39;, &#39;T&#39;, 1)
    try:
        try:
            return datetime.datetime.fromisoformat(iso)
        except AttributeError:
            return datetime.datetime.strptime(iso, &#34;%Y-%m-%dT%H:%M:%S&#34;)
    except ValueError:
        return None</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.date_from_timestamp"><code class="name flex">
<span>def <span class="ident">date_from_timestamp</span></span>(<span>ts)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert a UTC timestamp to a datetime object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L539-L547" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def date_from_timestamp(ts: int):
    &#34;&#34;&#34;
    Convert a UTC timestamp to a datetime object.
    &#34;&#34;&#34;
    if sys.version_info &gt;= (3, 12):
        dt = datetime.datetime.fromtimestamp(ts, datetime.UTC)
    else:
        dt = datetime.datetime.utcfromtimestamp(ts)
    return dt.replace(tzinfo=None)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.integers_of_slice"><code class="name flex">
<span>def <span class="ident">integers_of_slice</span></span>(<span>s)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an iterable that iterates the integers in the range given by the input slice.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L550-L557" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def integers_of_slice(s: slice) -&gt; Iterable[int]:
    &#34;&#34;&#34;
    Returns an iterable that iterates the integers in the range given by the input slice.
    &#34;&#34;&#34;
    if s.stop is None:
        return itertools.count(s.start or 0, s.step or 1)
    else:
        return range(s.start or 0, s.stop, s.step or 1)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.normalize_word_separators"><code class="name flex">
<span>def <span class="ident">normalize_word_separators</span></span>(<span>words, unified_separator, strip=True)</span>
</code></dt>
<dd>
<section class="desc"><p>For a sequence of words separated by whitespace, punctuation, slashes, dashes or underscores,
normalize all occurrences of one or more of these separators to one given symbol. Leading and
trailing occurrences of separators are removed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L560-L569" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize_word_separators(words: str, unified_separator: str, strip: bool = True):
    &#34;&#34;&#34;
    For a sequence of words separated by whitespace, punctuation, slashes, dashes or underscores,
    normalize all occurrences of one or more of these separators to one given symbol. Leading and
    trailing occurrences of separators are removed.
    &#34;&#34;&#34;
    normalized = re.sub(&#39;[-\\s_.,;:/\\\\]+&#39;, unified_separator, words)
    if strip:
        normalized = normalized.strip(unified_separator)
    return normalized</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.normalize_to_display"><code class="name flex">
<span>def <span class="ident">normalize_to_display</span></span>(<span>words, strip=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Normalizes all separators to dashes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L572-L576" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize_to_display(words: str, strip: bool = True):
    &#34;&#34;&#34;
    Normalizes all separators to dashes.
    &#34;&#34;&#34;
    return normalize_word_separators(words, &#39;-&#39;, strip)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.normalize_to_identifier"><code class="name flex">
<span>def <span class="ident">normalize_to_identifier</span></span>(<span>words, strip=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Normalizes all separators to underscores.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L579-L583" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize_to_identifier(words: str, strip: bool = True):
    &#34;&#34;&#34;
    Normalizes all separators to underscores.
    &#34;&#34;&#34;
    return normalize_word_separators(words, &#39;_&#39;, strip)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.typename"><code class="name flex">
<span>def <span class="ident">typename</span></span>(<span>thing)</span>
</code></dt>
<dd>
<section class="desc"><p>Determines the name of the type of an object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L586-L598" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def typename(thing):
    &#34;&#34;&#34;
    Determines the name of the type of an object.
    &#34;&#34;&#34;
    if not isinstance(thing, type):
        thing = type(thing)
    mro = [c for c in thing.__mro__ if c is not object]
    if mro:
        thing = mro[~0]
    try:
        return thing.__name__
    except AttributeError:
        return repr(thing)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.exception_to_string"><code class="name flex">
<span>def <span class="ident">exception_to_string</span></span>(<span>exception, default=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempts to convert a given exception to a good description that can be exposed to the user.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L601-L610" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def exception_to_string(exception: BaseException, default=None) -&gt; str:
    &#34;&#34;&#34;
    Attempts to convert a given exception to a good description that can be exposed to the user.
    &#34;&#34;&#34;
    if not exception.args:
        return exception.__class__.__name__
    it = (a for a in exception.args if isinstance(a, str))
    if default is None:
        default = str(exception)
    return max(it, key=len, default=default).strip()</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.nopdoc"><code class="name flex">
<span>def <span class="ident">nopdoc</span></span>(<span>obj)</span>
</code></dt>
<dd>
<section class="desc"><p>This decorator can be applied to any object to exclude it from the automatically generated
documentation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L613-L620" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nopdoc(obj: object):
    &#34;&#34;&#34;
    This decorator can be applied to any object to exclude it from the automatically generated
    documentation.
    &#34;&#34;&#34;
    pdoc: dict = sys.modules[obj.__module__].__dict__.setdefault(&#39;__pdoc__&#39;, {})
    pdoc[obj.__qualname__] = False
    return obj</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>x, t)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert the given object <code>x</code> to the type <code>t</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L623-L627" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def convert(x: _T | Any, t: type[_T]) -&gt; _T:
    &#34;&#34;&#34;
    Convert the given object `x` to the type `t`.
    &#34;&#34;&#34;
    return x if isinstance(x, t) else t(x) # type:ignore</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.tools.NoLogging"><code class="flex name class">
<span>class <span class="ident">NoLogging</span></span>
<span>(</span><span>mode=12)</span>
</code></dt>
<dd>
<section class="desc"><p>A context manager to prevent various unwanted kinds of logging messages to appear.
The class is initialized with a given mode that encodes the logging channels to be
suppressed. After the context is exited, the original logging behavior is restored.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L328-L379" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class NoLogging:
    &#34;&#34;&#34;
    A context manager to prevent various unwanted kinds of logging messages to appear.
    The class is initialized with a given mode that encodes the logging channels to be
    suppressed. After the context is exited, the original logging behavior is restored.
    &#34;&#34;&#34;

    class Mode(IntFlag):
        &#34;&#34;&#34;
        A set of flags for different logging mechanisms to be suppressed.
        &#34;&#34;&#34;
        STD_OUT = 0b0001
        &#34;&#34;&#34;Silence the standard output channel.&#34;&#34;&#34;
        STD_ERR = 0b0010
        &#34;&#34;&#34;Silence the standard error channel.&#34;&#34;&#34;
        WARNING = 0b0100
        &#34;&#34;&#34;Silence the Python warning module.&#34;&#34;&#34;
        LOGGING = 0b1000
        &#34;&#34;&#34;Silence the Python logging module.&#34;&#34;&#34;
        ALL     = 0b1111 # noqa
        &#34;&#34;&#34;Silence all known logging mechanisms.&#34;&#34;&#34;

    def __init__(self, mode: Mode = Mode.WARNING | Mode.LOGGING):
        self.mode = mode

    def __enter__(self):
        if self.mode &amp; NoLogging.Mode.LOGGING:
            logging.disable(logging.CRITICAL)
        if self.mode &amp; NoLogging.Mode.WARNING:
            self._warning_filters = list(warnings.filters)
            warnings.filterwarnings(&#39;ignore&#39;)
        if self.mode &amp; NoLogging.Mode.STD_ERR:
            self._stderr = sys.stderr
            sys.stderr = io.TextIOWrapper(open(os.devnull, &#39;wb&#39;), encoding=&#39;latin1&#39;)
        if self.mode &amp; NoLogging.Mode.STD_OUT:
            self._stdout = sys.stdout
            sys.stdout = io.TextIOWrapper(open(os.devnull, &#39;wb&#39;), encoding=&#39;latin1&#39;)
        return self

    def __exit__(self, *_):
        if self.mode &amp; NoLogging.Mode.LOGGING:
            logging.disable(logging.NOTSET)
        if self.mode &amp; NoLogging.Mode.WARNING:
            warnings.resetwarnings()
            assert isinstance(warnings.filters, list)
            warnings.filters[:] = self._warning_filters
        if self.mode &amp; NoLogging.Mode.STD_ERR:
            sys.stderr.close()
            sys.stderr = self._stderr
        if self.mode &amp; NoLogging.Mode.STD_OUT:
            sys.stdout.close()
            sys.stdout = self._stdout</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.tools.NoLogging.Mode"><code class="name">var <span class="ident">Mode</span></code></dt>
<dd>
<section class="desc"><p>A set of flags for different logging mechanisms to be suppressed.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.tools.NoLoggingProxy"><code class="flex name class">
<span>class <span class="ident">NoLoggingProxy</span></span>
<span>(</span><span>wrap, mode=15)</span>
</code></dt>
<dd>
<section class="desc"><p>This class can be used to wrap any object. It acts as a proxy for this object, passing though
and attribute access, operator use, and method calls to its base. However, any such action
is wrapped in a <code><a title="refinery.lib.tools.NoLogging" href="#refinery.lib.tools.NoLogging">NoLogging</a></code> context to ensure that it procudes no logging
output. Notably, any returned values that are not considered primitive are wrapped as a proxy
as well. The main downside of this is that instance checks no longer work as expected.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L382-L482" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class NoLoggingProxy:
    &#34;&#34;&#34;
    This class can be used to wrap any object. It acts as a proxy for this object, passing though
    and attribute access, operator use, and method calls to its base. However, any such action
    is wrapped in a `refinery.lib.tools.NoLogging` context to ensure that it procudes no logging
    output. Notably, any returned values that are not considered primitive are wrapped as a proxy
    as well. The main downside of this is that instance checks no longer work as expected.
    &#34;&#34;&#34;

    __slots__ = (
        &#39;__wrapped__&#39;,
        &#39;__nl_mode__&#39;,
    )

    __proxy_cache__ = {}

    def __new__(cls, wrap, mode: NoLogging.Mode = NoLogging.Mode.ALL):
        wrap_type = type(wrap)
        if isinstance(wrap, (int, float, str, bytes, bytearray, memoryview, Enum)):
            return wrap
        if (proxy_class := cls.__proxy_cache__.get(wrap_type)) is None:
            dunder_names = [
                name for name in dir(wrap_type) if name.startswith(&#39;__&#39;) and name.endswith(&#39;__&#39;)]
            proxied_dunder_methods = {}
            for name in dunder_names:
                if name == &#39;__new__&#39;:
                    continue
                class_method = getattr(wrap_type, name)
                if class_method and class_method is getattr(wrap, name):
                    def proxied_method(
                        _, *args,
                        _proxy___call=class_method,
                        _proxy___wrap=wrap,
                        _proxy___mode=mode,
                        **kwargs
                    ):
                        with NoLogging(_proxy___mode):
                            result = _proxy___call(_proxy___wrap, *args, **kwargs)
                        return NoLoggingProxy(result, _proxy___mode)
                    if not callable(class_method):
                        continue
                    proxied_dunder_methods[name] = proxied_method
            if proxied_dunder_methods:
                proxy_class = type(
                    F&#39;_proxy_{wrap_type.__name__}&#39;, (NoLoggingProxy,), proxied_dunder_methods)
            else:
                proxy_class = cls
            cls.__proxy_cache__[wrap_type] = proxy_class
        return super().__new__(proxy_class) # type:ignore

    def __init__(self, wrap, mode: NoLogging.Mode = NoLogging.Mode.ALL):
        self.__wrapped__ = wrap
        self.__nl_mode__ = mode

    def __setattr__(self, name, value):
        if name in NoLoggingProxy.__slots__:
            return super().__setattr__(name, value)
        mode = self.__nl_mode__
        wrap = self.__wrapped__
        with NoLogging(mode):
            setattr(wrap, name, value)

    def __repr__(self):
        with NoLogging(self.__nl_mode__):
            return repr(self.__wrapped__)

    def __getattribute__(self, name):
        wrap = super().__getattribute__(&#39;__wrapped__&#39;)
        mode = super().__getattribute__(&#39;__nl_mode__&#39;)
        if name == &#39;__wrapped__&#39;:
            return wrap
        if name == &#39;__nl_mode__&#39;:
            return mode
        with NoLogging(mode):
            attr = getattr(wrap, name)
        return NoLoggingProxy(attr, mode)

    def __getitem__(self, k):
        mode = self.__nl_mode__
        with NoLogging(mode):
            item = self.__wrapped__[k]
        return NoLoggingProxy(item, mode)

    def __iter__(self):
        mode = self.__nl_mode__
        with NoLogging(mode):
            it = iter(self.__wrapped__)
        while True:
            try:
                with NoLogging(mode):
                    item = next(it)
            except StopIteration:
                return
            else:
                yield NoLoggingProxy(item, mode)

    def __call__(self, *args, **kwargs):
        mode = self.__nl_mode__
        with NoLogging(mode):
            rv = self.__wrapped__(*args, **kwargs)
        return NoLoggingProxy(rv, mode)</code></pre>
</details>
</dd>
<dt id="refinery.lib.tools.NotOne"><code class="flex name class">
<span>class <span class="ident">NotOne</span></span>
<span>(</span><span>empty)</span>
</code></dt>
<dd>
<section class="desc"><p>A custom exception raised by <code><a title="refinery.lib.tools.one" href="#refinery.lib.tools.one">one()</a></code> if the input iterator does not yield
exactly one element. The property <code>empty</code> indicates whether the iterator was empty; if it is
false, then the exception was raised because the iterator contained more than one element.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L492-L501" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class NotOne(LookupError):
    &#34;&#34;&#34;
    A custom exception raised by `refinery.lib.tools.one` if the input iterator does not yield
    exactly one element. The property `empty` indicates whether the iterator was empty; if it is
    false, then the exception was raised because the iterator contained more than one element.
    &#34;&#34;&#34;
    def __init__(self, empty: bool):
        how = &#39;none&#39; if empty else &#39;more&#39;
        super().__init__(F&#39;Expected a single item, but the iterator was {how}&#39;)
        self.empty = empty</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.LookupError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="refinery.lib.tools.BoundsType"><code class="flex name class">
<span>class <span class="ident">BoundsType</span></span>
<span>(</span><span>bounds)</span>
</code></dt>
<dd>
<section class="desc"><p>Can be used to specify certain upper and lower bounds. For example, the following is <code>True</code>:</p>
<pre><code>5 in bounds[3:5]
</code></pre>
<p>This is notably different from how a <code>range</code> object functions since the upper bound is included
in the valid range, and it is also permitted to be <code>None</code> for an unbounded range.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/2c887cef6f2560025a1ac871b535f0d84fa3f321/refinery/lib/tools.py#L630-L672" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BoundsType:
    &#34;&#34;&#34;
    Can be used to specify certain upper and lower bounds. For example, the following is `True`:

        5 in bounds[3:5]

    This is notably different from how a `range` object functions since the upper bound is included
    in the valid range, and it is also permitted to be `None` for an unbounded range.
    &#34;&#34;&#34;
    __name__ = &#39;bounds&#39;

    def __getitem__(self, k: slice):
        return BoundsType(k)

    def __init__(self, bounds: slice[int, int | None, int | None]):
        start, stop, step = bounds.start, bounds.stop, bounds.step
        for field in (start, stop, step):
            if field is not None and not isinstance(field, int):
                raise TypeError(field)
        self.min = start or 0
        self.max = stop or INF
        self.inc = step or 1
        if stop and stop &lt; self.min:
            raise ValueError(F&#39;The maximum {self.max} is lesser than the minimum {self.min}.&#39;)
        if self.inc &lt; 0:
            raise ValueError(&#39;Negative step size not supported for range expressions.&#39;)

    def __iter__(self):
        k = self.min
        i = self.inc
        if (m := self.max) is INF:
            yield from itertools.count(k, i)
        else:
            while k &lt;= m:
                yield k
                k += i

    def __contains__(self, value: int):
        if value &lt; self.min:
            return False
        if (m := self.max) and value &gt; m:
            return False
        return (value - self.min) % self.inc == 0</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib" href="index.html">refinery.lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.tools.lookahead" href="#refinery.lib.tools.lookahead">lookahead</a></code></li>
<li><code><a title="refinery.lib.tools.get_terminal_size" href="#refinery.lib.tools.get_terminal_size">get_terminal_size</a></code></li>
<li><code><a title="refinery.lib.tools.terminalfit" href="#refinery.lib.tools.terminalfit">terminalfit</a></code></li>
<li><code><a title="refinery.lib.tools.documentation" href="#refinery.lib.tools.documentation">documentation</a></code></li>
<li><code><a title="refinery.lib.tools.begin" href="#refinery.lib.tools.begin">begin</a></code></li>
<li><code><a title="refinery.lib.tools.skipfirst" href="#refinery.lib.tools.skipfirst">skipfirst</a></code></li>
<li><code><a title="refinery.lib.tools.autoinvoke" href="#refinery.lib.tools.autoinvoke">autoinvoke</a></code></li>
<li><code><a title="refinery.lib.tools.entropy_fallback" href="#refinery.lib.tools.entropy_fallback">entropy_fallback</a></code></li>
<li><code><a title="refinery.lib.tools.entropy" href="#refinery.lib.tools.entropy">entropy</a></code></li>
<li><code><a title="refinery.lib.tools.index_of_coincidence" href="#refinery.lib.tools.index_of_coincidence">index_of_coincidence</a></code></li>
<li><code><a title="refinery.lib.tools.isstream" href="#refinery.lib.tools.isstream">isstream</a></code></li>
<li><code><a title="refinery.lib.tools.isbuffer" href="#refinery.lib.tools.isbuffer">isbuffer</a></code></li>
<li><code><a title="refinery.lib.tools.asbuffer" href="#refinery.lib.tools.asbuffer">asbuffer</a></code></li>
<li><code><a title="refinery.lib.tools.splitchunks" href="#refinery.lib.tools.splitchunks">splitchunks</a></code></li>
<li><code><a title="refinery.lib.tools.make_buffer_mutable" href="#refinery.lib.tools.make_buffer_mutable">make_buffer_mutable</a></code></li>
<li><code><a title="refinery.lib.tools.infinitize" href="#refinery.lib.tools.infinitize">infinitize</a></code></li>
<li><code><a title="refinery.lib.tools.unwrap" href="#refinery.lib.tools.unwrap">unwrap</a></code></li>
<li><code><a title="refinery.lib.tools.one" href="#refinery.lib.tools.one">one</a></code></li>
<li><code><a title="refinery.lib.tools.isodate" href="#refinery.lib.tools.isodate">isodate</a></code></li>
<li><code><a title="refinery.lib.tools.date_from_timestamp" href="#refinery.lib.tools.date_from_timestamp">date_from_timestamp</a></code></li>
<li><code><a title="refinery.lib.tools.integers_of_slice" href="#refinery.lib.tools.integers_of_slice">integers_of_slice</a></code></li>
<li><code><a title="refinery.lib.tools.normalize_word_separators" href="#refinery.lib.tools.normalize_word_separators">normalize_word_separators</a></code></li>
<li><code><a title="refinery.lib.tools.normalize_to_display" href="#refinery.lib.tools.normalize_to_display">normalize_to_display</a></code></li>
<li><code><a title="refinery.lib.tools.normalize_to_identifier" href="#refinery.lib.tools.normalize_to_identifier">normalize_to_identifier</a></code></li>
<li><code><a title="refinery.lib.tools.typename" href="#refinery.lib.tools.typename">typename</a></code></li>
<li><code><a title="refinery.lib.tools.exception_to_string" href="#refinery.lib.tools.exception_to_string">exception_to_string</a></code></li>
<li><code><a title="refinery.lib.tools.nopdoc" href="#refinery.lib.tools.nopdoc">nopdoc</a></code></li>
<li><code><a title="refinery.lib.tools.convert" href="#refinery.lib.tools.convert">convert</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.tools.NoLogging" href="#refinery.lib.tools.NoLogging">NoLogging</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.tools.NoLoggingProxy" href="#refinery.lib.tools.NoLoggingProxy">NoLoggingProxy</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.tools.NotOne" href="#refinery.lib.tools.NotOne">NotOne</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.tools.BoundsType" href="#refinery.lib.tools.BoundsType">BoundsType</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
