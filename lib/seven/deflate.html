<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>the refinery.lib.seven.deflate documentation</title>
<meta name="description" content="On a Mission to Refine Binaries" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{background-color:#0D0D0D;color:#EEEEEE;font-size:16pt}@font-face{font-family:"FixedSysEx";src:local('Fixedsys Excelsior 3.01-L2'),local('Fixedsys Excelsior 3.01'),local('FixedSysEx'),url(../../FixedSysEx.ttf) format('truetype')}code,pre,body,html{font-family:FixedSysEx,monospace}b,strong{font-weight:normal}#content{padding:20px}#sidebar{padding:1vw;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #EEEEEE;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}hr{display:none}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#EE8080;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#EEEEEE}// .title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#BB4040}pre code{background:#000000;display:block;padding:1px 0px 4px 0px;line-height:100%}code{background:#000000;padding:1px 0px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#000000;border:0;border-top:1px solid #EEEEEE;border-bottom:1px solid #EEEEEE;margin:1em 0;padding:1ex;overflow-x:auto}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index ul{list-style-type:square;padding:0}// #index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 10px}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#000000;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#0D0D0D}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#EEEEEE;border-left:5px solid #EEEEEE;padding-left:1em}.inheritance em{font-style:normal}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1ch}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition.note,.admonition.info,.admonition.todo,.admonition.versionadded,.admonition.important,.admonition.tip,.admonition.hint{background:#054000}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#998800}.admonition.error,.admonition.danger,.admonition.caution{background:#300000}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:1vw}main{display:flex;flex-direction:row;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #EEEEEE;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>refinery.lib.seven.deflate</code></h1>
</header>
<section id="section-intro">
<p>Structures for unpacking ZIP archives. This can cover a lot more than the built-in zipfile module,
but it is incapable of creating ZIP archives.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L1-L521" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Structures for unpacking ZIP archives. This can cover a lot more than the built-in zipfile module,
but it is incapable of creating ZIP archives.
&#34;&#34;&#34;
from __future__ import annotations

import enum

from typing import Callable

from refinery.lib.array import make_array
from refinery.lib.seven.huffman import BitDecoderBase, HuffmanDecoder, HuffmanDecoder7b
from refinery.lib.structures import StructReader

kNumHuffmanBits = 15
kHistorySize32 = (1 &lt;&lt; 15)
kHistorySize64 = (1 &lt;&lt; 16)
kDistTableSize32 = 30
kDistTableSize64 = 32
kNumLenSymbols32 = 256
kNumLenSymbols64 = 255
kNumLenSymbolsMax = kNumLenSymbols32

kNumLenSlots = 29

kFixedDistTableSize = 32
kFixedLenTableSize = 31

kSymbolEndOfBlock = 0x100
kSymbolMatch = kSymbolEndOfBlock + 1

kMainTableSize = kSymbolMatch + kNumLenSlots
kFixedMainTableSize = kSymbolMatch + kFixedLenTableSize

kLevelTableSize = 19

kTableDirectLevels = 16
kTableLevelRepNumber = kTableDirectLevels
kTableLevel0Number = kTableLevelRepNumber + 1
kTableLevel0Number2 = kTableLevel0Number + 1

kLevelMask = 0xF

kLenStartXX = (
    B&#39;\x00\x01\x02\x03\x04\x05\x06\x07\x08\x0a\x0c\x0e\x10\x14\x18\x1c&#39;
    B&#39;\x20\x28\x30\x38\x40\x50\x60\x70\x80\xa0\xc0\xe0&#39;
)
kLenStart32 = kLenStartXX + B&#39;\xff\x00\x00&#39;
kLenStart64 = kLenStartXX + B&#39;\x00\x00\x00&#39;

kLenDirectBitsXX = (
    B&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x01\x02\x02\x02\x02&#39;
    B&#39;\x03\x03\x03\x03\x04\x04\x04\x04\x05\x05\x05\x05&#39;
)
kLenDirectBits32 = kLenDirectBitsXX + B&#39;\x00\x00\x00&#39;
kLenDirectBits64 = kLenDirectBitsXX + B&#39;\x10\x00\x00&#39;

kDistStart = make_array(4, init=[
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0006, 0x0008, 0x000C,
    0x0010, 0x0018, 0x0020, 0x0030, 0x0040, 0x0060, 0x0080, 0x00C0,
    0x0100, 0x0180, 0x0200, 0x0300, 0x0400, 0x0600, 0x0800, 0x0C00,
    0x1000, 0x1800, 0x2000, 0x3000, 0x4000, 0x6000, 0x8000, 0xC000,
])
kDistDirectBits = (
    B&#39;\x00\x00\x00\x00\x01\x01\x02\x02\x03\x03\x04\x04\x05\x05\x06\x06&#39;
    B&#39;\x07\x07\x08\x08\x09\x09\x0a\x0a\x0b\x0b\x0c\x0c\x0d\x0d\x0e\x0e&#39;
)

kLevelDirectBits = B&#39;\02\03\07&#39;
kCodeLengthAlphabetOrder = B&#39;\x10\x11\x12\x00\x08\x07\x09\x06\x0a\x05\x0b\x04\x0c\x03\x0d\x02\x0e\x01\x0f&#39;

kMatchMinLen = 3
kMatchMaxLen32 = kNumLenSymbols32 + kMatchMinLen - 1 // 256 + 2
kMatchMaxLen64 = kNumLenSymbols64 + kMatchMinLen - 1 // 255 + 2
kMatchMaxLen = kMatchMaxLen32

kFinalBlockFieldSize = 1

kBlockTypeFieldSize = 2

kNumLenCodesFieldSize = 5
kNumDistCodesFieldSize = 5
kNumLevelCodesFieldSize = 4

kNumLitLenCodesMin = 257
kNumDistCodesMin = 1
kNumLevelCodesMin = 4

kLevelFieldSize = 3

kStoredBlockLengthFieldSize = 16


class FinalBlockField(enum.IntEnum):
    NotFinalBlock = 0
    FinalBlock = 1


class BlockType(enum.IntEnum):
    Stored = 0
    FixedHuffman = 1
    DynamicHuffman = 2


class DecoderLevels:
    main_levels: bytearray
    dist_levels: bytearray

    def __init__(self) -&gt; None:
        self.main_levels = bytearray(kFixedMainTableSize)
        self.dist_levels = bytearray(kFixedDistTableSize)

    def sub_clear(self):
        for i in range(kNumLitLenCodesMin, kFixedMainTableSize):
            self.main_levels[i] = 0
        for i in range(kFixedDistTableSize):
            self.dist_levels[i] = 0

    def set_fixed_levels(self):
        i = 0
        for i in range(144):
            self.main_levels[i] = 8
        for i in range(144, 256):
            self.main_levels[i] = 9
        for i in range(256, 280):
            self.main_levels[i] = 7
        for i in range(280, 288):
            self.main_levels[i] = 8
        for i in range(kFixedDistTableSize):
            self.dist_levels[i] = 5


kLenIdFinished = -1
kLenIdNeedInit = -2


kNumBigValueBits = 8 * 4
kNumValueBytes = 3
kNumValueBits = 8 * kNumValueBytes
kMask = (1 &lt;&lt; kNumValueBits) - 1
kInvertTable = bytes(
    ((v * 0x202020202) &amp; 0x10884422010) % 1023 for v in range(0x100))


class BitLDecoderBase:
    __slots__ = (
        &#39;_bit_pos&#39;,
        &#39;_value&#39;,
        &#39;_stream&#39;,
        &#39;_num_extra_bytes&#39;,
        &#39;read_direct_byte&#39;,
    )

    read_direct_byte: Callable[[], int]

    def __init__(self, reader: StructReader):
        def _rdb():
            try:
                return u8fast()
            except Exception:
                self._num_extra_bytes += 1
                return 0xFF
        self._bit_pos = kNumBigValueBits
        self._value = 0
        self._stream = reader
        self._num_extra_bytes = 0
        u8fast = reader.u8fast
        self.read_direct_byte = _rdb

    def get_stream_size(self):
        if self.extra_bits_were_read():
            return len(self._stream)
        else:
            return self.tell()

    def tell(self):
        return self._stream.tell() - ((kNumBigValueBits - self._bit_pos) &gt;&gt; 3)

    def there_are_data_in_bit_buffer(self):
        return self._bit_pos != kNumBigValueBits

    def normalize(self):
        while self._bit_pos &gt;= 8:
            self._value = (self.read_direct_byte() &lt;&lt; (kNumBigValueBits - self._bit_pos)) | self._value
            self._bit_pos -= 8

    def read_bits(self, numBits: int):
        self.normalize()
        res = self._value &amp; ((1 &lt;&lt; numBits) - 1)
        self._bit_pos += numBits
        self._value &gt;&gt;= numBits
        return res

    def extra_bits_were_read(self):
        return (self._num_extra_bytes &gt; 4 or kNumBigValueBits - self._bit_pos &lt; (self._num_extra_bytes &lt;&lt; 3))

    def extra_bits_were_read_fast(self):
        return self._num_extra_bytes &gt; 4


class BitLDecoder(BitDecoderBase, BitLDecoderBase):

    __slots__ = &#39;_normal_value&#39;,

    def __init__(self, reader: StructReader):
        super().__init__(reader)
        self._normal_value = 0

    def normalize(self):
        p = self._bit_pos
        if p &lt; 8:
            return
        v = self._value
        n = self._normal_value
        while p &gt;= 8:
            b = self.read_direct_byte()
            n |= b &lt;&lt; (kNumBigValueBits - p)
            p -= 8
            v = ((v &amp; 0xFFFFFF) &lt;&lt; 8) | kInvertTable[b]
        self._bit_pos = p
        self._value = v
        self._normal_value = n

    def get_value(self, num_bits: int):
        self.normalize()
        return ((self._value &gt;&gt; (8 - self._bit_pos)) &amp; kMask) &gt;&gt; (kNumValueBits - num_bits)

    def move_position(self, num_bits: int):
        self._bit_pos += num_bits
        self._normal_value &gt;&gt;= num_bits

    def read_bits(self, numBits: int):
        self.normalize()
        res = self._normal_value &amp; ((1 &lt;&lt; numBits) - 1)
        self.move_position(numBits)
        return res

    def align_to_byte(self):
        self.move_position((32 - self._bit_pos) &amp; 7)

    def read_aligned_byte(self):
        if self._bit_pos == kNumBigValueBits:
            return self.read_direct_byte()
        b = self._normal_value &amp; 0xFF
        self.move_position(8)
        return b

    def read_aligned_byte_from_buffer(self):
        if self._num_extra_bytes != 0:
            if self.extra_bits_were_read():
                return None
        return self.read_aligned_byte()


def replay(buffer: bytearray, offset: int, length: int):
    cursor = len(buffer)
    rep, r = divmod(length, offset)
    offset = cursor - offset
    replay = buffer[offset:offset + r]
    if rep &gt; 0:
        prefix = buffer[offset:cursor]
        for _ in range(rep):
            buffer.extend(prefix)
    buffer.extend(replay)


class Deflate:
    def __init__(
        self,
        dst: bytearray,
        src: StructReader,
        df64: bool = False,
        nsis: bool = False,
        zlib: bool = False,
    ):
        self.dst = dst
        self.src = src
        self.bits = BitLDecoder(src)
        self.main_decoder = HuffmanDecoder(kNumHuffmanBits, kFixedMainTableSize)
        self.dist_decoder = HuffmanDecoder(kNumHuffmanBits, kFixedDistTableSize)
        self.level_decoder = HuffmanDecoder7b(kLevelTableSize)
        self.stored_block_size = 0
        self.is_final_block = False
        self.stored_mode = False
        self.zlib_tail = bytearray(4)
        self.zlib_mode = zlib
        self.nsis_mode = nsis
        self.deflate64 = df64
        self.keep_history = False
        self._num_dist_levels = 0
        self._need_to_finish_input = False
        self._need_to_read_table = True
        self._leftover_replay_size = 0
        self._leftover_replay_dist = 0
        self._out_size = 0
        self._out_start_pos = 0

    @property
    def _out_size_defined(self):
        return self._out_size &gt; 0

    def decode_levels(self, levels: memoryview, numSymbols: int):
        bits = self.bits
        i = 0
        while i &lt; numSymbols:
            sym = self.level_decoder.decode(self.bits)
            if sym &lt; kTableDirectLevels:
                levels[i] = sym
                i += 1
                continue
            if sym &gt;= kLevelTableSize:
                return False
            if sym == kTableLevelRepNumber:
                if i == 0:
                    return False
                numBits = 2
                num = 0
                symbol = levels[i - 1]
            else:
                sym -= kTableLevel0Number
                sym &lt;&lt;= 2
                numBits = 3 + sym
                num = sym &lt;&lt; 1
                symbol = 0
            num += i + 3 + bits.read_bits(numBits)
            if num &gt; numSymbols:
                return False
            while True:
                levels[i] = symbol
                i += 1
                if i &gt;= num:
                    break
        return True

    def read_tables(self):
        bits = self.bits
        self.is_final_block = (bits.read_bits(kFinalBlockFieldSize) == FinalBlockField.FinalBlock)
        if self.bits.extra_bits_were_read():
            return False
        blockType = bits.read_bits(kBlockTypeFieldSize)
        if blockType &gt; BlockType.DynamicHuffman:
            return False
        if self.bits.extra_bits_were_read():
            return False
        if blockType == BlockType.Stored:
            self.stored_mode = True
            self.bits.align_to_byte()
            self.stored_block_size = self.read_aligned_u16()
            if self.nsis_mode:
                return True
            return (self.stored_block_size == ~self.read_aligned_u16() &amp; 0xFFFF)
        else:
            self.stored_mode = False

        levels = DecoderLevels()

        if blockType == BlockType.FixedHuffman:
            levels.set_fixed_levels()
            self._num_dist_levels = kDistTableSize64 if self.deflate64 else kDistTableSize32
        else:
            numLitLenLevels = bits.read_bits(kNumLenCodesFieldSize) + kNumLitLenCodesMin
            self._num_dist_levels = bits.read_bits(kNumDistCodesFieldSize) + kNumDistCodesMin
            numLevelCodes = bits.read_bits(kNumLevelCodesFieldSize) + kNumLevelCodesMin
            if not self.deflate64:
                if self._num_dist_levels &gt; kDistTableSize32:
                    return False
            levelLevels = bytearray(kLevelTableSize)
            for i in range(kLevelTableSize):
                position = kCodeLengthAlphabetOrder[i]
                if i &lt; numLevelCodes:
                    levelLevels[position] = bits.read_bits(kLevelFieldSize)
                else:
                    levelLevels[position] = 0

            if self.bits.extra_bits_were_read():
                return False

            if not self.level_decoder.build(levelLevels):
                return False

            b_tmpLevels = bytearray(kFixedMainTableSize + kFixedDistTableSize)
            tmpLevels = memoryview(b_tmpLevels)
            if not self.decode_levels(tmpLevels, numLitLenLevels + self._num_dist_levels):
                return False
            if self.bits.extra_bits_were_read():
                return False
            levels.sub_clear()
            levels.main_levels[:numLitLenLevels] = tmpLevels[:numLitLenLevels]
            levels.dist_levels[:self._num_dist_levels] = tmpLevels[numLitLenLevels:][:self._num_dist_levels]
        if not self.main_decoder.build(levels.main_levels):
            return False
        return self.dist_decoder.build(levels.dist_levels)

    def decode_block(self, size: int, finish_input_stream: bool):
        bits = self.bits
        dst = self.dst
        main_decoder = self.main_decoder
        dist_decoder = self.dist_decoder
        write_byte = dst.append

        if self._leftover_replay_size == kLenIdFinished:
            return True
        if self._leftover_replay_size == kLenIdNeedInit:
            if not self.keep_history:
                dst.clear()
            self.is_final_block = False
            self._leftover_replay_size = 0
            self._need_to_read_table = True
        if carry := min(self._leftover_replay_size, size):
            size -= carry
            replay(dst, self._leftover_replay_dist + 1, carry)
            self._leftover_replay_size -= carry
        while size &gt; 0 or finish_input_stream:
            if bits.extra_bits_were_read():
                return False
            if self._need_to_read_table:
                if self.is_final_block:
                    self._leftover_replay_size = kLenIdFinished
                    break
                if not self.read_tables():
                    return False
                if bits.extra_bits_were_read():
                    return False
                self._need_to_read_table = False
            if self.stored_mode:
                if finish_input_stream and size == 0 and self.stored_block_size != 0:
                    return False
                # NSIS version contains some bits in bitl bits buffer.
                # So we must read some first bytes via ReadAlignedByte
                while self.stored_block_size &gt; 0 and size &gt; 0 and bits.there_are_data_in_bit_buffer():
                    write_byte(bits.read_aligned_byte())
                    self.stored_block_size -= 1
                    size -= 1
                while self.stored_block_size &gt; 0 and size &gt; 0:
                    write_byte(bits.read_direct_byte())
                    self.stored_block_size -= 1
                    size -= 1
                self._need_to_read_table = self.stored_block_size == 0
                continue
            while size &gt; 0:
                if bits.extra_bits_were_read_fast():
                    return False
                if (sym := main_decoder.decode(bits)) &lt; 0x100:
                    write_byte(sym)
                    size -= 1
                    continue
                elif sym == kSymbolEndOfBlock:
                    self._need_to_read_table = True
                    break
                elif sym &gt;= kMainTableSize:
                    return False
                else:
                    sym -= kSymbolMatch
                    if self.deflate64:
                        length = kLenStart64[sym]
                        n_bits = kLenDirectBits64[sym]
                    else:
                        length = kLenStart32[sym]
                        n_bits = kLenDirectBits32[sym]
                    length += kMatchMinLen + bits.read_bits(n_bits)
                    loc = min(length, size)
                    sym = dist_decoder.decode(bits)
                    if sym &gt;= self._num_dist_levels:
                        return False
                    sym = kDistStart[sym] + bits.read_bits(kDistDirectBits[sym])
                    replay(dst, sym + 1, loc)
                    size -= loc
                    length -= loc
                    if length != 0:
                        self._leftover_replay_size = length
                        self._leftover_replay_dist = sym
                        break
            if finish_input_stream and size == 0:
                if main_decoder.decode(bits) != kSymbolEndOfBlock:
                    return False
                self._need_to_read_table = True
        return not bits.extra_bits_were_read()

    def decode_real(self):
        while True:
            size = 1 &lt;&lt; 20
            finish_input_stream = False
            if self._out_size_defined:
                rem = self._out_size - (len(self.dst) - self._out_start_pos)
                if size &gt;= rem:
                    size = rem
                    if self.zlib_mode or self._need_to_finish_input:
                        finish_input_stream = True
            if not finish_input_stream and size == 0:
                break
            if not self.decode_block(size, finish_input_stream):
                return False
            if self._leftover_replay_size == kLenIdFinished:
                break
        if self._leftover_replay_size == kLenIdFinished and self.zlib_mode:
            self.bits.align_to_byte()
            for i in range(4):
                self.zlib_tail[i] = self.bits.read_aligned_byte()
        return True

    def initialize_out_stream_for_resume(self, out_size: int = 0):
        if not self.keep_history:
            self.dst.clear()
        self._out_size = out_size
        self._out_start_pos = len(self.dst)
        self._leftover_replay_size = kLenIdNeedInit

    def decode(self, out_size: int = 0):
        self.initialize_out_stream_for_resume(out_size)
        return self.decode_real()

    def is_finished(self):
        return self._leftover_replay_size == kLenIdFinished

    def read_aligned_u16(self):
        b = self.bits
        v = b.read_aligned_byte()
        return v | (b.read_aligned_byte() &lt;&lt; 8)

    def had_input_eof_error(self):
        return self.bits.extra_bits_were_read()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="refinery.lib.seven.deflate.replay"><code class="name flex">
<span>def <span class="ident">replay</span></span>(<span>buffer, offset, length)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L255-L264" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def replay(buffer: bytearray, offset: int, length: int):
    cursor = len(buffer)
    rep, r = divmod(length, offset)
    offset = cursor - offset
    replay = buffer[offset:offset + r]
    if rep &gt; 0:
        prefix = buffer[offset:cursor]
        for _ in range(rep):
            buffer.extend(prefix)
    buffer.extend(replay)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="refinery.lib.seven.deflate.FinalBlockField"><code class="flex name class">
<span>class <span class="ident">FinalBlockField</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L94-L96" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class FinalBlockField(enum.IntEnum):
    NotFinalBlock = 0
    FinalBlock = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.seven.deflate.FinalBlockField.NotFinalBlock"><code class="name">var <span class="ident">NotFinalBlock</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.seven.deflate.FinalBlockField.FinalBlock"><code class="name">var <span class="ident">FinalBlock</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.seven.deflate.BlockType"><code class="flex name class">
<span>class <span class="ident">BlockType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L99-L102" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BlockType(enum.IntEnum):
    Stored = 0
    FixedHuffman = 1
    DynamicHuffman = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.seven.deflate.BlockType.Stored"><code class="name">var <span class="ident">Stored</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.seven.deflate.BlockType.FixedHuffman"><code class="name">var <span class="ident">FixedHuffman</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.seven.deflate.BlockType.DynamicHuffman"><code class="name">var <span class="ident">DynamicHuffman</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
</dd>
<dt id="refinery.lib.seven.deflate.DecoderLevels"><code class="flex name class">
<span>class <span class="ident">DecoderLevels</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L105-L130" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DecoderLevels:
    main_levels: bytearray
    dist_levels: bytearray

    def __init__(self) -&gt; None:
        self.main_levels = bytearray(kFixedMainTableSize)
        self.dist_levels = bytearray(kFixedDistTableSize)

    def sub_clear(self):
        for i in range(kNumLitLenCodesMin, kFixedMainTableSize):
            self.main_levels[i] = 0
        for i in range(kFixedDistTableSize):
            self.dist_levels[i] = 0

    def set_fixed_levels(self):
        i = 0
        for i in range(144):
            self.main_levels[i] = 8
        for i in range(144, 256):
            self.main_levels[i] = 9
        for i in range(256, 280):
            self.main_levels[i] = 7
        for i in range(280, 288):
            self.main_levels[i] = 8
        for i in range(kFixedDistTableSize):
            self.dist_levels[i] = 5</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="refinery.lib.seven.deflate.DecoderLevels.main_levels"><code class="name">var <span class="ident">main_levels</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
<dt id="refinery.lib.seven.deflate.DecoderLevels.dist_levels"><code class="name">var <span class="ident">dist_levels</span></code></dt>
<dd>
<section class="desc"><p>The type of the None singleton.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.seven.deflate.DecoderLevels.sub_clear"><code class="name flex">
<span>def <span class="ident">sub_clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L113-L117" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sub_clear(self):
    for i in range(kNumLitLenCodesMin, kFixedMainTableSize):
        self.main_levels[i] = 0
    for i in range(kFixedDistTableSize):
        self.dist_levels[i] = 0</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.DecoderLevels.set_fixed_levels"><code class="name flex">
<span>def <span class="ident">set_fixed_levels</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L119-L130" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_fixed_levels(self):
    i = 0
    for i in range(144):
        self.main_levels[i] = 8
    for i in range(144, 256):
        self.main_levels[i] = 9
    for i in range(256, 280):
        self.main_levels[i] = 7
    for i in range(280, 288):
        self.main_levels[i] = 8
    for i in range(kFixedDistTableSize):
        self.dist_levels[i] = 5</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.seven.deflate.BitLDecoderBase"><code class="flex name class">
<span>class <span class="ident">BitLDecoderBase</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L145-L198" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BitLDecoderBase:
    __slots__ = (
        &#39;_bit_pos&#39;,
        &#39;_value&#39;,
        &#39;_stream&#39;,
        &#39;_num_extra_bytes&#39;,
        &#39;read_direct_byte&#39;,
    )

    read_direct_byte: Callable[[], int]

    def __init__(self, reader: StructReader):
        def _rdb():
            try:
                return u8fast()
            except Exception:
                self._num_extra_bytes += 1
                return 0xFF
        self._bit_pos = kNumBigValueBits
        self._value = 0
        self._stream = reader
        self._num_extra_bytes = 0
        u8fast = reader.u8fast
        self.read_direct_byte = _rdb

    def get_stream_size(self):
        if self.extra_bits_were_read():
            return len(self._stream)
        else:
            return self.tell()

    def tell(self):
        return self._stream.tell() - ((kNumBigValueBits - self._bit_pos) &gt;&gt; 3)

    def there_are_data_in_bit_buffer(self):
        return self._bit_pos != kNumBigValueBits

    def normalize(self):
        while self._bit_pos &gt;= 8:
            self._value = (self.read_direct_byte() &lt;&lt; (kNumBigValueBits - self._bit_pos)) | self._value
            self._bit_pos -= 8

    def read_bits(self, numBits: int):
        self.normalize()
        res = self._value &amp; ((1 &lt;&lt; numBits) - 1)
        self._bit_pos += numBits
        self._value &gt;&gt;= numBits
        return res

    def extra_bits_were_read(self):
        return (self._num_extra_bytes &gt; 4 or kNumBigValueBits - self._bit_pos &lt; (self._num_extra_bytes &lt;&lt; 3))

    def extra_bits_were_read_fast(self):
        return self._num_extra_bytes &gt; 4</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="refinery.lib.seven.deflate.BitLDecoder" href="#refinery.lib.seven.deflate.BitLDecoder">BitLDecoder</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="refinery.lib.seven.deflate.BitLDecoderBase.read_direct_byte"><code class="name">var <span class="ident">read_direct_byte</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L145-L198" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BitLDecoderBase:
    __slots__ = (
        &#39;_bit_pos&#39;,
        &#39;_value&#39;,
        &#39;_stream&#39;,
        &#39;_num_extra_bytes&#39;,
        &#39;read_direct_byte&#39;,
    )

    read_direct_byte: Callable[[], int]

    def __init__(self, reader: StructReader):
        def _rdb():
            try:
                return u8fast()
            except Exception:
                self._num_extra_bytes += 1
                return 0xFF
        self._bit_pos = kNumBigValueBits
        self._value = 0
        self._stream = reader
        self._num_extra_bytes = 0
        u8fast = reader.u8fast
        self.read_direct_byte = _rdb

    def get_stream_size(self):
        if self.extra_bits_were_read():
            return len(self._stream)
        else:
            return self.tell()

    def tell(self):
        return self._stream.tell() - ((kNumBigValueBits - self._bit_pos) &gt;&gt; 3)

    def there_are_data_in_bit_buffer(self):
        return self._bit_pos != kNumBigValueBits

    def normalize(self):
        while self._bit_pos &gt;= 8:
            self._value = (self.read_direct_byte() &lt;&lt; (kNumBigValueBits - self._bit_pos)) | self._value
            self._bit_pos -= 8

    def read_bits(self, numBits: int):
        self.normalize()
        res = self._value &amp; ((1 &lt;&lt; numBits) - 1)
        self._bit_pos += numBits
        self._value &gt;&gt;= numBits
        return res

    def extra_bits_were_read(self):
        return (self._num_extra_bytes &gt; 4 or kNumBigValueBits - self._bit_pos &lt; (self._num_extra_bytes &lt;&lt; 3))

    def extra_bits_were_read_fast(self):
        return self._num_extra_bytes &gt; 4</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.seven.deflate.BitLDecoderBase.get_stream_size"><code class="name flex">
<span>def <span class="ident">get_stream_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L170-L174" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_stream_size(self):
    if self.extra_bits_were_read():
        return len(self._stream)
    else:
        return self.tell()</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.BitLDecoderBase.tell"><code class="name flex">
<span>def <span class="ident">tell</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L176-L177" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tell(self):
    return self._stream.tell() - ((kNumBigValueBits - self._bit_pos) &gt;&gt; 3)</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.BitLDecoderBase.there_are_data_in_bit_buffer"><code class="name flex">
<span>def <span class="ident">there_are_data_in_bit_buffer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L179-L180" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def there_are_data_in_bit_buffer(self):
    return self._bit_pos != kNumBigValueBits</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.BitLDecoderBase.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L182-L185" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize(self):
    while self._bit_pos &gt;= 8:
        self._value = (self.read_direct_byte() &lt;&lt; (kNumBigValueBits - self._bit_pos)) | self._value
        self._bit_pos -= 8</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.BitLDecoderBase.read_bits"><code class="name flex">
<span>def <span class="ident">read_bits</span></span>(<span>self, numBits)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L187-L192" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_bits(self, numBits: int):
    self.normalize()
    res = self._value &amp; ((1 &lt;&lt; numBits) - 1)
    self._bit_pos += numBits
    self._value &gt;&gt;= numBits
    return res</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.BitLDecoderBase.extra_bits_were_read"><code class="name flex">
<span>def <span class="ident">extra_bits_were_read</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L194-L195" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def extra_bits_were_read(self):
    return (self._num_extra_bytes &gt; 4 or kNumBigValueBits - self._bit_pos &lt; (self._num_extra_bytes &lt;&lt; 3))</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.BitLDecoderBase.extra_bits_were_read_fast"><code class="name flex">
<span>def <span class="ident">extra_bits_were_read_fast</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L197-L198" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def extra_bits_were_read_fast(self):
    return self._num_extra_bytes &gt; 4</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.seven.deflate.BitLDecoder"><code class="flex name class">
<span>class <span class="ident">BitLDecoder</span></span>
<span>(</span><span>reader)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L201-L252" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BitLDecoder(BitDecoderBase, BitLDecoderBase):

    __slots__ = &#39;_normal_value&#39;,

    def __init__(self, reader: StructReader):
        super().__init__(reader)
        self._normal_value = 0

    def normalize(self):
        p = self._bit_pos
        if p &lt; 8:
            return
        v = self._value
        n = self._normal_value
        while p &gt;= 8:
            b = self.read_direct_byte()
            n |= b &lt;&lt; (kNumBigValueBits - p)
            p -= 8
            v = ((v &amp; 0xFFFFFF) &lt;&lt; 8) | kInvertTable[b]
        self._bit_pos = p
        self._value = v
        self._normal_value = n

    def get_value(self, num_bits: int):
        self.normalize()
        return ((self._value &gt;&gt; (8 - self._bit_pos)) &amp; kMask) &gt;&gt; (kNumValueBits - num_bits)

    def move_position(self, num_bits: int):
        self._bit_pos += num_bits
        self._normal_value &gt;&gt;= num_bits

    def read_bits(self, numBits: int):
        self.normalize()
        res = self._normal_value &amp; ((1 &lt;&lt; numBits) - 1)
        self.move_position(numBits)
        return res

    def align_to_byte(self):
        self.move_position((32 - self._bit_pos) &amp; 7)

    def read_aligned_byte(self):
        if self._bit_pos == kNumBigValueBits:
            return self.read_direct_byte()
        b = self._normal_value &amp; 0xFF
        self.move_position(8)
        return b

    def read_aligned_byte_from_buffer(self):
        if self._num_extra_bytes != 0:
            if self.extra_bits_were_read():
                return None
        return self.read_aligned_byte()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="refinery.lib.seven.huffman.BitDecoderBase" href="huffman.html#refinery.lib.seven.huffman.BitDecoderBase">BitDecoderBase</a></li>
<li>abc.ABC</li>
<li><a title="refinery.lib.seven.deflate.BitLDecoderBase" href="#refinery.lib.seven.deflate.BitLDecoderBase">BitLDecoderBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.seven.deflate.BitLDecoder.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L209-L222" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize(self):
    p = self._bit_pos
    if p &lt; 8:
        return
    v = self._value
    n = self._normal_value
    while p &gt;= 8:
        b = self.read_direct_byte()
        n |= b &lt;&lt; (kNumBigValueBits - p)
        p -= 8
        v = ((v &amp; 0xFFFFFF) &lt;&lt; 8) | kInvertTable[b]
    self._bit_pos = p
    self._value = v
    self._normal_value = n</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.BitLDecoder.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, num_bits)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L224-L226" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_value(self, num_bits: int):
    self.normalize()
    return ((self._value &gt;&gt; (8 - self._bit_pos)) &amp; kMask) &gt;&gt; (kNumValueBits - num_bits)</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.BitLDecoder.move_position"><code class="name flex">
<span>def <span class="ident">move_position</span></span>(<span>self, num_bits)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L228-L230" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def move_position(self, num_bits: int):
    self._bit_pos += num_bits
    self._normal_value &gt;&gt;= num_bits</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.BitLDecoder.read_bits"><code class="name flex">
<span>def <span class="ident">read_bits</span></span>(<span>self, numBits)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L232-L236" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_bits(self, numBits: int):
    self.normalize()
    res = self._normal_value &amp; ((1 &lt;&lt; numBits) - 1)
    self.move_position(numBits)
    return res</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.BitLDecoder.align_to_byte"><code class="name flex">
<span>def <span class="ident">align_to_byte</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L238-L239" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def align_to_byte(self):
    self.move_position((32 - self._bit_pos) &amp; 7)</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.BitLDecoder.read_aligned_byte"><code class="name flex">
<span>def <span class="ident">read_aligned_byte</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L241-L246" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_aligned_byte(self):
    if self._bit_pos == kNumBigValueBits:
        return self.read_direct_byte()
    b = self._normal_value &amp; 0xFF
    self.move_position(8)
    return b</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.BitLDecoder.read_aligned_byte_from_buffer"><code class="name flex">
<span>def <span class="ident">read_aligned_byte_from_buffer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L248-L252" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_aligned_byte_from_buffer(self):
    if self._num_extra_bytes != 0:
        if self.extra_bits_were_read():
            return None
    return self.read_aligned_byte()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="refinery.lib.seven.deflate.Deflate"><code class="flex name class">
<span>class <span class="ident">Deflate</span></span>
<span>(</span><span>dst, src, df64=False, nsis=False, zlib=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L267-L521" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Deflate:
    def __init__(
        self,
        dst: bytearray,
        src: StructReader,
        df64: bool = False,
        nsis: bool = False,
        zlib: bool = False,
    ):
        self.dst = dst
        self.src = src
        self.bits = BitLDecoder(src)
        self.main_decoder = HuffmanDecoder(kNumHuffmanBits, kFixedMainTableSize)
        self.dist_decoder = HuffmanDecoder(kNumHuffmanBits, kFixedDistTableSize)
        self.level_decoder = HuffmanDecoder7b(kLevelTableSize)
        self.stored_block_size = 0
        self.is_final_block = False
        self.stored_mode = False
        self.zlib_tail = bytearray(4)
        self.zlib_mode = zlib
        self.nsis_mode = nsis
        self.deflate64 = df64
        self.keep_history = False
        self._num_dist_levels = 0
        self._need_to_finish_input = False
        self._need_to_read_table = True
        self._leftover_replay_size = 0
        self._leftover_replay_dist = 0
        self._out_size = 0
        self._out_start_pos = 0

    @property
    def _out_size_defined(self):
        return self._out_size &gt; 0

    def decode_levels(self, levels: memoryview, numSymbols: int):
        bits = self.bits
        i = 0
        while i &lt; numSymbols:
            sym = self.level_decoder.decode(self.bits)
            if sym &lt; kTableDirectLevels:
                levels[i] = sym
                i += 1
                continue
            if sym &gt;= kLevelTableSize:
                return False
            if sym == kTableLevelRepNumber:
                if i == 0:
                    return False
                numBits = 2
                num = 0
                symbol = levels[i - 1]
            else:
                sym -= kTableLevel0Number
                sym &lt;&lt;= 2
                numBits = 3 + sym
                num = sym &lt;&lt; 1
                symbol = 0
            num += i + 3 + bits.read_bits(numBits)
            if num &gt; numSymbols:
                return False
            while True:
                levels[i] = symbol
                i += 1
                if i &gt;= num:
                    break
        return True

    def read_tables(self):
        bits = self.bits
        self.is_final_block = (bits.read_bits(kFinalBlockFieldSize) == FinalBlockField.FinalBlock)
        if self.bits.extra_bits_were_read():
            return False
        blockType = bits.read_bits(kBlockTypeFieldSize)
        if blockType &gt; BlockType.DynamicHuffman:
            return False
        if self.bits.extra_bits_were_read():
            return False
        if blockType == BlockType.Stored:
            self.stored_mode = True
            self.bits.align_to_byte()
            self.stored_block_size = self.read_aligned_u16()
            if self.nsis_mode:
                return True
            return (self.stored_block_size == ~self.read_aligned_u16() &amp; 0xFFFF)
        else:
            self.stored_mode = False

        levels = DecoderLevels()

        if blockType == BlockType.FixedHuffman:
            levels.set_fixed_levels()
            self._num_dist_levels = kDistTableSize64 if self.deflate64 else kDistTableSize32
        else:
            numLitLenLevels = bits.read_bits(kNumLenCodesFieldSize) + kNumLitLenCodesMin
            self._num_dist_levels = bits.read_bits(kNumDistCodesFieldSize) + kNumDistCodesMin
            numLevelCodes = bits.read_bits(kNumLevelCodesFieldSize) + kNumLevelCodesMin
            if not self.deflate64:
                if self._num_dist_levels &gt; kDistTableSize32:
                    return False
            levelLevels = bytearray(kLevelTableSize)
            for i in range(kLevelTableSize):
                position = kCodeLengthAlphabetOrder[i]
                if i &lt; numLevelCodes:
                    levelLevels[position] = bits.read_bits(kLevelFieldSize)
                else:
                    levelLevels[position] = 0

            if self.bits.extra_bits_were_read():
                return False

            if not self.level_decoder.build(levelLevels):
                return False

            b_tmpLevels = bytearray(kFixedMainTableSize + kFixedDistTableSize)
            tmpLevels = memoryview(b_tmpLevels)
            if not self.decode_levels(tmpLevels, numLitLenLevels + self._num_dist_levels):
                return False
            if self.bits.extra_bits_were_read():
                return False
            levels.sub_clear()
            levels.main_levels[:numLitLenLevels] = tmpLevels[:numLitLenLevels]
            levels.dist_levels[:self._num_dist_levels] = tmpLevels[numLitLenLevels:][:self._num_dist_levels]
        if not self.main_decoder.build(levels.main_levels):
            return False
        return self.dist_decoder.build(levels.dist_levels)

    def decode_block(self, size: int, finish_input_stream: bool):
        bits = self.bits
        dst = self.dst
        main_decoder = self.main_decoder
        dist_decoder = self.dist_decoder
        write_byte = dst.append

        if self._leftover_replay_size == kLenIdFinished:
            return True
        if self._leftover_replay_size == kLenIdNeedInit:
            if not self.keep_history:
                dst.clear()
            self.is_final_block = False
            self._leftover_replay_size = 0
            self._need_to_read_table = True
        if carry := min(self._leftover_replay_size, size):
            size -= carry
            replay(dst, self._leftover_replay_dist + 1, carry)
            self._leftover_replay_size -= carry
        while size &gt; 0 or finish_input_stream:
            if bits.extra_bits_were_read():
                return False
            if self._need_to_read_table:
                if self.is_final_block:
                    self._leftover_replay_size = kLenIdFinished
                    break
                if not self.read_tables():
                    return False
                if bits.extra_bits_were_read():
                    return False
                self._need_to_read_table = False
            if self.stored_mode:
                if finish_input_stream and size == 0 and self.stored_block_size != 0:
                    return False
                # NSIS version contains some bits in bitl bits buffer.
                # So we must read some first bytes via ReadAlignedByte
                while self.stored_block_size &gt; 0 and size &gt; 0 and bits.there_are_data_in_bit_buffer():
                    write_byte(bits.read_aligned_byte())
                    self.stored_block_size -= 1
                    size -= 1
                while self.stored_block_size &gt; 0 and size &gt; 0:
                    write_byte(bits.read_direct_byte())
                    self.stored_block_size -= 1
                    size -= 1
                self._need_to_read_table = self.stored_block_size == 0
                continue
            while size &gt; 0:
                if bits.extra_bits_were_read_fast():
                    return False
                if (sym := main_decoder.decode(bits)) &lt; 0x100:
                    write_byte(sym)
                    size -= 1
                    continue
                elif sym == kSymbolEndOfBlock:
                    self._need_to_read_table = True
                    break
                elif sym &gt;= kMainTableSize:
                    return False
                else:
                    sym -= kSymbolMatch
                    if self.deflate64:
                        length = kLenStart64[sym]
                        n_bits = kLenDirectBits64[sym]
                    else:
                        length = kLenStart32[sym]
                        n_bits = kLenDirectBits32[sym]
                    length += kMatchMinLen + bits.read_bits(n_bits)
                    loc = min(length, size)
                    sym = dist_decoder.decode(bits)
                    if sym &gt;= self._num_dist_levels:
                        return False
                    sym = kDistStart[sym] + bits.read_bits(kDistDirectBits[sym])
                    replay(dst, sym + 1, loc)
                    size -= loc
                    length -= loc
                    if length != 0:
                        self._leftover_replay_size = length
                        self._leftover_replay_dist = sym
                        break
            if finish_input_stream and size == 0:
                if main_decoder.decode(bits) != kSymbolEndOfBlock:
                    return False
                self._need_to_read_table = True
        return not bits.extra_bits_were_read()

    def decode_real(self):
        while True:
            size = 1 &lt;&lt; 20
            finish_input_stream = False
            if self._out_size_defined:
                rem = self._out_size - (len(self.dst) - self._out_start_pos)
                if size &gt;= rem:
                    size = rem
                    if self.zlib_mode or self._need_to_finish_input:
                        finish_input_stream = True
            if not finish_input_stream and size == 0:
                break
            if not self.decode_block(size, finish_input_stream):
                return False
            if self._leftover_replay_size == kLenIdFinished:
                break
        if self._leftover_replay_size == kLenIdFinished and self.zlib_mode:
            self.bits.align_to_byte()
            for i in range(4):
                self.zlib_tail[i] = self.bits.read_aligned_byte()
        return True

    def initialize_out_stream_for_resume(self, out_size: int = 0):
        if not self.keep_history:
            self.dst.clear()
        self._out_size = out_size
        self._out_start_pos = len(self.dst)
        self._leftover_replay_size = kLenIdNeedInit

    def decode(self, out_size: int = 0):
        self.initialize_out_stream_for_resume(out_size)
        return self.decode_real()

    def is_finished(self):
        return self._leftover_replay_size == kLenIdFinished

    def read_aligned_u16(self):
        b = self.bits
        v = b.read_aligned_byte()
        return v | (b.read_aligned_byte() &lt;&lt; 8)

    def had_input_eof_error(self):
        return self.bits.extra_bits_were_read()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="refinery.lib.seven.deflate.Deflate.decode_levels"><code class="name flex">
<span>def <span class="ident">decode_levels</span></span>(<span>self, levels, numSymbols)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L302-L333" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decode_levels(self, levels: memoryview, numSymbols: int):
    bits = self.bits
    i = 0
    while i &lt; numSymbols:
        sym = self.level_decoder.decode(self.bits)
        if sym &lt; kTableDirectLevels:
            levels[i] = sym
            i += 1
            continue
        if sym &gt;= kLevelTableSize:
            return False
        if sym == kTableLevelRepNumber:
            if i == 0:
                return False
            numBits = 2
            num = 0
            symbol = levels[i - 1]
        else:
            sym -= kTableLevel0Number
            sym &lt;&lt;= 2
            numBits = 3 + sym
            num = sym &lt;&lt; 1
            symbol = 0
        num += i + 3 + bits.read_bits(numBits)
        if num &gt; numSymbols:
            return False
        while True:
            levels[i] = symbol
            i += 1
            if i &gt;= num:
                break
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.Deflate.read_tables"><code class="name flex">
<span>def <span class="ident">read_tables</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L335-L392" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_tables(self):
    bits = self.bits
    self.is_final_block = (bits.read_bits(kFinalBlockFieldSize) == FinalBlockField.FinalBlock)
    if self.bits.extra_bits_were_read():
        return False
    blockType = bits.read_bits(kBlockTypeFieldSize)
    if blockType &gt; BlockType.DynamicHuffman:
        return False
    if self.bits.extra_bits_were_read():
        return False
    if blockType == BlockType.Stored:
        self.stored_mode = True
        self.bits.align_to_byte()
        self.stored_block_size = self.read_aligned_u16()
        if self.nsis_mode:
            return True
        return (self.stored_block_size == ~self.read_aligned_u16() &amp; 0xFFFF)
    else:
        self.stored_mode = False

    levels = DecoderLevels()

    if blockType == BlockType.FixedHuffman:
        levels.set_fixed_levels()
        self._num_dist_levels = kDistTableSize64 if self.deflate64 else kDistTableSize32
    else:
        numLitLenLevels = bits.read_bits(kNumLenCodesFieldSize) + kNumLitLenCodesMin
        self._num_dist_levels = bits.read_bits(kNumDistCodesFieldSize) + kNumDistCodesMin
        numLevelCodes = bits.read_bits(kNumLevelCodesFieldSize) + kNumLevelCodesMin
        if not self.deflate64:
            if self._num_dist_levels &gt; kDistTableSize32:
                return False
        levelLevels = bytearray(kLevelTableSize)
        for i in range(kLevelTableSize):
            position = kCodeLengthAlphabetOrder[i]
            if i &lt; numLevelCodes:
                levelLevels[position] = bits.read_bits(kLevelFieldSize)
            else:
                levelLevels[position] = 0

        if self.bits.extra_bits_were_read():
            return False

        if not self.level_decoder.build(levelLevels):
            return False

        b_tmpLevels = bytearray(kFixedMainTableSize + kFixedDistTableSize)
        tmpLevels = memoryview(b_tmpLevels)
        if not self.decode_levels(tmpLevels, numLitLenLevels + self._num_dist_levels):
            return False
        if self.bits.extra_bits_were_read():
            return False
        levels.sub_clear()
        levels.main_levels[:numLitLenLevels] = tmpLevels[:numLitLenLevels]
        levels.dist_levels[:self._num_dist_levels] = tmpLevels[numLitLenLevels:][:self._num_dist_levels]
    if not self.main_decoder.build(levels.main_levels):
        return False
    return self.dist_decoder.build(levels.dist_levels)</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.Deflate.decode_block"><code class="name flex">
<span>def <span class="ident">decode_block</span></span>(<span>self, size, finish_input_stream)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L394-L477" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decode_block(self, size: int, finish_input_stream: bool):
    bits = self.bits
    dst = self.dst
    main_decoder = self.main_decoder
    dist_decoder = self.dist_decoder
    write_byte = dst.append

    if self._leftover_replay_size == kLenIdFinished:
        return True
    if self._leftover_replay_size == kLenIdNeedInit:
        if not self.keep_history:
            dst.clear()
        self.is_final_block = False
        self._leftover_replay_size = 0
        self._need_to_read_table = True
    if carry := min(self._leftover_replay_size, size):
        size -= carry
        replay(dst, self._leftover_replay_dist + 1, carry)
        self._leftover_replay_size -= carry
    while size &gt; 0 or finish_input_stream:
        if bits.extra_bits_were_read():
            return False
        if self._need_to_read_table:
            if self.is_final_block:
                self._leftover_replay_size = kLenIdFinished
                break
            if not self.read_tables():
                return False
            if bits.extra_bits_were_read():
                return False
            self._need_to_read_table = False
        if self.stored_mode:
            if finish_input_stream and size == 0 and self.stored_block_size != 0:
                return False
            # NSIS version contains some bits in bitl bits buffer.
            # So we must read some first bytes via ReadAlignedByte
            while self.stored_block_size &gt; 0 and size &gt; 0 and bits.there_are_data_in_bit_buffer():
                write_byte(bits.read_aligned_byte())
                self.stored_block_size -= 1
                size -= 1
            while self.stored_block_size &gt; 0 and size &gt; 0:
                write_byte(bits.read_direct_byte())
                self.stored_block_size -= 1
                size -= 1
            self._need_to_read_table = self.stored_block_size == 0
            continue
        while size &gt; 0:
            if bits.extra_bits_were_read_fast():
                return False
            if (sym := main_decoder.decode(bits)) &lt; 0x100:
                write_byte(sym)
                size -= 1
                continue
            elif sym == kSymbolEndOfBlock:
                self._need_to_read_table = True
                break
            elif sym &gt;= kMainTableSize:
                return False
            else:
                sym -= kSymbolMatch
                if self.deflate64:
                    length = kLenStart64[sym]
                    n_bits = kLenDirectBits64[sym]
                else:
                    length = kLenStart32[sym]
                    n_bits = kLenDirectBits32[sym]
                length += kMatchMinLen + bits.read_bits(n_bits)
                loc = min(length, size)
                sym = dist_decoder.decode(bits)
                if sym &gt;= self._num_dist_levels:
                    return False
                sym = kDistStart[sym] + bits.read_bits(kDistDirectBits[sym])
                replay(dst, sym + 1, loc)
                size -= loc
                length -= loc
                if length != 0:
                    self._leftover_replay_size = length
                    self._leftover_replay_dist = sym
                    break
        if finish_input_stream and size == 0:
            if main_decoder.decode(bits) != kSymbolEndOfBlock:
                return False
            self._need_to_read_table = True
    return not bits.extra_bits_were_read()</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.Deflate.decode_real"><code class="name flex">
<span>def <span class="ident">decode_real</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L479-L499" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decode_real(self):
    while True:
        size = 1 &lt;&lt; 20
        finish_input_stream = False
        if self._out_size_defined:
            rem = self._out_size - (len(self.dst) - self._out_start_pos)
            if size &gt;= rem:
                size = rem
                if self.zlib_mode or self._need_to_finish_input:
                    finish_input_stream = True
        if not finish_input_stream and size == 0:
            break
        if not self.decode_block(size, finish_input_stream):
            return False
        if self._leftover_replay_size == kLenIdFinished:
            break
    if self._leftover_replay_size == kLenIdFinished and self.zlib_mode:
        self.bits.align_to_byte()
        for i in range(4):
            self.zlib_tail[i] = self.bits.read_aligned_byte()
    return True</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.Deflate.initialize_out_stream_for_resume"><code class="name flex">
<span>def <span class="ident">initialize_out_stream_for_resume</span></span>(<span>self, out_size=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L501-L506" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def initialize_out_stream_for_resume(self, out_size: int = 0):
    if not self.keep_history:
        self.dst.clear()
    self._out_size = out_size
    self._out_start_pos = len(self.dst)
    self._leftover_replay_size = kLenIdNeedInit</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.Deflate.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, out_size=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L508-L510" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def decode(self, out_size: int = 0):
    self.initialize_out_stream_for_resume(out_size)
    return self.decode_real()</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.Deflate.is_finished"><code class="name flex">
<span>def <span class="ident">is_finished</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L512-L513" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_finished(self):
    return self._leftover_replay_size == kLenIdFinished</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.Deflate.read_aligned_u16"><code class="name flex">
<span>def <span class="ident">read_aligned_u16</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L515-L518" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read_aligned_u16(self):
    b = self.bits
    v = b.read_aligned_byte()
    return v | (b.read_aligned_byte() &lt;&lt; 8)</code></pre>
</details>
</dd>
<dt id="refinery.lib.seven.deflate.Deflate.had_input_eof_error"><code class="name flex">
<span>def <span class="ident">had_input_eof_error</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/binref/refinery/blob/4c0004e3a5e038a14f699905f942361689d71fc3/refinery/lib/seven/deflate.py#L520-L521" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def had_input_eof_error(self):
    return self.bits.extra_bits_were_read()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="refinery.lib.seven" href="index.html">refinery.lib.seven</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="refinery.lib.seven.deflate.replay" href="#refinery.lib.seven.deflate.replay">replay</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="refinery.lib.seven.deflate.FinalBlockField" href="#refinery.lib.seven.deflate.FinalBlockField">FinalBlockField</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.seven.deflate.BlockType" href="#refinery.lib.seven.deflate.BlockType">BlockType</a></code></h4>
</li>
<li>
<h4><code><a title="refinery.lib.seven.deflate.DecoderLevels" href="#refinery.lib.seven.deflate.DecoderLevels">DecoderLevels</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.seven.deflate.DecoderLevels.sub_clear" href="#refinery.lib.seven.deflate.DecoderLevels.sub_clear">sub_clear</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.DecoderLevels.set_fixed_levels" href="#refinery.lib.seven.deflate.DecoderLevels.set_fixed_levels">set_fixed_levels</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.seven.deflate.BitLDecoderBase" href="#refinery.lib.seven.deflate.BitLDecoderBase">BitLDecoderBase</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.seven.deflate.BitLDecoderBase.get_stream_size" href="#refinery.lib.seven.deflate.BitLDecoderBase.get_stream_size">get_stream_size</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.BitLDecoderBase.tell" href="#refinery.lib.seven.deflate.BitLDecoderBase.tell">tell</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.BitLDecoderBase.there_are_data_in_bit_buffer" href="#refinery.lib.seven.deflate.BitLDecoderBase.there_are_data_in_bit_buffer">there_are_data_in_bit_buffer</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.BitLDecoderBase.normalize" href="#refinery.lib.seven.deflate.BitLDecoderBase.normalize">normalize</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.BitLDecoderBase.read_bits" href="#refinery.lib.seven.deflate.BitLDecoderBase.read_bits">read_bits</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.BitLDecoderBase.extra_bits_were_read" href="#refinery.lib.seven.deflate.BitLDecoderBase.extra_bits_were_read">extra_bits_were_read</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.BitLDecoderBase.extra_bits_were_read_fast" href="#refinery.lib.seven.deflate.BitLDecoderBase.extra_bits_were_read_fast">extra_bits_were_read_fast</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.seven.deflate.BitLDecoder" href="#refinery.lib.seven.deflate.BitLDecoder">BitLDecoder</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.seven.deflate.BitLDecoder.normalize" href="#refinery.lib.seven.deflate.BitLDecoder.normalize">normalize</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.BitLDecoder.get_value" href="#refinery.lib.seven.deflate.BitLDecoder.get_value">get_value</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.BitLDecoder.move_position" href="#refinery.lib.seven.deflate.BitLDecoder.move_position">move_position</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.BitLDecoder.read_bits" href="#refinery.lib.seven.deflate.BitLDecoder.read_bits">read_bits</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.BitLDecoder.align_to_byte" href="#refinery.lib.seven.deflate.BitLDecoder.align_to_byte">align_to_byte</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.BitLDecoder.read_aligned_byte" href="#refinery.lib.seven.deflate.BitLDecoder.read_aligned_byte">read_aligned_byte</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.BitLDecoder.read_aligned_byte_from_buffer" href="#refinery.lib.seven.deflate.BitLDecoder.read_aligned_byte_from_buffer">read_aligned_byte_from_buffer</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="refinery.lib.seven.deflate.Deflate" href="#refinery.lib.seven.deflate.Deflate">Deflate</a></code></h4>
<ul class="">
<li><code><a title="refinery.lib.seven.deflate.Deflate.decode_levels" href="#refinery.lib.seven.deflate.Deflate.decode_levels">decode_levels</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.Deflate.read_tables" href="#refinery.lib.seven.deflate.Deflate.read_tables">read_tables</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.Deflate.decode_block" href="#refinery.lib.seven.deflate.Deflate.decode_block">decode_block</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.Deflate.decode_real" href="#refinery.lib.seven.deflate.Deflate.decode_real">decode_real</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.Deflate.initialize_out_stream_for_resume" href="#refinery.lib.seven.deflate.Deflate.initialize_out_stream_for_resume">initialize_out_stream_for_resume</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.Deflate.decode" href="#refinery.lib.seven.deflate.Deflate.decode">decode</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.Deflate.is_finished" href="#refinery.lib.seven.deflate.Deflate.is_finished">is_finished</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.Deflate.read_aligned_u16" href="#refinery.lib.seven.deflate.Deflate.read_aligned_u16">read_aligned_u16</a></code></li>
<li><code><a title="refinery.lib.seven.deflate.Deflate.had_input_eof_error" href="#refinery.lib.seven.deflate.Deflate.had_input_eof_error">had_input_eof_error</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.configure({languages: []})
hljs.initHighlightingOnLoad()
</script>
</body>
</html>
